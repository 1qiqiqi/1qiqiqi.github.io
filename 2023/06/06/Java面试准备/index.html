<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java求职准备之旅 | 藏心阁</title><meta name="keywords" content="Java面试准备"><meta name="author" content="xiaoqi"><meta name="copyright" content="xiaoqi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录一些Java学习的日常以及各种需要的面试题目">
<meta property="og:type" content="article">
<meta property="og:title" content="Java求职准备之旅">
<meta property="og:url" content="https://1qiqiqi.github.io/2023/06/06/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/index.html">
<meta property="og:site_name" content="藏心阁">
<meta property="og:description" content="记录一些Java学习的日常以及各种需要的面试题目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/08/04/lmAJuEYUBxSGrVt.jpg">
<meta property="article:published_time" content="2023-06-06T02:34:23.368Z">
<meta property="article:modified_time" content="2023-08-08T09:21:06.033Z">
<meta property="article:author" content="xiaoqi">
<meta property="article:tag" content="Java面试准备">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/08/04/lmAJuEYUBxSGrVt.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2022/08/12/JwHXL6vuaMDscpz.jpg"><link rel="canonical" href="https://1qiqiqi.github.io/2023/06/06/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java求职准备之旅',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-08-08 17:21:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"></head><body><sun_moon class="pugsvg" aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewbox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewbox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></sun_moon><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://s2.loli.net/2022/08/12/SKhOgCG6PuEA4rt.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">170</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/08/04/lmAJuEYUBxSGrVt.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">藏心阁</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java求职准备之旅</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T02:34:23.368Z" title="发表于 2023-06-06 10:34:23">2023-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-08T09:21:06.033Z" title="更新于 2023-08-08 17:21:06">2023-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">Java面试准备</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java求职准备之旅"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Test-angel"><a href="#Test-angel" class="headerlink" title="Test:angel:"></a>Test:angel:</h1><h3 id="技术学习指导思想"><a href="#技术学习指导思想" class="headerlink" title="技术学习指导思想"></a>技术学习指导思想</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这项技术诞生的是为什么? 解决了什么问题吗?</span><br><span class="line">它的这个技术的主要原理是什么?有什么骚操作?</span><br><span class="line">这个技术的缺点是什么? 如何解决这个技术的问题?</span><br><span class="line">有没有其他相同的技术做对比?</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Spring-airplane"><a href="#Spring-airplane" class="headerlink" title="Spring:airplane:"></a>Spring:airplane:</h1><h3 id="为什么选用Spring"><a href="#为什么选用Spring" class="headerlink" title="为什么选用Spring?"></a>为什么选用Spring?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么选用Spring，Spring提供了IOC以及AOP的核心，IOC能够把对象创建交给容器来处理，而不需要通过手写new 一个对象，这样就降低了代码的冗余性，并且实现了对象之间的松耦合，并且Spring能够通过AOP实现事务管理，Spring从1.0版本到现在，它的生态已经非常的庞大，而且Spring是一个轻量级的，只有2MB大小。Spring由AOP和IOC以及Test,WEB,JDBC，</span><br></pre></td></tr></tbody></table></figure>

<h3 id="SpringBoot的启动过程"><a href="#SpringBoot的启动过程" class="headerlink" title="SpringBoot的启动过程?"></a>SpringBoot的启动过程?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot启动的接口有SpringBootApplication注解里面有多个注解，SpringBootConfiguration、EnabletAutoConfiguration、ComponeScan等注解，然后我们从pom.xml文件加载组件，再从配置文件加载配置，再初始化Web容器，此时请求控制权限交给Web容器(Tomcat或者Jetty都行)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="SpringBoot自动配置源码分析"><a href="#SpringBoot自动配置源码分析" class="headerlink" title="SpringBoot自动配置源码分析"></a>SpringBoot自动配置源码分析</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication 这个注解里面有ComponeScan我们可以通过这种方式扫描Controller、Service、Configuration等注解Bean</span><br><span class="line">SpringApplication.run(BootApplication.class, args);这行代码里面的BootApplication其实也可以是别的,自己写一个类就行,这个类的作用就相当于一个配置类,这个run方法里面的逻辑代码主要是: 创建Spring容器,然后Register(配置类),然后再选择一个Web容器(Tomcat或者Jetty),Tomcat里面得加一个Servlet(具体是加DispacthServlet),这样就是SpringMVC将Controller分解成了前端的Controller(DispatcherServlet)和后端的Controller,当前端发送请求的时候,DispatcherServlet接受到请求之后去找HandleMapping找对应的Controller,然后再通过Controller到Service返回ModeAndView,DispatcherServlet接受到ModeAndView之后传给视图解析器(ViewSolver),再传给视图(HTML,JSP).</span><br><span class="line">@SpringBootApplication 下面还有EnableAutoConfiguration注解,这个就是Spring的自动配置,注意不是自动装配哈,EnableAutoConfiguration下面有@Import({AutoConfigurationImportSelector.class}),这个用来加载AutoConfiguration类,比如SqlSessionFactory,我们加载的时候,怎么去识别某个类是AutoConfiguration呢? 我们可以通过spring.factories来得到需要引入的自动配置类,这些在第三方jar包里面的自动配置类全部要加载过来吗? 当然不需要了,有些没有用到的自动配置类你加载干嘛,当然是加载需要用到的,怎么判断它是否需要用到呢? 里面有</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Spring中的Bean的生命周期"><a href="#Spring中的Bean的生命周期" class="headerlink" title="Spring中的Bean的生命周期"></a>Spring中的Bean的生命周期</h3><h5 id="5步骤看"><a href="#5步骤看" class="headerlink" title="5步骤看"></a>5步骤看</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 实例化 也就是构造方法</span><br><span class="line">2. 依赖注入 也就是set属性名</span><br><span class="line">3. 初始化</span><br><span class="line">4. 使用Bean</span><br><span class="line">5. 销毁Bean</span><br></pre></td></tr></tbody></table></figure>

<h5 id="7步骤看"><a href="#7步骤看" class="headerlink" title="7步骤看"></a>7步骤看</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 实例化 </span><br><span class="line">2. 依赖注入 </span><br><span class="line">3. 初始化Before 有点像AOP</span><br><span class="line">4. 初始化Bean</span><br><span class="line">5. 初始化After </span><br><span class="line">6. 使用Bean</span><br><span class="line">7. 销毁Bean</span><br></pre></td></tr></tbody></table></figure>

<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 工厂模式: 其实这个分两种实现方式，一种是抽线工程通过Spring当中的顶级接口BeanFactory作为容器来getBean方法获得Bean，还有一种是方法工厂通过一个FactoryBean接口来获得Bean，主要是能通过对这个Bean的一些初始化配置。</span><br><span class="line">2. 单例模式: 其实Spring就是对整个Bean的生命周期的一个管理，单例模式就是说需要用到某个bean的时候是同一个bean,不会去新建一个bean,也就是说这个bean是全局性的，涉及到一些懒汉和饿汉模式实现</span><br><span class="line">3. 代理模式: 这个主要就是通过动态代理的方式创建bean，主要实现就是AOP，用于增强某些功能</span><br><span class="line">4. 策略模式: 这个就是通过提供一个接口，有不同的实现类，比如说数据库的驱动加载，数据库来自不同厂家，只需要切换不同的数据源就能实现接口，能够自由切换</span><br><span class="line">5. 观察者模式: Spring当中的applicatoncontext接口作为上下文容器，里面实现了一个接口实现了订阅/发布功能，有点类似于MQ，那边动了，我这边也得做出改变</span><br><span class="line">6. 模板方法模式: RedisTemplete和JDBCTemplete这些，已经有很多类的框架已经写好了</span><br></pre></td></tr></tbody></table></figure>



<h1 id="计算机网络-alien"><a href="#计算机网络-alien" class="headerlink" title="计算机网络:alien:"></a>计算机网络:alien:</h1><h3 id="当你在浏览器中输入URL网址的时候发生了什么"><a href="#当你在浏览器中输入URL网址的时候发生了什么" class="headerlink" title="当你在浏览器中输入URL网址的时候发生了什么?"></a>当你在浏览器中输入URL网址的时候发生了什么?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DNS解析：当我们在浏览器中输入URL时，浏览器会首先将该URL发送给本地DNS服务器进行解析，以获取该URL所对应的IP地址。</span><br><span class="line"></span><br><span class="line">建立TCP连接：一旦浏览器获取到URL所对应的IP地址，浏览器会通过TCP/IP协议向该IP地址发起连接请求，以建立与Web服务器的连接。</span><br><span class="line"></span><br><span class="line">发送HTTP请求：一旦TCP连接建立成功，浏览器会通过该连接向Web服务器发送HTTP请求，请求服务器返回对应的HTML文件。</span><br><span class="line"></span><br><span class="line">服务器响应：Web服务器接收到浏览器的HTTP请求后，会查找请求的资源并返回HTTP响应。</span><br><span class="line"></span><br><span class="line">接收响应数据：浏览器接收到服务器返回的HTTP响应后，会解析响应数据，包括HTML、CSS和JavaScript等资源，并对其进行加载和渲染。</span><br><span class="line"></span><br><span class="line">显示网页：一旦浏览器完成了HTML、CSS和JavaScript等资源的加载和渲染工作，它就会将这些资源以及浏览器自身的UI元素结合起来，最终呈现出我们所看到的网页。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="对于Unicode的理解是什么"><a href="#对于Unicode的理解是什么" class="headerlink" title="对于Unicode的理解是什么?:"></a>对于Unicode的理解是什么?:</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unicode字符集有世界上大部分的语言字符构成，Unicode有17个面板，每个面板有65536个字符组成(即2的16次方)，总共有17个面，其中有个BMP面，表示的就是常用的语言，比如说英文字母以及常见的数字符号，有16个辅助面板，里面有emoij这种表情符号组成(一个表情符号字符由2个char组成，常见的字符只有一个char组成)，可以将Unicode字符集当成一个字典来看每个字符有对应的码点以及Unicode字符，每一个字符对应着一个，首先我们搞清楚什么是UTF-16编码，就是通过将一个码点转化为二进制数字的过程，一个char对应的是一个UTF-16代码单元</span><br></pre></td></tr></tbody></table></figure>

<h3 id="为什么TCP需要三次握手"><a href="#为什么TCP需要三次握手" class="headerlink" title="为什么TCP需要三次握手?"></a>为什么TCP需要三次握手?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP是一个可靠的基于字节流的面向连接的协议，需要三次握手的原因有三点</span><br></pre></td></tr></tbody></table></figure>

<h5 id="三次握手的流程是什么"><a href="#三次握手的流程是什么" class="headerlink" title="三次握手的流程是什么?"></a>三次握手的流程是什么?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端向服务端发送请求携带一个SYN</span><br><span class="line">服务端接受到请求后向客户端发送SYN(这个是服务端的同步序列)和一个ACK(这个是回应有没有收到客户端的同步序列的)</span><br><span class="line">客户端接受到服务端的请求后，向服务端发送ACK。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="三次握手的具体原因是什么"><a href="#三次握手的具体原因是什么" class="headerlink" title="三次握手的具体原因是什么?"></a>三次握手的具体原因是什么?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先是因为TCP需要在不可靠的网络环境下完成可靠传输，所以这样就需要用到SYN</span><br><span class="line">其次是因为如果只有两次握手，那么如果因为网络原因导致的之前的请求阻塞后面服务端看到之后有两种选择接受和不接受，不知道这个请求是有效还是无效的</span><br><span class="line">最后其实四次、五次也能够保证安全只是没有必要</span><br></pre></td></tr></tbody></table></figure>

<h5 id="TCP三次握手如何数据丢失怎么办"><a href="#TCP三次握手如何数据丢失怎么办" class="headerlink" title="TCP三次握手如何数据丢失怎么办?"></a>TCP三次握手如何数据丢失怎么办?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果第一次握手丢失，那么C端会不断发送SYN，直至默认最大值5次之后就不发了</span><br><span class="line">如果第二次握手丢失，那么C端会不断发送SYN，直至默认最大值5次之后就不发了，S端会不断发送SYN,ACK，直至默认最大值5次之后就不发了</span><br><span class="line">如果第三次握手丢失，S端会不断发送SYN,ACK，直至默认最大值5次之后就不发了</span><br><span class="line">第三次握手丢失时，C端处于ESTABLELIST状态，如果不发送数据，可能会触发保活机制，看tcp连接是否还在，如果发送数据，默认发送超过15次没有响应，那么也不会在发了</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45788043/article/details/120399740">CSDN的三次握手丢失处理方法</a></p>
<h1 id="OS-woman-astronaut"><a href="#OS-woman-astronaut" class="headerlink" title="OS:woman_astronaut:"></a>OS:woman_astronaut:</h1><h1 id="数据结构与算法-astonished"><a href="#数据结构与算法-astonished" class="headerlink" title="数据结构与算法:astonished:"></a>数据结构与算法:astonished:</h1><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">冒泡排序</a></h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要两层for循环，第一层for循环从后开始，第二层从第一个元素到第一层提供的元素</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int[] sortArray(int[] nums) {</span><br><span class="line">		 for(int i = nums.length - 1; i &gt; 0; i--) {</span><br><span class="line">			for(int j = 0; j &lt; i; j++) {</span><br><span class="line">				if(nums[j] &gt; nums[j+1]) {</span><br><span class="line">					int tmp = nums[j];</span><br><span class="line">					nums[j] = nums[j+1];</span><br><span class="line">					nums[j+1] = tmp;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return nums;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">选择排序</a></h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要两层for循环，第一层从前向后，第二层从第一层提供元素开始，到数组的末尾结束，找到第二层的最小下标，拿到最小值就行。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int[] sortArray(int[] nums) {</span><br><span class="line">		for(int i = 0; i &lt; nums.length - 1; i++) {</span><br><span class="line">			int minIndex = i;</span><br><span class="line">			for(int j = i+1; j &lt; nums.length; j++) {</span><br><span class="line">				if(nums[j] &lt; nums[minIndex]) minIndex = j;</span><br><span class="line">			}</span><br><span class="line">			int tmp = nums[i];</span><br><span class="line">			nums[i] = nums[minIndex];</span><br><span class="line">			nums[minIndex] = tmp;</span><br><span class="line">		}</span><br><span class="line">		return nums;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">插入排序</a></h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把数组分成两类，一类是排序的一类是非排序的，我们先把要插入的元素给存取出来，每次从有序的数组倒序遍历，只要元素大于要插入的元素，就移动一下元素，小于等于就弹出，并且填充要插入的元素</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int[] sortArray(int[] nums) {</span><br><span class="line">		for(int i = 1; i &lt; nums.length; i++) {</span><br><span class="line">			int tmp = nums[i];</span><br><span class="line">			int j;</span><br><span class="line">			for(j = i - 1; j &gt;= 0; j--) {</span><br><span class="line">				if(nums[j] &gt; tmp) {</span><br><span class="line">					nums[j+1] = nums[j];</span><br><span class="line">				} else {</span><br><span class="line">					break;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			nums[j+1] = tmp;</span><br><span class="line">		}</span><br><span class="line">		return nums;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">快速排序</a></h4><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从最左边选取一个key，start为key+1,end为数组最右边的一个元素,先从end开始，直到一个小于key的就停止，此时start开始向前移动直到大于key的就停止，此时end和start开始交换元素内容，直到end和start相遇，那么key和这个相遇的地方开始交换数据</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public int[] sortArray(int[] nums) {</span><br><span class="line">       if(nums.length == 0 || nums.length == 1) return nums;</span><br><span class="line">       QuickSort(nums,0,nums.length - 1);</span><br><span class="line">       return nums;</span><br><span class="line">    }</span><br><span class="line">public void QuickSort(int[] nums,start,end) {</span><br><span class="line">	if(start &gt;= end) return;</span><br><span class="line">	</span><br><span class="line">	int left = start;</span><br><span class="line">	int right = end;</span><br><span class="line">	int key = nums[start];</span><br><span class="line">	while(start &lt; end) {</span><br><span class="line">		while(nums[end] &gt;= key &amp;&amp; start &lt; end) {</span><br><span class="line">			end--;</span><br><span class="line">		}</span><br><span class="line">		while(nums[start] &lt;= key &amp;&amp; start &lt; end) {</span><br><span class="line">			start++;</span><br><span class="line">		}</span><br><span class="line">		int tmp = nums[start];</span><br><span class="line">		nums[start] = nums[end];</span><br><span class="line">		nums[end] = tmp;</span><br><span class="line">	}</span><br><span class="line">	int tmp = nums[end];</span><br><span class="line">	nums[end] = key;</span><br><span class="line">	nums[left] = tmp;</span><br><span class="line">	QuickSort(nums,left,end-1);</span><br><span class="line">	QuickSort(nums,end+1,right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">有效的字母异位词</a></h4><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为是26位字母且都是小写，字母异位词的意思就是相同大小的字符串中所有的字母出现次数都是一样的，因为字母只有26位，那么这样的话我们可以设一个26个大小的数组,怎么得到数组的下标，都是通过element - 'a'得到</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAnagram(String s, String t) 	{</span><br><span class="line">	if(s.length() != t.length()) return false;</span><br><span class="line"></span><br><span class="line">	int[] record = new int[26];</span><br><span class="line">	</span><br><span class="line">	for(int i = 0;i &lt; s.length(); i++) {</span><br><span class="line">		record[s.charAt(i) - 'a']++;</span><br><span class="line">	}</span><br><span class="line">	for(int j = 0;j &lt; t.length(); j++) {</span><br><span class="line">		record[s.charAt(j) - 'a']--;</span><br><span class="line">	}</span><br><span class="line">	for(int count:record) {</span><br><span class="line">		if(count != 0) return false;</span><br><span class="line">	}</span><br><span class="line">	return true;</span><br><span class="line"></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">两个数组的交集</a></h4><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先通过HashSet一个数组的元素，在遍历另外一个数组并且创建一个新的Set,遍历的时候如果之前的HashSet里面包含了另外一个数组的元素,则放入新创建的Set里面。在把Set转化为数组返回即可</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public int[] intersection(int[] nums1, int[] nums2) {</span><br><span class="line">		Set&lt;Integer&gt; set01 = new HashSet&lt;&gt;();</span><br><span class="line">		Set&lt;Integer&gt; set02 = new HashSet&lt;&gt;();</span><br><span class="line">		for(int i: nums1) {</span><br><span class="line">			set01.add(i);</span><br><span class="line">		}</span><br><span class="line">		for(int j:nums2) {</span><br><span class="line">			if(set01.contains(j)) {</span><br><span class="line">				set02.add(j);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		int[] arr = new int[set02.size()];</span><br><span class="line">		// 比较low的写法</span><br><span class="line">		int index = 0;</span><br><span class="line">		for(int num:set02) {</span><br><span class="line">			arr[index++] = num;</span><br><span class="line">		}</span><br><span class="line">		return arr;</span><br><span class="line">		// 比较high的写法</span><br><span class="line">		</span><br><span class="line">		return set02.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">快乐数</a></h4><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快乐数就是把某个整数上面的所有位数都开平方的和，得到一个整数，一直开平方直到为1就证明此数为快乐数，但是也可能存在无限循环，意思就是开平方得到的和可能存在重复，那么就要使用到Hash表来解决这个问题</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean isHappy(int n) {</span><br><span class="line">       int sum = 0;</span><br><span class="line">       Set&lt;Integer&gt; set01 = new HashSet();</span><br><span class="line">       while(sum != 1) {</span><br><span class="line">           sum = getSum(n);</span><br><span class="line">           if(set01.contains(sum)) return false;</span><br><span class="line">           set01.add(sum);</span><br><span class="line">           n = sum;</span><br><span class="line">       }</span><br><span class="line">       return true;</span><br><span class="line"></span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   public int getSum(int n) {</span><br><span class="line">       int sum = 0;</span><br><span class="line">       // 只要判断n / 10之后 这个n是个位数就可以</span><br><span class="line">       while(n &gt;= 10) {</span><br><span class="line">           sum = sum + (int)Math.pow(n % 10,2);</span><br><span class="line">           n = n / 10;</span><br><span class="line">       }</span><br><span class="line">       sum = sum + (int)Math.pow(n % 10,2);</span><br><span class="line">       return sum;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">两数之和</a></h4><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两数之和这个题目里面提供了target,那么我们可以创建一个Map来存储元素，key存储元素值，value存储元素下标,这样需要先遍历数组通过Map存储元素,因为Target我们是知道的，a+b = target,那么我们先遍历数组，在通过Map.contains方法判断需要补充的元素，这样就能取出两个下标。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) {</span><br><span class="line">     Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">     for(int i = 0 ; i &lt; nums.length; i++) {</span><br><span class="line">     		int need = target - nums[i];</span><br><span class="line">     		if(map.containsKey(need)) {</span><br><span class="line">     			return new int[] {i,map.get(need)};</span><br><span class="line">     		}</span><br><span class="line">     		map.put(nums[i],i);</span><br><span class="line">     }</span><br><span class="line">     return null;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">四数之和</a></h4><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目就是通过Map先取出两个集合当中的和就可以了，然后再去找另外两个集合里面的和是不是和之前的相等即可，这样的话又变成了两个数相加减</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {</span><br><span class="line">       int n = nums1.length;</span><br><span class="line">		Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">		for(int i = 0;i &lt; n;i++) {</span><br><span class="line">			for(int j = 0; j &lt; n; j++) {</span><br><span class="line">				int tmp = nums1[i]+nums2[j];</span><br><span class="line">				map.put(tmp,map.getOrDefault(key, 0)+1)；</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		int count = 0;</span><br><span class="line">		for(int i = 0;i &lt; n; i++) {</span><br><span class="line">			for(int j = 0; j &lt; n; j++) {</span><br><span class="line">				int tmp = nums3[i]+nums4[j];</span><br><span class="line">				if(map.containsKey(0 - tmp)) {</span><br><span class="line">					count += map.get(0 - tmp);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return count;</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="赎金条"><a href="#赎金条" class="headerlink" title="赎金条"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">赎金条</a></h4><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目给我的感觉就是很简单，一看就是用的数组索引，26个字母，那么就可以用new int[]的方式来获得各种字母出现的次数，先用magazine去统计字符出现次数再用ransomNote去减，这样最后数组遍历的时候看看是否存在0即可</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean canConstruct(String ransomNote, String magazine) {</span><br><span class="line">		int[] res = new int[26];</span><br><span class="line">		for(int i = 0; i &lt; magazine.length(); i++) {</span><br><span class="line">			res[magazine.charAt(i) - 'a']++;</span><br><span class="line">		}</span><br><span class="line">		for(int j = 0; j &lt; ransomNote.length(); j++) {</span><br><span class="line">			res[ransomNote.charAt(j) - 'a']--;</span><br><span class="line">		}</span><br><span class="line">		for(int i : res) {</span><br><span class="line">			if(i &lt; 0) return false;</span><br><span class="line">		}</span><br><span class="line">		return true;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/comments/">三数之和</a></h4><h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目最好是用双指针来写，为什么呢? 因为用哈希表会超时，首先需要明白题目的意思就是，不同的三元组，意味着三个元素的值&amp;&amp;位置是唯一的。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {</span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">	Arrays.sort(res);</span><br><span class="line">	for(int i = 0 ; i &lt; nums.length; i++) {</span><br><span class="line">		if(nums[i] &gt; 0) return res;</span><br><span class="line">		</span><br><span class="line">		if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;</span><br><span class="line">		</span><br><span class="line">		int left = i + 1;</span><br><span class="line">		int right = nums.length - 1;</span><br><span class="line">		while(left &lt; right) {</span><br><span class="line">			int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">			if(sum &lt; 0) left++;</span><br><span class="line">			else if(sum &gt; 0) right--;</span><br><span class="line">			else {</span><br><span class="line">				res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">				while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line">				while(left &lt; right &amp;&amp; nums[right] == nums[right-1]) right--;</span><br><span class="line">				left++;</span><br><span class="line">				right--;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	return res;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">反转字符串</a></h4><h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个反转字符串可以通过函数库来写，如果这样写的话就不道德了，那么我们可以通过双指针的方式来写，两个指针分别在头或者在尾，这样头尾指针交换值就可以了，这样就可以不用创建新的数组，非常Nice</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public void reverseString(char[] s) {</span><br><span class="line"> 		int i = 0;</span><br><span class="line"> 		int j = s.length -1;</span><br><span class="line"> 		while(i &lt; j) {</span><br><span class="line"> 			char tmp = s[i];</span><br><span class="line"> 			s[i] = s[j];</span><br><span class="line"> 			s[j] = tmp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line"> 		}</span><br><span class="line"> 		</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="反转字符串2"><a href="#反转字符串2" class="headerlink" title="反转字符串2"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">反转字符串2</a></h4><h5 id="思路-11"><a href="#思路-11" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一段字符串，每次取2k,前k反转,如果剩余的字符不超过k那么就全部反转，如果大于等于k,但小于2k，那么就反转前k个，问题是如果判断剩余有多少个?</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) {</span><br><span class="line">      Test test = new Test();</span><br><span class="line">      System.out.println(test.reverseStr("abcd", 2));</span><br><span class="line">  }</span><br><span class="line">  public String reverseStr(String s, int k) {</span><br><span class="line">      char[] sChar = s.toCharArray();</span><br><span class="line">      int len = sChar.length;</span><br><span class="line">      int alloc = len - 2*k;</span><br><span class="line">      int start = 0;</span><br><span class="line">      while (alloc &gt;= 0) {</span><br><span class="line">          reverse01(sChar, start, k);</span><br><span class="line">          alloc -= 2*k;</span><br><span class="line">          start += 2*k;</span><br><span class="line">      }</span><br><span class="line">      alloc += 2*k;</span><br><span class="line">      if (alloc &lt; 2*k &amp;&amp; alloc &gt;= k){</span><br><span class="line">          reverse01(sChar, start, k);</span><br><span class="line">      } else if (alloc &lt; k) {</span><br><span class="line">          reverse02(sChar, start, len - 1);</span><br><span class="line">      }</span><br><span class="line">      return String.valueOf(sChar);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  public void reverse01(char[] sChar, int start, int k) {</span><br><span class="line">      int i = start;</span><br><span class="line">      int j = start + k - 1;</span><br><span class="line">      while (i &lt; j) {</span><br><span class="line">          char tmp = sChar[i];</span><br><span class="line">          sChar[i] = sChar[j];</span><br><span class="line">          sChar[j] = tmp;</span><br><span class="line">          i++;</span><br><span class="line">          j--;</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  public void reverse02(char[] sChar, int start, int end) {</span><br><span class="line">      int i = start;</span><br><span class="line">      int j = end;</span><br><span class="line">      while (i &lt; j) {</span><br><span class="line">          char tmp = sChar[i];</span><br><span class="line">          sChar[i] = sChar[j];</span><br><span class="line">          sChar[j] = tmp;</span><br><span class="line">          i++;</span><br><span class="line">          j--;</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a href="%5B%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%5D(https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)">替换空格</a></h4><h5 id="思路-12"><a href="#思路-12" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目的思路使用双指针法来写，先用StringBuilder来计算需要填充的字符数量，这样得到了right指针下标，从右往左填，当left指到最左边的时候就出可以结束了。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个其实比较的简单，一个字符一个字符的去查，如果遇到了' '，那么就加%20</span><br></pre></td></tr></tbody></table></figure>



<h5 id="代码-12"><a href="#代码-12" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(String s) {</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line">		for(int i = 0; i &lt; s.length(); i++) {</span><br><span class="line">			if(s.charAt(i) == ' ') {</span><br><span class="line">				sb.append('  ');</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		if(sb.length() == 0) return s;</span><br><span class="line">		// 此时说明有空格</span><br><span class="line">		int left = s.length() - 1;</span><br><span class="line">		s += sb.toString();</span><br><span class="line">		int right= s.length() - 1;</span><br><span class="line">		char[] sChar = s.toCharArray();</span><br><span class="line">		</span><br><span class="line">		while(left &gt;= 0) {</span><br><span class="line">			if(sChar[left] == ' ') {</span><br><span class="line">				sChar[right--] = '0';</span><br><span class="line">				sChar[right--] = '2';</span><br><span class="line">				sChar[right--] = '%';</span><br><span class="line">			} else {</span><br><span class="line">				sChar[right--] = sChar[left];</span><br><span class="line">			}</span><br><span class="line">			left--;</span><br><span class="line">		}</span><br><span class="line">		return String.valueOf(sChar);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="反转字符串里的单词"><a href="#反转字符串里的单词" class="headerlink" title="反转字符串里的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">反转字符串里的单词</a></h4><h5 id="思路-13"><a href="#思路-13" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目就是把字符串里面的单词给反转过来，去除掉前面和后面的空格，再把字符串整体进行反转，再把单个单词进行反转，这样也同样实现了目的，当然也可以通过，创建一个新的数组来存储反转后的字符串，再通过倒序相加就得到了反转和的字符串，但这样也同样失去了这道题的意义。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-13"><a href="#代码-13" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public String reverseWords(String s) {</span><br><span class="line">		// 去除字符串当中的前后的空格以及中间的空格</span><br><span class="line">		String sb = removeSpace(s);</span><br><span class="line">		// 反转整个字符串</span><br><span class="line">		char[] sChar = sb.toCharArray();</span><br><span class="line">		reverseWhole(sChar,0,sChar.length);</span><br><span class="line">		// 反转单个单词</span><br><span class="line">		int start = 0;</span><br><span class="line"> 		int end = 0;</span><br><span class="line">		for(int i = 0; i &lt; sChar.length; i++) {</span><br><span class="line">           if(sChar[i] == ' ') {</span><br><span class="line">               end = i - 1;</span><br><span class="line">               reverseWords(sChar,start,end);</span><br><span class="line">               start = i + 1;</span><br><span class="line">           }</span><br><span class="line"> 		}</span><br><span class="line">		return String.valueOf(sChar);</span><br><span class="line">   }</span><br><span class="line">public String removeSpace(String s) {</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line">		int left = 0;</span><br><span class="line">		int right = s.length() - 1;</span><br><span class="line">		// 先去除掉尾部</span><br><span class="line">		while(left &lt; s.length()) {</span><br><span class="line">			if(s.charAt(left) != ' ') break;</span><br><span class="line">			left++;</span><br><span class="line">		}</span><br><span class="line">		while(0 &lt; right) {</span><br><span class="line">			if(s.charAt(right) != ' ') break;</span><br><span class="line">			right--;</span><br><span class="line">		}</span><br><span class="line">		// 除去中间</span><br><span class="line">		for(int i = left; i &lt;= right; i++) {</span><br><span class="line">			char c = s.chatAt(i);</span><br><span class="line">			if(c != ' ' || sb.charAt(sb.length() - 1) != ' ') {</span><br><span class="line">				sb.append(c);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return sb.toString();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public void reverseWhole(char[] sChar,int start,int end) {</span><br><span class="line">	  while(start &lt; end) {</span><br><span class="line">           char tmp = sChar[start];</span><br><span class="line">           sChar[start] = sChar[end];</span><br><span class="line">           sChar[end] = tmp;</span><br><span class="line">           start++;</span><br><span class="line">           end--;</span><br><span class="line">       }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> public void reverseWords(char[] sChar) {</span><br><span class="line"> 	int start = 0;</span><br><span class="line"> 	int end = 1;</span><br><span class="line"> 	int n = sChar.length;</span><br><span class="line"> 	while(start &lt; n) {</span><br><span class="line"> 		while(end &lt; n &amp;&amp; sChar[end] != ' ') {</span><br><span class="line"> 			end++;</span><br><span class="line"> 		}</span><br><span class="line"> 		reverseWhole(sChar,start,end);</span><br><span class="line"> 		start = end + 1;</span><br><span class="line"> 		end = start + 1;</span><br><span class="line"> 	}</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a></h4><h5 id="思路-14"><a href="#思路-14" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左旋转字符串的做题思路就是，先通过把前n个旋转,再通过把后n个旋转，再把整个字符串选择，如果用subStr,着当然可以一把梭哈，但会申请额外的空间O(n)</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-14"><a href="#代码-14" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String reverseLeftWords(String s, int n) {</span><br><span class="line">		char[] chars = s.toCharArray();</span><br><span class="line">		// 先旋转左边</span><br><span class="line">		reverse(chars,0,n - 1);</span><br><span class="line">		// 再旋转右边</span><br><span class="line">		reverse(chars,n,chars.length - 1);</span><br><span class="line">		// 整体进行旋转</span><br><span class="line">		reverse(chars,0,chars.length - 1);</span><br><span class="line">		return String.valueOf(chars);</span><br><span class="line">}</span><br><span class="line">public String reverse(char[] chars, int start, int end) {</span><br><span class="line">	while(start &lt; end) {</span><br><span class="line">		char tmp = chars[start];</span><br><span class="line">		chars[start] = chars[end];</span><br><span class="line">		chars[end] = tmp;</span><br><span class="line">		start++;</span><br><span class="line">		end--;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="找出字符串第一个匹配项的下标"><a href="#找出字符串第一个匹配项的下标" class="headerlink" title="找出字符串第一个匹配项的下标"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串第一个匹配项的下标</a></h4><h5 id="思路-15"><a href="#思路-15" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个经典的KMP算法，难点主要就是构建前缀表，给我的感觉就是，前缀表构建过程中的每个元素值对后面的一个元素值有影响，前缀意味着以第一个元素开始但是不以最后最后一位结束，后缀意味着以最后一个元素结尾但是开始不能到第一个元素，next[j],j代表着元素下标，next[j]代表着j元素结尾它的前缀最后一个元素索引位置。</span><br></pre></td></tr></tbody></table></figure>



<h5 id="代码-15"><a href="#代码-15" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public int strStr(String haystack, String needle) {</span><br><span class="line">		int len_needle = needle.length();</span><br><span class="line">		int[] preArray = new int[len_needle];</span><br><span class="line">		generatePreArray(preArray,needle);</span><br><span class="line">		int j = -1;</span><br><span class="line">		for(int i = 0; i &lt; haystack.length(); i++) {</span><br><span class="line">			while(j &gt;= 0 &amp;&amp; haystack.charAt(i) == needle.charAt(j+1)) {</span><br><span class="line">				j = next[j];</span><br><span class="line">			}</span><br><span class="line">			if(haystack.charAt(i) == needle.charAt(j+1)) {</span><br><span class="line">				j++;</span><br><span class="line">			}</span><br><span class="line">			if(j == needle.length() - 1) return (i - needle.length() + 1);</span><br><span class="line">		}</span><br><span class="line">		return -1;</span><br><span class="line">    }</span><br><span class="line">public void generatePreArray(int[] preArray,String needle) {</span><br><span class="line">		int j = -1;</span><br><span class="line">		preArray[0] = j;</span><br><span class="line">		for(int i = 1; i &lt; preArray.length; i++) {</span><br><span class="line">			while(j &gt;= 0 &amp;&amp; needle.charAt(i) != needle.charAt(j+1)) {</span><br><span class="line">				j = next[j];</span><br><span class="line">			}</span><br><span class="line">			if(needle.charAt(i) == needle.charAt(j+1)) {</span><br><span class="line">				j++;</span><br><span class="line">			}</span><br><span class="line">			next[i] = j; </span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串</a></h4><h5 id="思路-16"><a href="#思路-16" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个用的还是KMP，刚刚看完还是有点懵的，用s+s,取除掉前后子串，就能证明该s有多个相同的子字符串组成，然后又说用KMP来解这道题目，前后缀这个问题要理解清楚，前缀就是以第一个字符开始不能以最后一个字符结尾，后缀反之。什么是最小的子字符串? 就是通过s - 最长公共前后缀得到，怎么判断这个是符合我们目标的子字符串? len % 子串长度  == 0;哪个是最长的公共前后缀? next[len - 1];</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-16"><a href="#代码-16" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean repeatedSubstringPattern(String s) {</span><br><span class="line">		char[] chars = s.toCharArray();</span><br><span class="line">		int len = chars.length;</span><br><span class="line">		int[] next = new int[len];</span><br><span class="line">		int j = -1;</span><br><span class="line">		int next[0] = j;</span><br><span class="line">		for(int i = 1; i &lt; len; i++) {</span><br><span class="line">			while(j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j + 1)) {</span><br><span class="line">				j = next[j];</span><br><span class="line">			}</span><br><span class="line">			if(s.charAt(i) == s.charAt(j + 1)) {</span><br><span class="line">				j++;</span><br><span class="line">			}</span><br><span class="line">			next[i] = j;</span><br><span class="line">		}</span><br><span class="line">		int maxCommonLen = next[len - 1];</span><br><span class="line">		if(maxCommonLen == -1) return false;</span><br><span class="line">		// 下面是子串长度</span><br><span class="line">		int subLen = len - maxCommonLen - 1;</span><br><span class="line">		if(len % subLen == 0) return true;</span><br><span class="line">		else return false;</span><br><span class="line">		</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目给我的感受就是不是个简单题，这个题目需要一定的数学基础，怎么判断哪个是最小子字符串(当然这个题目没有要求给出具体子字符串，但是也是可以实现的)，如何判断该子字符是否满足组成s字符串的要求? 构建一个next数组，并且取最后一个next[len - 1]的大小，得到子字符串的长度，总字符串%子字符串==0就说明能满足。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><h4 id="栈实现队列-232-用栈实现队列-力扣（LeetCode）"><a href="#栈实现队列-232-用栈实现队列-力扣（LeetCode）" class="headerlink" title="[栈实现队列](232. 用栈实现队列 - 力扣（LeetCode）)"></a>[栈实现队列](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode）</a>)</h4><h5 id="思路-17"><a href="#思路-17" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过用两个栈来实现队列的所有操作，一个是进栈一个是出栈，添加元素时就往进栈当中加就可以了，如果是pop操作那么先判断出栈里面有没有元素，有则从出栈里面去出元素，否则，先把进栈里面的元素全部导入到出栈里面，然后再在出栈里面出一个元素，如何判断队列为空，就看出栈进栈是否都为空，如果都为空说明队列为空，如何获得第一个元素peek()，如何得到呢，其实就和前面的pop逻辑一样，先判断出栈有没有，有出栈栈顶的第一个元素就是的，出栈没有则需要把进栈的元素栈底那个就是的</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-17"><a href="#代码-17" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stackIn;</span><br><span class="line">Stack&lt;Integer&gt; stackOut;</span><br><span class="line">  	public MyQueue() {</span><br><span class="line"> 		stackIn = new Stack();</span><br><span class="line">        stackOut = new Stack();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void push(int x) {</span><br><span class="line">    	stackIn.push(x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public int pop() {</span><br><span class="line">    	InsertIntoOut();</span><br><span class="line">    	return stackOut.pop();</span><br><span class="line">    	</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public int peek() {</span><br><span class="line">    	InsertIntoOut();</span><br><span class="line">    	return stackOut.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public boolean empty() {</span><br><span class="line">    	if(stackOut.isEmpty() &amp;&amp; stackIn.isEmpty()) return true;</span><br><span class="line">    	else return false;</span><br><span class="line">    }</span><br><span class="line">    public void InsertIntoOut() {</span><br><span class="line">    	if(!stackOut.isEmpty()) {</span><br><span class="line">    		return;</span><br><span class="line">    	}</span><br><span class="line">    	while(!stackIn.isEmpty()) {</span><br><span class="line">    		stackOut.push(stackIn.pop());</span><br><span class="line">    	}</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">用队列实现栈</a></h4><h5 id="思路-18"><a href="#思路-18" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此时我们需要两个队列来实现栈，一个queue1,一个queue2,queue2完全是用来备份的，push操作直接往queue2当中放,然后再把queue1里面的元素放到queue2里面去, 然后再把queue2里面的元素放到quque1</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-18"><a href="#代码-18" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue1;</span><br><span class="line">Queue&lt;Integer&gt; queue2;</span><br><span class="line">   public MyStack() {</span><br><span class="line">   	queue1 = new LinkedList&lt;&gt;();</span><br><span class="line">   	queue2 = new LinkedList&lt;&gt;();</span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   public void push(int x) {</span><br><span class="line">   	queue2.offer(x);</span><br><span class="line">   	while(!queue1.isEmpty()) {</span><br><span class="line">   		queue2.offer(queue1.poll());</span><br><span class="line">   	}</span><br><span class="line">       Queue tmp = new LinkedList();</span><br><span class="line">       tmp = queue1;</span><br><span class="line">       queue1 = queue2;</span><br><span class="line">       queue2 = tmp;</span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   public int pop() {</span><br><span class="line">   	return queue1.poll();</span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   public int top() {</span><br><span class="line">   	return queue1.peek();</span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   public boolean empty() {</span><br><span class="line">   	return queue1.isEmpty();</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></h4><h5 id="思路-19"><a href="#思路-19" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">必须满足三个条件，每个左边的符号要和右边的符号匹配且同类型，左边的符号要以正确的顺序闭合，这个我觉得可以用栈来解决，当遍历到左符号了，就直接往里面压就行，当遍历到右边符号了，就直接和栈顶元素进行匹配，如果一样栈顶元素弹出，且遍历下一个元素，元素遍历完之后，判断栈是否为空。刚刚测试完发现，有没有注意到的点就是遍历到右边符号时要判断一个栈是否为空。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-19"><a href="#代码-19" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) {</span><br><span class="line">		Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">		Map&lt;Character,Character&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">		map.put('[',']');</span><br><span class="line">		map.put('(',')');</span><br><span class="line">		map.put('{','}');</span><br><span class="line">		char[] chars = s.toCharArray();</span><br><span class="line">		for(int i = 0; i &lt; chars.length; i++) {</span><br><span class="line">			if(chars[i] == '[' || chars[i] == '(' || chars[i] == '{') {</span><br><span class="line">				stack.push(chars[i]);</span><br><span class="line">			} else {</span><br><span class="line">				if(!stack.isEmpty() &amp;&amp; map.get(stack.pop()) == chars[i]) {</span><br><span class="line">				</span><br><span class="line">				} else {</span><br><span class="line">					return false;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		if(stack.isEmpty()) return true;</span><br><span class="line">        return false;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值</a></h4><h5 id="思路-20"><a href="#思路-20" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逆波兰表达式的思路就是，把每个字符串数组的tokens,如果是数字就往栈里面压，如果不是就把后面两个pop出来并进行计算，再把计算结果压入栈里面，继续遍历字符</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-20"><a href="#代码-20" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int evalRPN(String[] tokens) {</span><br><span class="line">		Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">		for(String str : tokens) {</span><br><span class="line">			if(str.equals("+")) {</span><br><span class="line">				stack.push(stack.pop() + stack.pop());</span><br><span class="line">			} else if(str.equals("-")) {</span><br><span class="line">				int num1 = stack.pop();</span><br><span class="line">				int num2 = stack.pop();</span><br><span class="line">				stack.push(num2 - num1);</span><br><span class="line">			} else if(str.equals("*")) {</span><br><span class="line">				stack.push(stack.pop() * stack.pop());</span><br><span class="line">			} else if(str.equals("/")) {</span><br><span class="line">				int num1 = stack.pop();</span><br><span class="line">				int num2 = stack.pop();</span><br><span class="line">				stack.push(num2 / num1);</span><br><span class="line">			} else {</span><br><span class="line">				stack.push(Integer.valueOf(str));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return Integer.valueOf(stack.pop());</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a></h4><h5 id="思路-21"><a href="#思路-21" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目的需求就是给定一个数组nums和一个k大小的滑动窗口,每次移动的时候给出滑动窗口里的最大值。我们需要一个队列queue来做滑动窗口，每次pop()的时候，队列出口的元素就是最大值，pop()出去即可。每次push的时候，push进去的元素要把小于它的元素给去除掉，直到遇到大于等于它的就停止。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-21"><a href="#代码-21" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Class MyQueue {</span><br><span class="line">	Queue&lt;Integer&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	public void poll(int val) {</span><br><span class="line">		if(!que.isEmpty() &amp;&amp; que.peek() == val) {</span><br><span class="line">			que.poll();</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	public void push(int val) {</span><br><span class="line">		while(!que.isEmpty() &amp;&amp; que.getLast() &lt; val) {</span><br><span class="line">			que.removeLast();</span><br><span class="line">		}</span><br><span class="line">		que.push(val);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	public Integer front() {</span><br><span class="line">		return que.peek();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int[] maxSlidingWindow(int[] nums, int k) {</span><br><span class="line">		int len = nums.length - k + 1;</span><br><span class="line">		int[] res = new int[len + 1];</span><br><span class="line">		int num = 0;</span><br><span class="line">		MyQueue myQue = new MyQueue();</span><br><span class="line">		// 先把K个元素放进去</span><br><span class="line">		for(int i = 0; i &lt; k; i++) {</span><br><span class="line">			myQue.push(nums[i]);</span><br><span class="line">		}</span><br><span class="line">		res[num++] = myQue.peek();</span><br><span class="line">		for(int j = k; j &lt; nums.length; j++) {</span><br><span class="line">			myQue.poll(nums[j-k]);</span><br><span class="line">			myQue.push(nums[j]);</span><br><span class="line">			res[num++] = myQueue.peek();</span><br><span class="line">		}</span><br><span class="line">		return res;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="前k个高频元素"><a href="#前k个高频元素" class="headerlink" title="前k个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">前k个高频元素</a></h4><h5 id="思路-22"><a href="#思路-22" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目给一个数组nums和k,先通过Map把num中元素出现的频率进行统计一波，再把PriorityQueue放入二元组，对其pair[1] - pair[2]进行小堆顶进行排序，再通过创建一个k大小的数组存储前k个元素;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-22"><a href="#代码-22" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int[] topKFrequent(int[] nums, int k) {</span><br><span class="line">		Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">		for(int num : nums) {</span><br><span class="line">			map.put(num,map.getOrDefault(num,0) + 1);</span><br><span class="line">		}</span><br><span class="line">		PriorityQueue&lt;int[]&gt; priorityQue = new PriorityQueue&lt;&gt;((pair1,pair2)-&gt;pair2[1] - pair1[1]);</span><br><span class="line">		for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()) {</span><br><span class="line">			priorityQue.add(new int[]{entry.getKey(),entry.getValue()});</span><br><span class="line">		}</span><br><span class="line">		int[] res = new int[k];</span><br><span class="line">		for(int i = 0; i &lt; k; i++) {</span><br><span class="line">			res[i] = priorityQue.poll()[0];</span><br><span class="line">		}</span><br><span class="line">		return res;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">递归遍历</a></h4><h5 id="思路1-1"><a href="#思路1-1" class="headerlink" title="思路1:"></a>思路1:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前中后序遍历，我们这次主打的递归的方式，递归那么就需要确定递归的参数以及返回值，递归的终止条件，递归的逻辑，咱们这个递归的终止条件就是当遍历的节点为null时就是终止条件了，返回值是List&lt;Integer&gt;，所以我们需要创建一个List(result)来存储值，参数就是TreeNode以及result,如果是前序遍历那么递归的逻辑就是中左右，其他遍历也是如此</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码1"><a href="#代码1" class="headerlink" title="代码1:"></a>代码1:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) {</span><br><span class="line">		List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">		Traveral(root, result);</span><br><span class="line">		return result;</span><br><span class="line">   }</span><br><span class="line">public void Traversal(TreeNode root, List&lt;Integer&gt; result) {</span><br><span class="line">		if(root == null) return;</span><br><span class="line">		result.add(root.val);</span><br><span class="line">		Traversal(root.left,result);</span><br><span class="line">		Traversal(root.right,result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="思路2"><a href="#思路2" class="headerlink" title="思路2:"></a>思路2:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用迭代法来实现前序遍历的原理很简单，就是通过栈来实现，先把根节点压入栈当中，在把根节点给pop出来，这样就能得到根节点的左右子节点，记得是先压入右子节点，再是左子节点，因为栈是先进后出的</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码2"><a href="#代码2" class="headerlink" title="代码2:"></a>代码2:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">前序</span><br><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) {</span><br><span class="line">		List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		if(root == null) return res;</span><br><span class="line">		Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">		stack.push(root);</span><br><span class="line">		while(!stack.isEmpty()) {</span><br><span class="line">			TreeNode root1 = stack.pop();</span><br><span class="line">			res.add(root1.val);</span><br><span class="line">			if(root1.right != null) stack.push(root1.right);</span><br><span class="line">			if(root1.left != null) stack.push(root1.left);</span><br><span class="line">		}</span><br><span class="line">		return res;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码3"><a href="#代码3" class="headerlink" title="代码3:"></a>代码3:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">后序</span><br><span class="line"> public List&lt;Integer&gt; backorderTraversal(TreeNode root) {</span><br><span class="line"> 		List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"> 		Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line"> 		stack.push(root);</span><br><span class="line"> 		while(!stack.isEmpty()) {</span><br><span class="line"> 			TreeNode node = stack.pop();</span><br><span class="line"> 			res.add(node.val);</span><br><span class="line"> 			if(node.left != null) stack.push(node.left);</span><br><span class="line"> 			if(node.right != null) stack.push(node.right);</span><br><span class="line"> 		}</span><br><span class="line"> 		Collections.reverse(res);</span><br><span class="line"> 		return res;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h5 id="思路4"><a href="#思路4" class="headerlink" title="思路4:"></a>思路4:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代法的中序遍历不太好整，遍历的顺序是左中右，那么我们可以先把元素存储到栈当中，先把最左边的，最左边为空了，再放最右边的，可以想象一个三层的二叉树，一个根节点，根节点接着左节点，但没有右节点，左节点跟着一个左节点＋右节点，那么在遍历的时候，我们先把根节点压入栈当中，再把根节点的左孩子节点压入栈中，再把左孩子的左孩子压入栈中，此事孙左节点没有左右儿子了，那么就把它从栈里面弹出来，指针cur指向弹出的左子孙的右节点，判断右节点为空，那么此时就把左孩子给弹出来，再把cur指向右子孙，听起来挺复杂，咱们只要把它实例化就行了。去想想它的构造过程，Though it is painful.</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码4"><a href="#代码4" class="headerlink" title="代码4:"></a>代码4:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) {</span><br><span class="line">       List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		if (root == null){</span><br><span class="line">           return res;</span><br><span class="line">       }</span><br><span class="line">		Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">		TreeNode cur = root;</span><br><span class="line">		while(cur != null || !stack.isEmpty()) {</span><br><span class="line">			if(cur != null) {</span><br><span class="line">				stack.push(cur);</span><br><span class="line">				cur = cur.left;</span><br><span class="line">			} else {</span><br><span class="line">				cur = stack.pop();</span><br><span class="line">				res.add(cur.val);</span><br><span class="line">				cur = cur.right;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return res;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">层序遍历</a></h4><h5 id="思路-23"><a href="#思路-23" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们使用队列Queue来存储二叉树的节点,从左到右的一层一层的遍历，怎么一层一层的遍历? 我们通过队列里面的元素大小来确定每次每一层的元素大小。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-23"><a href="#代码-23" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">		if(root != null) que.offer(root);</span><br><span class="line">		while(!que.isEmpty()) {</span><br><span class="line">			int size = que.size();</span><br><span class="line">			List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">			for(int i = 0 ; i &lt; size; i++) {</span><br><span class="line">				TreeNode node = que.poll();</span><br><span class="line">				list.add(node.val);</span><br><span class="line">				if(node.left != null) que.offer(node.left);</span><br><span class="line">				if(node.right != null) que.offer(node.right);</span><br><span class="line">			}</span><br><span class="line">			res.add(list);</span><br><span class="line">		}</span><br><span class="line">		return res;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></h4><h5 id="思路-24"><a href="#思路-24" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目只要把左右子节点进行调换即可，前后序的递归，前序的迭代,层序遍历都可以实现</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1:"></a>代码1:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> DFS</span><br><span class="line"> public TreeNode invertTree(TreeNode root) {</span><br><span class="line">		if(root == null) return null;</span><br><span class="line">		swap(root);</span><br><span class="line">		invertTree(root.left);</span><br><span class="line">		invertTree(root.right);</span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line"> public TreeNode invertTree(TreeNode root) {</span><br><span class="line">		if(root == null) return null;</span><br><span class="line">		invertTree(root.left);</span><br><span class="line">		invertTree(root.right);</span><br><span class="line">		swap(root);</span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line">    public void swap(TreeNode root) {</span><br><span class="line">		TreeNode node = root.left;</span><br><span class="line">		root.left = root.right;</span><br><span class="line">		root.right = node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码2-1"><a href="#代码2-1" class="headerlink" title="代码2:"></a>代码2:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">  public TreeNode invertTree(TreeNode root) {</span><br><span class="line">		Stack&lt;TreeNode&gt; stack = new Stack();</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">		stack.push(root);</span><br><span class="line">		while(!stack.isEmpty()) {</span><br><span class="line">			TreeNode node = stack.pop();</span><br><span class="line">			swap(node);</span><br><span class="line">			if(node.right != null) stack.push(node.right);</span><br><span class="line">			if(node.left != null) stack.push(node.left);</span><br><span class="line">			</span><br><span class="line">		}</span><br><span class="line">		return root;</span><br><span class="line">    }</span><br><span class="line">    public void swap(TreeNode root) {</span><br><span class="line">		TreeNode node = root.left;</span><br><span class="line">		root.left = root.right;</span><br><span class="line">		root.right = node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码3-1"><a href="#代码3-1" class="headerlink" title="代码3:"></a>代码3:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  public TreeNode invertTree(TreeNode root) {</span><br><span class="line">		Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">		que.offer(root);</span><br><span class="line">		while(!que.isEmpty()) {</span><br><span class="line">			int size = que.size();</span><br><span class="line">			for(int i = 0;i &lt; size; i++) {</span><br><span class="line">				TreeNode node = que.pop();</span><br><span class="line">				swap(node);</span><br><span class="line">				if(node.left != null) que.offer(node.left);</span><br><span class="line">				if(node.right != null) que.offer(node.right);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return rootl</span><br><span class="line">    }</span><br><span class="line">    public void swap(TreeNode root) {</span><br><span class="line">		TreeNode node = root.left;</span><br><span class="line">		root.left = root.right;</span><br><span class="line">		root.right = node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></h4><h5 id="思路-25"><a href="#思路-25" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个可以用递归和迭代两种写法，递归我们先要确定终止条件，左右子节点只有一个为空，返回false,都为空返回false,左右都不空但值不同返回false,递归的参数就是左右子节点，递归的单层逻辑就是，左孩子的左孩子与右孩子的右孩子相比较。左孩子的右孩子和右孩子的左孩子相互比较，比较完之后看是否都相等，返回比较结果。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1:"></a>代码1:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSymmetric(TreeNode root) {</span><br><span class="line">		if(root == null) return true;</span><br><span class="line">		return isCompare(root.left,root.right);</span><br><span class="line">   }</span><br><span class="line">public boolean isCompare(TreeNode left,TreeNode right) {</span><br><span class="line">		if(left == null &amp;&amp; right != null) return false;</span><br><span class="line">		else if(left != null &amp;&amp; right == null) return false;</span><br><span class="line">		else if(left == null &amp;&amp; right == null) return true;</span><br><span class="line">		else if(left.val != right.val) return false;</span><br><span class="line">		boolean L = isCompare(left.left,right.right);</span><br><span class="line">		boolean R = isCompare(left.right,right.left);</span><br><span class="line">		return L&amp;&amp;R;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码2-2"><a href="#代码2-2" class="headerlink" title="代码2:"></a>代码2:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSymmetric(TreeNode root) {</span><br><span class="line">		Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">		que.offer(root.left);</span><br><span class="line">		que.offer(root.right);</span><br><span class="line">		while(!que.isEmpty()) {</span><br><span class="line">			TreeNode left = que.poll();</span><br><span class="line">			TreeNode right = que.poll();</span><br><span class="line">			if(left == null &amp;&amp; right == null) continue;</span><br><span class="line">			</span><br><span class="line">			if(left == null &amp;&amp; right !=null) return false;</span><br><span class="line">			else if(left != null &amp;&amp; right ==null) return false;</span><br><span class="line">			else if(left.val != right.val) return false;</span><br><span class="line">           </span><br><span class="line">           que.offer(left.left);</span><br><span class="line">           que.offer(right.right);</span><br><span class="line">           que.offer(left.right);</span><br><span class="line">           que.offer(right.left);</span><br><span class="line">		}</span><br><span class="line">		return true;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">最大深度</a></h4><h5 id="思路-26"><a href="#思路-26" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目最好是用前序遍历来写这样才能让你弄懂这个题目，因为用前序的方式来写的话你就能清楚什么叫回溯了，当然你也可以用后序遍历的方式来写，但这样感受不到回溯的美，也可以用迭代法来写，这样写其实其实就是层序遍历了。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-24"><a href="#代码-24" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">后序遍历</span><br><span class="line">public int maxDepth(TreeNode root) {</span><br><span class="line">		if(root == null) return;</span><br><span class="line">		int L = maxDepth(root.left); // 左</span><br><span class="line">		int R = maxDepth(root.right); // 右</span><br><span class="line">		int depth = 1 + Math.max(L,R); // 中</span><br><span class="line">		return depth;</span><br><span class="line">    }</span><br><span class="line">public int maxDepth(TreeNode root) {</span><br><span class="line">	int result = 0;</span><br><span class="line">	maxD(root,1);</span><br><span class="line">	return result;</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line">public void maxD(TreeNode root,int depth) {</span><br><span class="line">	result = result &gt; depth ? result:depth;</span><br><span class="line">	if(root.left == null &amp;&amp; root.right == null) return;</span><br><span class="line">	if(root.left != null) {</span><br><span class="line">		depth++</span><br><span class="line">		maxD(root.left,depth);</span><br><span class="line">		depth--</span><br><span class="line">	}</span><br><span class="line">	if(root.right != null) {</span><br><span class="line">		depth++;</span><br><span class="line">		maxD(root.right,depth);</span><br><span class="line">		depth--;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1:"></a>代码1:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) {</span><br><span class="line">	Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">	if(root == null) return 0;</span><br><span class="line">	que.offer(root);</span><br><span class="line">	int res = 0;</span><br><span class="line">	while(!que.isEmpty()) {</span><br><span class="line">		res++;</span><br><span class="line">		int size = que.size();</span><br><span class="line">		for(int i = 0; i &lt; size; i++) {</span><br><span class="line">			TreeNode node = que.pop();</span><br><span class="line">			que.offer(node.left);</span><br><span class="line">			que.offer(node.right);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	return res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">最小深度</a></h4><h5 id="思路-27"><a href="#思路-27" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先清楚什么是最小深度，从根节点到最短路程的叶子节点，那么我们可能会遇到的情况就是左子树为空，那么最短距离就是1+右子树最短深度， 右子树为空，那么最短距离就是1+左子树最短深度，递归的写法就是，停止条件就是碰到左右节点为空，单层逻辑就是先判断得到左右字子树高度，再给出最低的。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-25"><a href="#代码-25" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> public int minDepth(TreeNode root) {</span><br><span class="line"> 		if(root == null) return 0;</span><br><span class="line"> 		if(root.left == null &amp;&amp; root.right != null) {</span><br><span class="line"> 			return 1 + minDepth(root.right);</span><br><span class="line"> 		}</span><br><span class="line"> 		if(root.left != null &amp;&amp; root.right == null) {</span><br><span class="line"> 			return 1 + minDepth(root.left);</span><br><span class="line"> 		}</span><br><span class="line"> 		int L = minDepth(root.left);</span><br><span class="line"> 		int R = minDepth(root.right);</span><br><span class="line"> 		int minD = 1 + Math.min(L,R);</span><br><span class="line"> 		return minD;</span><br><span class="line">    }</span><br><span class="line">//迭代法</span><br><span class="line">public int minDepth(TreeNode root) {</span><br><span class="line">		Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">		if(root == null) return 0;</span><br><span class="line">		que.offer(root);</span><br><span class="line">		int depth = 0;</span><br><span class="line">		while(!que.isEmpty()) {</span><br><span class="line">			int size = que.size();</span><br><span class="line">			depth++;</span><br><span class="line">			for(int i = 0; i &lt; size; i++) {</span><br><span class="line">				TreeNode node = que.pop();</span><br><span class="line">				if(node.left != null)que.offer(node.left);</span><br><span class="line">				if(node.right != null)que.offer(node.right);</span><br><span class="line">				if(node.left == null &amp;&amp; node.right == null) return depth;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return depth;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">完全二叉树</a></h4><h5 id="思路-28"><a href="#思路-28" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于普通的二叉树直接用递归的方式就能解决，对于完全二叉树，咱们有特殊的办法，什么特殊的办法呢? 完全二叉树里面肯定都会有子的满二叉树，怎么判断是否是满二叉树呢? 最左边的深度和最右边的深度是一样长说明是满二叉树，你怎么这么确定呢? 因为完全二叉树的原因，完全最后一层的叶子节点都是靠左的。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-26"><a href="#代码-26" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int countNodes(TreeNode root) {</span><br><span class="line">		if(root == null) return 0;</span><br><span class="line">		TreeNode left = root.left;</span><br><span class="line">		TreeNode right = root.right;</span><br><span class="line">		int L = 0;</span><br><span class="line">		while(left != null) {</span><br><span class="line">			L++;</span><br><span class="line">			left = left.left;</span><br><span class="line">		}</span><br><span class="line">		int R = 0;</span><br><span class="line">		while(right != null) {</span><br><span class="line">			R++;</span><br><span class="line">			right = right.right;</span><br><span class="line">		}</span><br><span class="line">		if(L == R) {</span><br><span class="line">			return (2 &lt;&lt; L) - 1;</span><br><span class="line">		}</span><br><span class="line">		return 1 + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">平衡二叉树</a></h4><h5 id="思路-29"><a href="#思路-29" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个题目最好是用递归来写，因为是求高度，咱们用后序遍历来写这道题目。平衡二叉树就是左右子树的高度差小于1</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-27"><a href="#代码-27" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isBalanced(TreeNode root) {</span><br><span class="line">		if(root == null) return true;</span><br><span class="line">		return getHeight(root) == -1 ? false:true;</span><br><span class="line">    }</span><br><span class="line">public int getHeight(TreeNode root) {</span><br><span class="line">		if(root == null) {</span><br><span class="line">			return 0;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		int L = getHeight(root.left);</span><br><span class="line">		int R = getHeight(root.right);</span><br><span class="line">		</span><br><span class="line">		if(Math.abs(L-R) &gt; 1) {</span><br><span class="line">			return -1;</span><br><span class="line">		}</span><br><span class="line">		int res = Math.max(L,R) + 1;</span><br><span class="line">		return res;</span><br><span class="line">		</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="二叉树所有的路径"><a href="#二叉树所有的路径" class="headerlink" title="二叉树所有的路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">二叉树所有的路径</a></h4><h5 id="思路-30"><a href="#思路-30" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个直接用递归去写就好，确定好终止条件是什么，单层逻辑是什么，递归函数的参数是什么，这样就可以了，听说迭代也可以写，本题用到了回溯的方法。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-28"><a href="#代码-28" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) {</span><br><span class="line">		List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		list.add(root);</span><br><span class="line">		getPath(root,list,res);</span><br><span class="line">		return res;</span><br><span class="line">    }</span><br><span class="line">public void getPath(TreeNode root, List&lt;Integer&gt; list, List&lt;String&gt; res) {</span><br><span class="line">		if(root.left == null &amp;&amp; root.right == null) {</span><br><span class="line">			int size = list.size();</span><br><span class="line">			StringBuilder sb = new StringBuilder();</span><br><span class="line">			for(int i = 0; i &lt; size - 1; i ++) {</span><br><span class="line">				sb.append(list.get(i));</span><br><span class="line">				sb.append("-&gt;");</span><br><span class="line">			}</span><br><span class="line">			sb.append(list.get(size - 1));</span><br><span class="line">			res.add(sb.toString());</span><br><span class="line">		}</span><br><span class="line">		if(root.left != null) {</span><br><span class="line">			list.add(root.left);</span><br><span class="line">			getPath(root.left,list,res);</span><br><span class="line">			list.remove(list.size() -1);</span><br><span class="line">		}</span><br><span class="line">		if(root.right != null) {</span><br><span class="line">			list.add(root.right);</span><br><span class="line">			getPath(root.right,list,res);</span><br><span class="line">			list.remove(list.size() -1);</span><br><span class="line">		}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a></h4><h5 id="思路-31"><a href="#思路-31" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个贪心算法，也就是通过局部最优得到全局最优。我们需要能喂足尽可能多的孩子，那么最大孩子数是饼干数，g[i] &gt;= s[j],需要先给这两个数组排序,用最大的饼喂给胃口最大的</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-29"><a href="#代码-29" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int findContentChildren(int[] g, int[] s) {</span><br><span class="line">		Collections.sort(g);</span><br><span class="line">		Collections.sort(s);</span><br><span class="line">		int res = 0;</span><br><span class="line">		int index = s.length - 1;</span><br><span class="line">		for(int i = g.length - 1; i &gt;= 0; i--) {</span><br><span class="line">			if(index &gt;=0 &amp;&amp; s[index] &gt;= g[i]) {</span><br><span class="line">				res++;</span><br><span class="line">				index++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return res;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="摇摆序列"><a href="#摇摆序列" class="headerlink" title="摇摆序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">摇摆序列</a></h4><h5 id="思路-32"><a href="#思路-32" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前后的差值是不一样的，那么我们就可以定义两个参数了，一个preDiff,一个curDiff,一个代表当前元素和前面的元素差距，一个代表当前的元素和下一个元素的差距，我们需要去维护有多少个峰值。我们会遇到两种特殊的情况，第一种就平坡，比如 1，2，2，2，1.其实这个序列只有2个峰值，那么我们可以舍去左边的两个2，也就是当preDiff = 0,curDiff &gt; 0的时候算一个峰值，第二种特殊情况就是出现单调递增1，2，2，2，2，3，4.如果我们还是按遍历的顺序来实时维护preDiff的话，也就是(preDiff &gt;=0 &amp;&amp; curDiff &lt; 0)就算峰值的话，再单调的坡上面是不行的，那么我们需要在遇到峰值的时候再改变preDiff.最后的一个特殊情况就是只有两个元素，也就是不能满足preDiff，那么该怎么办呢？我们都是先假设第一个元素前面会有一个和第一个元素值相同的元素，这样就有了preDiff = 0,并且与此同时我们默认最右边的元素是一个峰值。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-30"><a href="#代码-30" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int wiggleMaxLength(int[] nums) {</span><br><span class="line">       int curDiff;</span><br><span class="line">       int preDiff = 0;</span><br><span class="line">       int res = 1; // 默认最右边的元素为一个峰值</span><br><span class="line">       for(int i = 0; i &lt; nums.length - 1; i++) {</span><br><span class="line">       	curDiff = nums[i+1] - nums[i];</span><br><span class="line">       	if((preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0) || (preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0)) {</span><br><span class="line">       		res++;</span><br><span class="line">       		preDiff = curDiff;</span><br><span class="line">       	}</span><br><span class="line">       }</span><br><span class="line">       return res;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">最大子序和</a></h4><h5 id="思路-33"><a href="#思路-33" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要贪心贪的地方就是当出现和为&lt;=0的时候那么咱们就可以停止了，每到连续最大值的时候就记录以下。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-31"><a href="#代码-31" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) {</span><br><span class="line">		int res = Integer.MIN_VALUE;</span><br><span class="line">		int sum = 0;</span><br><span class="line">		for(int i : nums) {</span><br><span class="line">			sum += i;</span><br><span class="line">			if(sum &gt; res) res = sum;</span><br><span class="line">			if(sum &lt;= 0) {</span><br><span class="line">				sum = 0;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return res;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票</a></h4><h5 id="思路-34"><a href="#思路-34" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">局部最优获得整体最优，我们把股票价格数组prices进行拆分，只要相邻两天为正数，那么这笔买卖咱们就做</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-32"><a href="#代码-32" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) {</span><br><span class="line">		int[] value = new int[prices.length - 1];</span><br><span class="line">		for(int i = 0; i &lt; prices.length - 1; i++) {</span><br><span class="line">			if((prices[i+1] - prices[i]) &gt; 0) sum +=  (prices[i+1] - prices[i]);</span><br><span class="line">			</span><br><span class="line">		}</span><br><span class="line">		return sum;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a></h4><h5 id="思路-35"><a href="#思路-35" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在每个起跳点values[i]上力所能及的所有点位上选择能条最远的。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-33"><a href="#代码-33" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean canJump(int[] nums) {</span><br><span class="line">		int cover = 0;</span><br><span class="line">		for(int i = 0; i &lt;= cover; i++) {</span><br><span class="line">			cover = Math.max(i + nums[i],cover);</span><br><span class="line">			if(cover &gt;= (nums.length - 1)) return true;</span><br><span class="line">		}</span><br><span class="line">		return false;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码2-3"><a href="#代码2-3" class="headerlink" title="代码2:"></a>代码2:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int jump(int[] nums) {</span><br><span class="line">		int cover = 0;</span><br><span class="line">		int moreCover = 0;</span><br><span class="line">		int res = 1;</span><br><span class="line">		int startIndex = 0;</span><br><span class="line">		int highIndex = 0;</span><br><span class="line">		while(moreCover &lt; (nums.length - 1)) {</span><br><span class="line">			cover = moreCover;</span><br><span class="line">			startIndex = highIndex;</span><br><span class="line">			for(int i = startIndex; i &lt;= cover; i++) {</span><br><span class="line">              if((i+nums[i]) &gt; moreCover) {</span><br><span class="line">                  moreCover = i+nums[i];</span><br><span class="line">                  highIndex = i;</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">          res++;</span><br><span class="line">		}</span><br><span class="line">		return res;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="k次取反"><a href="#k次取反" class="headerlink" title="k次取反"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">k次取反</a></h4><h5 id="思路-36"><a href="#思路-36" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k次取反可以对同一个元素重复取，我们先通过从小到大进行排序，遇到K小于0的取反，遇到大于0的直接来回取反</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-34"><a href="#代码-34" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int largestSumAfterKNegations(int[] nums, int k) {</span><br><span class="line">			nums = IntStream.of(nums).boxed().sorted((o1,o2) -&gt; Math.abs(o2) - Math.abs(o1)).mapToInt(Integer::intValue).toArray();</span><br><span class="line">			for(int i = 0; i &lt; nums.length &amp;&amp; k &gt; 0; i++) {</span><br><span class="line">				if(nums[i] &lt; 0) {</span><br><span class="line">					nums[i] = -nums[i];</span><br><span class="line">					k--;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			if(k % 2 == 1) {</span><br><span class="line">				nums[nums.length -1] = -nums[nums.length -1];</span><br><span class="line">			}</span><br><span class="line">			return Arrays.stream(nums).sum();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="汽车加油"><a href="#汽车加油" class="headerlink" title="汽车加油"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">汽车加油</a></h4><h5 id="思路-37"><a href="#思路-37" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用暴力的解法很简单，循环每个加油站，每个加油站i到下一个加油站i+1需要cos[i]升汽油，</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-35"><a href="#代码-35" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) {</span><br><span class="line">		for(int i = 0; i &lt; gas.length; i++) {</span><br><span class="line">			int res = 0;</span><br><span class="line">			res = gas[i] - cos[i];</span><br><span class="line">			int index = (i+1)%gas.length;</span><br><span class="line">			while(res &lt; 0 &amp;&amp; index != i) {</span><br><span class="line">				res += gas[index] - cos[index];</span><br><span class="line">				index = (1+index)%gas.length;</span><br><span class="line">			}</span><br><span class="line">			if(res &gt;=0 &amp;&amp; index == i) return i;</span><br><span class="line">		}</span><br><span class="line">		return -1;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码1-4"><a href="#代码1-4" class="headerlink" title="代码1:"></a>代码1:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) {</span><br><span class="line">       int curSum = 0;</span><br><span class="line">       int totalSum = 0;</span><br><span class="line">       int start = 0;</span><br><span class="line">       int i;</span><br><span class="line">     	for(i = 0; i &lt; gas.length; i++) {</span><br><span class="line">     		curSum += gas[i] - cost[i];</span><br><span class="line">     		totalSum += gas[i] - cost[i];</span><br><span class="line">     		if(curSum &lt; 0) {</span><br><span class="line">     			start = i + 1;</span><br><span class="line">     			curSum = 0;</span><br><span class="line">     		}</span><br><span class="line">     	}</span><br><span class="line">     	if(totalSum &lt; 0) return -1;</span><br><span class="line">     	return start;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">分发糖果</a></h4><h5 id="思路-38"><a href="#思路-38" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先从左到右前序遍历，判断右边大于左边的情况，再从右到左的后序遍历，判断左边大于右边的情况，这个是时候要非常注意的点就是当左边大于右边时，得选一个(candy[i],candy[i+1] + 1)中最大的，candy[i]是i-1和i相比较得到的，而后者是i和i+1相互比较得到的</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-36"><a href="#代码-36" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int candy(int[] ratings) {</span><br><span class="line">		int[] candys = new int[ratings.length];</span><br><span class="line">		for(int i = 0; i &lt; candys.length; i++) {</span><br><span class="line">			candys[i] = 1;</span><br><span class="line">		}</span><br><span class="line">		for(int i = 0; i &lt; ratings.length - 1; i++) {</span><br><span class="line">			if(ratings[i+1] &gt; rating[i]) {</span><br><span class="line">				candys[i+1]++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		for(int i = ratings.length - 2; i &gt;= 0; i--) {</span><br><span class="line">			if(ratings[i] &gt; ratings[i+1]) {</span><br><span class="line">				candys[i] = Math.max(candys[i],candys[i+1] + 1);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return Arrays.stream(candys).sum();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/">柠檬水找零</a></h4><h5 id="思路-39"><a href="#思路-39" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5，10，20这三个元素是固定的，当我们收到5元时直接收入，10元就是返五元，20就先放10再返5，或者先返10再返10</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-37"><a href="#代码-37" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean lemonadeChange(int[] bills) {</span><br><span class="line">			int[] moneys = new int[3];</span><br><span class="line">			for(int i:bills) {</span><br><span class="line">				if(i == 5) {</span><br><span class="line">					moneys[0]++;</span><br><span class="line">				} </span><br><span class="line">				if(i == 10) {</span><br><span class="line">					if(moneys[0] &lt;=0 ) return false;</span><br><span class="line">					moneys[1]++;</span><br><span class="line">					moneys[0]--;</span><br><span class="line">				}</span><br><span class="line">				if(i == 20) {</span><br><span class="line">					if(moneys[1] &gt;=1 &amp;&amp; moneys[0] &gt;= 1) {</span><br><span class="line">						moneys[1]--;</span><br><span class="line">						moneys[0]--;</span><br><span class="line">						moneys[2]++;</span><br><span class="line">					} else {</span><br><span class="line">						moneys[0] -= 3;</span><br><span class="line">						if(moneys[0] &lt; 0) return false;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			return true;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="弓箭引爆气球"><a href="#弓箭引爆气球" class="headerlink" title="弓箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">弓箭引爆气球</a></h4><h5 id="思路-40"><a href="#思路-40" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先对数组元素的起始下标进行排序,找到右边界最小值，再去判断左边界是否超出最小右边界，若有超出则给弓箭加1，重新更换最小右边界，其实右边界是随着遍历变化的，我们需要判断下一个元素的左边界是否大于最小右边界，这样我们就能得到全局最优，res记得遍历之后要加1，因为不管最后是否有重叠都是一样的要加1。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-38"><a href="#代码-38" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int findMinArrowShots(int[][] points) {</span><br><span class="line">		Arrays.sort(points,(o1,o2) -&gt; Integer.compare(o1[0] - o2[0]));</span><br><span class="line">		int res = 0;</span><br><span class="line">		int minRightValue = Integer.MAX_VALUE;</span><br><span class="line">		for(int i = 0; i &lt; points.length; i++) {</span><br><span class="line">			if(points[i][1] &lt; minRightValue) {</span><br><span class="line">				minRightValue = points[i][1];</span><br><span class="line">				continue;</span><br><span class="line">			}</span><br><span class="line">			if(points[i][0] &gt; minRightValue) {</span><br><span class="line">				minRightValue = points[i][1];</span><br><span class="line">				res++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return res+1;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="无重复区间"><a href="#无重复区间" class="headerlink" title="无重复区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">无重复区间</a></h4><h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总数组个数减去不相交的区间，我们先对数组进行右排序，每当下一个元素的左边的值大于等于上一次的元素的右边值，那么就将结果加1，并且将minRight更新为此元素的右边值</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-39"><a href="#代码-39" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int eraseOverlapIntervals(int[][] intervals) {</span><br><span class="line">		Arrays.sort((o1,o2) -&gt; Integer.compare(o1[1],o2[1]));</span><br><span class="line">		int remove = 0;</span><br><span class="line">		int pre = intervals[0][1];</span><br><span class="line">		for(int i = 1; i &lt; intervals.length; i++) {</span><br><span class="line">			if(intervals[i][0] &lt; pre) {</span><br><span class="line">				remove++;</span><br><span class="line">				pre = Math.min(pre,intervals[i][1]);</span><br><span class="line">			} else {</span><br><span class="line">				pre = intervals[i][1];</span><br><span class="line">			}</span><br><span class="line">			return remove;</span><br><span class="line">		}</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="划分子区间"><a href="#划分子区间" class="headerlink" title="划分子区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">划分子区间</a></h4><h5 id="思路-41"><a href="#思路-41" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先是对每个小字母出现的最大值进行记录，然后我们再遍历数组，当最大值下标和正在遍历的值相等时就是最大的区间了。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-40"><a href="#代码-40" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; partitionLabels(String s) {</span><br><span class="line">		int[] edge = new int[26];</span><br><span class="line">		char[] chars = s.toCharArray();</span><br><span class="line">		for(int i = 0 ; i &lt; chars.length; i++) {</span><br><span class="line">			edge[chars[i] - 'a'] = i;</span><br><span class="line">		}</span><br><span class="line">		int maxIndex = 0;</span><br><span class="line">		int last = 0;</span><br><span class="line">		List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		for(int i = 0; i &lt; chars.length; i++) {</span><br><span class="line">			maxIndex = Math.max(maxIndex,edge[chars[i] - 'a']);</span><br><span class="line">			if(i == maxIndex) {</span><br><span class="line">				res.add(maxIndex - last + 1);</span><br><span class="line">				last = maxIndex + 1;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return res;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">合并区间</a></h4><h5 id="思路-42"><a href="#思路-42" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">咱们先对数组进行左排序，遍历数组，动态更新最右边的值，每次取最大的，前提是下一个元素的最左边会小于之前的右边值，如果左边值大于之前的右边值那么就算了。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-41"><a href="#代码-41" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int[][] merge(int[][] intervals) {</span><br><span class="line">		List&lt;Int[]&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		Arrays.sort(intervals,(o1,o2) -&gt; Integer.compare(o1[0],o2[0]));</span><br><span class="line">		int maxRightIndex = intervals[0][1];</span><br><span class="line">		int last = intervals[0][0];</span><br><span class="line">		for(int i = 1; i &lt; intervals.length; i++) {</span><br><span class="line">			if(maxRightIndex &gt;= intervals[i][0]) {</span><br><span class="line">				maxRightIndex = Math.max(maxRightIndex,intervals[i][1]) // 其实这一步可以不比较</span><br><span class="line">				continue;</span><br><span class="line">			} else {</span><br><span class="line">				res.add(new int[] {last,maxRightIndex});</span><br><span class="line">				last = intervals[i][0];</span><br><span class="line">				maxRightIndex = intervals[i][1];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		int[][] arr = new int[list.size()][2];</span><br><span class="line"></span><br><span class="line">        // 遍历 List，并将每个元素转换为 int 型并保存到数组中</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) {</span><br><span class="line">            arr[i][0] = list.get(i)[0].intValue();</span><br><span class="line">            arr[i][1] = list.get(i)[1].intValue();</span><br><span class="line">        }</span><br><span class="line">		return arr;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="递增数字"><a href="#递增数字" class="headerlink" title="递增数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">递增数字</a></h4><h5 id="思路-43"><a href="#思路-43" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暴力解法理论上是可以的，但是在力扣上面会超时，首先要意识到一点就是当遇到StrNum[i] &lt; StrNum[i-1],此时strNum[i-1]要--。比如说98这个，变成89.那么我们如果从前向后遍历的话会不会出问题? 当然会了,如果StrNum[i-1] &lt; StrNum[i]时，StrNum[i-1]--,但是此时StrNum[i-2]会大于StrNum[i-1]该咋整。就比如说335，变成了329这好吗? 这不好, 那么我们就向后遍历，这不美滋滋</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码-42"><a href="#代码-42" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int monotoneIncreasingDigits(int n) {</span><br><span class="line">		String[] nums = (n + "").split("");</span><br><span class="line">		int start = nums.length;</span><br><span class="line">		for(int i = nums.length-1; i &gt; 0; i--) {</span><br><span class="line">			if(Integer.parseInt(nums[i-1]) &gt; Integer.parseInt(nums[i])) {</span><br><span class="line">				nums[i-1] = String.valueOf(Integer.valueOf(nums[i-1]) -1);</span><br><span class="line">				start = i;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		for(int i = start; i &lt; nums.length; i++) {</span><br><span class="line">			nums[i] = "9";</span><br><span class="line">		}</span><br><span class="line">		return Integer.parseInt(String.join("",strings));</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<h1 id="MyBatis-ambulance"><a href="#MyBatis-ambulance" class="headerlink" title="MyBatis:ambulance:"></a>MyBatis:ambulance:</h1><h1 id="Redis-aerial-tramway"><a href="#Redis-aerial-tramway" class="headerlink" title="Redis:aerial_tramway:"></a>Redis:aerial_tramway:</h1><h3 id="如何保证Redis与Mysql数据库的一致性"><a href="#如何保证Redis与Mysql数据库的一致性" class="headerlink" title="如何保证Redis与Mysql数据库的一致性?"></a>如何保证Redis与Mysql数据库的一致性?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">保证Redis以及MySQL的数据一致性问题，这里有两种方案，首先就是先更新MySQL数据库再更新Redis,其次就是先删除Redis缓存再通过更新MySQL数据库来更新Redis缓存来达到数据一致性，其次可以通过消息通信，还有就是cannel</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Redis集群如何工作"><a href="#Redis集群如何工作" class="headerlink" title="Redis集群如何工作?"></a>Redis集群如何工作?</h3><h5 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis是一个基于内存的key-value的非关系数据库，它支持5种数据类型，但不是所有数据类型都支持分布式例如:Sorted set.</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Redis的集群组成是什么样的"><a href="#Redis的集群组成是什么样的" class="headerlink" title="Redis的集群组成是什么样的?"></a>Redis的集群组成是什么样的?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">路由器: 负责把请求分发到不同的Redis节点上面</span><br><span class="line">主节点: 主要负责读写的节点</span><br><span class="line">从节点: 必要时可以为主节点分担读的压力</span><br><span class="line">集群总线: 用来探测集群里某些节点是正常</span><br></pre></td></tr></tbody></table></figure>

<h5 id="工作流程是什么样的"><a href="#工作流程是什么样的" class="headerlink" title="工作流程是什么样的?"></a>工作流程是什么样的?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当请求发送过来的时候,路由器负责把请求分发到指定的节点上面，如果请求落到主节点上面直接进行读写操作，如果是丛节点将请求转移给主节点。集群里面的节点会定时发送心跳检测，如果某个节点长时间没有进行心跳发送，那么这个节点可以认为是宕机了(哨兵模式)，如果主节点宕机了，从节点顶上，如果主节点恢复不了了，将数据迁移到某个节点，并讲某个节点升级为主节点。当需要新增加一个Redis节点时，需要这个Redis节点与集群中的一个主节点发生三次握手(类似TCP连接)，如果加入那么就通知其他集群中的节点，此时组成了一个更加庞大的集群。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="路由器是怎么找节点的"><a href="#路由器是怎么找节点的" class="headerlink" title="路由器是怎么找节点的?"></a>路由器是怎么找节点的?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据发送请求的键值对来判断要存放的地方，存放的地方就是hash槽(16384)</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Redis的应用场景是什么？"><a href="#Redis的应用场景是什么？" class="headerlink" title="Redis的应用场景是什么？"></a>Redis的应用场景是什么？</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排行榜需要用到Sorted set,共同好友、共同爱好用到Set,Session登录如果遇到集群，那么落地到不同机器的时候需要频繁登录，那么此时可以用String,如果要限制访问次数，点赞数，计数器的功能我们就需要String.Hash可以存储对象信息。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Redis不适用的场景有哪些"><a href="#Redis不适用的场景有哪些" class="headerlink" title="Redis不适用的场景有哪些?"></a>Redis不适用的场景有哪些?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据量大，且访不频繁的数据，这简直纯属浪费内存资源</span><br></pre></td></tr></tbody></table></figure>



<h3 id="AOF的工作原理是什么"><a href="#AOF的工作原理是什么" class="headerlink" title="AOF的工作原理是什么?"></a>AOF的工作原理是什么?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis中的AOF能够实现数据的实时持久化操作，但是这样会造成一个问题就是AOF的存储文件过大，这样IO的性能就会降低,读取内存当中所有键值对的时候时间过长</span><br></pre></td></tr></tbody></table></figure>

<h5 id="如何解决AOF的IO性能"><a href="#如何解决AOF的IO性能" class="headerlink" title="如何解决AOF的IO性能?"></a>如何解决AOF的IO性能?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AOF的重写功能能够挺高IO性能也就是减小AOF文件大小，AOF的重写通过一个子进程同步Redis内存当中的所有键值对，AOF重写说白了就是把相同操作相同的Key的不同命令压缩，还有个问题是可能会造成Redis内存与AOF的数据不一致</span><br></pre></td></tr></tbody></table></figure>

<h5 id="如何解决AOF重写不一致"><a href="#如何解决AOF重写不一致" class="headerlink" title="如何解决AOF重写不一致?"></a>如何解决AOF重写不一致?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加入一个AOF缓冲区文件，先通过新的AOF文件读取Redis当中的键值对,重写完后，再把AOF缓冲区文件当中的数据复制到新的AOF文件当中</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Redis当中SDS的原理是什么"><a href="#Redis当中SDS的原理是什么" class="headerlink" title="Redis当中SDS的原理是什么?"></a>Redis当中SDS的原理是什么?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis当中的SDS(Simple Synmatic String), 这个对象里面有len,alloc,buf[],flags(类型)</span><br></pre></td></tr></tbody></table></figure>

<h5 id="SDS的相比C语言的字符串好在哪里"><a href="#SDS的相比C语言的字符串好在哪里" class="headerlink" title="SDS的相比C语言的字符串好在哪里?"></a>SDS的相比C语言的字符串好在哪里?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">能够动态分配String的容量，比如String的拼接或者删除</span><br><span class="line">不需要多次的修改字符串的内存，其中使用到内存预分配</span><br><span class="line">二进制安全传输</span><br></pre></td></tr></tbody></table></figure>

<h3 id="如何保持Redis的数据一致性"><a href="#如何保持Redis的数据一致性" class="headerlink" title="如何保持Redis的数据一致性?"></a>如何保持Redis的数据一致性?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先可以通过主动更新的方式(这里涉及到先删除缓存还是先更新数据库的问题),当需要写数据库的时候，其实无论是先删除缓存还是先更新数据库都会出现数据不一致的问题，在发生数据不一致性概率的高低程度来看我们更偏向于先更新数据库再删除缓存。</span><br><span class="line">其次可以通过Redis自带的内存淘汰机制</span><br><span class="line">最后可以通过给key设置有效时间TTL</span><br></pre></td></tr></tbody></table></figure>

<h3 id="缓存会遇到哪些问题"><a href="#缓存会遇到哪些问题" class="headerlink" title="缓存会遇到哪些问题?"></a>缓存会遇到哪些问题?</h3><h5 id="概念描述"><a href="#概念描述" class="headerlink" title="概念描述:"></a>概念描述:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透: 当数据库和缓存都没有某个key的数据的时候，用户一直访问会导致数据库崩溃</span><br><span class="line">缓存雪崩: 在某个时间段大量的key同时失效</span><br><span class="line">缓存击穿: 当某个key一直处于高并发访问的时候突然失效了，那么数据库会崩溃</span><br></pre></td></tr></tbody></table></figure>

<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透的解决方案: 访问某个key的时候，如果缓存没有命中，数据库当中同样也没有，那么我们就在缓存把key的值设置为null,set(key,null)。</span><br><span class="line">缓存雪崩的解决方案: 给不同的key设置随机的TTL</span><br><span class="line">缓存击穿的解决方案: 通过互斥锁的方式来获取操作某个key的缓存重建对象锁。当没有获取到锁的线程去访问的时候，正好有一个线程在访问互斥锁，那么其他的线程需要休息一段时间然后重新从Redis当中去访问。</span><br></pre></td></tr></tbody></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230710093712334.png" alt="image-20230710093712334"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230710094631453.png" alt="image-20230710094631453"></p>
<h1 id="MySQL-apple"><a href="#MySQL-apple" class="headerlink" title="MySQL:apple:"></a>MySQL:apple:</h1><h3 id="InnoDB的原理是什么"><a href="#InnoDB的原理是什么" class="headerlink" title="InnoDB的原理是什么?"></a>InnoDB的原理是什么?</h3><h5 id="声明-a是索引字段"><a href="#声明-a是索引字段" class="headerlink" title="声明: a是索引字段"></a><em><strong>声明: a是索引字段</strong></em></h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnoDB中每一页16kb大小,默认是10行数据,页目录和用户数据区域是主要构成成分，用户数据区域的数据插入是按顺序插入的(索引),这样查询的时候可以提高性能; Innodb有三大优点: 1.支持高并发(多版本并发控制，某个一行数据更新的时候有个版本数据) 2.支持事务 3.支持外键和聚族索引(也就是说删除某个表的数据那么有这个表的外键索引的外表同时也会删除此行数据)；同时Innodb也有缺点，缺点就是存储的时候的内存这块需求较大，可以通过压缩表的方式以及选择合适的数据类型和数据大小来减少内存的使用。对比MylSAM的话，MylSAM不支持事务和高并发，MyLSAM更适合用于读不适用写。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="如果在插入某个数据的时候当前这一页数据满了怎么办"><a href="#如果在插入某个数据的时候当前这一页数据满了怎么办" class="headerlink" title="如果在插入某个数据的时候当前这一页数据满了怎么办?"></a>如果在插入某个数据的时候当前这一页数据满了怎么办?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新创建一页,并且要判断这条数据的索引值在当前页中是否满足插入条件，并且把最后的一条满足条件的数据给放到新的一页当中,相邻页用指针相连接，其实这样还是非常的难受的，这也是为什么我建议使用自增的索引</span><br></pre></td></tr></tbody></table></figure>

<p>请看下图</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230424155002346.png" alt="image-20230424155002346"></p>
<p>再建立一级索引，二级索引，主要就是通过范围查找来减少IO。</p>
<h5 id="什么情况会是全表扫描"><a href="#什么情况会是全表扫描" class="headerlink" title="什么情况会是全表扫描?"></a>什么情况会是全表扫描?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where b = 2,这个b不是索引，那么就需要全表扫描</span><br></pre></td></tr></tbody></table></figure>

<h5 id="哪些常见的sql语句会用到索引"><a href="#哪些常见的sql语句会用到索引" class="headerlink" title="哪些常见的sql语句会用到索引?"></a>哪些常见的sql语句会用到索引?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a &gt; 6; 这个会先去找a=6的索引, 底层的数据区域也都是两个指针相互连接并且有顺序的，那么只需要a后面的数据就可以了; select * from a &lt;6 同样如此</span><br></pre></td></tr></tbody></table></figure>

<h5 id="什么是联合索引"><a href="#什么是联合索引" class="headerlink" title="什么是联合索引?"></a>什么是联合索引?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是多个字段一起作为索引(b,c,d)三个字段都作为索引，这样会有一个索引树依据b,c,d来建立的，并且遵从最左前缀的规律，也就是说以*cd,**d这种就不可以作为索引进行查找，写成sql语句就是: select * from where c = 1 and d = 1;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="什么是索引覆盖"><a href="#什么是索引覆盖" class="headerlink" title="什么是索引覆盖?"></a>什么是索引覆盖?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引覆盖就是当你要查询的字段都在建立好的索引表里面都有那么你就不需要再去通过主键索引去找了。</span><br></pre></td></tr></tbody></table></figure>

<h6 id="为什么不通过主键索引去找"><a href="#为什么不通过主键索引去找" class="headerlink" title="为什么不通过主键索引去找?"></a>为什么不通过主键索引去找?</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为主键索引去找的话，可以想想就是主键索引的数据页(16kb)每一页能存储2条，而联合索引树的数据页可以存储三条，这样就减少了页数也就减少了IO操作，这样就能提高IO的性能，这样就不用回表了，因为联合索引下面的叶子节点本来就有你想要查找的数据。</span><br></pre></td></tr></tbody></table></figure>

<h6 id="再想想为什么只能存储三条呢"><a href="#再想想为什么只能存储三条呢" class="headerlink" title="再想想为什么只能存储三条呢?"></a>再想想为什么只能存储三条呢?</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原因很简单就是因为，主键索引下面每条记录存储的是完整的一条记录，而联合索引下面存储的字段要少很多，主要就是联合索引的几个字段加上主键索引的字段。</span><br></pre></td></tr></tbody></table></figure>

<h6 id="能用sql语句展示吗"><a href="#能用sql语句展示吗" class="headerlink" title="能用sql语句展示吗?"></a>能用sql语句展示吗?</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select b,c,d,a from table_name where b &gt; 1,此时此刻就能使用联合索引，因为要查询的字段联合索引里面都有。</span><br><span class="line">select * from table_name where b &gt; 1这样的话就全表扫描比索引强多了，因为这样还要回表。</span><br></pre></td></tr></tbody></table></figure>

<p>请看下图</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230424175008539.png" alt="image-20230424175008539"></p>
<h5 id="什么情况下会导致索引失效"><a href="#什么情况下会导致索引失效" class="headerlink" title="什么情况下会导致索引失效?"></a>什么情况下会导致索引失效?</h5><p>只要对字段的值有所改变那么索引就会失效</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e from table_name where e = 1,e是varchar类型(255),SQL除了数字之外，其他的英文什么的都转化位0，而数字任然是数字，这段索引为什么会失效原因就是,e字段是varchar类型，如果要和1比较，那么自生就得先转化为数字，这样消耗的成本实在太大，那就只能走全表扫描了。</span><br></pre></td></tr></tbody></table></figure>

<p>请看下图</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230424203138333.png" alt="image-20230424203138333"></p>
<p>也有可能破坏一个完整的B+树：本来1是小于b的，结果转化为Number类型之后b变成了0。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230424225135663.png" alt="image-20230424225135663"></p>
<h5 id="Innodb是如何实现事务的"><a href="#Innodb是如何实现事务的" class="headerlink" title="Innodb是如何实现事务的?"></a>Innodb是如何实现事务的?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">四种元素:Buffer Pool,LogBuffer,Redo Log,Undo Log。在一次修改数据的事务当中，Innodb收到update请求之后，将根据要修改的数据查找到某一页并使用Buffer Pool存储这一页的数据，再对数据进行修改生成Redo Log对象存储再LogBuffer当中，如果你突然不想修改了那么你就执行Undo Log。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="主键索引的图可以优化成什么样"><a href="#主键索引的图可以优化成什么样" class="headerlink" title="主键索引的图可以优化成什么样?"></a>主键索引的图可以优化成什么样?</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230426114041672.png" alt="image-20230426114041672"></p>
<h3 id="为什么Mysql单表最大两千万"><a href="#为什么Mysql单表最大两千万" class="headerlink" title="为什么Mysql单表最大两千万?"></a>为什么Mysql单表最大两千万?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在索引页中,假设主键a大小为8个bit，页号大小为4个bit,那么每页15k那么就能存储15k/12 = 1280,在叶子节点(也就是数据页当中)每一条1k,那么15k/1k = 15,根据数据量计算公式1280^（z-1）* 15,其中z为B+数的层数。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="为什么是15k而不是16k"><a href="#为什么是15k而不是16k" class="headerlink" title="为什么是15k而不是16k?"></a>为什么是15k而不是16k?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一页当中包含页目录以及页头，去掉之后就剩下15k</span><br></pre></td></tr></tbody></table></figure>

<h5 id="为什么不可以是1亿"><a href="#为什么不可以是1亿" class="headerlink" title="为什么不可以是1亿?"></a>为什么不可以是1亿?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案是当然可以, 假设数据页是250byte每条，那么如果是3层，N = 1280^2 * 60 = 1个亿</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MVCC是什么"><a href="#MVCC是什么" class="headerlink" title="MVCC是什么?"></a>MVCC是什么?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVCC是MYSQL中的innodb引擎在RC,RR事务且快照读当中实现的多版本并发控制，这个版本下面有隐藏字段，arx_id 和 rollPointer分表代表着某个版本的记录id和指向当前版本的前一个版本，Undo版本链代表着多个版本形成的链表，ReadView代表着你在多个版本下面选出一个版本出来，选哪个版本的时候会伴随着某个选择版本的算法</span><br></pre></td></tr></tbody></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230517113457231.png" alt="image-20230517113457231"></p>
<h5 id="MVCC在RC、RR场景的区别"><a href="#MVCC在RC、RR场景的区别" class="headerlink" title="MVCC在RC、RR场景的区别?"></a>MVCC在RC、RR场景的区别?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果读取某条记录两次，那么在RC场景下面，每次返回的是不同的版本，而在RR下面返回的是同一个版本，这也天然的方式解释了什么是不可重复读和可重复读</span><br></pre></td></tr></tbody></table></figure>

<h5 id="MVCC有什么用"><a href="#MVCC有什么用" class="headerlink" title="MVCC有什么用?"></a>MVCC有什么用?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">避免了被阻塞，虽然可能读取的数据不是最新的数据</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在RR下避免了幻读</span><br></pre></td></tr></tbody></table></figure>

<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.read uncommited</span><br><span class="line">2.read commited</span><br><span class="line">3.Repeatable read</span><br><span class="line">4.Serilizable</span><br></pre></td></tr></tbody></table></figure>

<h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.事务A读取数据</span><br><span class="line">2.事务B insert数据并未提交</span><br><span class="line">3.事务A读取数据发现数据有变化</span><br></pre></td></tr></tbody></table></figure>

<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.事务A读取数据</span><br><span class="line">2.事务B insert数据并提交</span><br><span class="line">3.事务A读取数据发现数据有变化</span><br></pre></td></tr></tbody></table></figure>

<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.事务A读取数据</span><br><span class="line">2.事务B insert数据(1,老王)</span><br><span class="line">3.事务A读取数据发现没有变化</span><br><span class="line">4.事务A insert数据(1,老哥)</span><br><span class="line">5.事务A爆出错误 Duplicate 意味着主键重复</span><br></pre></td></tr></tbody></table></figure>

<h4 id="侧重点"><a href="#侧重点" class="headerlink" title="侧重点"></a>侧重点</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">脏读和不可重复读侧重于读-读的不同</span><br><span class="line">幻读侧重于读-读-写，通过写来验证读的幻觉</span><br></pre></td></tr></tbody></table></figure>

<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230727171413977.png" alt="image-20230727171413977"></p>
<h5 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230727172112084.png" alt="image-20230727172112084"></p>
<h5 id="表锁和意向锁的缘分"><a href="#表锁和意向锁的缘分" class="headerlink" title="表锁和意向锁的缘分"></a>表锁和意向锁的缘分</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表锁是否加成功得看意向锁的脸色，意向锁相当于整个表的一个标识，当执行DML的时候会加意向锁，那么表锁来加锁的时候得看意向锁，意向锁标识当前表是否有数据行有加锁，这样就不用在加表锁的时候一行一行的查看是否要加锁了</span><br></pre></td></tr></tbody></table></figure>

<h3 id="事务是怎么实现的"><a href="#事务是怎么实现的" class="headerlink" title="事务是怎么实现的?"></a>事务是怎么实现的?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先事务主要是有四个特性，ACID，A就是Atomic原子性，原子性其实是基于这个undolog日志来实现的，就是说在执行DML语句的时候，执行的数据会先存储在undolog版本链里面,不是真正的数据库文件里，如果事务执行失败就可以撤销操作，如果事务成功，commit提交之后它可以把数据真正的放到数据库文件里面，C就是Consistency一致性，这个一致性其实是基于其他三个属性实现的，I就是Isolation,就是隔离性，这个隔离性有四个级别，都是基于这个MVCC和锁来实现的，MVCC层面比如说快照读就是在RR和Serilaze实现，读取的是之前读取的undolog版本，就是在每次读取的时候会服用之前的ReadView,但是在RC级别下，当前读是读取的最新的一个undolog版本日志，也就是每次查询都是新建的一个readview,从锁的层面来讲的话，就是RC级别下就是行锁，RR级别是在行锁的粒度基础上面加了间隙锁，就是会锁住某个范围的数据，当某个事务读取数据时，其他不允许插入数据，锁的性质来讲的话就是，在RR级别下，A事务读取数据时，其他事务可以得到了共享锁和排它锁，B事务写入数据时，其他事务不能得到共享锁和排它锁。</span><br></pre></td></tr></tbody></table></figure>



<h1 id="Java基础-anchor"><a href="#Java基础-anchor" class="headerlink" title="Java基础:anchor:"></a>Java基础:anchor:</h1><h3 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h3><h5 id="反射实现有哪些"><a href="#反射实现有哪些" class="headerlink" title="反射实现有哪些?"></a>反射实现有哪些?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName("com.jdbc.cj.Driver.mysql")</span><br><span class="line">类名.class</span><br><span class="line">对象名.getClass()</span><br></pre></td></tr></tbody></table></figure>

<h5 id="反射优缺点有哪些"><a href="#反射优缺点有哪些" class="headerlink" title="反射优缺点有哪些?"></a>反射优缺点有哪些?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点: 能够动态的获取类的实例，提高灵活性</span><br><span class="line">缺点: 会降低性能，解决办法: 1. 如果多次创建某个对象的实例，使用缓存 2. 通过SetAccessible关闭JDK的安全检查来提高提升反射速度。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230707135655807.png" alt="image-20230707135655807"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个本类指的是自己创建的这个类里面的范围，而不包括本类下面的一个默认修饰符修饰的类</span><br></pre></td></tr></tbody></table></figure>

<h5 id="修饰符使用范围"><a href="#修饰符使用范围" class="headerlink" title="修饰符使用范围?"></a>修饰符使用范围?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">四种修饰符可以用在属性和方法</span><br><span class="line">类和接口只能用public 和 默认</span><br></pre></td></tr></tbody></table></figure>

<h5 id="为什么子类的访问修饰符得大于父类"><a href="#为什么子类的访问修饰符得大于父类" class="headerlink" title="为什么子类的访问修饰符得大于父类?"></a>为什么子类的访问修饰符得大于父类?</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private修饰的属性和方法子类是不能继承的。</span><br><span class="line">当子类对象当作父类对象使用的时候，如果父类是public 而子类是private,那么想要调用子类的方法就不行了，这不符合继承的特性。</span><br></pre></td></tr></tbody></table></figure>



<h3 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h3><h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">super关键字是指调用父类的当中的一些特征，super()方法必然会执行，通常来构造方法的第一行,所以在初始化子类的实例对象的时候先调用父类的初始化特征，注意： new 照样还是子类的对象，super只是给子类扩充属性</span><br><span class="line">super关键字通常能够省略，有些情况不能省略：1.需要调用父类的属性,但是子类和父类有相同的属性名和方法名，如果子类想要调用父类的属性或者方法那么必须使用super来访问</span><br><span class="line">super可以看作是对new 对象的属性的一个扩充，这也是为什么每个对象都有一个wait()和notify()方法</span><br></pre></td></tr></tbody></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230622102057654.png" alt="image-20230622102057654"></p>
<h5 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest02 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        String s1 = "hello";</span><br><span class="line">        // "hello"是存储在方法区的字符串常量池当中</span><br><span class="line">        // 所以这个"hello"不会新建。（因为这个对象已经存在了！）</span><br><span class="line">        String s2 = "hello";</span><br><span class="line">        </span><br><span class="line">        // == 双等号比较的是变量中保存的内存地址</span><br><span class="line">        System.out.println(s1 == s2); // true</span><br><span class="line"></span><br><span class="line">        String x = new String("xyz");</span><br><span class="line">        String y = new String("xyz");</span><br><span class="line">        </span><br><span class="line">        // == 双等号比较的是变量中保存的内存地址</span><br><span class="line">        System.out.println(x == y); //false</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230622104128081.png" alt="image-20230622104128081"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Java当中的数组有一维、二维、三维(三维几乎用不到)，数组的优点就是检索的过程会非常快，就比如说让你查100个大小数组和查10000个大小数组，你觉得哪个更快? 其实是一样快的，数组的存储位置的元素都是连续存储的，并且每个元素都有下标，而且每个元素的存储大小都是一样的，这样就知道了偏移量，所以只需要算一遍就能计算出最终结果。二维数组就是每个元素都是一个一维数组。</p>
<h5 id="数组需要注意的点"><a href="#数组需要注意的点" class="headerlink" title="数组需要注意的点:"></a>数组需要注意的点:</h5><ol>
<li>数组要求元素的类型一样</li>
<li>数组的每个元素的大小一样</li>
<li>数组元素的存储位置是连续的，方便查找</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol>
<li>接口和接口之间不需要有任何的继承关系就可以完成互转，可能会爆出ClassCastExceptino问题</li>
<li>类转化成没有任何关系的接口是可以的</li>
<li>类和类之间转化必须得有继承关系</li>
<li>接口不可以被实例化，接口当中的方法默认是public abstract ,方法是用public final 修饰，也就意味着接口当中所有的元素都是用public修饰，同样接口当中不能写方法体。</li>
<li>一个接口可以继承多个方法</li>
<li>一个类可以实现多个接口</li>
</ol>
<p>接口的出现解决了之前的什么问题? 首先就是之前遗留下的类之间只能单继承的问题，而现实当中往往是多继承关系</p>
<h3 id="Java加载与执行"><a href="#Java加载与执行" class="headerlink" title="Java加载与执行"></a>Java加载与执行</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">编译期：（可以在windows上）</span><br><span class="line">	第一步：在硬盘的某个位置（随意），新建一个xxx.java文件</span><br><span class="line">	第二步：使用记事本或者其它文本编辑器例如EditPlus打开xxx.java文件</span><br><span class="line">	第三步：在xxx.java文件中编写“符合java语法规则的”源代码。</span><br><span class="line">	第四步：保存（一定要将xxx.java文件保存一下）</span><br><span class="line">	第五步：使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译。</span><br><span class="line"></span><br><span class="line">	第六步：如果xxx.java文件中编写的源代码是符合语法规则的，编译会通过，</span><br><span class="line">	如果xxx.java文件中编写的源代码违背了语法规则，那么编译器会报错，编译器</span><br><span class="line">	报错之后class文件是不会生成的，只有编译通过了才会生成class字节码文件。</span><br><span class="line">	并且一个java源文件是可以生成多个class文件的。（编译实质上是检查语法）</span><br><span class="line"></span><br><span class="line">运行期（JRE在起作用）：（可以在windows上，也可以在其他的OS上。）</span><br><span class="line">	第七步：如果是在Linux上运行，需要将windows上生成的class文件拷贝过去</span><br><span class="line">	不需要拷贝源代码，真正运行的是字节码。（但是源代码也不要删除，有用）</span><br><span class="line"></span><br><span class="line">	第八步：使用JDK自带的一个命令/工具：java（负责运行的命令/工具）执行字节码</span><br><span class="line"></span><br><span class="line">	第九步：往下的步骤就全部交给JVM了，就不需要程序员干涉了。</span><br><span class="line">	JVM会将字节码文件装载进去，然后JVM对字节码进行解释（解释器负责将字节码</span><br><span class="line">	解释为1010101010..等的二进制）</span><br><span class="line"></span><br><span class="line">	第十步：JVM会将生成的二进制码交给OS操作系统，操作系统会执行二进制码和</span><br><span class="line">	硬件进行交互。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK\JRE\JVM"></a>JDK\JRE\JVM</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK包含JRE，JRE包含JVM，JVM不能独立存在，其他两个可以。</span><br><span class="line">JDK是Java开发的工具箱，JRE是Java程序的运行时环境</span><br></pre></td></tr></tbody></table></figure>



































<h1 id="并发编程-avocado"><a href="#并发编程-avocado" class="headerlink" title="并发编程:avocado:"></a>并发编程:avocado:</h1><h3 id="ReentryLock"><a href="#ReentryLock" class="headerlink" title="ReentryLock"></a>ReentryLock</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">可重入锁</span><br><span class="line">ReentryLock implements Lock{</span><br><span class="line">	void lock() {</span><br><span class="line">		sycn.lock();</span><br><span class="line">	};</span><br><span class="line">	void unlock() {</span><br><span class="line">	    sycn.release();</span><br><span class="line">	};</span><br><span class="line">	public class Sycn extends AbstractQueueSychonizer {</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	public Sycn sycn;</span><br><span class="line">}</span><br><span class="line">AQS extends AbstractOwnableSynchonizer {</span><br><span class="line">	这个就是线程的对象锁的拥有</span><br><span class="line">	volatile int state;// 锁的同步状态</span><br><span class="line">	阻塞队列;</span><br><span class="line">	条件队列;</span><br><span class="line">}</span><br><span class="line">其中阻塞队列和条件队列都是用Node结点来操作</span><br><span class="line">class Node {</span><br><span class="line">	public Thread thread; // 代表当前线程</span><br><span class="line">}</span><br><span class="line">阻塞队列是通过FIFO的顺序进出队列，条件队列是通过满足特定条件之后，线程就能出来了，比较的灵活</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="同步异步阻塞非阻塞"><a href="#同步异步阻塞非阻塞" class="headerlink" title="同步异步阻塞非阻塞"></a>同步异步阻塞非阻塞</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户 -&gt; 服务员 -&gt; 后厨</span><br><span class="line">首先声明: 我们把服务员看作是请求线程，后厨看作是处理线程</span><br><span class="line">1. 同步加阻塞: 客户把点的菜给服务员，服务员把菜单给后厨，同时客户在店里面等着，服务员也是一样,且不能服务于其他客户</span><br><span class="line">2. 同步加非阻塞: 客户把点的菜给服务员，服务员把菜单给后厨，给完之后服务员再去接待其他客户，但是得过一会就得再去问问后厨做好了没有，但是客户还是在店里面等着</span><br><span class="line">3. 异步就是非阻塞的，不存在说什么异步阻塞的，当服务员把菜单给后厨的时候，后厨的台面上面会有一个要做的菜单列表，就相当于一个消息队列一样，你完全没有必要等待后厨，服务员也不用去问后厨做好了没有，做好了后厨会告诉服务员的。</span><br></pre></td></tr></tbody></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230706154730273.png" alt="image-20230706154730273"></p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompareAndSwap(offset,变量值，期望值，要改变的成的值)</span><br><span class="line">这个就是自旋锁，具体实现就是自旋锁while(CAS),AtomicInteger(i++的时候，JVM有用到)</span><br></pre></td></tr></tbody></table></figure>

<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个不需要加锁，也就减少了消耗，也避免了死锁问题，提高了性能</span><br></pre></td></tr></tbody></table></figure>

<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一直自旋： 当多个线程访问相同的资源，那么就会出现一直自旋的情况</span><br><span class="line">ABA问题: 这个问题其实就是其他线程改了当前变量，从A改成B又改成A，这样其实你去看的时候，感觉没有变化其实是变化的，我们通过加时间轴的方式解决</span><br></pre></td></tr></tbody></table></figure>

<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230706175315485.png" alt="image-20230706175315485"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个classpoint指向的是类加载的时候的元数据(包括类的一些方法和属性之类的)</span><br><span class="line">sychronized之前一直都是重量级锁，Java6之后，通过锁升级的方式变成重量级锁</span><br></pre></td></tr></tbody></table></figure>

<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230706180137377.png" alt="image-20230706180137377"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从无锁到锁偏向，偏向锁其实就是只给同一个线程去访问，如果有其他线程访问，就升级为轻量级锁，如果超过20次访问，那么就重新变成偏向锁，轻量级锁它也是通过CAS的方式来实现锁重入，也就是同一个线程多次访问同一个对象，对象的state上面就加1，如果遇到了其他的线程访问该对象，那么就会出现锁膨胀，升级为重量级锁，如果线程访问不到重量级锁，那么就通过自旋10次(自旋锁)的方式看看能不能获取到，如果获取不到那么线程就进入阻塞状态。当然也有自适应自旋这个较为智能。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Moniteor对象"><a href="#Moniteor对象" class="headerlink" title="Moniteor对象"></a>Moniteor对象</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230706180436872.png" alt="image-20230706180436872"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个就是重量级锁，sychronized的MarkWord对应着monitor对象，monitor对象有三个属性，waitset,owner,EntryList,waitset就是实现notify和wait的，体现了同步，然后EntryList就是获取该对象的一些阻塞线程队列</span><br></pre></td></tr></tbody></table></figure>

<h3 id="对象的强软引用"><a href="#对象的强软引用" class="headerlink" title="对象的强软引用"></a>对象的强软引用</h3><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">强引用是对象的引用如果没更换引用对象，那么引用的对象就不能被GC给清楚掉，这样可能会导致内存泄漏</span><br></pre></td></tr></tbody></table></figure>

<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个引用其实就没有之前那么的强盗了，主打的就是一个谦让，当内存不足的时候就被GC给回收掉，把内存给其他对象让出来</span><br></pre></td></tr></tbody></table></figure>

<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在发生GC的时候就会回收</span><br></pre></td></tr></tbody></table></figure>

<h3 id="JUC常见类"><a href="#JUC常见类" class="headerlink" title="JUC常见类"></a>JUC常见类</h3><h5 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore就好比类似一个加减计时器，当资源释放的时候增加资源数，当获取资源的时候减少资源数，会预先设置一个资源的数量，当资源数量为0的时候，还去获取资源，当前线程就会阻塞，需要等到一个线程释放该资源的时候才能获取资源</span><br></pre></td></tr></tbody></table></figure>

<h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch会预先设置一个线程调用次数，也就是countdown()方法，当执行到值为0的时候，await()方法才会返回，如果countDownLatch的值大于0，那么等待线程继续阻塞，CountDownLatch的主要作用就是当多个子线程完成某个任务之后，再继续执行主线程的任务。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="JUC集合"><a href="#JUC集合" class="headerlink" title="JUC集合"></a>JUC集合</h3><h5 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个容器主打的就是读写分离，适合多读少写，写的时候原理是写时复制，也就是说，当写的时候会把容器复制一个，得到一个副本容器，读的时候读旧的，当一个线程在写的时候，读的线程是不会读到正在写的数据，写完之后，把之前指向旧的引用指向新的，然后再把旧的容器给删除掉。</span><br></pre></td></tr></tbody></table></figure>

<p>2023-7-23</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看过CopyOnWriteList源码后发现，CopyOnWriteList每次写的时候扩容只是容量加1，get方法访问如果还没有写完那还得访问原来的。写的时候是加了ReentrantLock这个锁。</span><br></pre></td></tr></tbody></table></figure>

<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它的这个读的时效性没有那么的好，读总是读久的，要等扩容了新的完成了才行。</span><br></pre></td></tr></tbody></table></figure>

<h6 id="对比"><a href="#对比" class="headerlink" title="对比:"></a>对比:</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList扩容也是在满了的时候去扩容，扩容的代码是:  int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);,如果说扩容后还是满足不了实际需要存储的元素数量，那newCapacity = 需要的元素，底层是把原来的数组元素拷贝到新的数组里面，System.ArrayCopy(),是个Native修饰的方法，意思就是C++底层需要调用的方法。</span><br></pre></td></tr></tbody></table></figure>

<h6 id="CopyOnWriteList扩容"><a href="#CopyOnWriteList扩容" class="headerlink" title="CopyOnWriteList扩容"></a>CopyOnWriteList扩容</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) {</span><br><span class="line">       final ReentrantLock lock = this.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       try {</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           int len = elements.length;</span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">           newElements[len] = e;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">           return true;</span><br><span class="line">       } finally {</span><br><span class="line">           lock.unlock();</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h6 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) {</span><br><span class="line">      // overflow-conscious code</span><br><span class="line">      int oldCapacity = elementData.length;</span><br><span class="line">      int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">      if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">      if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      // minCapacity is usually close to size, so this is a win:</span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h5 id="ConCurrentHashMap"><a href="#ConCurrentHashMap" class="headerlink" title="ConCurrentHashMap"></a>ConCurrentHashMap</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK1.8之前是HashTable,这个不支持多线程并发写，因为当有一个线程在写的时候，是对整个容器进行加锁，效率极低，并且在扩容的时候是直接全部拷贝过去，执行的时候会很慢很慢。</span><br><span class="line">JDK1.8之后做了很大改进，出现了ConCurrentHashMap，这个设计是数组+链表的方式，每个槽叫哈希槽，存储的是一个链表，每次写操作的时候只锁住这个链表的头节点，而不用锁住整个表，这样效率就好很多了。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="排它锁和共享锁"><a href="#排它锁和共享锁" class="headerlink" title="排它锁和共享锁"></a>排它锁和共享锁</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开始我还很难理解，后来我猜测了有没有一种可能的好奇心；当一个事务获取到某行数据的排它锁，那么其他事务可以读该还数据，但是不能获取到读锁和写锁，也就意味着读的时候可能是旧的，也就是不能保证数据的一致性；当一个事务获取到某行数据的共享锁，那么其他事务可以读该行数据，能保证数据读的一致性；</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要是由生成者、消费者、broker以及Zookeeper组成</span><br><span class="line">一个集群里面有多个broker,一个broker可以有多个topic，一个topic有多个partition,每个partition下面有一个log文件</span><br></pre></td></tr></tbody></table></figure>

<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个partition有一个leader,同时有多个follow，每次producer发送消息的时候，有两种选择，让一个半的follow同步，然后发送ack或者让全部的follow和leader同步，然后再发送ack;</span><br><span class="line">如果一个follow宕机了，那么ISR会暂时把Follow给踢出去，等到Follow后来恢复了，并且恢复到了HW</span><br><span class="line">LEO: 每个副本的最后一个Offset</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Kafka的优点"><a href="#Kafka的优点" class="headerlink" title="Kafka的优点?"></a>Kafka的优点?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可靠性: 能够实现数据的持久化存储，也就是将数据写入到磁盘当中</span><br><span class="line">高吞吐量: 能够实现零拷贝，就是数据复制的时候不需要先把数据写入到用户存储区，接受端再通过去用户存储区把数据放入到内核存储区，而是直接在内核存储区去拷贝，这样就能使持久化更快，不需要进行用户存储区和内核存储区的交互</span><br></pre></td></tr></tbody></table></figure>

<h3 id="如何保证数据一致性"><a href="#如何保证数据一致性" class="headerlink" title="如何保证数据一致性?"></a>如何保证数据一致性?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先保证数据一致性，那么读写分离就会大打折扣，kafka之前一直主张leader副本来复制读取和发送消息，follow副本只负责同步leader,并且有一个HW(High Water)的概念,也就是说leader副本partition里面有4个message,follow副本分别只有2，3，那么Consumer消费的时候只能读取到2，其他不能读取，为什么这样做呢? 如果leader副本宕机了，选举出来的follow作为新的leader，此时consumer再次读取的时候就有问题了，发现了不一致。</span><br></pre></td></tr></tbody></table></figure>







<h1 id="Python-star-and-crescent"><a href="#Python-star-and-crescent" class="headerlink" title="Python:star_and_crescent:"></a>Python:star_and_crescent:</h1><h3 id="如何创建一个虚拟环境"><a href="#如何创建一个虚拟环境" class="headerlink" title="如何创建一个虚拟环境?"></a>如何创建一个虚拟环境?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先输入命令: python -m venv env  # Windows</span><br><span class="line">输入以上命令之后我们可以生成一个env文件此时我们激活环境: env\Scripts\activate</span><br><span class="line">退出虚拟环境: deactivate</span><br></pre></td></tr></tbody></table></figure>

<h3 id="如何定位参数位置"><a href="#如何定位参数位置" class="headerlink" title="如何定位参数位置?"></a>如何定位参数位置?</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Ctrl + F 进行全局搜索</span><br><span class="line">2.增加snippets(代码片段) </span><br><span class="line">3.使用插件来定位(Hook)</span><br><span class="line">4.通过XHR来定位(比如说请求包含的字段)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="加密方式有哪些"><a href="#加密方式有哪些" class="headerlink" title="加密方式有哪些?"></a>加密方式有哪些?</h3><h5 id="维吉尼亚加密"><a href="#维吉尼亚加密" class="headerlink" title="维吉尼亚加密"></a>维吉尼亚加密</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这会有一张矩形表，一个密钥，密钥的长度必须和明文一样长，如果不一样长的话，密钥就得自我复制，注意这种加密只对字母有效无论大小字母</span><br></pre></td></tr></tbody></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230522095623282.png" alt="image-20230522095623282"></p>
<h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">明文：I've got it.</span><br><span class="line"></span><br><span class="line">密钥：ok</span><br><span class="line"></span><br><span class="line">密文：W'fs qcd wd.</span><br></pre></td></tr></tbody></table></figure>

<h5 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这没什么好讲的，主打的就是一个偏移量，ABCDEFGHIJKLMNOPQRSTUVWXYZ，DEFGHIJKLMNOPQRSTUVWXYZABC，偏移量为3</span><br></pre></td></tr></tbody></table></figure>

<h5 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过交替的组合得到一个新的字符串，比如ABSDASEAF,ASBDAESAF。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="摩斯密码"><a href="#摩斯密码" class="headerlink" title="摩斯密码"></a>摩斯密码</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种密码其实就是一一对应的映射表</span><br></pre></td></tr></tbody></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230522100242906.png" alt="image-20230522100242906"></p>
<h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><h5 id="猎聘"><a href="#猎聘" class="headerlink" title="猎聘"></a><a target="_blank" rel="noopener" href="https://www.liepin.com/">猎聘</a></h5><h5 id="思路-44"><a href="#思路-44" class="headerlink" title="思路:"></a>思路:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先我遇到的问题就是用JS发条去调试代码的时候发现报错， o = new Uint8Array(16);就是这个代码，因为Js发条工具没有这个创建数组的环境所以得通过在pycharm创建并打开js文件，使用本地的Node.js环境，还有一个问题就是这个随机加密函数getRandomValues，其实这种Native method，我是没有在浏览器开发者工具有看到，但是做这种的告诉我得从外面去找这种东西。还有就是可以把代码边的简洁，有些地方是明显不需要的就直接扔掉，哈哈哈，总结出来的新方法，比如说if(c[n]) new Error 知道里面肯定为false就不要了</span><br></pre></td></tr></tbody></table></figure>

<p>代码:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> for (var c = false, s = [], l = 0; l &lt; 256; ++l)</span><br><span class="line">        s.push((l + 256).toString(16).substr(1));</span><br><span class="line"></span><br><span class="line">function a() {</span><br><span class="line">        var r = aa();</span><br><span class="line">        return u(r)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">function u(e) {</span><br><span class="line">    var t = 0</span><br><span class="line">          , n = (s[e[t + 0]] + s[e[t + 1]] + s[e[t + 2]] + s[e[t + 3]] + "-" + s[e[t + 4]] + s[e[t + 5]] + "-" + s[e[t + 6]] + s[e[t + 7]] + "-" + s[e[t + 8]] + s[e[t + 9]] + "-" + s[e[t + 10]] + s[e[t + 11]] + s[e[t + 12]] + s[e[t + 13]] + s[e[t + 14]] + s[e[t + 15]]).toLowerCase();</span><br><span class="line">        return n</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function aa() {</span><br><span class="line">        var r, o = new Uint8Array(16);</span><br><span class="line">        return getRandomValues(o)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">function randoms(min, max) {</span><br><span class="line">    return Math.floor(Math.random() * (max - min + 1) + min)</span><br><span class="line">}</span><br><span class="line">function getRandomValues(buf) {</span><br><span class="line">    var min = 0,</span><br><span class="line">    max = 255;</span><br><span class="line">    if (buf.length &gt; 65536) {</span><br><span class="line">        var e = new Error();</span><br><span class="line">        e.code = 22;</span><br><span class="line">        e.message = 'Failed to execute \'getRandomValues\' : The ' + 'ArrayBufferView\'s byte length (' + buf.length + ') exceeds the ' + 'number of bytes of entropy available via this API (65536).';</span><br><span class="line">        e.name = 'QuotaExceededError';</span><br><span class="line">        throw e;</span><br><span class="line">    }</span><br><span class="line">    if (buf instanceof Uint16Array) {</span><br><span class="line">        max = 65535;</span><br><span class="line">    } else if (buf instanceof Uint32Array) {</span><br><span class="line">        max = 4294967295;</span><br><span class="line">    }</span><br><span class="line">    for (var element in buf) {</span><br><span class="line">        buf[element] = randoms(min, max);</span><br><span class="line">    }</span><br><span class="line">    return buf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">console.log(a())</span><br></pre></td></tr></tbody></table></figure>

<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">解释一下“过拟合”是什么？</span><br><span class="line">答：过拟合是指模型在训练数据上表现良好，但在测试数据上表现较差的现象，模型过于复杂，无法泛化到新的数据集上。</span><br><span class="line"></span><br><span class="line">什么是梯度下降？</span><br><span class="line">答：梯度下降是求解损失函数最小化的一种常用方法，在训练过程中，通过不断的沿着损失函数梯度方向调整模型参数，以达到最小化损失函数的目的。</span><br><span class="line"></span><br><span class="line">什么是深度学习？</span><br><span class="line">答：深度学习是一种以人工神经网络模型为基础的机器学习技术，通过多层次的结构来学习数据的特征表达，可用于图像识别、语音识别、自然语言处理等诸多领域。</span><br><span class="line"></span><br><span class="line">解释一下“卷积神经网络”是什么？</span><br><span class="line">答：卷积神经网络是一种特殊的神经网络，主要用于图像、音频、视频等数据的处理，能够自动学习数据的特征并进行分类或回归等任务，其主要特点是进行局部权重共享和参数共享，减少了需要学习的参数数量，降低了网络的复杂度。</span><br><span class="line"></span><br><span class="line">什么是“监督学习”？</span><br><span class="line">答：监督学习是一种常见的机器学习方法，需要使用标注好的数据进行模型训练，通过训练得到的模型可以对新的未标注数据进行预测或分类。监督学习适用于分类、回归等场景。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">什么是无监督学习？</span><br><span class="line">答：无监督学习是一种机器学习技术，用于在没有标注数据的情况下，从数据本身中发现隐藏的结构或模式。无监督学习适用于聚类、降维等场景。</span><br><span class="line"></span><br><span class="line">什么是深度神经网络？</span><br><span class="line">答：深度神经网络（Deep Neural Network，DNN）是一种特殊的神经网络，由多个隐含层（Hidden Layer）组成，可用于处理复杂的非线性问题，例如图像识别、自然语言处理等。</span><br><span class="line"></span><br><span class="line">什么是梯度消失问题？</span><br><span class="line">答：梯度消失问题是指在深度神经网络中，随着误差反向传播（Backpropagation）向前传递，梯度会逐渐变小，甚至趋近于0，导致前面的层参数更新缓慢或不更新的现象。</span><br><span class="line"></span><br><span class="line">什么是LSTM？</span><br><span class="line">答：LSTM（Long Short-Term Memory）是一种常用的循环神经网络（Recurrent Neural Network，RNN）结构，专门用于处理序列数据，其主要特点是通过带有门控（Gate）机制的结构来控制记忆单元（Memory Cell）的读写，提高了长期依赖关系的建模能力。</span><br><span class="line"></span><br><span class="line">什么是强化学习？</span><br><span class="line">答：强化学习（Reinforcement Learning）是一种基于试错的学习方式，通过智能体（Agent）与环境的交互学习，从环境反馈中逐步调整策略，使得智能体在完成某种任务时能够最大化奖励（Reward）或最小化惩罚（Punishment）。强化学习适用于游戏AI、机器人控制等领域。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">策略迭代算法主要是策略评估、策略改进，通过不断的迭代，收敛到最优策略值</span><br><span class="line">值迭代算法主要是通过不断更新状态值函数迭代来求最优策略值，直至收敛到最优状态值函数，通过状态值函数求得最优策略</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">符号主义基于物理符号系统假设和有限合理性原理</span><br><span class="line">联接主义基于神经网络和网络间的连接机制与学习算法</span><br><span class="line">行为主义基于控制论和"动作-感知"控制系统</span><br></pre></td></tr></tbody></table></figure>



<h1 id="Travel"><a href="#Travel" class="headerlink" title="Travel"></a>Travel</h1><h3 id="南京"><a href="#南京" class="headerlink" title="南京"></a>南京</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">南京南到玄武湖(25分钟)</span><br><span class="line">请扮演一位导游，目前我是8:42到南京站，我想去的目的地是玄武湖、南京博物馆、钟山风景区、秦淮河、先锋书店，请给我生成一份旅游攻略，什么景点早上去，什么景点下午去，什么景点晚上去。以及中午和晚上在哪里吃，吃什么。Let's think step by step。</span><br><span class="line"></span><br><span class="line">苏州北 44</span><br><span class="line">石湖北 -&gt; 苏州 21</span><br><span class="line">苏州 -&gt; 南京站: 7:23 ~ 8:42 (94r)</span><br><span class="line"></span><br><span class="line">南京站 -&gt; 玄武湖(8分钟) 一号线 9:00 一个小时</span><br><span class="line">玄武湖 -&gt; 上海路(7分钟，朝天宫) (12.5r) 需要预约</span><br><span class="line">玄武湖 -&gt; 新街口(5分钟) -&gt; 明故宫(5分钟) 此地有南京博物馆 ×</span><br><span class="line"></span><br><span class="line">明故宫 -&gt; 宿园(2分钟) 钟山风景区（50r) 需要提前购票</span><br><span class="line"></span><br><span class="line">宿园 -&gt; 大行宫(5分钟) -&gt; 夫子庙(4分钟)</span><br><span class="line">夫子庙 -&gt; 先锋书店(2分钟)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">南京南 -&gt; 苏州 21:41 ~ 22:53(104r)</span><br><span class="line">早上：</span><br><span class="line"></span><br><span class="line">1.从南京站出发前往玄武湖，玄武湖公园位于南京市中心，是一个美丽宜人的公园，适合早晨散步和呼吸新鲜空气。</span><br><span class="line">2.玄武湖参观完毕后，前往南京博物馆，这里收藏了大量的中国历史文化遗产和南京特色文物。</span><br><span class="line">中午：</span><br><span class="line">3. 中午您可以前往秦淮河畔的美食街，这里有许多传统的南京小吃，如狮子头、板鸭、金陵饭等。您可以在此品尝地道的南京美食。</span><br><span class="line"></span><br><span class="line">下午：</span><br><span class="line">4. 下午您可以前往钟山风景区，这里是南京最高的山峰，有着优美的自然环境和众多的文化景点，如明孝陵、灵谷寺等。</span><br><span class="line">5. 参观完钟山风景区后，您可以前往先锋书店，这是一个非常有特色的书店，可以购买到一些艺术类书籍和文具用品。</span><br><span class="line"></span><br><span class="line">晚上：</span><br><span class="line">6. 晚上可以前往秦淮河畔游船，您可以欣赏到南京灯火辉煌的夜景，还可以听到一些戏曲表演和民乐演奏。</span><br><span class="line">7. 晚上也可以选择在秦淮河畔的餐厅里品尝一些特色菜肴，如清蒸活鱼、炒鳝片等。</span><br></pre></td></tr></tbody></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="http://static.city.manmankan.com/kimages/202302/27_1677459974139797.jpg" alt="img"></p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h3 id="常熟银行"><a href="#常熟银行" class="headerlink" title="常熟银行"></a>常熟银行</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java的三大特性。多态，封装，继承。</span><br><span class="line">重载，重写。</span><br><span class="line">MySQL的数据库优化。</span><br><span class="line">乐观锁和悲观锁。</span><br><span class="line">线程创建的方式：1.Thread 2.线程池 3.Runnable。</span><br><span class="line">StringBuilder 和 StringBuffer.</span><br></pre></td></tr></tbody></table></figure>

<h3 id="秋招投递"><a href="#秋招投递" class="headerlink" title="秋招投递"></a>秋招投递</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">理想汽车</span><br><span class="line">腾讯校招</span><br><span class="line">特斯拉</span><br><span class="line">快手   --简历挂</span><br><span class="line">美团   --简历过 目前笔试阶段</span><br><span class="line">掌趣</span><br><span class="line">多益网络 - 不知道什么挂</span><br><span class="line">米哈游</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h1><h3 id="BeiJing"><a href="#BeiJing" class="headerlink" title="BeiJing"></a>BeiJing</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230807115445674.png" alt="image-20230807115445674"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230807115504150.png" alt="image-20230807115504150"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230807115516889.png" alt="image-20230807115516889"></p>
<h1 id="每天记录"><a href="#每天记录" class="headerlink" title="每天记录"></a>每天记录</h1><h3 id="2023-7-04"><a href="#2023-7-04" class="headerlink" title="2023-7-04"></a>2023-7-04</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这天主要是早上刷了一上午的算法，下午看了Java线程(快乐的野指针)，然后看了SpringCloud的东西(Eurake,Feign,熔断与降级,zuul,Config，Bus全局消息),看了王汉远讲的SpringCloud视频内容。SpringCloud服务之间的调用失败了，看的庆哥的，说实话有点low,服务注册我确实是弄好了，就是不能调用</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-05"><a href="#2023-7-05" class="headerlink" title="2023-7-05"></a>2023-7-05</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天上午主要是把Java线程全部给看完了，下午主要是去了解这个RabbitMQ和RocketMQ以及kafka等消息中间件，最后学了一点oo的如何学习一门新的技术的理论。最后刷了一下四数之和这个哈希表的题目。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-06"><a href="#2023-7-06" class="headerlink" title="2023-7-06"></a>2023-7-06</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天主要是弄懂异步同步阻塞非阻塞概念，刷了一下字符串算法，再就是弄懂CAS和锁升级的问题。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-07"><a href="#2023-7-07" class="headerlink" title="2023-7-07"></a>2023-7-07</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天主要是学了一下java基础里面的修饰符的使用，然后下午就是刷了一下午算法(字符串之类的)。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-09"><a href="#2023-7-09" class="headerlink" title="2023-7-09"></a>2023-7-09</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天主要就是学了Redis缓存那一块，也就是那个CSDN上面的，讲的一些Redis如何保持数据一致性，主动更新的概念，还有对缓存击穿和缓存雪崩和缓存穿透的一些概念的理解，以及一些解决这些问题的办法。</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_59212867/article/details/128007094">CSDN_Redis</a></p>
<h3 id="2023-7-10"><a href="#2023-7-10" class="headerlink" title="2023-7-10"></a>2023-7-10</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天主要就是把弱引用强引用虚引用都重温了一遍，以及ThreadLocal了解一下</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-11"><a href="#2023-7-11" class="headerlink" title="2023-7-11"></a>2023-7-11</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EZ4y147qZ?p=7&amp;spm_id_from=pageDriver&amp;vd_source=64ef920f32acb8a04a7d5d3ee9d054a2">Threadlocal讲解地址</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal源码分析, </span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-14"><a href="#2023-7-14" class="headerlink" title="2023-7-14"></a>2023-7-14</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">彻底把ThreadLocal的具体应用常见，包括它的弱引用和强引用在内存泄漏方面都是一样的，要避免内存泄漏那么我们就需要手动的去remove，并且在访问Thread.ThreadMap中entry对象的key为null的时候，把value同样也设置为null</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44184990/article/details/122279854">CSDN的ThreadLocal的讲解</a></p>
<h3 id="2023-7-16"><a href="#2023-7-16" class="headerlink" title="2023-7-16"></a>2023-7-16</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要是看了看mysql下面的存储引擎有哪些,通过登录mysql，输入show engines,就能看到mysql所有的存储引擎。其中用的最多的就是MyISAM和Innodb,其中MyISAM主要适用于读的操作，而Innodb支持事务和高并发以及外键索引和联级索引。数据库的三大范式。Innodb里面的B+数，看了看之前的视频</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-17"><a href="#2023-7-17" class="headerlink" title="2023-7-17"></a>2023-7-17</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天主要就是早上用scp -r root@远程地址 本地位置 来拷贝文件。下午主要是看了看野指针的JAVASE的内容。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-18"><a href="#2023-7-18" class="headerlink" title="2023-7-18"></a>2023-7-18</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pcj_888/article/details/122227334">CSDN_ziplist实现</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天主要是了解了Redis的五种数据类型的底层结构，其中最主要是了解散列表(类似于Java当中的HashMap)和跳表以及ziplist, 特别要知道ziplist的底层实现，【整个ziplist的占用字节数】【最后一个节点的首地址到ziplist最前面的字节大小】【元素的个数】【entry----entry】【尾部标记元素】，早上主要是深一步了解什么是幻读，不可重复度，脏读。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-19"><a href="#2023-7-19" class="headerlink" title="2023-7-19"></a>2023-7-19</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_58850105/article/details/124228023">CSDN_JUC</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天主要是学习了一下常见的JUC类(Semaphore,CountDownLatch,ReentryLock)和一些线程安全的容器(CopyOnWriteArrayList,ConcurrentHashMap),还要就是初步的学了一会git的进一步使用</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-20"><a href="#2023-7-20" class="headerlink" title="2023-7-20"></a>2023-7-20</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">感觉干了整整一天的项目，Debug还没有完成 麻了</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-23"><a href="#2023-7-23" class="headerlink" title="2023-7-23"></a>2023-7-23</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天主要是看了看八股的视频，主要有ArrayList源码分析,</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2023-7-27"><a href="#2023-7-27" class="headerlink" title="2023-7-27"></a>2023-7-27</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天主要是看了看fafka的一些架构和消息传递原理以及持久化机制，华科佬的Mysql加锁机制</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wanghaiping1993/article/details/125346010">Kafka面试题</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42073408/article/details/119751796">Kafka原理</a></p>
<h3 id="2023-08-01"><a href="#2023-08-01" class="headerlink" title="2023-08-01"></a>2023-08-01</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天早上填个多益网络招聘，下午看咕咪的文档，下午主要是看</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Company"><a href="#Company" class="headerlink" title="Company"></a>Company</h1><p>思路</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.databaseList当中的BaseDatabase实体类是哪一个? DataBaseListService是哪一个? 是要自己创建一个吗?</span><br><span class="line">2.之前数据库名有对应id,operate用的是Equal，但是现在要模糊查询，也就是说要Exits</span><br></pre></td></tr></tbody></table></figure>

<h3 id="核心代码块"><a href="#核心代码块" class="headerlink" title="核心代码块"></a>核心代码块</h3><p>1.拼装SearchField的in的SQL语句</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SearchField&gt; rebuildField = getRebuildField();</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;SearchField&gt; getRebuildField() {</span><br><span class="line">        BaseQueryContext context = getContext();</span><br><span class="line">        List&lt;SearchField&gt; searchFields = new ArrayList&lt;&gt;(this.searchFields.size());</span><br><span class="line">        for (SearchField searchField : this.searchFields) {</span><br><span class="line">            IndexField indexField = context.fieldMapper(searchField.getFieldName());</span><br><span class="line">            if (indexField == null) {</span><br><span class="line">                searchFields.add(searchField);</span><br><span class="line">                continue;</span><br><span class="line">            }</span><br><span class="line">            if (StringUtils.isBlank(indexField.getValuesMapping())) {</span><br><span class="line">                searchFields.add(searchField);</span><br><span class="line">                continue;</span><br><span class="line">            }</span><br><span class="line">            Map&lt;String, ValuesMapping&gt; beanMap =</span><br><span class="line">                    SpringContextUtils.getContext().getBeansOfType(ValuesMapping.class);</span><br><span class="line">            SearchField mapping = beanMap.get(indexField.getValuesMapping()).getMapping(searchField.getValue(),</span><br><span class="line">                    this.searchFields, searchField);</span><br><span class="line">            if (mapping == null) {</span><br><span class="line">                return null;</span><br><span class="line">            }</span><br><span class="line">            searchFields.add(mapping);</span><br><span class="line">        }</span><br><span class="line">        return searchFields;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public SearchField getMapping(</span><br><span class="line">                List&lt;String&gt; values, List&lt;SearchField&gt; searchFields, SearchField searchField) {</span><br><span class="line">            List&lt;String&gt; policyList = new ArrayList&lt;&gt;();</span><br><span class="line">            Operator operator = searchField.getOperator();</span><br><span class="line">            boolean isExact =</span><br><span class="line">                    operator.equals(Operator.EQUAL) || operator.equals(Operator.NOT_EQUAL);</span><br><span class="line">            boolean isForwardQuery =</span><br><span class="line">                    operator.equals(Operator.EQUAL) || operator.equals(Operator.EXISTS);</span><br><span class="line">            for (String value : values) {</span><br><span class="line">                List&lt;Long&gt; policyIdListByName =</span><br><span class="line">                        basePolicyService.findPolicyIdListByName(value, isExact, isForwardQuery);</span><br><span class="line">                if (CollectionUtils.isEmpty(policyIdListByName)) {</span><br><span class="line">                    return null;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                policyList.addAll(</span><br><span class="line">                        policyIdListByName.stream()</span><br><span class="line">                                .map(id -&gt; String.valueOf(id))</span><br><span class="line">                                .collect(Collectors.toList()));</span><br><span class="line">            }</span><br><span class="line">            return new SearchField(searchField.getFieldName(), Operator.EQUAL, policyList);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public List&lt;Long&gt; findPolicyIdListByName(</span><br><span class="line">           String policyName, boolean isExact, boolean isForwardQuery) {</span><br><span class="line"></span><br><span class="line">       LambdaQueryWrapper&lt;BasePolicy&gt; like;</span><br><span class="line">       if (isForwardQuery) {</span><br><span class="line">           like = QueryWrapperUtil.lambdaQuery(BasePolicy.class)</span><br><span class="line">                   .like(BasePolicy::getName, StrUtils.escapeSQLLike(policyName));</span><br><span class="line">       } else {</span><br><span class="line">           like = QueryWrapperUtil.lambdaQuery(BasePolicy.class)</span><br><span class="line">                   .notLike(BasePolicy::getName, StrUtils.escapeSQLLike(policyName));</span><br><span class="line">       }</span><br><span class="line">       List&lt;BasePolicy&gt; all = this.list(like);</span><br><span class="line">       if (CollectionUtils.isEmpty(all)) {</span><br><span class="line">           return null;</span><br><span class="line">       }</span><br><span class="line">       return all.stream().map(basePolicy -&gt; basePolicy.getId()).collect(Collectors.toList());</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryBuilder.append("(").append(rebuildField.get(i).getEsQuery(getContext())).append(")");</span><br></pre></td></tr></tbody></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230721112532721.png" alt="image-20230721112532721"></p>
<h3 id="完整SQL语句"><a href="#完整SQL语句" class="headerlink" title="完整SQL语句"></a>完整SQL语句</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mainBuilder.append(" where auditId in (select auditId from ").append(tableName)</span><br><span class="line">                       .append(" where ").append(builder.toString());</span><br></pre></td></tr></tbody></table></figure>



<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20230721115820750.png" alt="image-20230721115820750"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT sqlText,riskLevel,storageTime,policyId,clientIp,alarmId,tenantId,databaseId,sqlPredicate,responseCode FROM dbaudit.audit_log where auditId in (select auditId from audit_log where  1=1 AND toDateTime(storageTime) &gt;= '2023-07-21 00:00:00' AND toDateTime(storageTime) &lt;= '2023-07-21 23:59:59' AND 1=1 AND ((databaseId IN (50001,50000) ) AND (policyId IN (107,207) ) AND (tenantId IN (2) )) order by storageTime desc limit ?,?) order by storageTime desc</span><br></pre></td></tr></tbody></table></figure>



















<h3 id="审计日志系统功能更新"><a href="#审计日志系统功能更新" class="headerlink" title="审计日志系统功能更新"></a>审计日志系统功能更新</h3><h5 id="bug01"><a href="#bug01" class="headerlink" title="bug01"></a>bug01</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The bean 'org.springframework.context.annotation.internalScheduledAnnotationProcessor', defined in class path resource [org/springframework/scheduling/annotation/SchedulingConfiguration.class], could not be registered. A bean with that name has already been defined in class path resource [com/idss/dbaudit/config/schedule/annotation/ProgressSchedulingConfiguration.class] and overriding is disabled.</span><br></pre></td></tr></tbody></table></figure>

<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45821255/article/details/126724228">参考文档</a></p>
<h5 id="bug02"><a href="#bug02" class="headerlink" title="bug02"></a>bug02</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error running DbauditApplication. Command line is too long. Shorten the command line via JAR manifest or via a classpath file and rerun</span><br></pre></td></tr></tbody></table></figure>

<h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><p>Edit项目的Configuration，增加VM option ,short Command line选项 </p>
<h5 id="bug03"><a href="#bug03" class="headerlink" title="bug03"></a>bug03</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postman报Error: write EPROTO 140600974724440:error:100000f7:SSL routines:OPENSSL_internal:</span><br></pre></td></tr></tbody></table></figure>

<h5 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h5><p>把https改成http就可以了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42110844/article/details/124379691">参考文档</a></p>
<p>遇到的问题</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目前模型类(敏感数据审计和业务审计都是这样)里面只有String DataBaseId, 之前是固定一个数据库Id参与查询，需求是我通过数据库名模糊查询出来有多个Id, 然后参与查询。</span><br><span class="line">实现: 那么我需要改之前的SQL, 把 1.database =  -&gt; in   2. 模型类增加DatabaseIdS </span><br><span class="line">问题: 是按我的上面所说来改还是说像昨天说的那个资产监控那样目前这个需求不动了。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="告警查询"><a href="#告警查询" class="headerlink" title="告警查询"></a>告警查询</h4><p><strong><u>前端之后得用SearchDataBaseName字段来查询</u></strong></p>
<p>QueryAuditAlarmBo 前</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 数据库id列表</span><br><span class="line">    */</span><br><span class="line">   private List&lt;Long&gt; databaseIdList;</span><br></pre></td></tr></tbody></table></figure>

<p>QueryAuditAlarmBo 后</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 数据库名称</span><br><span class="line">    */</span><br><span class="line">   private String searchDataBaseName;</span><br><span class="line">   /**</span><br><span class="line">    * 数据库id列表</span><br><span class="line">    */</span><br><span class="line">   private List&lt;Long&gt; databaseIdList;</span><br></pre></td></tr></tbody></table></figure>



<h4 id="万能代码"><a href="#万能代码" class="headerlink" title="万能代码"></a>万能代码</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; databaseIdListByName =</span><br><span class="line">                    databaseService.findDatabaseIdListByName(queryAuditAlarmBo.getSearchDataBaseName(), true, true);</span><br><span class="line">        if (CollectionUtils.isNotEmpty(databaseIdListByName)) {</span><br><span class="line">            queryAuditAlarmBo.setDatabaseIdList(databaseIdListByName);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (CollectionUtils.isNotEmpty(queryRiskAnalysisAlarmBo.getDatabaseIdList())) {</span><br><span class="line">           boolBuilder.append(" AND databaseId IN (")</span><br><span class="line">                   .append(StringUtils.join(queryRiskAnalysisAlarmBo.getDatabaseIdList(), ",")).append(") ");</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addb3c3755c21b7a3859b33e577732a6355d7821</span><br><span class="line">dbb23a63b4ac158631cb225546769905efc18bd2</span><br><span class="line">58811e25e124c57dbcee7310fcb24199b190a987</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.in(CollectionUtils.isNotEmpty(queryPolicyBo.getDatabaseIdList()),BasePolicy::getDatabaseIdList,queryPolicyBo.getDatabaseIdList())</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.and(CollectionUtils.isNotEmpty(queryHighPolicyBo.getDatabaseIdList()),qw-&gt;{</span><br><span class="line"></span><br><span class="line">                        for (Long o : queryHighPolicyBo.getDatabaseIdList()) {</span><br><span class="line">                            qw.like(HighFrequencyStatistics::getDatabaseIdListQuery, ","+o+",").or();</span><br><span class="line">                        }</span><br><span class="line">                    })</span><br></pre></td></tr></tbody></table></figure>



<h3 id="没有数据的模块"><a href="#没有数据的模块" class="headerlink" title="没有数据的模块"></a>没有数据的模块</h3><p>1.会话分析-失败登录</p>
<p>2.数据敏感发现</p>
<p>3.业务审计</p>
<p>4.告警查询</p>
<p>———————————————————————— 2023-07-31 问题已解决  ——————————————————————————–</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库审计系统和我们写的Jar包是独立的, 2.0.1是查的ES，类似于北京联通4A，2.3.1是从ck里面去查，然后我们需要做的事情就是把产生的日志文件发送到FTP上面, 我们导出的数据文件也得是CSV文件的, 然后YML文件得给出一个存储list的方式，</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目前进度: 熟悉北京联通发送日志的代码和了解ES查询代码，知道yml文件配置数据库ID列表</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">数据库日志文件</span><br><span class="line">1、范围:18套涉敏系统数据库</span><br><span class="line">2、内容:数据库审计日志《包含增删查改)</span><br><span class="line">3、数据库日志文件后缀名:.xml、.csy、.1og</span><br><span class="line">4、数据库日志文件命名:增量/全量/新增数据标志机构编码接口单元编码 数据日期 重传序号序列号数据库类型 数据库版本号.10g。</span><br><span class="line">示例: a 10200_13014 20170401 00 001 mysq1 5.0.0.1og</span><br><span class="line">需要修改的内容如下:</span><br><span class="line">1)数据日期:填当天日期，如: 20230724</span><br><span class="line">2)重传序号:当天第一次重传的某个表结构文件为01，以此类推</span><br><span class="line">3)序列号:当天上传的第一个表结构文件为001，以此类推。</span><br><span class="line">4)数据库类型:表结构文件对应的数据库类型，如mysql、oracle等</span><br><span class="line">5)数据库版本号:表结构文件对应的数据库版本，如5.0.0、12.1.0.2.0等</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (CollectionUtils.isEmpty(databaseIdListByName)) {</span><br><span class="line">                    return null;</span><br><span class="line">                }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目前进度: 代码写了CSV文件需要的实体类，如何实现将数据写入到CSV文件，完全弄懂北京联通4A代码</span><br><span class="line">不懂的点: 1. ES查询是要查哪个索引，查询的索引里面的字段是不是就是之前数据库审计系统导出的CSV文件,ES的IP地址和Port是北京联通的吗还是别的. 2. ClickHouse的ip和port目前不清楚 3. 文件命名的具体规则有点模糊不清除</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">整体梳理: 1. 通过版本号区别分别查ES和clickhouse 2. 将查出来的数据放入到CSV文件 3. 将csv文件发送到FTP服务器 4. 打成Jar部署到远端。</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目前进度: 项目的大体框架有了；</span><br><span class="line">todolist: 1. ES需要测试环境 2. 查询到的数据进行数据值的转化(数据库ID -&gt; 数据库Name) 3. 将生成的CSV文件发送到FTP服务器上面 4. CK查询数据的处理(如何传递给消费者)</span><br></pre></td></tr></tbody></table></figure>

<script> 
  $(function(){
    // 切换TOC目录展开收缩的相关操作.
  const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        let $itemHasChild = $(".toc-list-item:has(> .toc-list)");
        $itemHasChild.prepend("<i class='fa fa-caret-down'></i><i class='fa fa-caret-right'></i><span>&nbsp;</span>");
        let $iconToFold = $(".toc-list-item > .fa-caret-down");
        let $iconToExpand = $(".toc-list-item > .fa-caret-right");
        $iconToFold.addClass("hide");

        const targetNodes = document.getElementsByClassName("toc-list-item");
        const config = { attributes: true, childList: false, subtree: false };
        const callback = function(mutationsList, observer) {
          for(let mutation of mutationsList) {
            if (mutation.type === "attributes") {
              let target = $(mutation.target)
              if (target.hasClass("is-active-li")) {
                let $toFold = $(".toc-list-item > .fa-caret-down");
                let $toExpand = $(".toc-list-item > .fa-caret-right");
                $toFold.addClass("hide");
                $toExpand.removeClass("hide");
                target.children(".fa-caret-right").first().addClass("hide")
                target.children(".fa-caret-down").first().removeClass("hide")
                let parents = target.parents(".toc-list-item")
                for (p of parents) {
                  $(p).children(".fa-caret-right").first().addClass("hide")
                  $(p).children(".fa-caret-down").first().removeClass("hide")
                }
              }
            }
          }
        };
        const observer = new MutationObserver(callback);
        for (node of targetNodes) {
          observer.observe(node, config)
        }
  });  
</script><!-- hexo injector body_end start --><script data-pjax="">
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" href="categories/安装教程/">安装教程</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">Ubuntu指南</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" href="categories/脚本/">脚本</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">玩转Win10</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" href="categories/Docker/">Docker</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">长篇小说连载</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" href="categories/Java基础/">Java基础</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">个人日记</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" href="categories/Linux/">Linux</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">诗词歌赋</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover6.webp);"> <a class="categoryBar-list-link" href="categories/Java面试准备/">Java面试准备</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">杂谈教程</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/Redis/">Redis</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/项目/">项目</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/Hexo/">Hexo</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/数据采集/">数据采集</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/python基础/">python基础</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/可视化/">可视化</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/逆向/">逆向</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/数据库/">数据库</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/vue/">vue</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/云计算/">云计算</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/">算法简史</a><span class="categoryBar-list-count">84</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/回溯/">回溯</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/二叉树/">二叉树</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/字符串/">字符串</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/数组/">数组</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/栈/">栈</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/队列/">队列</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/贪心/">贪心</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/动态规划/">动态规划</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/链表/">链表</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/吉他/">吉他</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/口语/">口语</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/算法简史/哈希表/">哈希表</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/内功/">内功</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/计网/">计网</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/论文/">论文</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/SpringCloud/">SpringCloud</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax="">
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/10/04/sql练习/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://img1.imgtp.com/2022/07/15/UwiQAoqi.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-04</span><a class="blog-slider__title" href="2023/10/04/sql练习/" alt="">SQL练习复盘</a><div class="blog-slider__text">SQL练习复盘</div><a class="blog-slider__button" href="2023/10/04/sql练习/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/10/22/vue_报错/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://s2.loli.net/2022/06/29/yXqWYF4skvtomBO.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-10-22</span><a class="blog-slider__title" href="2022/10/22/vue_报错/" alt="">Vue报错汇总</a><div class="blog-slider__text">Vue报错汇总</div><a class="blog-slider__button" href="2022/10/22/vue_报错/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/08/15/瑞吉外卖_day01/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://img1.imgtp.com/2022/07/15/p02mXQU3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-15</span><a class="blog-slider__title" href="2022/08/15/瑞吉外卖_day01/" alt="">瑞吉外卖-Day01</a><div class="blog-slider__text">复习一下两个月之前做过的项目</div><a class="blog-slider__button" href="2022/08/15/瑞吉外卖_day01/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/07/07/Docker容器命令/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://s2.loli.net/2022/08/04/Tqev12JDspakimW.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-07-07</span><a class="blog-slider__title" href="2022/07/07/Docker容器命令/" alt="">Docker容器命令</a><div class="blog-slider__text">学习常用的Docker容器命令</div><a class="blog-slider__button" href="2022/07/07/Docker容器命令/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/07/07/Docker镜像命令/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://s2.loli.net/2022/08/04/ixURJ3ymTsaqKdu.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-07-07</span><a class="blog-slider__title" href="2022/07/07/Docker镜像命令/" alt="">Docker镜像命令</a><div class="blog-slider__text">学习常用的Docker镜像命令</div><a class="blog-slider__button" href="2022/07/07/Docker镜像命令/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/07/05/英语口语01/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://img1.imgtp.com/2022/07/15/DBfkaoIF.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-07-05</span><a class="blog-slider__title" href="2022/07/05/英语口语01/" alt="">学习口语</a><div class="blog-slider__text">一些口语武器库</div><a class="blog-slider__button" href="2022/07/05/英语口语01/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/07/04/Redis常用命令/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://img1.imgtp.com/2022/07/15/8Nk1eyJ6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-07-04</span><a class="blog-slider__title" href="2022/07/04/Redis常用命令/" alt="">Redis命令大全</a><div class="blog-slider__text">学习Redis使用</div><a class="blog-slider__button" href="2022/07/04/Redis常用命令/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer="" src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer="" data-pjax="" src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://1qiqiqi.github.io">xiaoqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://1qiqiqi.github.io/2023/06/06/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">https://1qiqiqi.github.io/2023/06/06/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://1qiqiqi.github.io" target="_blank">藏心阁</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">Java面试准备</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/08/04/lmAJuEYUBxSGrVt.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/img/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/img/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/21/%E8%BD%BB%E6%9D%BE%E9%98%85%E8%AF%BB-SpringCloud/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://s2.loli.net/2022/08/04/Tqev12JDspakimW.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">轻松阅读</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/12/%E5%9B%BE%E6%A0%87%E5%88%B7%E6%96%B0/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://img1.imgtp.com/2022/07/15/p02mXQU3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图标修复</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Test-angel"><span class="toc-text">Test:angel:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC%E6%80%9D%E6%83%B3"><span class="toc-text">技术学习指导思想</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-airplane"><span class="toc-text">Spring:airplane:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E7%94%A8Spring"><span class="toc-text">为什么选用Spring?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">SpringBoot的启动过程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">SpringBoot自动配置源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Spring中的Bean的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E6%AD%A5%E9%AA%A4%E7%9C%8B"><span class="toc-text">5步骤看</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E6%AD%A5%E9%AA%A4%E7%9C%8B"><span class="toc-text">7步骤看</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-alien"><span class="toc-text">计算机网络:alien:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E7%BD%91%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">当你在浏览器中输入URL网址的时候发生了什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8EUnicode%E7%9A%84%E7%90%86%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">对于Unicode的理解是什么?:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">为什么TCP需要三次握手?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">三次握手的流程是什么?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%85%B7%E4%BD%93%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">三次握手的具体原因是什么?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%A6%82%E4%BD%95%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">TCP三次握手如何数据丢失怎么办?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OS-woman-astronaut"><span class="toc-text">OS:woman_astronaut:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-astonished"><span class="toc-text">数据结构与算法:astonished:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-text">代码:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">有效的字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">代码：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-text">两个数组的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-text">快乐数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">四数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8E%E9%87%91%E6%9D%A1"><span class="toc-text">赎金条</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-text">代码:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">反转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22"><span class="toc-text">反转字符串2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-text">替换空格</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1"><span class="toc-text">思路1:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-text">反转字符串里的单词</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">左旋转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="toc-text">找出字符串第一个匹配项的下标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">重复的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-text">代码:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="toc-text">[栈实现队列](232. 用栈实现队列 - 力扣（LeetCode）)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-text">用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">滑动窗口最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-text">前k个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-text">代码:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-text">递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-1"><span class="toc-text">思路1:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%811"><span class="toc-text">代码1:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2"><span class="toc-text">思路2:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%812"><span class="toc-text">代码2:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%813"><span class="toc-text">代码3:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF4"><span class="toc-text">思路4:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%814"><span class="toc-text">代码4:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%811-1"><span class="toc-text">代码1:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%812-1"><span class="toc-text">代码2:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%813-1"><span class="toc-text">代码3:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%811-2"><span class="toc-text">代码1:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%812-2"><span class="toc-text">代码2:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-24"><span class="toc-text">代码:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%811-3"><span class="toc-text">代码1:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-text">最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-25"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-26"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-27"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">二叉树所有的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-28"><span class="toc-text">代码:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-text">分发饼干</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-29"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%87%E6%91%86%E5%BA%8F%E5%88%97"><span class="toc-text">摇摆序列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-30"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-text">最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-31"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8"><span class="toc-text">买卖股票</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-32"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-33"><span class="toc-text">代码:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%812-3"><span class="toc-text">代码2:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#k%E6%AC%A1%E5%8F%96%E5%8F%8D"><span class="toc-text">k次取反</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-36"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-34"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%BD%E8%BD%A6%E5%8A%A0%E6%B2%B9"><span class="toc-text">汽车加油</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-37"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-35"><span class="toc-text">代码:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%811-4"><span class="toc-text">代码1:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-text">分发糖果</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-38"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-36"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-text">柠檬水找零</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-39"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-37"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%93%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-text">弓箭引爆气球</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-40"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-38"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%8C%BA%E9%97%B4"><span class="toc-text">无重复区间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-1"><span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-39"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%92%E5%88%86%E5%AD%90%E5%8C%BA%E9%97%B4"><span class="toc-text">划分子区间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-41"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-40"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-text">合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-42"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-41"><span class="toc-text">代码:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E6%95%B0%E5%AD%97"><span class="toc-text">递增数字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-43"><span class="toc-text">思路:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-42"><span class="toc-text">代码:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyBatis-ambulance"><span class="toc-text">MyBatis:ambulance:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-aerial-tramway"><span class="toc-text">Redis:aerial_tramway:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E4%B8%8EMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">如何保证Redis与Mysql数据库的一致性?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-text">Redis集群如何工作?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%9F"><span class="toc-text">什么是Redis？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis%E7%9A%84%E9%9B%86%E7%BE%A4%E7%BB%84%E6%88%90%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-text">Redis的集群组成是什么样的?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-text">工作流程是什么样的?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%BE%E8%8A%82%E7%82%B9%E7%9A%84"><span class="toc-text">路由器是怎么找节点的?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Redis的应用场景是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Redis不适用的场景有哪些?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">AOF的工作原理是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3AOF%E7%9A%84IO%E6%80%A7%E8%83%BD"><span class="toc-text">如何解决AOF的IO性能?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3AOF%E9%87%8D%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-text">如何解决AOF重写不一致?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%BD%93%E4%B8%ADSDS%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Redis当中SDS的原理是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SDS%E7%9A%84%E7%9B%B8%E6%AF%94C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A5%BD%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-text">SDS的相比C语言的字符串好在哪里?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">如何保持Redis的数据一致性?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BC%9A%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-text">缓存会遇到哪些问题?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E6%8F%8F%E8%BF%B0"><span class="toc-text">概念描述:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">解决方法:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL-apple"><span class="toc-text">MySQL:apple:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">InnoDB的原理是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-a%E6%98%AF%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5"><span class="toc-text">声明: a是索引字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E6%8F%92%E5%85%A5%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%E5%BD%93%E5%89%8D%E8%BF%99%E4%B8%80%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">如果在插入某个数据的时候当前这一页数据满了怎么办?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E6%98%AF%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="toc-text">什么情况会是全表扫描?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84sql%E8%AF%AD%E5%8F%A5%E4%BC%9A%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95"><span class="toc-text">哪些常见的sql语句会用到索引?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">什么是联合索引?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="toc-text">什么是索引覆盖?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%9A%E8%BF%87%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%8E%BB%E6%89%BE"><span class="toc-text">为什么不通过主键索引去找?</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%8D%E6%83%B3%E6%83%B3%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E8%83%BD%E5%AD%98%E5%82%A8%E4%B8%89%E6%9D%A1%E5%91%A2"><span class="toc-text">再想想为什么只能存储三条呢?</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%83%BD%E7%94%A8sql%E8%AF%AD%E5%8F%A5%E5%B1%95%E7%A4%BA%E5%90%97"><span class="toc-text">能用sql语句展示吗?</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">什么情况下会导致索引失效?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Innodb%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%9A%84"><span class="toc-text">Innodb是如何实现事务的?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9B%BE%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7"><span class="toc-text">主键索引的图可以优化成什么样?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Mysql%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A7%E4%B8%A4%E5%8D%83%E4%B8%87"><span class="toc-text">为什么Mysql单表最大两千万?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF15k%E8%80%8C%E4%B8%8D%E6%98%AF16k"><span class="toc-text">为什么是15k而不是16k?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%98%AF1%E4%BA%BF"><span class="toc-text">为什么不可以是1亿?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">MVCC是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MVCC%E5%9C%A8RC%E3%80%81RR%E5%9C%BA%E6%99%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">MVCC在RC、RR场景的区别?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MVCC%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-text">MVCC有什么用?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB"><span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB"><span class="toc-text">幻读</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A7%E9%87%8D%E7%82%B9"><span class="toc-text">侧重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">快照读和当前读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81%E5%92%8C%E6%84%8F%E5%90%91%E9%94%81%E7%9A%84%E7%BC%98%E5%88%86"><span class="toc-text">表锁和意向锁的缘分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">事务是怎么实现的?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80-anchor"><span class="toc-text">Java基础:anchor:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84"><span class="toc-text">Java反射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">反射实现有哪些?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">反射优缺点有哪些?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">修饰符使用范围?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%90%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%BE%97%E5%A4%A7%E4%BA%8E%E7%88%B6%E7%B1%BB"><span class="toc-text">为什么子类的访问修饰符得大于父类?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9B%B8%E5%85%B3"><span class="toc-text">类相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-text">String类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-text">数组需要注意的点:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-text">Java加载与执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-JRE-JVM"><span class="toc-text">JDK\JRE\JVM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-avocado"><span class="toc-text">并发编程:avocado:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentryLock"><span class="toc-text">ReentryLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">同步异步阻塞非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-text">锁升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Moniteor%E5%AF%B9%E8%B1%A1"><span class="toc-text">Moniteor对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%BA%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-text">对象的强软引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-text">弱引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JUC%E5%B8%B8%E8%A7%81%E7%B1%BB"><span class="toc-text">JUC常见类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">Semaphore(信号量)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JUC%E9%9B%86%E5%90%88"><span class="toc-text">JUC集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CopyOnWriteList"><span class="toc-text">CopyOnWriteList</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-text">缺点:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CopyOnWriteList%E6%89%A9%E5%AE%B9"><span class="toc-text">CopyOnWriteList扩容</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ArrayList%E6%89%A9%E5%AE%B9"><span class="toc-text">ArrayList扩容</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConCurrentHashMap"><span class="toc-text">ConCurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%AE%83%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-text">排它锁和共享锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka"><span class="toc-text">Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">Kafka的优点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">如何保证数据一致性?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python-star-and-crescent"><span class="toc-text">Python:star_and_crescent:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83"><span class="toc-text">如何创建一个虚拟环境?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE"><span class="toc-text">如何定位参数位置?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">加密方式有哪些?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%8A%A0%E5%AF%86"><span class="toc-text">维吉尼亚加密</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81"><span class="toc-text">凯撒密码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%85%E6%A0%8F%E5%AF%86%E7%A0%81"><span class="toc-text">栅栏密码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81"><span class="toc-text">摩斯密码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%90%91"><span class="toc-text">逆向</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8C%8E%E8%81%98"><span class="toc-text">猎聘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-44"><span class="toc-text">思路:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-text">机器学习</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Travel"><span class="toc-text">Travel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%97%E4%BA%AC"><span class="toc-text">南京</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%86%9F%E9%93%B6%E8%A1%8C"><span class="toc-text">常熟银行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%8B%E6%8B%9B%E6%8A%95%E9%80%92"><span class="toc-text">秋招投递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Base"><span class="toc-text">Base</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeiJing"><span class="toc-text">BeiJing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%8F%E5%A4%A9%E8%AE%B0%E5%BD%95"><span class="toc-text">每天记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-04"><span class="toc-text">2023-7-04</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-05"><span class="toc-text">2023-7-05</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-06"><span class="toc-text">2023-7-06</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-07"><span class="toc-text">2023-7-07</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-09"><span class="toc-text">2023-7-09</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-10"><span class="toc-text">2023-7-10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-11"><span class="toc-text">2023-7-11</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-14"><span class="toc-text">2023-7-14</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-16"><span class="toc-text">2023-7-16</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-17"><span class="toc-text">2023-7-17</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-18"><span class="toc-text">2023-7-18</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-19"><span class="toc-text">2023-7-19</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-20"><span class="toc-text">2023-7-20</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-23"><span class="toc-text">2023-7-23</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-7-27"><span class="toc-text">2023-7-27</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-08-01"><span class="toc-text">2023-08-01</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Company"><span class="toc-text">Company</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">核心代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4SQL%E8%AF%AD%E5%8F%A5"><span class="toc-text">完整SQL语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E6%9B%B4%E6%96%B0"><span class="toc-text">审计日志系统功能更新</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bug01"><span class="toc-text">bug01</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">解决办法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bug02"><span class="toc-text">bug02</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-1"><span class="toc-text">解决办法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bug03"><span class="toc-text">bug03</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-2"><span class="toc-text">解决办法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%8A%E8%AD%A6%E6%9F%A5%E8%AF%A2"><span class="toc-text">告警查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%87%E8%83%BD%E4%BB%A3%E7%A0%81"><span class="toc-text">万能代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-text">没有数据的模块</span></a></li></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2020 - 2023 By xiaoqi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my <a target="_blank" rel="noopener" href="https://github.com/1qiqiqi">blog</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div id="he-plugin-simple"></div><script type="text/javascript" src="/src/js/tianqijs.js"></script><script src="/src/js/he-simple-common.js?v=2.0"></script><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script async="" src="/js/diytitle.js"></script><script src="/js/sun_moon.js" async=""></script><link rel="stylesheet" href="/src/css/he-simple.css"><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="/pluginsSrc/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Fighting,Beauty,Postive Thought,Strong Muscle" data-fontsize="15px" data-random="false" async="async"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>