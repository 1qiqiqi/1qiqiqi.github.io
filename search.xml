<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AndroidStudio安装教程</title>
    <url>/2022/08/30/Android%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<html><head></head><body><h1 id="AndroidStudio安装教程"><a href="#AndroidStudio安装教程" class="headerlink" title="AndroidStudio安装教程"></a>AndroidStudio安装教程</h1><h2 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h2><p><a href="https://developer.android.google.cn/studio">地址链接</a></p>
<p><img src="https://s2.loli.net/2022/09/03/Q1knS4ayLjpstVv.png" alt="image-20220830223750955.png"></p>
<h2 id="更改目录"><a href="#更改目录" class="headerlink" title="更改目录"></a>更改目录</h2><p><img src="https://s2.loli.net/2022/09/03/omF4g7V3pxa5cbU.png" alt="image-20220830223646997.png"></p>
<p>基本一路next</p>
<p><img src="https://s2.loli.net/2022/09/03/HsCpBycZRugjI9G.png" alt="image-20220830223852138.png"></p>
<p>这里记得选择 do not import settings</p>
<p><img src="https://s2.loli.net/2022/09/03/eRwBCtuyPSjo4Kc.png" alt="image-20220830223952507.png"></p>
<p>这里可以手动调节</p>
<p><img src="https://s2.loli.net/2022/09/03/gGaPHtjKm32yVqA.png" alt="image-20220830223930221.png"></p>
<h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img src="https://s2.loli.net/2022/09/03/eRwBCtuyPSjo4Kc.png" alt="image-20220830223952507.png"></p>
</body></html>]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>C盘清理教程</title>
    <url>/2022/08/23/C%E7%9B%98%E6%B8%85%E7%90%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<html><head></head><body><h1 id="C盘清理教程"><a href="#C盘清理教程" class="headerlink" title="C盘清理教程"></a>C盘清理教程</h1><h2 id="通过输入-temp-清理临时文件"><a href="#通过输入-temp-清理临时文件" class="headerlink" title="通过输入%temp% 清理临时文件"></a>通过输入%temp% 清理临时文件</h2><p><img src="https://s2.loli.net/2022/08/23/SC9HfRDXnINiGPs.png" alt="image-20220823103021415"></p>
<h2 id="通过打开C盘属性，点击磁盘清理"><a href="#通过打开C盘属性，点击磁盘清理" class="headerlink" title="通过打开C盘属性，点击磁盘清理"></a>通过打开C盘属性，点击磁盘清理</h2><p>这个能清理系统更新文件</p>
<p><img src="https://s2.loli.net/2022/08/23/CE6ZxNS4vLta3Jk.png" alt="image-20220823102011061"></p>
<h2 id="通过更改桌面路径"><a href="#通过更改桌面路径" class="headerlink" title="通过更改桌面路径"></a>通过更改桌面路径</h2><p>通过点开桌面的属性找到位置的字段然后更改到其他盘(默认为C盘)</p>
<p><img src="https://s2.loli.net/2022/08/23/zBUtGZXplIy3QmY.png" alt="image-20220823102851200"></p>
<p>此时我已经移动到D盘</p>
<h2 id="更改QQ微信的文件下载和文件缓存地址"><a href="#更改QQ微信的文件下载和文件缓存地址" class="headerlink" title="更改QQ微信的文件下载和文件缓存地址"></a>更改QQ微信的文件下载和文件缓存地址</h2><p><img src="https://s2.loli.net/2022/08/23/JOiwfjKzQIpuP6D.png" alt="image-20220823103449903"></p>
<p>此时上面有三处可以更改到D盘</p>
<p><img src="https://s2.loli.net/2022/08/23/yN9gO3GXAULcE8w.png" alt="image-20220823103710246"></p>
<h2 id="下载SpaceSniffer软件看个盘的空间分布"><a href="#下载SpaceSniffer软件看个盘的空间分布" class="headerlink" title="下载SpaceSniffer软件看个盘的空间分布"></a>下载SpaceSniffer软件看个盘的空间分布</h2><p><img src="https://s2.loli.net/2022/08/23/U3vTFes2HxRc81b.png" alt="image-20220823105056024"></p>
<h2 id="下载Dism-软件清理C盘内存"><a href="#下载Dism-软件清理C盘内存" class="headerlink" title="下载Dism++软件清理C盘内存"></a>下载Dism++软件清理C盘内存</h2><p><img src="https://s2.loli.net/2022/08/23/hOqjfmRCNTVoxdP.png" alt="image-20220823105431699"></p>
<h2 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h2><p>链接：<a href="https://pan.baidu.com/s/1qnLvIX24bHY6hqWoxXPJBw?pwd=6666">https://pan.baidu.com/s/1qnLvIX24bHY6hqWoxXPJBw?pwd=6666</a><br>提取码：6666<br>–来自百度网盘超级会员V2的分享</p>
</body></html>]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器命令</title>
    <url>/2022/07/07/Docker%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Docker容器命令"><a href="#Docker容器命令" class="headerlink" title="Docker容器命令"></a>Docker容器命令</h1><h3 id="Docker将镜像转为容器"><a href="#Docker将镜像转为容器" class="headerlink" title="Docker将镜像转为容器"></a>Docker将镜像转为容器</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></tbody></table></figure>



<h3 id="查看docker容器状态"><a href="#查看docker容器状态" class="headerlink" title="查看docker容器状态"></a>查看docker容器状态</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></tbody></table></figure>

<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">docker logs 容器名称</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像命令</title>
    <url>/2022/07/07/Docker%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Docker常用镜像命令"><a href="#Docker常用镜像命令" class="headerlink" title="Docker常用镜像命令"></a>Docker常用镜像命令</h1><p>这些是最基本的Docker镜像命令，也是最有用的</p>
<h3 id="镜像名组成"><a href="#镜像名组成" class="headerlink" title="镜像名组成"></a>镜像名组成</h3><p>name:tags tags指版本号 列如：mysql:5.3</p>
<h3 id="systemctl-start-docker"><a href="#systemctl-start-docker" class="headerlink" title="systemctl start docker"></a>systemctl start docker</h3><p>开启docker 的作用</p>
<h3 id="systemctl-status-docker"><a href="#systemctl-status-docker" class="headerlink" title="systemctl status docker"></a>systemctl status docker</h3><p>查看docker的状态 是运行还是dead</p>
<h3 id="systemctl-stop-docker"><a href="#systemctl-stop-docker" class="headerlink" title="systemctl stop docker"></a>systemctl stop docker</h3><p>关闭docker</p>
<h3 id="docker-pull-镜像名"><a href="#docker-pull-镜像名" class="headerlink" title="docker pull 镜像名"></a>docker pull 镜像名</h3><p>(从Dockerhub官网上面找列如nginx,如果不指定版本 那么就是最新的版本 latest)</p>
<h3 id="docker-save-o-镜像名-tar"><a href="#docker-save-o-镜像名-tar" class="headerlink" title="docker save -o 镜像名.tar"></a>docker save -o 镜像名.tar</h3><p>将镜像打包成一个压缩包</p>
<h3 id="docker-load-i-镜像名-tar"><a href="#docker-load-i-镜像名-tar" class="headerlink" title="docker load -i 镜像名.tar"></a>docker load -i 镜像名.tar</h3><p>将压缩包解压为一个镜像</p>
<h3 id="docker-rmi-镜像名或者镜像ID"><a href="#docker-rmi-镜像名或者镜像ID" class="headerlink" title="docker rmi 镜像名或者镜像ID"></a>docker rmi 镜像名或者镜像ID</h3><p>删除镜像</p>
<h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>查看镜像</p>
</body></html>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之Map遍历</title>
    <url>/2022/08/16/Java%E5%9F%BA%E7%A1%80_Map%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Java之Map遍历"><a href="#Java之Map遍历" class="headerlink" title="Java之Map遍历"></a>Java之Map遍历</h1><h2 id="Map集合遍历方式一：键找值"><a href="#Map集合遍历方式一：键找值" class="headerlink" title="Map集合遍历方式一：键找值"></a>Map<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&amp;spm=1001.2101.3001.7020">集合</a>遍历方式一：键找值</h2><ul>
<li>先获取Map集合的全部键的Set集合 //Set key=map.keySet();</li>
<li>遍历键的Set集合，然后通过键提取对应值map.getValue()</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">        Set&lt;String&gt; keys=maps.keySet();</span><br><span class="line">        <span class="keyword">for</span>(String key1:keys){</span><br><span class="line">            <span class="type">int</span> valu1e=maps.get(key1);</span><br><span class="line">            System.out.println(key1+<span class="string">"====&gt;"</span>+valu1e);</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//        鸿星尔克====&gt;2</span></span><br><span class="line"><span class="comment">//        数据结构====&gt;2</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Map集合遍历方式二：键值对流程"><a href="#Map集合遍历方式二：键值对流程" class="headerlink" title="Map集合遍历方式二：键值对流程"></a>Map集合<a href="https://so.csdn.net/so/search?q=%E9%81%8D%E5%8E%86&amp;spm=1001.2101.3001.7020">遍历</a>方式二：键值对流程</h2><ul>
<li>先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了</li>
<li>遍历Set集合，然后提取键以及提取值<br><img src="https://s2.loli.net/2022/08/16/1berpfKN3Ek5d8o.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用foreach遍历map集合，发现Map集合的键值对元素直接是没有类型的，所以不可以直接foreach遍历集合</span></span><br><span class="line"><span class="comment">         * 可以通过条用Map的方法entrySet把Map集合S转换成Set集合形式</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.把Map集合转换成Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries=maps.entrySet();</span><br><span class="line">        <span class="comment">//2.for开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:entries){</span><br><span class="line">            String key=entry.getKey();</span><br><span class="line">            <span class="type">int</span> value=entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">"=====&gt;"</span>+value);</span><br><span class="line">        }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Map集合的遍历方式三：Lambda"><a href="#Map集合的遍历方式三：Lambda" class="headerlink" title="Map集合的遍历方式三：Lambda"></a>Map集合的遍历方式三：Lambda</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">//Map集合的遍历方式：Lambda</span></span><br><span class="line"><span class="comment">//        maps.forEach(new BiConsumer&lt;String, Integer&gt;() {</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String key, Integer value) {</span></span><br><span class="line"><span class="comment">//                System.out.println(key+"---&gt;"+value);</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//        });</span></span><br><span class="line">        maps.forEach((k,v)-&gt;{</span><br><span class="line">            System.out.println(k+<span class="string">"---&gt;"</span>+v);</span><br><span class="line">        });</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Liunx上传文件报错原因</title>
    <url>/2022/08/10/Liunx%E4%B8%8A%E4%BC%A0%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<html><head></head><body><h2 id="Liunx上传文件报错原因"><a href="#Liunx上传文件报错原因" class="headerlink" title="Liunx上传文件报错原因"></a>Liunx上传文件报错原因</h2><p>今天在上传JDK8的时候报错了，原因竟然是SSH连接的用户名必须为root才能上传</p>
<p><img src="https://s2.loli.net/2022/08/10/6bLJNWmunwCz2tc.png" alt="image-20220810183742904"></p>
</body></html>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux目录结构</title>
    <url>/2022/08/10/Liunx%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><p>登录到Linux系统之后，我们需要先来熟悉一下Linux的目录结构。在Linux系统中，也是存在目录的</p>
<p>概念的，但是Linux的目录结构和Windows的目录结构是存在比较多的差异的 在Windows目录下，是</p>
<p>一个一个的盘符(C盘、D盘、E盘)，目录是归属于某一个盘符的。Linux系统中的目录有以下特点：</p>
<p><strong>A. /</strong> <strong>是所有目录的顶点</strong></p>
<p><strong>B.</strong> <strong>目录结构像一颗倒挂的树</strong></p>
<p><strong>Linux</strong> <strong>和</strong> <strong>Windows**<strong>的目录结构对比</strong></strong>:**</p>
<p><img src="https://s2.loli.net/2022/08/10/TABI8jumZ2NLQyU.png" alt="Snipaste_2022-08-10_16-32-19.png"></p>
<p>linux目录如下：</p>
<p><img src="https://s2.loli.net/2022/08/10/ndclbBogFMRDLAS.png" alt="image-20220810164434267"></p>
<p><img src="https://s2.loli.net/2022/08/10/z7uIxCRnGjrE86L.png" alt="image-20220810164702276"></p>
</body></html>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux软件安装</title>
    <url>/2022/08/10/Liunx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<html><head></head><body><h2 id="Linux软件安装"><a href="#Linux软件安装" class="headerlink" title="Linux软件安装"></a>Linux软件安装</h2><h3 id="软件安装方式"><a href="#软件安装方式" class="headerlink" title="软件安装方式"></a>软件安装方式</h3><p><img src="C:\Users\13772\Desktop\img\image-20220810223414152.png" alt="image-20220810223414152"></p>
<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>上述我们介绍了Linux系统软件安装的四种形式，接下来我们就通过第一种(二进制发布包)形式来安装</p>
<p>JDK。 JDK对应的二进制发布包，在课程资料中已经提供，如下：JDK具体安装步骤如下：</p>
<p><strong>1).</strong> <strong>上传安装包</strong></p>
<p>使用FinalShell自带的上传工具将jdk的二进制发布包上传到Linux</p>
<p>由于上述在进行文件上传时，选择的上传目录为根目录 /，上传完毕后，我们执行指令 cd / 切换到</p>
<p>根目录下，查看上传的安装包。</p>
<p><img src="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20220810223814390.png" alt="image-20220810223814390"></p>
<p><strong>2).</strong> <strong>解压安装包</strong></p>
<p>执行如下指令，将上传上来的压缩包进行解压，并通过-C参数指定解压文件存放目录为</p>
<p>/usr/local。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local</span><br></pre></td></tr></tbody></table></figure>

<p><strong>3).</strong> <strong>配置环境变量</strong></p>
<p>使用vim命令修改/etc/profile文件，在文件末尾加入如下配置</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_171 </span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></tbody></table></figure>

<p>1具体操作指令如下:</p>
<p>1). 编辑/etc/profile文件，进入命令模式 </p>
<p>vim /etc/profile </p>
<p>2). 在命令模式中，输入指令 G ， 切换到文件最后 </p>
<p>G </p>
<p>3). 在命令模式中输入 i/a/o 进入插入模式，然后切换到文件最后一行 </p>
<p>i </p>
<p>4). 将上述的配置拷贝到文件中 </p>
<p>JAVA_HOME=/usr/local/jdk1.8.0_171 </p>
<p>PATH=$JAVA_HOME/bin:$PATH </p>
<p>5). 从插入模式，切换到指令模式 </p>
<p>ESC </p>
<p>6). 按:进入底行模式，然后输入wq，回车保存 </p>
<p>:wq </p>
<p><strong>4).</strong> <strong>重新加载<strong><strong>profile</strong></strong>文件</strong></p>
<p>为了使更改的配置立即生效，需要重新加载profile文件，执行命令:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure>

<p><strong>5).</strong> <strong>检查安装是否成功</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a><strong>安装</strong>Tomcat</h2><h3 id="1-3-1-Tomcat安装"><a href="#1-3-1-Tomcat安装" class="headerlink" title="1.3.1 Tomcat安装"></a>1.3.1 Tomcat安装</h3><p>Tomcat的安装和上述JDK的安装采用相同的方式，都是使用二进制发布包的形式进行安装，在我们的</p>
<p>资料目录下，也已经准备了Tomcat的安装包：</p>
<p>具体安装步骤如下：</p>
<p><strong>1).</strong> <strong>上传安装包</strong></p>
<p>使用FinalShell自带的上传工具将Tomcat的二进制发布包上传到Linux(与前面上传JDK安装包步骤</p>
<p>一致)。</p>
<p><strong>2).</strong> <strong>解压安装包</strong></p>
<p>将上传上来的安装包解压到指定目录/usr/local下，执行命令为</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-7.0.57.tar.gz -C /usr/local </span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-启动Tomcat"><a href="#3-启动Tomcat" class="headerlink" title="3). 启动Tomcat"></a><strong>3).</strong> 启动Tomcat</h5><p>进入Tomcat的bin目录启动服务。执行命令为: </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cd /usr/local/apache-tomcat-7.0.57/ </span><br><span class="line"></span><br><span class="line">cd bin </span><br><span class="line"></span><br><span class="line">sh startup.sh或者./startup.sh </span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-3-2-Tomcat进程查看"><a href="#1-3-2-Tomcat进程查看" class="headerlink" title="1.3.2 Tomcat进程查看"></a>1.3.2 Tomcat进程查看</h3><p>上述我们将Tomcat启动完成之后，并不能知道Tomcat是否正常运行，那么我们验证Tomcat启动是否</p>
<p>成功，有多种方式，我们这里主要介绍常见的两种方式：</p>
<p><strong>1).</strong> <strong>查看启动日志</strong></p>
<p>Tomcat的启动日志输出在Tomcat的安装目录下的logs目录中，Tomcat的启动及运行日志文件名为</p>
<p>catalina.out，所以我们查看Tomcat启动日志，主要可以通过两条指令，如下：</p>
<p>只要Tomcat在启动的过程中，日志输出没有报错，基本可以判定Tomcat启动成功了。</p>
<p>1). 分页查询Tomcat的日志信息 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">more /usr/local/apache-tomcat-7.0.57/logs/catalina.out </span><br></pre></td></tr></tbody></table></figure>

<p>2). 查询日志文件尾部的50行记录 </p>
<p>tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out </p>
<p><strong>2).</strong> <strong>查询系统进程</strong></p>
<p>我们也可以通过Linux系统的查看系统进程的指令，来判定Tomcat进程是否存在，从而判定Tomcat是</p>
<p>否启动。执行如下指令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ps -ef|grep tomcat </span><br></pre></td></tr></tbody></table></figure>

<p><strong>ps</strong> 命令是linux下非常强大的进程查看命令，通过ps -ef可以查看当前运行的所有进程的详细</p>
<p>信息</p>
<p><strong>“|”</strong> 在Linux中称为管道符，可以将前一个命令的结果输出给后一个命令作为输入</p>
<p>使用ps命令查看进程时，经常配合管道符和查找命令 grep 一起使用，来查看特定进程</p>
<p><strong>1.3.3</strong> <strong>防火墙操作</strong></p>
<p>前面我们已经通过日志的方式及查看系统进程的方式，验证了Tomcat服务已经正常启动，接下来我们</p>
<p>就可以尝试访问一下。访问地址：<strong><a href="http://192.168.138.130:8080/">http://192.168.138.130:8080</a></strong>，我们发现是访问不到的。</p>
<p>那为什么tomcat启动成功了，但就是访问不到呢？原因就在于Linux系统的防火墙，系统安装完毕</p>
<p>后，系统启动时，防火墙自动启动，防火墙拦截了所有端口的访问。接下来我们就需要学习一下，如何</p>
<p>操作防火墙，具体指令如下：</p>
<p><img src="C:\Users\13772\Desktop\img\image-20220810225507945.png" alt="image-20220810225507945"></p>
<p>那么我们要想访问到Tomcat，就可以采取两种类型的操作：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></tbody></table></figure>

<p>关闭之后，再次访问Tomcat，就可以访问到了。</p>
<p>systemctl stop firewalld </p>
<p>1注意: 上面我们也提到了，直接关闭系统的防火墙，是不建议的，因为这样会造成系统不安全。</p>
<p><strong>B.</strong> 开放Tomcat的端口号8080</p>
<p>执行指令:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">①. 先开启系统防火墙 systemctl start firewalld </span><br><span class="line">②. 再开放<span class="number">8080</span>端口号 firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">8080</span>/tcp --permanent </span><br><span class="line">③. 重新加载防火墙 firewall-cmd --reload</span><br></pre></td></tr></tbody></table></figure>

<p>执行上述的操作之后，就开放了当前系统中的8080端口号，再次访问Tomcat。</p>
<h5 id="1-3-4停止Tomcat"><a href="#1-3-4停止Tomcat" class="headerlink" title="1.3.4停止Tomcat"></a>1.3.4停止Tomcat</h5><p>在Linux系统中，停止Tomcat服务的方式主要有两种：</p>
<p><strong>1).</strong> 运行Tomcat提供的脚本文件</p>
<p>在Tomcat安装目录下有一个bin目录，这个目录中存放的是tomcat的运行脚本文件，其中有一个脚本</p>
<p>就是用于停止tomcat服务的。</p>
<p>我们可以切换到bin目录，并执行如下指令，来停止Tomcat服务：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sh shutdown.sh</span><br><span class="line">./shutdown.sh</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-结束Tomcat进程"><a href="#2-结束Tomcat进程" class="headerlink" title="2). 结束Tomcat进程"></a><strong>2).</strong> 结束Tomcat进程</h5><p>我们可以先通过 ps -ef|grep tomcat 指令查看tomcat进程的信息，从进程信息中获取tomcat</p>
<p>服务的进程号。然后通过kill -9 的形式，来杀死系统进程。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">kill -9 79947</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-4-安装MySQL"><a href="#1-4-安装MySQL" class="headerlink" title="1.4 安装MySQL"></a>1.4 安装MySQL</h2><p><strong>1.4.1 MySQL****安装</strong></p>
<p>对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了</p>
<p>解一下什么rpm？</p>
<p><strong>RPM****：</strong>全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安</p>
<p>装软件的工具。</p>
<p>我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下：</p>
<p><strong>1).</strong> <strong>检测当前系统是否安装过<strong><strong>MySQL</strong></strong>相关数据库</strong></p>
<p>需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">rpm -qa 查询当前系统中安装的所有软件 </span><br><span class="line">rpm -qa | grep mysql 查询当前系统中安装的名称带mysql的软件 </span><br><span class="line">rpm -qa | grep mariadb 查询当前系统中安装的名称带mariadb的软件</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2).</strong> <strong>卸载现有的<strong><strong>MySQL</strong></strong>数据库</strong></p>
<p>在rpm中，卸载软件的语法为</p>
<p>那么，我们就可以通过指令，卸载 mariadb，具体指令为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64</span><br></pre></td></tr></tbody></table></figure>

<p><img src="C:\Users\13772\Desktop\img\image-20220810231126992.png" alt="image-20220810231126992"></p>
<p>我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。</p>
</body></html>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Liunx项目部署</title>
    <url>/2022/08/11/Liunx%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<html><head></head><body><h2 id="Liunx项目部署"><a href="#Liunx项目部署" class="headerlink" title="Liunx项目部署"></a>Liunx项目部署</h2><h3 id="手动部署项目"><a href="#手动部署项目" class="headerlink" title="手动部署项目"></a>手动部署项目</h3><h5 id="1-在IDEA中开发Springboot并且打jar包"><a href="#1-在IDEA中开发Springboot并且打jar包" class="headerlink" title="1). 在IDEA中开发Springboot并且打jar包"></a><strong>1).</strong> 在IDEA中开发Springboot并且打jar包</h5><p><img src="https://s2.loli.net/2022/08/11/pVD91TygAXvkIHY.png" alt="image-20220811185344874"></p>
<h5 id="2-将jar包上传到Liunx服务器"><a href="#2-将jar包上传到Liunx服务器" class="headerlink" title="2). 将jar包上传到Liunx服务器"></a><strong>2).</strong> 将jar包上传到Liunx服务器</h5><p>通过 rz 指令，将打好的jar包上传至Linux服务器的 /usr/local/app 目录下。 先执行指令创</p>
<p>建app目录</p>
<h5 id="3-启动Springboot程序"><a href="#3-启动Springboot程序" class="headerlink" title="3). 启动Springboot程序"></a><strong>3).</strong> 启动Springboot程序</h5><p>由于我们的项目已经打成jar包上传上来到Linux服务器，我们只需要运行这个jar包项目就启动起来</p>
<p>了，所以只需要执行如下指令即可：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">java -jar helloworld-1.0-SNAPSHOT.jar</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-检查防火墙，确保8080端口没有被防火墙给端掉"><a href="#4-检查防火墙，确保8080端口没有被防火墙给端掉" class="headerlink" title="4). 检查防火墙，确保8080端口没有被防火墙给端掉"></a><strong>4).</strong> 检查防火墙，确保8080端口没有被防火墙给端掉</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></tbody></table></figure>

<p>如果防火墙没有放开8080端口，还需要放开对应的端口号，执行如下指令:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br></pre></td></tr></tbody></table></figure>

<h5 id="5-访问测试"><a href="#5-访问测试" class="headerlink" title="5). 访问测试"></a><strong>5).</strong> 访问测试</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.166.130:8087/backend/page/login/login.html</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-后台运行项目"><a href="#6-后台运行项目" class="headerlink" title="6). 后台运行项目"></a><strong>6).</strong> 后台运行项目</h5><p>当前这个demo工程我们已经部署成功了，并且我们也可以访问项目了。但是这个工程目前是存在问题</p>
<p>的，就是当前我们项目启动的这个窗口被霸屏占用了，如果我们把这个窗口关闭掉(或ctrl+c)，当前</p>
<p>服务也就访问不到了，我们可以试一下。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">nohup java -jar helloworld-1.0-SNAPSHOT.jar &amp;&gt; hello.log &amp;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="基于Shell脚本自动部署"><a href="#基于Shell脚本自动部署" class="headerlink" title="基于Shell脚本自动部署"></a>基于Shell脚本自动部署</h2><p>这个搞一下午了还没搞好，</p>
<p>如何在使用git的时候不用重复输入账号和密码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git config --global credential.helper stor</span><br></pre></td></tr></tbody></table></figure>

<p>输入上面的命令</p>
<p>以上命令会在当前linux机器的 /home/用户名 下新建一个.git-credentials的隐藏文件，把用户名和密码写入这个文件</p>
</body></html>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis安装教程</title>
    <url>/2022/07/21/Redis%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B(windows)/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Redis安装教程"><a href="#Redis安装教程" class="headerlink" title="Redis安装教程"></a>Redis安装教程</h1><p>[安装地址链接](<a href="https://github.com/microsoftarchive/redis/releases">Releases · microsoftarchive/redis (github.com)</a>)</p>
<p><img src="https://s2.loli.net/2022/07/21/b5dmoDWpJIgaKs7.png" alt="image-20220721233543796"></p>
<p>安装好后放在：</p>
<p><img src="https://s2.loli.net/2022/07/21/pqJP1uMBg5TaRDL.png" alt="image-20220721233710217"></p>
<p>启动服务：点开redis-serve.exe 打开客户端点开redis-cli.exe</p>
</body></html>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓7.0以上添加Fiddler证书到系统根证书</title>
    <url>/2022/07/31/OpenSSL%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<html><head></head><body><h1 id="安卓7-0以上添加Fiddler证书到系统根证书（模拟器）"><a href="#安卓7-0以上添加Fiddler证书到系统根证书（模拟器）" class="headerlink" title="安卓7.0以上添加Fiddler证书到系统根证书（模拟器）"></a>安卓7.0以上添加Fiddler证书到系统根证书（模拟器）</h1><p><a href="https://null119.lanzoul.com/iewv205n22ad">安装链接</a></p>
<h2 id="1、cer证书转pem"><a href="#1、cer证书转pem" class="headerlink" title="1、cer证书转pem"></a>1、cer证书转pem</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">openssl x509 -inform der -in FiddlerRoot.cer的目录 -out 同层目录/Fiddler.pem</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2、获取pem证书hash"><a href="#2、获取pem证书hash" class="headerlink" title="2、获取pem证书hash"></a>2、获取pem证书hash</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -in Fiddler.pem</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3、将pem证书改名为hash-0"><a href="#3、将pem证书改名为hash-0" class="headerlink" title="3、将pem证书改名为hash.0"></a>3、将pem证书改名为hash.0</h3><h3 id="4、将证书上传到手机或模拟器"><a href="#4、将证书上传到手机或模拟器" class="headerlink" title="4、将证书上传到手机或模拟器"></a>4、将证书上传到手机或模拟器</h3><p><img src="https://s2.loli.net/2022/07/31/qwbx3ZUteK4ASr8.png" alt="Snipaste_2022-07-31_15-15-25.png"></p>
</body></html>]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis命令大全</title>
    <url>/2022/07/04/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h1><p>本文记录常用的Redis命令 方便以后复习使用</p>
<h3 id="在服务器上使用Redis-命令"><a href="#在服务器上使用Redis-命令" class="headerlink" title="在服务器上使用Redis 命令"></a>在服务器上使用Redis 命令</h3><h4 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">$redis<span class="operator">-</span>cli</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> PING</span><br><span class="line"> </span><br><span class="line">PONG</span><br></pre></td></tr></tbody></table></figure>

<h4 id="远程使用"><a href="#远程使用" class="headerlink" title="远程使用"></a>远程使用</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$redis-cli -h 127.0.0.1 -p 6379 -a "mypass"</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line"> </span><br><span class="line">PONG</span><br></pre></td></tr></tbody></table></figure>

<h3 id="字符串常用命令"><a href="#字符串常用命令" class="headerlink" title="字符串常用命令"></a>字符串常用命令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SET key value #设置一个key-value 键值对</span><br><span class="line">GET key #获取key对应的value</span><br><span class="line">SETEX key seconds value #设置key的有效时间指向value</span><br><span class="line">SETNX KEY VALUE #在key不存在时 才会设置VALUE</span><br></pre></td></tr></tbody></table></figure>

<h4 id="String在Redis中所需要的常识"><a href="#String在Redis中所需要的常识" class="headerlink" title="String在Redis中所需要的常识"></a>String在Redis中所需要的常识</h4><ol>
<li>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</li>
<li>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</li>
<li>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</li>
</ol>
<h4 id="实列"><a href="#实列" class="headerlink" title="实列"></a>实列</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">SET</span> name "redis.net.cn"</span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">GET</span> name</span><br><span class="line">"redis.net.cn"</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Redis-keys命令"><a href="#Redis-keys命令" class="headerlink" title="Redis keys命令"></a>Redis keys命令</h3><ol>
<li><a href="https://www.redis.net.cn/order/3528.html">DEL key</a> 该命令用于在 key 存在是删除 key</li>
<li><a href="https://www.redis.net.cn/order/3530.html">EXISTS key</a> 检查给定 key 是否存在</li>
<li><a href="https://www.redis.net.cn/order/3531.html">EXPIRE key</a> seconds 为给定 key 设置过期时间。</li>
<li><a href="https://www.redis.net.cn/order/3536.html">MOVE key db</a> 将当前数据库的 key 移动到给定的数据库 db 当中。</li>
</ol>
<h3 id="Redis-集合"><a href="#Redis-集合" class="headerlink" title="Redis 集合"></a>Redis 集合</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS w3ckey</span><br><span class="line"> </span><br><span class="line">1) "mysql"</span><br><span class="line">2) "mongodb"</span><br><span class="line">3) "redis"</span><br></pre></td></tr></tbody></table></figure>

<p>在以上实例中我们通过 <strong>SADD</strong> 命令向名为 w3ckey 的集合插入的三个元素。</p>
<h3 id="Redis-哈希"><a href="#Redis-哈希" class="headerlink" title="Redis 哈希"></a>Redis 哈希</h3><h4 id="实列-1"><a href="#实列-1" class="headerlink" title="实列"></a>实列</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; HMSET w3ckey name "redis tutorial" description "redis basic commands for caching" likes 20 visitors 23000</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; HGETALL w3ckey</span><br><span class="line"> </span><br><span class="line">1) "name"</span><br><span class="line">2) "redis tutorial"</span><br><span class="line">3) "description"</span><br><span class="line">4) "redis basic commands for caching"</span><br><span class="line">5) "likes"</span><br><span class="line">6) "20"</span><br><span class="line">7) "visitors"</span><br><span class="line">8) "23000"</span><br></pre></td></tr></tbody></table></figure>

<p>在以上实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 w3ckey 中</p>
<h4 id="哈希命令"><a href="#哈希命令" class="headerlink" title="哈希命令"></a>哈希命令</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.HDEL key field2 [field2] 删除一个或多个哈希表字段</span><br><span class="line">2.HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。</span><br><span class="line">3.HGET key field 获取存储在哈希表中指定字段的值</span><br><span class="line">4.HGETALL key 获取在哈希表中指定 key 的所有字段和值</span><br><span class="line">7.HKEYS key 获取所有哈希表中的字段</span><br><span class="line">8.HLEN key 获取哈希表中字段的数量</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Redis-列表"><a href="#Redis-列表" class="headerlink" title="Redis 列表"></a>Redis 列表</h3><h4 id="实列-2"><a href="#实列-2" class="headerlink" title="实列"></a>实列</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; LPUSH w3ckey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH w3ckey mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH w3ckey mysql</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE w3ckey 0 10</span><br><span class="line"> </span><br><span class="line">1) "mysql"</span><br><span class="line">2) "mongodb"</span><br><span class="line">3) "redis"</span><br></pre></td></tr></tbody></table></figure>

<p>在以上实例中我们使用了 <strong>LPUSH</strong> 将三个值插入了名为 w3ckey 的列表当中。</p>
<p>列表命令：</p>
<ol>
<li><a href="https://www.redis.net.cn/order/3582.html">LLEN key</a> 获取列表长度</li>
<li><a href="https://www.redis.net.cn/order/3583.html">LPOP key</a> 移出并获取列表的第一个元素</li>
<li><a href="https://www.redis.net.cn/order/3586.html">LRANGE key start stop</a> 获取列表指定范围内的元素</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>caj文件转pdf安装教程</title>
    <url>/2022/09/05/caj%E6%96%87%E4%BB%B6%E8%BD%ACpdf%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<html><head></head><body><h1 id="caj文件转pdf安装教程"><a href="#caj文件转pdf安装教程" class="headerlink" title="caj文件转pdf安装教程"></a>caj文件转pdf安装教程</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机:"></a>动机:</h2><p>最近需要看论文，在知网下载的时候是caj类型的文件，windows里面的软件都打不开，用notepad++打开会是乱码的现象，所以需要一个工具来进行转换</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h2><p><a href="https://github.com/sainnhe/caj2pdf-qt/releases/download/v0.1.4/caj2pdf-qt-windows-x86_64-0.1.4.zip">下载地址</a></p>
<p>安装好zip文件后直接解压就行</p>
<p>点开caj2pdf.exe就行</p>
<p><img src="https://s2.loli.net/2022/09/05/yPozEOXfbeLAYUI.png" alt="image-20220905092352989.png"></p>
</body></html>]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>SMMS照片下载至压缩包</title>
    <url>/2022/08/02/SMMS%E7%85%A7%E7%89%87%E4%B8%8B%E8%BD%BD%E8%87%B3%E5%8E%8B%E7%BC%A9%E5%8C%85/</url>
    <content><![CDATA[<html><head></head><body><h1 id="SMMS照片下载至压缩包"><a href="#SMMS照片下载至压缩包" class="headerlink" title="SMMS照片下载至压缩包"></a>SMMS照片下载至压缩包</h1><p>进入下面的地址</p>
<p><img src="https://s2.loli.net/2022/08/02/TgvbkMdXDUpWPqw.png" alt="image-20220802090045671"></p>
<p>按F12，打开调式器，在控制台输入以下代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @?: *********************************************************************</span><br><span class="line"> * @Author: Weidows</span><br><span class="line"> * @Date: 2021-07-07 20:30:59</span><br><span class="line"> * @LastEditors: Weidows</span><br><span class="line"> * @LastEditTime: 2021-07-09 00:05:15</span><br><span class="line"> * @FilePath: \awesome-image-collector\implements\SM.MS-collector.js</span><br><span class="line"> * @Description:</span><br><span class="line"> * @!: *********************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">(async () =&gt; {</span><br><span class="line">  // 引入库函数</span><br><span class="line">  const jsZip = document.createElement("script"),</span><br><span class="line">    collector = document.createElement("script");</span><br><span class="line">  jsZip.src = "https://cdn.bootcdn.net/ajax/libs/jszip/3.5.0/jszip.min.js";</span><br><span class="line">  collector.src =</span><br><span class="line">    "https://cdn.jsdelivr.net/gh/Weidows-projects/awesome-image-collector@master/dist/collector.min.js";</span><br><span class="line">  document</span><br><span class="line">    .getElementsByTagName("head")[0]</span><br><span class="line">    .appendChild(jsZip)</span><br><span class="line">    .appendChild(collector);</span><br><span class="line"></span><br><span class="line">  await Promise.all([</span><br><span class="line">    new Promise(resolve =&gt; jsZip.onload = () =&gt; window.JSZip &amp;&amp; resolve()),</span><br><span class="line">    new Promise(resolve =&gt; collector.onload = () =&gt; window.start &amp;&amp; resolve()),</span><br><span class="line">  ]);</span><br><span class="line">  smmsCollector();</span><br><span class="line">})();</span><br><span class="line"></span><br><span class="line">// ======================== 添加样式 ========================</span><br><span class="line">function smmsCollector() {</span><br><span class="line">  // 下载图片按钮 (不主动下载,按按钮时才下载)</span><br><span class="line">  let downloadButton = document.createElement("button");</span><br><span class="line">  downloadButton.type = "button";</span><br><span class="line">  downloadButton.innerText = "下载本页面图片";</span><br><span class="line">  downloadButton.style.width = "100%";</span><br><span class="line">  downloadButton.addEventListener("click", function () {</span><br><span class="line">    // 调用入口函数</span><br><span class="line">    start(document.getElementsByClassName("fancybox"));</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  // 全选CheckBox按钮</span><br><span class="line">  let deleteButton = document.createElement("button");</span><br><span class="line">  deleteButton.type = "button";</span><br><span class="line">  deleteButton.innerHTML = "全选CheckBox按钮";</span><br><span class="line">  deleteButton.style.width = "100%";</span><br><span class="line">  deleteButton.addEventListener("click", function () {</span><br><span class="line">    let checkBoxes = document.getElementsByClassName("filedelete");</span><br><span class="line">    for (const checkbox of checkBoxes) {</span><br><span class="line">      checkbox.checked = !checkbox.checked;</span><br><span class="line">    }</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  // 创建标签</span><br><span class="line">  let downloadLi = document.createElement("li");</span><br><span class="line">  let deleteLi = document.createElement("li");</span><br><span class="line">  downloadLi.id = "downloader";</span><br><span class="line">  deleteLi.id = "deleter";</span><br><span class="line">  downloadLi.appendChild(downloadButton);</span><br><span class="line">  deleteLi.appendChild(deleteButton);</span><br><span class="line"></span><br><span class="line">  // 追加标签</span><br><span class="line">  if (document.getElementById("downloader") == null) {</span><br><span class="line">    document</span><br><span class="line">      .getElementsByClassName("sidebar-menu tree")[0]</span><br><span class="line">      .appendChild(downloadLi);</span><br><span class="line">    document</span><br><span class="line">      .getElementsByClassName("sidebar-menu tree")[0]</span><br><span class="line">      .appendChild(deleteLi);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>此时页面显示：</p>
<p><img src="https://s2.loli.net/2022/08/02/eWQDy4ldmNXxzvb.png" alt="image-20220802090338705"></p>
<p>就可以了</p>
</body></html>]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/06/22/hello-world/</url>
    <content><![CDATA[<html><head></head><body><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<p>thanks for your listenning</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</body></html>]]></content>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2022/07/23/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol>
<li>安装Git</li>
<li>安装Node.js</li>
<li>安装Hexo</li>
<li>GitHub创建个人仓库</li>
<li>生成SSH添加到GitHub</li>
<li>将hexo部署到GitHub</li>
<li>设置个人域名</li>
<li>发布文章</li>
</ol>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）选择 Git Bash Here，然后依次输入如下命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># hexo框架的安装</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>

<p>依旧用<code>hexo -v</code>查看一下版本</p>
<p>至此就全部安装完了。</p>
<p>接下来初始化一下hexo</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cd myblog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></tbody></table></figure>

<p>新建完成后，指定文件夹目录下有：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li>** _config.yml: 博客的配置文件**</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure>

<h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>首先，你先要有一个GitHub账户，去注册一个吧。</p>
<p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库</p>
<p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。</p>
<p>点击create repository。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d002150a2eb02a0358d1c88199e4e726.png" alt="img"></p>
<h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></tbody></table></figure>


<p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure>


<p>然后</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure>


<p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p>
<p>注意deploy时可能要你输入username和password。</p>
<h3 id="安装butterfly主题"><a href="#安装butterfly主题" class="headerlink" title="安装butterfly主题"></a>安装butterfly主题</h3><p>在你的 Hexo 根目录里</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br></pre></td></tr></tbody></table></figure>

<p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></tbody></table></figure>

<p>在 hexo 的根目录创建一个文件，并把主题目录的内容复制到 去。 （ 注意： 复制的是主题的 _config.yml ，而不是 hexo 的 _config.yml_config.butterfly.yml_config.yml_config.butterfly.yml)</p>
<p>注意： 不要把主题目录的 删掉_config.yml</p>
</body></html>]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>leancloud失效解决方案</title>
    <url>/2022/08/03/leancloud%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<html><head></head><body><h1 id="leancloud失效解决方案"><a href="#leancloud失效解决方案" class="headerlink" title="leancloud失效解决方案"></a>leancloud失效解决方案</h1><h2 id="1-点击LeanCloud设置"><a href="#1-点击LeanCloud设置" class="headerlink" title="1.点击LeanCloud设置"></a>1.点击LeanCloud设置</h2><p>进入到域名绑定后，点击Api访问域名，输入域名</p>
<p>域名解析：xxx.cherlyonly.cn 后面两个是小姐姐的已经备案好的域名 前面xxx涉随便你怎么写</p>
<p>然后将CNAME复制提交给她 </p>
<p><img src="https://s1.328888.xyz/2022/08/03/OUPRB.png" alt="image-20220803123606916"></p>
<h2 id="2-进入到主题配置文件"><a href="#2-进入到主题配置文件" class="headerlink" title="2.进入到主题配置文件"></a>2.进入到主题配置文件</h2><p>将ServerURL替换掉</p>
<p><img src="https://s1.328888.xyz/2022/08/03/OU8VP.png" alt="image-20220803123757028"></p>
<h2 id="3-修改CDN下的third-party-provider"><a href="#3-修改CDN下的third-party-provider" class="headerlink" title="3.修改CDN下的third_party_provider"></a>3.修改CDN下的third_party_provider</h2><p><img src="https://s1.328888.xyz/2022/08/03/OUg6R.png" alt="image-20220803124036256"></p>
</body></html>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_大众闲谈</title>
    <url>/2022/08/22/python-%20%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84/</url>
    <content><![CDATA[<html><head></head><body><h1 id="大众闲谈"><a href="#大众闲谈" class="headerlink" title="大众闲谈"></a>大众闲谈</h1><p>先知：评论的数据目前没有采集，要采集也能实现。</p>
<h2 id="打开开发者工具找到加密字体"><a href="#打开开发者工具找到加密字体" class="headerlink" title="打开开发者工具找到加密字体"></a>打开开发者工具找到加密字体</h2><p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220822232904562.png" alt="image-20220822232904562"></p>
<p>再去找到这个字体的font-family</p>
<p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220822233048352.png" alt="image-20220822233048352"></p>
<p>把鼠标放到css结尾的链接上面，你可以看到，这个链接</p>
<p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220822233311427.png" alt="image-20220822233311427"></p>
<p>通过这个链接下载这个woff字体文件并且保存到同层文件夹</p>
<h2 id="分析Html文件"><a href="#分析Html文件" class="headerlink" title="分析Html文件"></a>分析Html文件</h2><p>Html文件head标签里面会有链接，通过正则表达式提取出来，前面加上http通过request模块把它下载到本地</p>
<p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220822235316175.png" alt="image-20220822235316175"></p>
<h2 id="name-amp-amp-id-amp-amp-class"><a href="#name-amp-amp-id-amp-amp-class" class="headerlink" title="name&amp;&amp;id&amp;&amp;class"></a>name&amp;&amp;id&amp;&amp;class</h2><p>通过字典的关系实现相互映射(font.xml文件)，最后通过正则表达式替换源码中的加密字体</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 替换列表页面的字体反爬内容</span></span><br><span class="line">sub_old = <span class="string">'&lt;d class="num"&gt;&amp;#{};&lt;'</span>.<span class="built_in">format</span>(info)</span><br><span class="line">sub_new = <span class="string">'&lt;d class="num"&gt;{}&lt;'</span>.<span class="built_in">format</span>(v)</span><br><span class="line">self.list_html = re.sub(sub_old, sub_new, self.list_html)</span><br></pre></td></tr></tbody></table></figure>

<p>最后就是常规的提取了，就这么简单，需要源码私信我</p>
<h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220823000440773.png" alt="image-20220823000440773"></p>
</body></html>]]></content>
      <categories>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>Python模块</title>
    <url>/2022/08/01/python%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Python模块"><a href="#Python模块" class="headerlink" title="Python模块"></a>Python模块</h1><h2 id="为什么需要模块？"><a href="#为什么需要模块？" class="headerlink" title="为什么需要模块？"></a>为什么需要模块？</h2><p>大多数应用项目往往具有功能要求多、性能要求高的特点，由此导致的结果是使得程序代码复杂而且庞大。当程序代码多达几百行、几千行甚至上万行时，为了加快开发进度、提高开发效率，需要团队协作、分工合作开发程序。如果缺少有效的组织方式，那么不仅使得协同开发难以做到，而且程序的调试将变得异常艰难，后期的维护和升级更加困难重重。这时候就需要模块化。</p>
<h2 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h2><h3 id="1-大模块"><a href="#1-大模块" class="headerlink" title="1.大模块"></a>1.大模块</h3><p>大模块即“包（Package）”。<br>一个相对大型的程序通常包含多个文件，按照功能相近的原则，可将这些文件分组，每组包含若干个文件，每个组常被称为“包”。每个“包”即所谓的“大模块”。</p>
<h3 id="2-中模块"><a href="#2-中模块" class="headerlink" title="2.中模块"></a>2.中模块</h3><p>中模块即一个文件。<br>为了提高代码的可维护性，可将项目中的所有自定义函数进行归类分组，以文件形式组织同类函数，因此，每个文件的功能相对单一，每个文件包含的代码相对较少。这对项目管理和代码的重复利用十分有利。多数计算机语言均支持类似的组织代码方式，Python也不例外。在Python中，一个.py文件常被称为一个模块（Module）</p>
<h3 id="3-小模块"><a href="#3-小模块" class="headerlink" title="3.小模块"></a>3.小模块</h3><p>模块即一个函数。<br>函数也是模块化设计的产物，通过函数实现程序功能是模块化设计思想的一种很好的体现。一个模块文件通常是由若干个函数或类组成的。</p>
<h2 id="关于模块的几个概念"><a href="#关于模块的几个概念" class="headerlink" title="关于模块的几个概念"></a>关于模块的几个概念</h2><p>模块具有层次性，因此模块又可被分为内置函数、内置模块、第三方模块和自定义模块。<br>内置函数是Python的标准函数，可被直接调用。<br>内置模块是Python的标准库，必须通过import语句引用后才可使用。内置模块文件默认安装在Python的“安装路径\Python\PythonXXX\lib”下，即安装在lib文件夹下。<br>第三方模块是指由第三方开发的、实现各种特定功能的模块，又被称为“第三方库”。数量众多的第三方库是Python优越性的重要体现。<br>自定义模块是指由开发者自行设计的模块</p>
<h2 id="关于模块测试"><a href="#关于模块测试" class="headerlink" title="关于模块测试"></a>关于模块测试</h2><p>由if语句组织相关的测试代码，它的工作原理是：当运行模块文件本身时，Python解释器将特殊变量（内置全局变量）<strong>name__的值置为字符串__main__，因此__name</strong>==’<strong>main</strong>‘成立；如果该模块被其他程序所引用，那么__name__的值会被置为引用它的程序文件名（不包括.py），此时，<strong>name</strong>==’<strong>main</strong>‘不再成立，所以测试语句块不会被执行。因此，模块中的测试代码只用于测试模块本身的正确性，不会对引用它的模块造成影响。</p>
<h2 id="引入模块的四种方式"><a href="#引入模块的四种方式" class="headerlink" title="引入模块的四种方式"></a>引入模块的四种方式</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>引用一个名为fibonacci的模块，该模块的文件名为fibonacci.py。<br>再如：<br>上述语句引用3个名为fibonacci、geometric、arithmetic的模块，3个模块对应的文件名为fibonacci.py、geometric.py和arithmetic.py。<br>由此可见，import可一次性导入多个模块，模块之间必须以“,”隔开。</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>形式如下：<br>由于别名往往比较简洁，因而引用模块中的对象和方法更加便捷。当采用此方式引用模块中的对象或方法时，必须使用别名。</p>
<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>引用模块的第三种方式<br>形式如下：<br>从模块中导入指定的函数、变量或类，可对导入的对象或方法（函数）指定别名以简化引用</p>
<p>在这种方式下，引用模块中的对象或方法（函数）的形式必须是“模块.对象或方法的别名”，例如，geometric.geo1(2,3,6)。</p>
<h3 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h3><p>导入模块中的所有对象和方法（函数）。“*”被称为“通配符”，意为全部、所有。<br>虽然方式四可一次性导入模块中的所有对象和方法（函数），但是通常不建议这么做，因为它极有可能引起命名冲突（Name Conflict），即该模块中的对象名或函数名与被导入的其他模块中的对象名或函数名重名，从而导致冲突。</p>
<h2 id="模块是如何被找到并引用的"><a href="#模块是如何被找到并引用的" class="headerlink" title="模块是如何被找到并引用的"></a>模块是如何被找到并引用的</h2><p>sys.path通常由以下几部分组成：<br>（1）脚本文件所在的路径，即当前路径。<br>（2）PYTHONPATH系统变量设定的路径。<br>（3）默认安装路径。</p>
<h3 id="动态修改sys-path"><a href="#动态修改sys-path" class="headerlink" title="动态修改sys.path"></a>动态修改sys.path</h3><p>通过sys.path.append(‘路径’)添加所需路径，它属于一种动态修改sys.path的方法。所谓“动态”，是指程序退出后，将删除添加的路径信息，恢复sys.path的内容</p>
<h3 id="静态修改sys-path"><a href="#静态修改sys-path" class="headerlink" title="静态修改sys.path"></a>静态修改sys.path</h3><p>可通过以下两种方式静态修改sys.path：<br>· 在系统环境变量中新建变量PYTHONPATH，然后添加所需路径，即PYTHONPATH =e:\myprj。<br>· 直接在Path系统环境变量中添加所需路径，即Path=[各种路径]; e:\myprj，或者Path=%PATH%; e:\myprj。前者表示在现有各种路径后添加所需路径，后者表示在Path变量现有值的基础上添加一项新的内容e:\myprj。上述两种方法均以“;”作为分隔符。<br>通过静态修改法添加的路径是静态的，永久有效</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="同级目录文件"><a href="#同级目录文件" class="headerlink" title="同级目录文件"></a>同级目录文件</h3><p>目录结构：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">|-- love.py</span><br><span class="line">|-- me.py</span><br></pre></td></tr></tbody></table></figure>

<p>me中引用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import love</span><br><span class="line">love.min()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="子级目录文件"><a href="#子级目录文件" class="headerlink" title="子级目录文件"></a>子级目录文件</h3><p>目录结构：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">|-- yep</span><br><span class="line">	--fuck</span><br><span class="line">|-- me.py</span><br></pre></td></tr></tbody></table></figure>

<p>me中引用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">from yep import fuck</span><br><span class="line">fuck.fuckyou()</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python存储csv文件</title>
    <url>/2022/08/03/python%E5%AD%98%E5%82%A8csv%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<html><head></head><body><h1 id="python存储csv文件"><a href="#python存储csv文件" class="headerlink" title="python存储csv文件"></a>python存储csv文件</h1><p>源代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line">headers = ["username","age","height"]</span><br><span class="line">values = [("张三","18","180"),("李四","19","190"),("王五","18","160")]</span><br><span class="line">def csv_1():</span><br><span class="line">    headers = ["username", "age", "height"]</span><br><span class="line">    values = [("张三", "18", "180"), ("李四", "19", "190"), ("王五", "18", "160")]</span><br><span class="line">    with open("classroom1.csv","w",encoding="utf-8",newline="") as fp:</span><br><span class="line">        new_fp = csv.writer(fp)</span><br><span class="line">        new_fp.writerow(headers)</span><br><span class="line">        new_fp.writerows(values)</span><br><span class="line"></span><br><span class="line">def csv_2():</span><br><span class="line">    headers = ["username", "age", "height"]</span><br><span class="line">    values = [{"username":"张三","age":"18","height":"180"},{"username":"李四","age":"19","height":"190"},{"username":"王五","age":"18","height":"160"}]</span><br><span class="line">    with open("classroom2.csv","w",encoding="utf-8",newline="") as fp:</span><br><span class="line">        writer = csv.DictWriter(fp,headers)</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        writer.writerows(values)</span><br><span class="line">if __name__ == '__main__':</span><br><span class="line">    # csv_1()</span><br><span class="line">    csv_2()</span><br></pre></td></tr></tbody></table></figure>

<p>csv2长这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">username,age,height</span><br><span class="line">张三,18,180</span><br><span class="line">李四,19,190</span><br><span class="line">王五,18,160</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据可视化大屏</title>
    <url>/2022/08/16/python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F_%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<html><head></head><body><h1 id="数据大屏可视化"><a href="#数据大屏可视化" class="headerlink" title="数据大屏可视化"></a>数据大屏可视化</h1><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>便利性工具, 结构简单, 直接传数据就可以实现数据大屏</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple flask</span><br></pre></td></tr></tbody></table></figure>

<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cd big_screen;</span><br><span class="line">python app.py;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>大数据可视化展板通用模板 <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a></li>
<li>4600 万企业数据大屏可视化 <a href="http://127.0.0.1:5000/corp">http://127.0.0.1:5000/corp</a></li>
<li>(2020-09) 厦门 10 万招聘数据大屏可视化 <a href="http://127.0.0.1:5000/job">http://127.0.0.1:5000/job</a></li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="https://s2.loli.net/2022/08/17/dxZPswcq9oRnUSH.png" alt="image-20220816234523123.png"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li>1、编辑 data.py 中的 SourceData 类（或者新增类，新增的话需要编辑 app.py 增加路由，请参考 CorpData/JobData）</li>
<li>2、从任何地方读取你的数据，按照 SourceDataDemo 的数据格式，填充到 SourceData 类</li>
<li>3、运行 python app.py 查看数据变更后的效果</li>
</ul>
<h1 id="源码链接地址"><a href="#源码链接地址" class="headerlink" title="源码链接地址"></a>源码链接地址</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/1qiqiqi/dataVisual</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件基础</title>
    <url>/2022/08/03/python%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<html><head></head><body><h1 id="python数据预处理"><a href="#python数据预处理" class="headerlink" title="python数据预处理"></a>python数据预处理</h1><p>user_profile.csv:  这个文件太大 就复制少一点</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">,userid,cms_segid,cms_group_id,final_gender_code,age_level,pvalue_level,occupation,new_user_class_level </span><br><span class="line">0,234,0,5,2,5,,0,3.0</span><br><span class="line">1,523,5,2,2,2,1.0,1,2.0</span><br><span class="line">2,612,0,8,1,2,2.0,0,</span><br><span class="line">3,1670,0,4,2,4,,0,</span><br><span class="line">4,2545,0,10,1,4,,0,</span><br><span class="line">5,3644,49,6,2,6,2.0,0,2.0</span><br><span class="line">6,5777,44,5,2,5,2.0,0,2.0</span><br><span class="line">7,6211,0,9,1,3,,0,2.0</span><br><span class="line">8,6355,2,1,2,1,1.0,0,4.0</span><br><span class="line">9,6823,43,5,2,5,2.0,0,1.0</span><br><span class="line">10,6972,5,2,2,2,2.0,1,2.0</span><br><span class="line">11,9293,0,5,2,5,,0,4.0</span><br><span class="line">12,9510,55,8,1,2,2.0,0,2.0</span><br><span class="line">13,10122,33,4,2,4,2.0,0,2.0</span><br><span class="line">14,10549,0,4,2,4,2.0,0,</span><br><span class="line">15,10812,0,4,2,4,,0,</span><br><span class="line">16,10912,0,4,2,4,2.0,0,</span><br><span class="line">17,10996,0,5,2,5,,0,4.0</span><br><span class="line">18,11256,8,2,2,2,1.0,0,3.0</span><br><span class="line">19,11310,31,4,2,4,1.0,0,4.0</span><br></pre></td></tr></tbody></table></figure>

<p>ads_sample.csv：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">,user_id,adgroup_id,pid,nonclk,clk,date</span><br><span class="line">0,581738,1,430548_1007,1,0,2021-03-07 14:14:04</span><br><span class="line">1,449818,3,430548_1007,1,0,2021-03-13 09:26:18</span><br><span class="line">2,914836,4,430548_1007,1,0,2021-03-13 12:47:59</span><br><span class="line">3,914836,5,430548_1007,1,0,2021-03-13 12:50:29</span><br><span class="line">4,399907,8,430548_1007,1,0,2021-03-09 12:09:18</span><br><span class="line">5,628137,9,430548_1007,1,0,2021-03-12 01:48:55</span><br><span class="line">6,298139,9,430539_1007,1,0,2021-03-11 08:29:53</span><br><span class="line">7,775475,9,430548_1007,1,0,2021-03-12 11:50:36</span><br><span class="line">8,555266,11,430539_1007,1,0,2021-03-09 13:18:56</span><br><span class="line">9,117840,11,430548_1007,1,0,2021-03-06 10:12:23</span><br><span class="line">10,739815,11,430539_1007,1,0,2021-03-07 08:03:07</span><br><span class="line">11,623911,11,430548_1007,1,0,2021-03-13 05:41:41</span><br><span class="line">12,623911,11,430548_1007,1,0,2021-03-11 05:26:48</span><br><span class="line">13,421590,11,430548_1007,1,0,2021-03-06 09:29:04</span><br><span class="line">14,976358,13,430548_1007,1,0,2021-03-07 19:35:49</span><br><span class="line">15,286630,13,430539_1007,1,0,2021-03-08 12:42:59</span><br><span class="line">16,286630,13,430539_1007,1,0,2021-03-09 08:20:47</span><br><span class="line">17,771431,13,430548_1007,1,0,2021-03-07 18:44:27</span><br></pre></td></tr></tbody></table></figure>

<p>在做数据分析处理时要用到的一系列操作</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proProcess</span>(<span class="params">filename1,filename2</span>):</span><br><span class="line">     <span class="comment">#加载文件</span></span><br><span class="line">     df1 = pd.read_csv(filename1)</span><br><span class="line">     <span class="comment"># df = pd.DataFrame(data,columns=title,dtype=float)</span></span><br><span class="line">     <span class="comment"># title = ['data', 'feature_names']</span></span><br><span class="line">     <span class="comment"># a = [['2015年', 137462.0],</span></span><br><span class="line">     <span class="comment">#      ['2015年', 137462.0],</span></span><br><span class="line">     <span class="comment">#      [nan, nan],</span></span><br><span class="line">     <span class="comment">#      [nan, nan]]</span></span><br><span class="line">     <span class="comment">#去重</span></span><br><span class="line">     df1 = df1.drop_duplicates()</span><br><span class="line">     <span class="comment">#去除缺失值</span></span><br><span class="line">     df1 = df1.dropna()</span><br><span class="line">     <span class="comment"># 去重</span></span><br><span class="line">     df1 = df1.drop_duplicates()</span><br><span class="line">     <span class="comment"># 去除缺失值</span></span><br><span class="line">     df1 = df1.dropna()</span><br><span class="line"></span><br><span class="line">     <span class="comment">#填补数值</span></span><br><span class="line">     <span class="comment"># df = df.Age.fillna(df.Age.mean())</span></span><br><span class="line">     <span class="built_in">print</span>(df1)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 加载文件</span></span><br><span class="line">     df2 = pd.read_csv(filename2)</span><br><span class="line">     <span class="comment"># df = pd.DataFrame(data,columns=title,dtype=float)</span></span><br><span class="line">     <span class="comment"># title = ['data', 'feature_names']</span></span><br><span class="line">     <span class="comment"># a = [['2015年', 137462.0],</span></span><br><span class="line">     <span class="comment">#      ['2015年', 137462.0],</span></span><br><span class="line">     <span class="comment">#      [nan, nan],</span></span><br><span class="line">     <span class="comment">#      [nan, nan]]</span></span><br><span class="line">     <span class="comment"># 去重</span></span><br><span class="line">     df2 = df2.drop_duplicates()</span><br><span class="line">     <span class="comment"># 去除缺失值</span></span><br><span class="line">     df2 = df2.dropna()</span><br><span class="line">     <span class="comment"># 去重</span></span><br><span class="line">     df2 = df2.drop_duplicates()</span><br><span class="line">     <span class="comment"># 去除缺失值</span></span><br><span class="line">     df2 = df2.dropna()</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 填补数值</span></span><br><span class="line">     <span class="comment"># df = df.Age.fillna(df.Age.mean())</span></span><br><span class="line">     <span class="built_in">print</span>(df2)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     <span class="comment"># data = [['Google', 10], ['Runoob', 12], ['Wiki', 13], [nan, nan], ['Wiki', 13]]</span></span><br><span class="line">     <span class="comment"># title = ['Site', 'Age']</span></span><br><span class="line">     filename1 = <span class="string">'user_profile.csv'</span></span><br><span class="line">     filename2 = <span class="string">'ads_sample.csv'</span></span><br><span class="line">     proProcess(filename1,filename2)</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件基础</title>
    <url>/2022/08/01/python%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Python文件基础"><a href="#Python文件基础" class="headerlink" title="Python文件基础"></a>Python文件基础</h1><h2 id="关于文件的几点注意事项"><a href="#关于文件的几点注意事项" class="headerlink" title="关于文件的几点注意事项"></a>关于文件的几点注意事项</h2><h3 id="1-文件对象属性"><a href="#1-文件对象属性" class="headerlink" title="1.文件对象属性"></a>1.文件对象属性</h3><p>打开一个文件后，得到一个文件对象fp，通过它可以获得与该文件相关的各种信息。以下是与文件对象相关的所有属性。<br>· fp.closed：如果文件已被关闭，则返回True；否则返回False。<br>· fp.mode：打开文件的模式。<br>· fp.name：得到已被打开的文件的文件名。</p>
<h3 id="2-列表中出现字符串“-ufeff”及其解决方案"><a href="#2-列表中出现字符串“-ufeff”及其解决方案" class="headerlink" title="2.列表中出现字符串“\ufeff”及其解决方案"></a>2.列表中出现字符串“\ufeff”及其解决方案</h3><p>举例36：\ufeff问题及其解决办法。<br>上述程序打开一个示例文件，但从结果中发现，在读取的内容中出现了\ufeff，而真正的文件内容是从“你好”开始的。<br>解决办法如下：<br>从上述改进后的程序中可以看出，解决\ufeff问题的关键在于通过utf-8-sig编码格式对字符串进行转码：decode(‘utf-8-sig’)。<br>由此得到启发，如果在打开文件时直接采用utf-8-sig编码格式，那么能不能解决这个乱码问题？答案是令人惊喜的，请看：<br>真的解决了！这是为什么呢？<br>实际上，需要从以下两种编码格式的本质加以阐述。<br>（1）UTF-8编码。它以字节为编码单元，字节顺序在所有系统中都相同，不存在字节序的问题，因此它并不需要字节序标记（Byte Order Mark，BOM）。<br>（2）utf-8-sig编码。<strong>它是一种带BOM的UTF-8编码格式</strong>，存在字节序的问题，必须带BOM以标识字节序，而BOM即字符U+FEFF。<strong>从Unicode 3.2开始，U+FEFF只能出现在字节流的开头</strong>，只能用于标识字节序。由此可知，列表中的字符串“\ufeff”并不是乱码，而是由于编码格式不一致才出现的。</p>
<h2 id="利用Pygal模块对JSON格式的数据进行可视化"><a href="#利用Pygal模块对JSON格式的数据进行可视化" class="headerlink" title="利用Pygal模块对JSON格式的数据进行可视化"></a>利用Pygal模块对JSON格式的数据进行可视化</h2><p>[参考文档](<a href="https://zhuanlan.zhihu.com/p/341450079">Pygal，可导出矢量图的Python可视化利器 - 知乎 (zhihu.com)</a>)</p>
<h3 id="安装并导入Pygal"><a href="#安装并导入Pygal" class="headerlink" title="安装并导入Pygal"></a>安装并导入Pygal</h3><p>使用pip或者conda进行安装，在命令行输入：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">pip install pygal</span><br></pre></td></tr></tbody></table></figure>

<h3 id="雷达图"><a href="#雷达图" class="headerlink" title="雷达图"></a>雷达图</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">radar_chart = pygal.Radar()</span><br><span class="line">radar_chart.title = <span class="string">'V8 benchmark results'</span></span><br><span class="line">radar_chart.x_labels = [<span class="string">'Richards'</span>, <span class="string">'DeltaBlue'</span>, <span class="string">'Crypto'</span>, <span class="string">'RayTrace'</span>, <span class="string">'EarleyBoyer'</span>, <span class="string">'RegExp'</span>, <span class="string">'Splay'</span>, <span class="string">'NavierStokes'</span>]</span><br><span class="line">radar_chart.add(<span class="string">'Chrome'</span>, [<span class="number">6395</span>, <span class="number">8212</span>, <span class="number">7520</span>, <span class="number">7218</span>, <span class="number">12464</span>, <span class="number">1660</span>, <span class="number">2123</span>, <span class="number">8607</span>])</span><br><span class="line">radar_chart.add(<span class="string">'Firefox'</span>, [<span class="number">7473</span>, <span class="number">8099</span>, <span class="number">11700</span>, <span class="number">2651</span>, <span class="number">6361</span>, <span class="number">1044</span>, <span class="number">3797</span>, <span class="number">9450</span>])</span><br><span class="line">radar_chart.add(<span class="string">'Opera'</span>, [<span class="number">3472</span>, <span class="number">2933</span>, <span class="number">4203</span>, <span class="number">5229</span>, <span class="number">5810</span>, <span class="number">1828</span>, <span class="number">9013</span>, <span class="number">4669</span>])</span><br><span class="line">radar_chart.add(<span class="string">'IE'</span>, [<span class="number">43</span>, <span class="number">41</span>, <span class="number">59</span>, <span class="number">79</span>, <span class="number">144</span>, <span class="number">136</span>, <span class="number">34</span>, <span class="number">102</span>])</span><br><span class="line">radar_chart.render()</span><br></pre></td></tr></tbody></table></figure>

<p>效果如下：</p>
<p><img src="https://s2.loli.net/2022/08/01/zxv9W8fr71P3ew6.png" alt="image-20220801102051712"></p>
</body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python正则表达式篇</title>
    <url>/2022/09/08/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<html><head></head><body><h1 id="python正则表达式篇"><a href="#python正则表达式篇" class="headerlink" title="python正则表达式篇"></a>python正则表达式篇</h1><h3 id="1、请写出一段代码用正则匹配出ip？"><a href="#1、请写出一段代码用正则匹配出ip？" class="headerlink" title="1、请写出一段代码用正则匹配出ip？"></a>1、请写出一段代码用正则匹配出ip？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">ip ='192.168.1.1'</span><br><span class="line">trueIp =re.search(r'(([01]{0,1}\d{0,1}\d|2[0-4]\d|25[0-5])\.){3}([01]{0,1}\d{0,1}\d|2[0-4]\d|25[0-5])',ip)</span><br><span class="line">print(trueIp)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2、a-x3D-“abbbccc”，用正则匹配为abccc-不管有多少b，就出现一次？"><a href="#2、a-x3D-“abbbccc”，用正则匹配为abccc-不管有多少b，就出现一次？" class="headerlink" title="2、a = “abbbccc”，用正则匹配为abccc,不管有多少b，就出现一次？"></a>2、a = “abbbccc”，用正则匹配为abccc,不管有多少b，就出现一次？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">思路：不管有多少个b替换成一个</span><br><span class="line"></span><br><span class="line">re.sub(r'b+', 'b', a)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3、Python字符串查找和替换？"><a href="#3、Python字符串查找和替换？" class="headerlink" title="3、Python字符串查找和替换？"></a>3、Python字符串查找和替换？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">a、str.find()：正序字符串查找函数</span><br><span class="line">函数原型：</span><br><span class="line">str.find(substr [,pos_start [,pos_end ] ] )</span><br><span class="line">返回str中第一次出现的substr的第一个字母的标号，如果str中没有substr则返回-1，也就是说从左边算起的第一次出现的substr的首字母标号。</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">str：代表原字符串</span><br><span class="line">substr：代表要查找的字符串</span><br><span class="line">pos_start：代表查找的开始位置，默认是从下标0开始查找</span><br><span class="line">pos_end：代表查找的结束位置</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">'aabbcc.find('bb')' # 2</span><br><span class="line"></span><br><span class="line">b、str.index()：正序字符串查找函数</span><br><span class="line">index()函数类似于find()函数，在Python中也是在字符串中查找子串第一次出现的位置，跟find()不同的是，未找到则抛出异常。</span><br><span class="line"></span><br><span class="line">函数原型：</span><br><span class="line">str.index(substr [, pos_start, [ pos_end ] ] )</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">str：代表原字符串</span><br><span class="line">substr：代表要查找的字符串</span><br><span class="line">pos_start：代表查找的开始位置，默认是从下标0开始查找</span><br><span class="line">pos_end：代表查找的结束位置</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">'acdd l1 23'.index(' ') # 4</span><br><span class="line"></span><br><span class="line">c、str.rfind()：倒序字符串查找函数</span><br><span class="line"></span><br><span class="line">函数原型：</span><br><span class="line">str.rfind( substr [, pos_start [,pos_ end ] ])</span><br><span class="line">返回str中最后出现的substr的第一个字母的标号，如果str中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号。</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">str：代表原字符串</span><br><span class="line">substr：代表要查找的字符串</span><br><span class="line">pos_start：代表查找的开始位置，默认是从下标0开始查找</span><br><span class="line">pos_end：代表查找的结束位置</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">'adsfddf'.rfind('d') # 5</span><br><span class="line"></span><br><span class="line">d、str.rindex()：倒序字符串查找函数</span><br><span class="line">rindex()函数类似于rfind()函数，在Python中也是在字符串中倒序查找子串最后一次出现的位置，跟rfind()不同的是，未找到则抛出异常。</span><br><span class="line"></span><br><span class="line">函数原型：</span><br><span class="line">str.rindex(substr [, pos_start, [ pos_end ] ] )</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">str：代表原字符串</span><br><span class="line">substr：代表要查找的字符串</span><br><span class="line">pos_start：代表查找的开始位置，默认是从下标0开始查找</span><br><span class="line">pos_end：代表查找的结束位置</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"> 'adsfddf'.rindex('d') # 5</span><br><span class="line"></span><br><span class="line">e、使用re模块进行查找和替换：</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>re.match(pat, s)</td>
<td>只从字符串s的头开始匹配，比如(‘123’, ‘12345’)匹配上了，而(‘123’,’01234’)就是没有匹配上，没有匹配上返回None，匹配上返回matchobject</td>
</tr>
<tr>
<td>re.search(pat, s)</td>
<td>从字符串s的任意位置都进行匹配，比如(‘123’,’01234’)就是匹配上了，只要s只能存在符合pat的连续字符串就算匹配上了，没有匹配上返回None，匹配上返回matchobject</td>
</tr>
<tr>
<td>re.sub(pat,newpat,s)</td>
<td>re.sub(pat,newpat,s) 对字符串中s的包含的所有符合pat的连续字符串进行替换，如果newpat为str,那么就是替换为newpat,如果newpat是函数，那么就按照函数返回值替换。sub函数两个有默认值的参数分别是count表示最多只处理前几个匹配的字符串，默认为0表示全部处理；最后一个是flags，默认为0</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">f、使用replace()进行替换：</span><br><span class="line">基本用法：对象.replace(rgExp,replaceText,max)</span><br><span class="line"></span><br><span class="line">其中，rgExp和replaceText是必须要有的，max是可选的参数，可以不加。</span><br><span class="line">rgExp是指正则表达式模式或可用标志的正则表达式对象，也可以是 String 对象或文字；</span><br><span class="line">replaceText是一个String 对象或字符串文字；</span><br><span class="line">max是一个数字。</span><br><span class="line">对于一个对象，在对象的每个rgExp都替换成replaceText，从左到右最多max次。</span><br><span class="line"></span><br><span class="line">s1='hello world'</span><br><span class="line">s1.replace('world','liming')</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4、用Python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别"><a href="#4、用Python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别" class="headerlink" title="4、用Python匹配HTML tag的时候，<.*> 和 <.*?> 有什么区别"></a>4、用Python匹配HTML tag的时候，&lt;.*&gt; 和 &lt;.*?&gt; 有什么区别</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">第一个代表贪心匹配，第二个代表非贪心；</span><br><span class="line">?在一般正则表达式里的语法是指的"零次或一次匹配左边的字符或表达式"相当于{0,1}</span><br><span class="line">而当?后缀于*,+,?,{n},{n,},{n,m}之后，则代表非贪心匹配模式，也就是说，尽可能少的匹配左边的字符或表达式，这里是尽可能少的匹配.(任意字符)</span><br><span class="line"></span><br><span class="line">所以：第一种写法是，尽可能多的匹配，就是匹配到的字符串尽量长，第二中写法是尽可能少的匹配，就是匹配到的字符串尽量短。</span><br><span class="line">比如&lt;tag&gt;tag&gt;tag&gt;end，第一个会匹配&lt;tag&gt;tag&gt;tag&gt;,第二个会匹配&lt;tag&gt;。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5、正则表达式贪婪与非贪婪模式的区别？"><a href="#5、正则表达式贪婪与非贪婪模式的区别？" class="headerlink" title="5、正则表达式贪婪与非贪婪模式的区别？"></a>5、正则表达式贪婪与非贪婪模式的区别？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">贪婪模式：</span><br><span class="line">定义：正则表达式去匹配时，会尽量多的匹配符合条件的内容</span><br><span class="line">标识符：+，?，*，{n}，{n,}，{n,m}</span><br><span class="line">匹配时，如果遇到上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容</span><br><span class="line"></span><br><span class="line">非贪婪模式：</span><br><span class="line">定义：正则表达式去匹配时，会尽量少的匹配符合条件的内容 也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有g，开启下一组匹配)</span><br><span class="line">标识符：+?，??，*?，{n}?，{n,}?，{n,m}?</span><br><span class="line">可以看到，非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个?</span><br><span class="line"></span><br><span class="line">参考文章：https://dailc.github.io/2017/07/06/regularExpressionGreedyAndLazy.html</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6、写出开头匹配字母和下划线，末尾是数字的正则表达式？"><a href="#6、写出开头匹配字母和下划线，末尾是数字的正则表达式？" class="headerlink" title="6、写出开头匹配字母和下划线，末尾是数字的正则表达式？"></a>6、写出开头匹配字母和下划线，末尾是数字的正则表达式？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">s1='_aai0efe00'</span><br><span class="line">res=re.findall('^[a-zA-Z_]?[a-zA-Z0-9_]{1,}\d$',s1)</span><br><span class="line">print(res)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7、怎么过滤评论中的表情？"><a href="#7、怎么过滤评论中的表情？" class="headerlink" title="7、怎么过滤评论中的表情？"></a>7、怎么过滤评论中的表情？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">思路：主要是匹配表情包的范围，将表情包的范围用空替换掉</span><br><span class="line">import re</span><br><span class="line">pattern = re.compile(u'[\uD800-\uDBFF][\uDC00-\uDFFF]')</span><br><span class="line">pattern.sub('',text)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8、简述Python里面search和match的区别"><a href="#8、简述Python里面search和match的区别" class="headerlink" title="8、简述Python里面search和match的区别"></a>8、简述Python里面search和match的区别</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">match()函数只检测字符串开头位置是否匹配，匹配成功才会返回结果，否则返回None；</span><br><span class="line">search()函数会在整个字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫基础</title>
    <url>/2022/08/01/python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<html><head></head><body><h1 id="python爬虫基础"><a href="#python爬虫基础" class="headerlink" title="python爬虫基础"></a>python爬虫基础</h1><h3 id="1、-HTTPS和HTTP的区别："><a href="#1、-HTTPS和HTTP的区别：" class="headerlink" title="1、 HTTPS和HTTP的区别："></a>1、 HTTPS和HTTP的区别：</h3><ul>
<li>https协议要申请证书到ca，需要一定经济成本</li>
<li>http是明文传输，https是加密的安全传输</li>
<li>连接的端口不一样，http是80，https是443</li>
<li>http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全。</li>
</ul>
<p>还有很多，自己去整理一下吧</p>
<h3 id="2、-如何解决验证码的问题，用什么模块，听过哪些人工打码平台？"><a href="#2、-如何解决验证码的问题，用什么模块，听过哪些人工打码平台？" class="headerlink" title="2、 如何解决验证码的问题，用什么模块，听过哪些人工打码平台？"></a>2、 如何解决验证码的问题，用什么模块，听过哪些人工打码平台？</h3><p>PIL、pytesser、tesseract模块</p>
<p>平台的话有：（打码平台特殊，不保证时效性）</p>
<ul>
<li>云打码</li>
<li>挣码</li>
<li>斐斐打码</li>
<li>若快打码</li>
<li>超级鹰</li>
</ul>
<h3 id="3、-ip-被封了怎么解决，自己做过-ip-池么？"><a href="#3、-ip-被封了怎么解决，自己做过-ip-池么？" class="headerlink" title="3、 ip 被封了怎么解决，自己做过 ip 池么？"></a>3、 ip 被封了怎么解决，自己做过 ip 池么？</h3><p>关于 ip 可以通过 ip 代理池来解决问题 ip 代理池相关的可以在 github 上搜索 ip proxy 自己选一个 去说 <a href="https://github.com/awolfly9/IPProxyTool">github.com/awolfly9/IP…</a> 提供大体思路：</p>
<ol>
<li>获取器 通过 requests 的爬虫爬取免费的 IP 代理网址获取 IP。</li>
<li>过滤器通过获取器获取的代理请求网页数据有数据返回的保存进 Redis。</li>
<li>定时检测器定时拿出一部分 Proxy 重新的用过滤器进行检测剔除不能用的代理。</li>
<li>利用 Flask web 服务器提供 API 方便提取 IP</li>
</ol>
<h3 id="4、Python如何爬取-HTTPS-网站？"><a href="#4、Python如何爬取-HTTPS-网站？" class="headerlink" title="4、Python如何爬取 HTTPS 网站？"></a>4、Python如何爬取 HTTPS 网站？</h3><p>这类问题属于简单类问题</p>
<ul>
<li>在使用 requests 前加入：requests.packages.urllib3.disable_warnings()。</li>
<li>为 requests 添加 verify=False 参数</li>
<li>导入ssl模块</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import ssl</span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5、python-爬虫有哪些常用框架？"><a href="#5、python-爬虫有哪些常用框架？" class="headerlink" title="5、python 爬虫有哪些常用框架？"></a>5、python 爬虫有哪些常用框架？</h3><table>
<thead>
<tr>
<th>序号</th>
<th>框架名称</th>
<th>描述</th>
<th>官网</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Scrapy</td>
<td>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。用这个框架可以轻松爬下来如亚马逊商品信息之类的数据。</td>
<td><a href="https://scrapy.org/">scrapy.org/</a></td>
</tr>
<tr>
<td>2</td>
<td>PySpider</td>
<td>pyspider 是一个用python实现的功能强大的网络爬虫系统，能在浏览器界面上进行脚本的编写，功能的调度和爬取结果的实时查看，后端使用常用的数据库进行爬取结果的存储，还能定时设置任务与任务优先级等。</td>
<td><a href="https://github.com/binux/pyspider">github.com/binux/pyspi…</a></td>
</tr>
<tr>
<td>3</td>
<td>Crawley</td>
<td>Crawley可以高速爬取对应网站的内容，支持关系和非关系数据库，数据可以导出为JSON、XML等。</td>
<td><a href="http://project.crawley-cloud.com/">project.crawley-cloud.com/</a></td>
</tr>
<tr>
<td>4</td>
<td>Portia</td>
<td>Portia是一个开源可视化爬虫工具，可让您在不需要任何编程知识的情况下爬取网站！简单地注释您感兴趣的页面，Portia将创建一个蜘蛛来从类似的页面提取数据。</td>
<td><a href="https://github.com/scrapinghub/portia">github.com/scrapinghub…</a></td>
</tr>
<tr>
<td>5</td>
<td>Newspaper</td>
<td>Newspaper可以用来提取新闻、文章和内容分析。使用多线程，支持10多种语言等。</td>
<td><a href="https://github.com/codelucas/newspaper">github.com/codelucas/n…</a></td>
</tr>
<tr>
<td>6</td>
<td>Beautiful Soup</td>
<td>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间</td>
<td><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">www.crummy.com/software/Be…</a></td>
</tr>
<tr>
<td>7</td>
<td>Grab</td>
<td>Grab是一个用于构建Web刮板的Python框架。借助Grab，您可以构建各种复杂的网页抓取工具，从简单的5行脚本到处理数百万个网页的复杂异步网站抓取工具。Grab提供一个API用于执行网络请求和处理接收到的内容，例如与HTML文档的DOM树进行交互。</td>
<td><a href="http://docs.grablib.org/en/latest/#grab-spider-user-manual">docs.grablib.org/en/latest/#…</a></td>
</tr>
<tr>
<td>8</td>
<td>Cola</td>
<td>Cola是一个分布式的爬虫框架，对于用户来说，只需编写几个特定的函数，而无需关注分布式运行的细节。任务会自动分配到多台机器上，整个过程对用户是透明的。</td>
<td>没找着~</td>
</tr>
<tr>
<td>9</td>
<td>很多</td>
<td>看自己积累</td>
<td>多百度</td>
</tr>
</tbody></table>
<h3 id="6、-Scrapy-的优缺点"><a href="#6、-Scrapy-的优缺点" class="headerlink" title="6、 Scrapy 的优缺点?"></a>6、 Scrapy 的优缺点?</h3><h5 id="优点：scrapy-是异步的"><a href="#优点：scrapy-是异步的" class="headerlink" title="优点：scrapy 是异步的"></a>优点：scrapy 是异步的</h5><p>采取可读性更强的 xpath 代替正则强大的统计和 log 系统，同时在不同的 url 上爬行支持 shell 方式，方便独立调试写 middleware,方便写一些统一的过滤器，通过管道的方式存入数据库。</p>
<h5 id="缺点：基于-python-的爬虫框架，扩展性比较差"><a href="#缺点：基于-python-的爬虫框架，扩展性比较差" class="headerlink" title="缺点：基于 python 的爬虫框架，扩展性比较差"></a>缺点：基于 python 的爬虫框架，扩展性比较差</h5><p>基于 twisted 框架，运行中的 exception 是不会干掉 reactor，并且异步框架出错后是不会停掉其他任务的，数据出错后难以察觉。</p>
<h3 id="7、-scrapy-和-request"><a href="#7、-scrapy-和-request" class="headerlink" title="7、 scrapy 和 request?"></a>7、 scrapy 和 request?</h3><ul>
<li>scrapy 是封装起来的框架，他包含了下载器，解析器，日志及异常处理，基于多线程， twisted 的方式处理，对于固定单个网站的爬取开发，有优势，但是对于多网站爬取，并发及分布式处理方面，不够灵活，不便调整与括展。</li>
<li>request 是一个 HTTP 库， 它只是用来，进行请求，对于 HTTP 请求，他是一个强大的库，下载，解析全部自己处理，灵活性更高，高并发与分布式部署也非常灵活，对于功能可以更好实现。</li>
</ul>
<h3 id="8、描述下-scrapy-框架运行的机制？"><a href="#8、描述下-scrapy-框架运行的机制？" class="headerlink" title="8、描述下 scrapy 框架运行的机制？"></a>8、描述下 scrapy 框架运行的机制？</h3><ol>
<li>从 start_urls 里获取第一批 url 并发送请求，请求由引擎交给调度器入请求队列，获取完毕后，调度器将请求队列里的请求交给下载器去获取请求对应的响应资源，并将响应交给自己编写的解析方法做提取处理，如果提取出需要的数据，则交给管道文件处理；</li>
<li>如果提取出 url，则继续执行之前的步骤（发送 url 请求，并由引擎将请求交给调度器入队列…)，直到请求队列里没有请求，程序结束。</li>
</ol>
<h3 id="9、-实现模拟登录的方式有哪些？"><a href="#9、-实现模拟登录的方式有哪些？" class="headerlink" title="9、 实现模拟登录的方式有哪些？"></a>9、 实现模拟登录的方式有哪些？</h3><ul>
<li>使用一个具有登录状态的 cookie，结合请求报头一起发送，可以直接发送 get 请求，访问登录后才能访问的页面。</li>
<li>先发送登录界面的 get 请求，在登录页面 HTML 里获取登录需要的数据（如果需要的话），然后结合账户密码，再发送 post 请求，即可登录成功。然后根据获取的 cookie信息，继续访问之后的页面。</li>
</ul>
<h3 id="10、-你遇到过的反爬虫的策略？怎么解决？"><a href="#10、-你遇到过的反爬虫的策略？怎么解决？" class="headerlink" title="10、 你遇到过的反爬虫的策略？怎么解决？"></a>10、 你遇到过的反爬虫的策略？怎么解决？</h3><ol>
<li>BAN IP</li>
<li>BAN USERAGENT</li>
<li>BAN COOKIES</li>
<li>验证码验证</li>
<li>javascript渲染</li>
<li>ajax异步传输</li>
<li>等…….</li>
</ol>
<ul>
<li>通过headers反爬虫：解决策略，伪造headers</li>
<li>基于用户行为反爬虫：动态变化去爬取数据，模拟普通用户的行为</li>
<li>通过动态更改代理ip来反爬虫</li>
<li>基于动态页面的反爬虫：跟踪服务器发送的ajax请求，模拟ajax请求,selnium 和phtamjs</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python程序打包pyinstaller</title>
    <url>/2022/08/03/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<html><head></head><body><p>安装pyinstaller 在控制台输入就行</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://imgloc.com/i/OnuaU"><img src="https://s1.328888.xyz/2022/08/03/OnuaU.png" alt="OnuaU.png"></a></p>
<p>python程序打包pyinstaller</p>
<p><img src="https://s1.328888.xyz/2022/08/03/OnFSC.png"></p>
<p>然后再在控制台输入Pyinstaller -F -w 文件名.py</p>
<p>注意：环境得是Anaconda : 3.6.0</p>
<p><a href="https://imgloc.com/i/ORN9y"><img src="https://s1.328888.xyz/2022/08/03/ORN9y.png" alt="ORN9y.png"></a></p>
<p>此时会生成build和dist ，dist里面会有一个exe文件 点击就可以运行</p>
<p><a href="https://imgloc.com/i/OR0TP"><img src="https://s1.328888.xyz/2022/08/03/OR0TP.png" alt="OR0TP.png"></a></p>
<p><a href="https://imgloc.com/i/ORFGU"><img src="https://s1.328888.xyz/2022/08/03/ORFGU.png" alt="ORFGU.png"></a></p>
<p><a href="%5B(11%E6%9D%A1%E6%B6%88%E6%81%AF">参考文档</a> [Python教程]保姆版教使用Pyinstaller 打包python成exe文件_王同学在这的博客-CSDN博客_pycharm打包多个py](<a href="https://blog.csdn.net/flyskymood/article/details/123668136">https://blog.csdn.net/flyskymood/article/details/123668136</a>))</p>
</body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python词频分析</title>
    <url>/2022/08/03/python%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<html><head></head><body><h1 id="python词频分析"><a href="#python词频分析" class="headerlink" title="python词频分析"></a>python词频分析</h1><p>文本名：结果50.txt：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">datasets labels testing used real test synthetic different contains</span><br><span class="line">vol ieee pp analysis machine transactions pattern intelligence trans learning journal  acm  based</span><br><span class="line">tree l2 l1 ac trees pc ab se template latent sm decision uk 70 go minutiae mc fr sw es</span><br><span class="line">arxiv query preprint queries 2017 abs corr qi 2016 ba 2015 101 fo 2014 glass 2018 networks brox image recommendation</span><br><span class="line">face x1 recognition facial faces database ii expression x2 age identity alignment person expressions veriﬁcation sign sketch im identiﬁcation wild</span><br><span class="line">matrix xi vector denotes th denote norm matrices yi xt respectively element vectors tr elements operator covariance product let diagonal</span><br><span class="line">bound complete theorem complexity problem lower upper np extension bounds whether arguments hard af bounded given stable argument ap regret</span><br><span class="line">context event co events mod car cc contexts ut road modeling nd bridge aj activity els neuron ff 360</span><br><span class="line">function space distance eq linear kernel loss functions deﬁned objective parameter parameters using equation term two problem following vector non</span><br><span class="line">object features feature detection level image objects segmentation region semantic local based regions box bounding spatial pooling detector cnn using</span><br><span class="line">pp proc conf vis comput int 2014 vol recognit 2016 english 2011 pm intell springer inf det notes res syst</span><br><span class="line">scale large language visual v1 v2 natural fei discovery mining u1 ng machines data support 2010 multi ijcv challenge machine</span><br><span class="line">images dataset ground truth datasets data image real training synthetic contains different scenes world scene used annotations benchmark annotated categories</span><br><span class="line">graph local edge matching nodes node global edges graphs cluster constraint clusters set two constraints similarity structure vertices pairwise tree</span><br><span class="line">set error test training average mean score used values evaluation number data different table sets metrics testing validation performance results</span><br><span class="line">learning deep neural networks wang li zhang liu 2016 2017 2018 pp chen convolutional yang 2015 processing image cvpr sun</span><br><span class="line">system human systems user ai visual people information interaction understanding models uncertainty control applications research users data task gaze model</span><br><span class="line">point points camera position direction surface rotation plane center outliers projection angle cloud two normal registration set orientation along positions</span><br><span class="line">section paper experiments end results study described details following sec work experimental present main presented analysis detailed implementation see next</span><br><span class="line">results performance method methods table proposed accuracy better art state comparison compared also baseline model best show fig shown datasets</span><br><span class="line">model distribution probability random variable gaussian variables sampling distributions inference density models data prior likelihood bayesian mixture probabilities conditional variational</span><br><span class="line">gradient block update convergence blocks vs stochastic algorithm updated least descent updates rs mm residual wavelet algo gradients greedy method</span><br><span class="line">time algorithm number step cost search solution iteration instances optimal size complexity computation sat steps computational iterations polynomial total times</span><br><span class="line">based methods problem approach proposed work method algorithms data learning approaches problems also propose optimization framework however algorithm related used</span><br><span class="line">introduction pt ps gt 33 cl closure dp 200 400 ft lk sound nc 600 mt fs mp rational nm</span><br><span class="line">domain class learning target label samples classiﬁcation data classes source training task supervised labels adaptation cross classiﬁer loss multi transfer</span><br><span class="line">size rate binary batch memory 100 code normalization 64 codes quantization 128 256 learning length bit gpu 32 training epochs</span><br><span class="line">al et rain proposed wang removal zhang li liu methods recently based chen streaks recent yang zhu deraining works introduced</span><br><span class="line">let set proof every since deﬁnition lemma rule follows consider following thus proposition theorem case formula true one assume holds</span><br><span class="line">one may however case also would even thus small could since possible number due example cases large two information different</span><br><span class="line">table input adversarial loss output image generation generative generated gan decoder translation images encoder generator generate style discriminator s1 f1</span><br><span class="line">fig figure shown right shows left example top row line results see bottom two red false show lines examples vi</span><br><span class="line">part attributes attribute work supported ni grant material stereo project version authors w1 photometric ﬁxation fc w2 water duration media</span><br><span class="line">set logic knowledge relation model semantics reasoning models program rules epistemic relations sets base properties answer abstract formulas programs interpretation</span><br><span class="line">explanation text explanations question word words questions open sentence zi answer xk post answers participants concepts document answering intention gadget</span><br><span class="line">data rank sparse clustering low representation dimensional tensor subspace si bi ri spectral dictionary pca high sparsity completion recovery s0</span><br><span class="line">video motion view frame frames temporal depth sequence sequences videos ﬂow camera optical views time rgb using tracking dynamic cameras</span><br><span class="line">online tracking term association long exp available 32 ti short graphics landmark lda 55 else 49 tracker pn interactive po</span><br><span class="line">intelligence artiﬁcial 40 30 50 60 2021 ci 2019 80 300 35 2020 aaai 100 27 00 ui 20 150</span><br><span class="line">university research science computer degree engineering received technology china interests department institute mail include ph vision currently professor learning school</span><br><span class="line">3d pose shape estimation 2d model reconstruction body human head poses using images shapes landmarks depth hand appearance surface based</span><br><span class="line">image images resolution map noise pixel pixels light high depth color maps quality super low using ﬁeld ﬁlter channel saliency</span><br><span class="line">de index ieee di terms member information 1000 2000 org sk sa la 500 http dk requires dx www publications</span><br><span class="line">action state actions planning states plan agent goal initial policy appendix pr transition robot observation observations set belief reward goals</span><br><span class="line">network layer model deep training layers learning trained networks cnn architecture neural convolutional attention two pre input feature end models</span><br><span class="line">log path st references change paths return ij y1 ad inequality publication accepted ds worker hm final xn wk information</span><br><span class="line">pp proceedings conference international vol journal theory acm max pages press springer xj volume systems statistics new 2007 programming statistical</span><br><span class="line">agents agent group game groups player games strategy utility value p1 social p2 players items allocation communication cs preferences ln</span><br><span class="line">vision computer conference ieee recognition pattern pp international proceedings cvpr 2015 image 2017 2016 iccv european 2018 2013 pages object</span><br><span class="line">supplementary embeddings dp lp text english w2 expansion document sentences dx languages</span><br></pre></td></tr></tbody></table></figure>

<p>源代码:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gettext</span>():</span><br><span class="line">    txt = <span class="built_in">open</span>(<span class="string">"结果50.txt"</span>,<span class="string">"r"</span>,errors=<span class="string">'ignore'</span>).read()</span><br><span class="line">    txt = txt.lower()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'!"#$&amp;()*+,-./:;&lt;=&gt;?@[\\]^_{|}·~‘’'</span>:</span><br><span class="line">        txt = txt.replace(ch,<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> txt</span><br><span class="line">txt = gettext()</span><br><span class="line">words = txt.split()</span><br><span class="line"><span class="built_in">print</span>(words)</span><br><span class="line">counts = {}</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    counts[word] = counts.get(word,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">items = <span class="built_in">list</span>(counts.items())</span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># print(items)</span></span><br><span class="line">words = []</span><br><span class="line">counts = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    words.append(items[i][<span class="number">0</span>])</span><br><span class="line">    counts.append(items[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(words)</span></span><br><span class="line"><span class="comment"># print(counts)</span></span><br><span class="line">c = (</span><br><span class="line">    Bar()</span><br><span class="line">    .add_xaxis(words)</span><br><span class="line">    .add_yaxis(<span class="string">"次数"</span>, counts)</span><br><span class="line">    .reversal_axis()</span><br><span class="line">    .set_series_opts(label_opts=opts.LabelOpts(position=<span class="string">"right"</span>))</span><br><span class="line">    .set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">"英文词出现字数"</span>))</span><br><span class="line">    .render(<span class="string">"英文词出现字数.html"</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<p>效果展示：</p>
<p><img src="https://s1.328888.xyz/2022/08/03/OqR0g.png" alt="image-20220803172136919"></p>
</body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python网络编程</title>
    <url>/2022/09/08/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<html><head></head><body><h1 id="python网络编程"><a href="#python网络编程" class="headerlink" title="python网络编程"></a>python网络编程</h1><h3 id="1、怎么实现强行关闭客户端和服务器之间的连接"><a href="#1、怎么实现强行关闭客户端和服务器之间的连接" class="headerlink" title="1、怎么实现强行关闭客户端和服务器之间的连接?"></a>1、怎么实现强行关闭客户端和服务器之间的连接?</h3><p>在socket通信过程中不算循环检测一个全局变量（开关标记变量），一旦标记变量变为关闭，则调用socket的close方法，循环结束，从而达到关闭连接的目的。</p>
<p>推荐阅读： <a href="https://www.cnblogs.com/yang950718/p/10794019.html">https://www.cnblogs.com/yang950718/p/10794019.html</a></p>
<h3 id="2、简述TCP和UDP的区别以及优缺点"><a href="#2、简述TCP和UDP的区别以及优缺点" class="headerlink" title="2、简述TCP和UDP的区别以及优缺点?"></a>2、简述TCP和UDP的区别以及优缺点?</h3><p><a href="https://blog.csdn.net/xiaobangkuaipao/article/details/76793702">https://blog.csdn.net/xiaobangkuaipao/article/details/76793702</a></p>
<h3 id="3、简述浏览器通过WSGI请求动态资源的过程"><a href="#3、简述浏览器通过WSGI请求动态资源的过程" class="headerlink" title="3、简述浏览器通过WSGI请求动态资源的过程?"></a>3、简述浏览器通过WSGI请求动态资源的过程?</h3><p>浏览器发送的请求被Nginx监听到，Nginx根据请求的URL的PATH或者后缀把请求静态资源的分发到静态资源的目录，别的请求根据配置好的转发到相应端口。 实现了WSGI的程序会监听某个端口，监听到Nginx转发过来的请求接收后(一般用socket的recv来接收HTTP的报文)以后把请求的报文封装成<code>environ</code>的字典对象，然后再提供一个<code>start_response</code>的方法。把这两个对象当成参数传入某个方法比如<code>wsgi_app(environ, start_response)</code>或者实现了<code>__call__(self, environ, start_response)</code>方法的某个实例。这个实例再调用<code>start_response</code>返回给实现了WSGI的中间件，再由中间件返回给Nginx。</p>
<h3 id="4、描述用浏览器访问www-baidu-com的过程"><a href="#4、描述用浏览器访问www-baidu-com的过程" class="headerlink" title="4、描述用浏览器访问www.baidu.com的过程"></a>4、描述用浏览器访问<a href="http://www.baidu.com的过程/">www.baidu.com的过程</a></h3><p>1.根据域名到DNS中找到IP</p>
<p>2.根据IP建立TCP连接(三次握手)</p>
<p>3.连接建立成功发起http请求</p>
<p>4.服务器响应http请求</p>
<p>5.浏览器解析HTML代码并请求html中的静态资源（js,css）</p>
<p>6.关闭TCP连接（四次挥手）</p>
<p>7.浏览器渲染页面</p>
<p>推荐阅读： <a href="https://blog.csdn.net/weixin_38497513/article/details/80918425">https://blog.csdn.net/weixin_38497513/article/details/80918425</a></p>
<h3 id="5、Post和Get请求的区别"><a href="#5、Post和Get请求的区别" class="headerlink" title="5、Post和Get请求的区别?"></a>5、Post和Get请求的区别?</h3><p>POST和GET都是HTTP请求的方法，当然并不只有这两个方法，只是这两个最常用。</p>
<p>过谷歌浏览器开发者工具的Network选项卡，可以捕获HTTP请求或者响应的相关信息。</p>
<p>上面就是一个GET请求，再来看一个POST请求演示截图：</p>
<p><strong>POST与GET请求区别总结：</strong></p>
<p><strong>（1）.请求数据的传输方式不同:</strong></p>
<p>GET请求数据是通过URI链接传输，看如下请求：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[HTML] 纯文本查看 复制代码http://www.softwhy.com/forum.php?mod=viewthread&amp;tid=6191</span><br></pre></td></tr></tbody></table></figure>

<p>上面链接问号（?）后面就是要向HTTP服务器发送的数据，如果有多个数据，用&amp;连接。</p>
<p>POST请求则是将数据放在HTTP请求体中，截图如下：</p>
<p>红框中就是POST请求向HTTP发送的部分数据，GET和HEAD请求不具有此部分。</p>
<p><strong>（2）.传输数据的大小不同：</strong></p>
<p>虽然HTTP协议没有对传输的数据大小进行限制，也没有对URI长度进行限制，但是实际应用中，不同的浏览器和服务器对此都有所限制。GET方式所能发送数据的大小非常有限，不同的浏览器有所不同。POST不通过URL传值，理论上数据大小不受限，不过各个HTTP服务器会规定对POST提交数据大小的限制，Apache、IIS6都有各自的配置，传输数据的大小要远大于GET方式。</p>
<p><strong>（3）.安全性：</strong></p>
<p>GET是通过URI发送数据，甚至直接在浏览器地址栏就能观察到，安全性非常的低。</p>
<p>POST在各个方面都要比GET更为安全。</p>
<h3 id="6、cookie-和session-的区别？"><a href="#6、cookie-和session-的区别？" class="headerlink" title="6、cookie 和session 的区别？"></a>6、cookie 和session 的区别？</h3><p><strong>1、存储位置不同</strong></p>
<blockquote>
<p>cookie的数据信息存放在客户端浏览器上。</p>
</blockquote>
<blockquote>
<p>session的数据信息存放在服务器上。</p>
</blockquote>
<p><strong>2、存储容量不同</strong></p>
<blockquote>
<p>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</p>
</blockquote>
<blockquote>
<p>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</p>
</blockquote>
<p><strong>3、存储方式不同</strong></p>
<blockquote>
<p>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p>
</blockquote>
<blockquote>
<p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p>
</blockquote>
<p><strong>4、隐私策略不同</strong></p>
<blockquote>
<p>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</p>
</blockquote>
<blockquote>
<p>session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。</p>
</blockquote>
<p><strong>5、有效期上不同</strong></p>
<blockquote>
<p>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。</p>
</blockquote>
<blockquote>
<p>session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</p>
</blockquote>
<p><strong>6、服务器压力不同</strong></p>
<blockquote>
<p>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p>
</blockquote>
<blockquote>
<p>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p>
</blockquote>
<p><strong>7、浏览器支持不同</strong></p>
<p>假如客户端浏览器不支持cookie：</p>
<blockquote>
<p>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</p>
</blockquote>
<blockquote>
<p>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</p>
</blockquote>
<p>假如客户端支持cookie：</p>
<blockquote>
<p>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</p>
</blockquote>
<blockquote>
<p>session只能在本窗口以及子窗口内有效。</p>
</blockquote>
<p><strong>8、跨域支持上不同</strong></p>
<blockquote>
<p>cookie支持跨域名访问。</p>
</blockquote>
<blockquote>
<p>session不支持跨域名访问。</p>
</blockquote>
<hr>
<h3 id="7、列出你知道的HTTP协议的状态码，说出表示什么意思？"><a href="#7、列出你知道的HTTP协议的状态码，说出表示什么意思？" class="headerlink" title="7、列出你知道的HTTP协议的状态码，说出表示什么意思？"></a>7、列出你知道的HTTP协议的状态码，说出表示什么意思？</h3><h5 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h5><p>表示临时响应并需要请求者继续执行操作的状态码。</p>
<table>
<thead>
<tr>
<th>100（继续）</th>
<th>请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</th>
</tr>
</thead>
<tbody><tr>
<td>101（切换协议）</td>
<td>请求者已要求服务器切换协议，服务器已确认并准备切换。</td>
</tr>
</tbody></table>
<h5 id="2xx（成功）-表示成功处理了请求的状态码。"><a href="#2xx（成功）-表示成功处理了请求的状态码。" class="headerlink" title="2xx（成功） 表示成功处理了请求的状态码。"></a>2xx（成功） 表示成功处理了请求的状态码。</h5><table>
<thead>
<tr>
<th>200（成功）</th>
<th>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。</th>
</tr>
</thead>
<tbody><tr>
<td>201（已创建）</td>
<td>请求成功并且服务器创建了新的资源。</td>
</tr>
<tr>
<td>202（已接受）</td>
<td>服务器已接受请求，但尚未处理。</td>
</tr>
<tr>
<td>203（非授权信息）</td>
<td>服务器已成功处理了请求，但返回的信息可能来自另一来源。</td>
</tr>
<tr>
<td>204（无内容）</td>
<td>服务器成功处理了请求，但没有返回任何内容。</td>
</tr>
<tr>
<td>205（重置内容）</td>
<td>服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。</td>
</tr>
<tr>
<td>206（部分内容）</td>
<td>服务器成功处理了部分 GET 请求。</td>
</tr>
</tbody></table>
<h5 id="3xx（重定向）"><a href="#3xx（重定向）" class="headerlink" title="3xx（重定向）"></a>3xx（重定向）</h5><p>要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。</p>
<table>
<thead>
<tr>
<th>300（多种选择）</th>
<th>针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</th>
</tr>
</thead>
<tbody><tr>
<td>301（永久移动）</td>
<td>请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。</td>
</tr>
<tr>
<td>302、（临时移动）</td>
<td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href="http://blog.liujason.com/tag/301">301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</td>
</tr>
<tr>
<td>303（查看其他位置）</td>
<td>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。</td>
</tr>
<tr>
<td>304（未修改）</td>
<td>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 .</td>
</tr>
<tr>
<td>305（使用代理）</td>
<td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</td>
</tr>
<tr>
<td>307（临时重定向）</td>
<td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 &lt;a href=answer.py?answer=&gt;<a href="http://blog.liujason.com/tag/301">301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</td>
</tr>
</tbody></table>
<h5 id="4xx（请求错误）-这些状态码表示请求可能出错，妨碍了服务器的处理。"><a href="#4xx（请求错误）-这些状态码表示请求可能出错，妨碍了服务器的处理。" class="headerlink" title="4xx（请求错误） 这些状态码表示请求可能出错，妨碍了服务器的处理。"></a>4xx（请求错误） 这些状态码表示请求可能出错，妨碍了服务器的处理。</h5><table>
<thead>
<tr>
<th>400（错误请求）</th>
<th>服务器不理解请求的语法。</th>
</tr>
</thead>
<tbody><tr>
<td>401（未授权）</td>
<td>请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。</td>
</tr>
<tr>
<td>403（禁止）</td>
<td>服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。</td>
</tr>
<tr>
<td>404（未找到）</td>
<td>服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。 如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。 如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。</td>
</tr>
<tr>
<td>405（方法禁用）</td>
<td>禁用请求中指定的方法。</td>
</tr>
<tr>
<td>406（不接受）</td>
<td>无法使用请求的内容特性响应请求的网页。</td>
</tr>
<tr>
<td>407（需要代理授权）</td>
<td>此状态码与 &lt;a href=answer.py?answer=35128&gt;401（未授权）类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。</td>
</tr>
<tr>
<td>408（请求超时）</td>
<td>服务器等候请求时发生超时。</td>
</tr>
<tr>
<td>409（冲突）</td>
<td>服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。</td>
</tr>
<tr>
<td>410（已删除）</td>
<td>如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。</td>
</tr>
<tr>
<td>411（需要有效长度）</td>
<td>服务器不接受不含有效内容长度标头字段的请求。</td>
</tr>
<tr>
<td>412（未满足前提条件）</td>
<td>服务器未满足请求者在请求中设置的其中一个前提条件。</td>
</tr>
<tr>
<td>413（请求实体过大）</td>
<td>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td>
</tr>
<tr>
<td>414（请求的 URI 过长）</td>
<td>请求的 URI（通常为网址）过长，服务器无法处理。</td>
</tr>
<tr>
<td>415（不支持的媒体类型）</td>
<td>请求的格式不受请求页面的支持。</td>
</tr>
<tr>
<td>416（请求范围不符合要求）</td>
<td>如果页面无法提供请求的范围，则服务器会返回此状态码。</td>
</tr>
<tr>
<td>417（未满足期望值）</td>
<td>服务器未满足”期望”请求标头字段的要求。</td>
</tr>
</tbody></table>
<h5 id="5xx（服务器错误）-这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。"><a href="#5xx（服务器错误）-这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。" class="headerlink" title="5xx（服务器错误） 这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。"></a>5xx（服务器错误） 这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</h5><table>
<thead>
<tr>
<th>500（服务器内部错误）</th>
<th>服务器遇到错误，无法完成请求。</th>
</tr>
</thead>
<tbody><tr>
<td>501（尚未实施）</td>
<td>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</td>
</tr>
<tr>
<td>502（错误网关）</td>
<td>服务器作为网关或代理，从上游服务器收到无效响应。</td>
</tr>
<tr>
<td>503（服务不可用）</td>
<td>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</td>
</tr>
<tr>
<td>504（网关超时）</td>
<td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td>
</tr>
<tr>
<td>505（HTTP 版本不受支持）</td>
<td>服务器不支持请求中所用的 HTT</td>
</tr>
</tbody></table>
</body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python逆向_房天下</title>
    <url>/2022/09/09/python%E9%80%86%E5%90%91_%E6%88%BF%E5%A4%A9%E4%B8%8B/</url>
    <content><![CDATA[<html><head></head><body><h1 id="房天下密码加密分析"><a href="#房天下密码加密分析" class="headerlink" title="房天下密码加密分析"></a>房天下密码加密分析</h1><p><a href="https://fang.com/default.htm">网址地址</a></p>
<p>查看浏览器开发工具发现pwd是个加密的参数</p>
<p><img src="https://img1.imgtp.com/2022/09/09/UQQ1YqhH.png" alt="image-20220909174411080.png"></p>
<p>通过全局搜素找到有pwd的文件</p>
<p><img src="https://img1.imgtp.com/2022/09/09/n0xDog4V.png" alt="image-20220909174637678.png"></p>
<p>这个js文件里面确实有pwd这个参数，在此处打上断点</p>
<p><img src="https://img1.imgtp.com/2022/09/09/o4tTa11x.png" alt="image-20220909174742715.png"></p>
<p>在控制台打印that.password,.val()</p>
<p><img src="https://img1.imgtp.com/2022/09/09/Ae4FLDmu.png" alt="image-20220909175100749.png"></p>
<p>再解决key_to_code这个参数，通过全局搜索找到这个参数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var key_to_encode = new RSAKeyPair("010001", "", "978C0A92D2173439707498F0944AA476B1B62595877DD6FA87F6E2AC6DCB3D0BF0B82857439C99B5091192BC134889DFF60C562EC54EFBA4FF2F9D55ADBCCEA4A2FBA80CB398ED501280A007C83AF30C3D1A142D6133C63012B90AB26AC60C898FB66EDC3192C3EC4FF66925A64003B72496099F4F09A9FB72A2CF9E4D770C41");</span><br></pre></td></tr></tbody></table></figure>

<p>再全局搜索RSAKeyPair，发现一个js文件，将其全部拷贝</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function setMaxDigits(n) {</span><br><span class="line">    maxDigits = n;</span><br><span class="line">    ZERO_ARRAY = new Array(maxDigits);</span><br><span class="line">    for (var t = 0; t &lt; ZERO_ARRAY.length; t++)</span><br><span class="line">        ZERO_ARRAY[t] = 0;</span><br><span class="line">    bigZero = new BigInt;</span><br><span class="line">    bigOne = new BigInt;</span><br><span class="line">    bigOne.digits[0] = 1</span><br><span class="line">}</span><br><span class="line">function BigInt(n) {</span><br><span class="line">    this.digits = typeof n == "boolean" &amp;&amp; n == !0 ? null : ZERO_ARRAY.slice(0);</span><br><span class="line">    this.isNeg = !1</span><br><span class="line">}</span><br><span class="line">function biFromDecimal(n) {</span><br><span class="line">    for (var u = n.charAt(0) == "-", t = u ? 1 : 0, i, f, r; t &lt; n.length &amp;&amp; n.charAt(t) == "0"; )</span><br><span class="line">        ++t;</span><br><span class="line">    if (t == n.length)</span><br><span class="line">        i = new BigInt;</span><br><span class="line">    else {</span><br><span class="line">        for (f = n.length - t,</span><br><span class="line">        r = f % dpl10,</span><br><span class="line">        r == 0 &amp;&amp; (r = dpl10),</span><br><span class="line">        i = biFromNumber(Number(n.substr(t, r))),</span><br><span class="line">        t += r; t &lt; n.length; )</span><br><span class="line">            i = biAdd(biMultiply(i, lr10), biFromNumber(Number(n.substr(t, dpl10)))),</span><br><span class="line">            t += dpl10;</span><br><span class="line">        i.isNeg = u</span><br><span class="line">    }</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line">function biCopy(n) {</span><br><span class="line">    var t = new BigInt(!0);</span><br><span class="line">    return t.digits = n.digits.slice(0),</span><br><span class="line">    t.isNeg = n.isNeg,</span><br><span class="line">    t</span><br><span class="line">}</span><br><span class="line">function biFromNumber(n) {</span><br><span class="line">    var t = new BigInt, i;</span><br><span class="line">    for (t.isNeg = n &lt; 0,</span><br><span class="line">    n = Math.abs(n),</span><br><span class="line">    i = 0; n &gt; 0; )</span><br><span class="line">        t.digits[i++] = n &amp; maxDigitVal,</span><br><span class="line">        n = Math.floor(n / biRadix);</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function reverseStr(n) {</span><br><span class="line">    for (var i = "", t = n.length - 1; t &gt; -1; --t)</span><br><span class="line">        i += n.charAt(t);</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line">function biToString(n, t) {</span><br><span class="line">    var r = new BigInt, i, u;</span><br><span class="line">    for (r.digits[0] = t,</span><br><span class="line">    i = biDivideModulo(n, r),</span><br><span class="line">    u = hexatrigesimalToChar[i[1].digits[0]]; biCompare(i[0], bigZero) == 1; )</span><br><span class="line">        i = biDivideModulo(i[0], r),</span><br><span class="line">        digit = i[1].digits[0],</span><br><span class="line">        u += hexatrigesimalToChar[i[1].digits[0]];</span><br><span class="line">    return (n.isNeg ? "-" : "") + reverseStr(u)</span><br><span class="line">}</span><br><span class="line">function biToDecimal(n) {</span><br><span class="line">    var i = new BigInt, t, r;</span><br><span class="line">    for (i.digits[0] = 10,</span><br><span class="line">    t = biDivideModulo(n, i),</span><br><span class="line">    r = String(t[1].digits[0]); biCompare(t[0], bigZero) == 1; )</span><br><span class="line">        t = biDivideModulo(t[0], i),</span><br><span class="line">        r += String(t[1].digits[0]);</span><br><span class="line">    return (n.isNeg ? "-" : "") + reverseStr(r)</span><br><span class="line">}</span><br><span class="line">function digitToHex(n) {</span><br><span class="line">    var t = "";</span><br><span class="line">    for (i = 0; i &lt; 4; ++i)</span><br><span class="line">        t += hexToChar[n &amp; 15],</span><br><span class="line">        n &gt;&gt;&gt;= 4;</span><br><span class="line">    return reverseStr(t)</span><br><span class="line">}</span><br><span class="line">function biToHex(n) {</span><br><span class="line">    for (var i = "", r = biHighIndex(n), t = biHighIndex(n); t &gt; -1; --t)</span><br><span class="line">        i += digitToHex(n.digits[t]);</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line">function charToHex(n) {</span><br><span class="line">    var t = 48</span><br><span class="line">      , u = t + 9</span><br><span class="line">      , i = 97</span><br><span class="line">      , f = i + 25</span><br><span class="line">      , r = 65;</span><br><span class="line">    return n &gt;= t &amp;&amp; n &lt;= u ? n - t : n &gt;= r &amp;&amp; n &lt;= 90 ? 10 + n - r : n &gt;= i &amp;&amp; n &lt;= f ? 10 + n - i : 0</span><br><span class="line">}</span><br><span class="line">function hexToDigit(n) {</span><br><span class="line">    for (var t = 0, r = Math.min(n.length, 4), i = 0; i &lt; r; ++i)</span><br><span class="line">        t &lt;&lt;= 4,</span><br><span class="line">        t |= charToHex(n.charCodeAt(i));</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function biFromHex(n) {</span><br><span class="line">    for (var i = new BigInt, u = n.length, t = u, r = 0; t &gt; 0; t -= 4,</span><br><span class="line">    ++r)</span><br><span class="line">        i.digits[r] = hexToDigit(n.substr(Math.max(t - 4, 0), Math.min(t, 4)));</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line">function biFromString(n, t) {</span><br><span class="line">    var f = n.charAt(0) == "-", e = f ? 1 : 0, i = new BigInt, r = new BigInt, u;</span><br><span class="line">    for (r.digits[0] = 1,</span><br><span class="line">    u = n.length - 1; u &gt;= e; u--) {</span><br><span class="line">        var o = n.charCodeAt(u)</span><br><span class="line">          , s = charToHex(o)</span><br><span class="line">          , h = biMultiplyDigit(r, s);</span><br><span class="line">        i = biAdd(i, h);</span><br><span class="line">        r = biMultiplyDigit(r, t)</span><br><span class="line">    }</span><br><span class="line">    return i.isNeg = f,</span><br><span class="line">    i</span><br><span class="line">}</span><br><span class="line">function biDump(n) {</span><br><span class="line">    return (n.isNeg ? "-" : "") + n.digits.join(" ")</span><br><span class="line">}</span><br><span class="line">function biAdd(n, t) {</span><br><span class="line">    var r, u, f, i;</span><br><span class="line">    if (n.isNeg != t.isNeg)</span><br><span class="line">        t.isNeg = !t.isNeg,</span><br><span class="line">        r = biSubtract(n, t),</span><br><span class="line">        t.isNeg = !t.isNeg;</span><br><span class="line">    else {</span><br><span class="line">        for (r = new BigInt,</span><br><span class="line">        u = 0,</span><br><span class="line">        i = 0; i &lt; n.digits.length; ++i)</span><br><span class="line">            f = n.digits[i] + t.digits[i] + u,</span><br><span class="line">            r.digits[i] = f % biRadix,</span><br><span class="line">            u = Number(f &gt;= biRadix);</span><br><span class="line">        r.isNeg = n.isNeg</span><br><span class="line">    }</span><br><span class="line">    return r</span><br><span class="line">}</span><br><span class="line">function biSubtract(n, t) {</span><br><span class="line">    var r, f, u, i;</span><br><span class="line">    if (n.isNeg != t.isNeg)</span><br><span class="line">        t.isNeg = !t.isNeg,</span><br><span class="line">        r = biAdd(n, t),</span><br><span class="line">        t.isNeg = !t.isNeg;</span><br><span class="line">    else {</span><br><span class="line">        for (r = new BigInt,</span><br><span class="line">        u = 0,</span><br><span class="line">        i = 0; i &lt; n.digits.length; ++i)</span><br><span class="line">            f = n.digits[i] - t.digits[i] + u,</span><br><span class="line">            r.digits[i] = f % biRadix,</span><br><span class="line">            r.digits[i] &lt; 0 &amp;&amp; (r.digits[i] += biRadix),</span><br><span class="line">            u = 0 - Number(f &lt; 0);</span><br><span class="line">        if (u == -1) {</span><br><span class="line">            for (u = 0,</span><br><span class="line">            i = 0; i &lt; n.digits.length; ++i)</span><br><span class="line">                f = 0 - r.digits[i] + u,</span><br><span class="line">                r.digits[i] = f % biRadix,</span><br><span class="line">                r.digits[i] &lt; 0 &amp;&amp; (r.digits[i] += biRadix),</span><br><span class="line">                u = 0 - Number(f &lt; 0);</span><br><span class="line">            r.isNeg = !n.isNeg</span><br><span class="line">        } else</span><br><span class="line">            r.isNeg = n.isNeg</span><br><span class="line">    }</span><br><span class="line">    return r</span><br><span class="line">}</span><br><span class="line">function biHighIndex(n) {</span><br><span class="line">    for (var t = n.digits.length - 1; t &gt; 0 &amp;&amp; n.digits[t] == 0; )</span><br><span class="line">        --t;</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function biNumBits(n) {</span><br><span class="line">    for (var i = biHighIndex(n), r = n.digits[i], u = (i + 1) * bitsPerDigit, t = u; t &gt; u - bitsPerDigit; --t) {</span><br><span class="line">        if ((r &amp; 32768) != 0)</span><br><span class="line">            break;</span><br><span class="line">        r &lt;&lt;= 1</span><br><span class="line">    }</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function biMultiply(n, t) {</span><br><span class="line">    for (var i = new BigInt, u, o = biHighIndex(n), s = biHighIndex(t), e, f, r = 0; r &lt;= s; ++r) {</span><br><span class="line">        for (u = 0,</span><br><span class="line">        f = r,</span><br><span class="line">        j = 0; j &lt;= o; ++j,</span><br><span class="line">        ++f)</span><br><span class="line">            e = i.digits[f] + n.digits[j] * t.digits[r] + u,</span><br><span class="line">            i.digits[f] = e &amp; maxDigitVal,</span><br><span class="line">            u = e &gt;&gt;&gt; biRadixBits;</span><br><span class="line">        i.digits[r + o + 1] = u</span><br><span class="line">    }</span><br><span class="line">    return i.isNeg = n.isNeg != t.isNeg,</span><br><span class="line">    i</span><br><span class="line">}</span><br><span class="line">function biMultiplyDigit(n, t) {</span><br><span class="line">    var u, r, f, i;</span><br><span class="line">    for (result = new BigInt,</span><br><span class="line">    u = biHighIndex(n),</span><br><span class="line">    r = 0,</span><br><span class="line">    i = 0; i &lt;= u; ++i)</span><br><span class="line">        f = result.digits[i] + n.digits[i] * t + r,</span><br><span class="line">        result.digits[i] = f &amp; maxDigitVal,</span><br><span class="line">        r = f &gt;&gt;&gt; biRadixBits;</span><br><span class="line">    return result.digits[1 + u] = r,</span><br><span class="line">    result</span><br><span class="line">}</span><br><span class="line">function arrayCopy(n, t, i, r, u) {</span><br><span class="line">    for (var o = Math.min(t + u, n.length), f = t, e = r; f &lt; o; ++f,</span><br><span class="line">    ++e)</span><br><span class="line">        i[e] = n[f]</span><br><span class="line">}</span><br><span class="line">function biShiftLeft(n, t) {</span><br><span class="line">    var e = Math.floor(t / bitsPerDigit), i = new BigInt, u, o, r, f;</span><br><span class="line">    for (arrayCopy(n.digits, 0, i.digits, e, i.digits.length - e),</span><br><span class="line">    u = t % bitsPerDigit,</span><br><span class="line">    o = bitsPerDigit - u,</span><br><span class="line">    r = i.digits.length - 1,</span><br><span class="line">    f = r - 1; r &gt; 0; --r,</span><br><span class="line">    --f)</span><br><span class="line">        i.digits[r] = i.digits[r] &lt;&lt; u &amp; maxDigitVal | (i.digits[f] &amp; highBitMasks[u]) &gt;&gt;&gt; o;</span><br><span class="line">    return i.digits[0] = i.digits[r] &lt;&lt; u &amp; maxDigitVal,</span><br><span class="line">    i.isNeg = n.isNeg,</span><br><span class="line">    i</span><br><span class="line">}</span><br><span class="line">function biShiftRight(n, t) {</span><br><span class="line">    var e = Math.floor(t / bitsPerDigit), i = new BigInt, u, o, r, f;</span><br><span class="line">    for (arrayCopy(n.digits, e, i.digits, 0, n.digits.length - e),</span><br><span class="line">    u = t % bitsPerDigit,</span><br><span class="line">    o = bitsPerDigit - u,</span><br><span class="line">    r = 0,</span><br><span class="line">    f = r + 1; r &lt; i.digits.length - 1; ++r,</span><br><span class="line">    ++f)</span><br><span class="line">        i.digits[r] = i.digits[r] &gt;&gt;&gt; u | (i.digits[f] &amp; lowBitMasks[u]) &lt;&lt; o;</span><br><span class="line">    return i.digits[i.digits.length - 1] &gt;&gt;&gt;= u,</span><br><span class="line">    i.isNeg = n.isNeg,</span><br><span class="line">    i</span><br><span class="line">}</span><br><span class="line">function biMultiplyByRadixPower(n, t) {</span><br><span class="line">    var i = new BigInt;</span><br><span class="line">    return arrayCopy(n.digits, 0, i.digits, t, i.digits.length - t),</span><br><span class="line">    i</span><br><span class="line">}</span><br><span class="line">function biDivideByRadixPower(n, t) {</span><br><span class="line">    var i = new BigInt;</span><br><span class="line">    return arrayCopy(n.digits, t, i.digits, 0, i.digits.length - t),</span><br><span class="line">    i</span><br><span class="line">}</span><br><span class="line">function biModuloByRadixPower(n, t) {</span><br><span class="line">    var i = new BigInt;</span><br><span class="line">    return arrayCopy(n.digits, 0, i.digits, 0, t),</span><br><span class="line">    i</span><br><span class="line">}</span><br><span class="line">function biCompare(n, t) {</span><br><span class="line">    if (n.isNeg != t.isNeg)</span><br><span class="line">        return 1 - 2 * Number(n.isNeg);</span><br><span class="line">    for (var i = n.digits.length - 1; i &gt;= 0; --i)</span><br><span class="line">        if (n.digits[i] != t.digits[i])</span><br><span class="line">            return n.isNeg ? 1 - 2 * Number(n.digits[i] &gt; t.digits[i]) : 1 - 2 * Number(n.digits[i] &lt; t.digits[i]);</span><br><span class="line">    return 0</span><br><span class="line">}</span><br><span class="line">function biDivideModulo(n, t) {</span><br><span class="line">    var a = biNumBits(n), s = biNumBits(t), v = t.isNeg, r, i, u, e, h, o, f, y, p;</span><br><span class="line">    if (a &lt; s)</span><br><span class="line">        return n.isNeg ? (r = biCopy(bigOne),</span><br><span class="line">        r.isNeg = !t.isNeg,</span><br><span class="line">        n.isNeg = !1,</span><br><span class="line">        t.isNeg = !1,</span><br><span class="line">        i = biSubtract(t, n),</span><br><span class="line">        n.isNeg = !0,</span><br><span class="line">        t.isNeg = v) : (r = new BigInt,</span><br><span class="line">        i = biCopy(n)),</span><br><span class="line">        [r, i];</span><br><span class="line">    for (r = new BigInt,</span><br><span class="line">    i = n,</span><br><span class="line">    u = Math.ceil(s / bitsPerDigit) - 1,</span><br><span class="line">    e = 0; t.digits[u] &lt; biHalfRadix; )</span><br><span class="line">        t = biShiftLeft(t, 1),</span><br><span class="line">        ++e,</span><br><span class="line">        ++s,</span><br><span class="line">        u = Math.ceil(s / bitsPerDigit) - 1;</span><br><span class="line">    for (i = biShiftLeft(i, e),</span><br><span class="line">    a += e,</span><br><span class="line">    h = Math.ceil(a / bitsPerDigit) - 1,</span><br><span class="line">    o = biMultiplyByRadixPower(t, h - u); biCompare(i, o) != -1; )</span><br><span class="line">        ++r.digits[h - u],</span><br><span class="line">        i = biSubtract(i, o);</span><br><span class="line">    for (f = h; f &gt; u; --f) {</span><br><span class="line">        var c = f &gt;= i.digits.length ? 0 : i.digits[f]</span><br><span class="line">          , w = f - 1 &gt;= i.digits.length ? 0 : i.digits[f - 1]</span><br><span class="line">          , b = f - 2 &gt;= i.digits.length ? 0 : i.digits[f - 2]</span><br><span class="line">          , l = u &gt;= t.digits.length ? 0 : t.digits[u]</span><br><span class="line">          , k = u - 1 &gt;= t.digits.length ? 0 : t.digits[u - 1];</span><br><span class="line">        for (r.digits[f - u - 1] = c == l ? maxDigitVal : Math.floor((c * biRadix + w) / l),</span><br><span class="line">        y = r.digits[f - u - 1] * (l * biRadix + k),</span><br><span class="line">        p = c * biRadixSquared + (w * biRadix + b); y &gt; p; )</span><br><span class="line">            --r.digits[f - u - 1],</span><br><span class="line">            y = r.digits[f - u - 1] * (l * biRadix | k),</span><br><span class="line">            p = c * biRadix * biRadix + (w * biRadix + b);</span><br><span class="line">        o = biMultiplyByRadixPower(t, f - u - 1);</span><br><span class="line">        i = biSubtract(i, biMultiplyDigit(o, r.digits[f - u - 1]));</span><br><span class="line">        i.isNeg &amp;&amp; (i = biAdd(i, o),</span><br><span class="line">        --r.digits[f - u - 1])</span><br><span class="line">    }</span><br><span class="line">    return i = biShiftRight(i, e),</span><br><span class="line">    r.isNeg = n.isNeg != v,</span><br><span class="line">    n.isNeg &amp;&amp; (r = v ? biAdd(r, bigOne) : biSubtract(r, bigOne),</span><br><span class="line">    t = biShiftRight(t, e),</span><br><span class="line">    i = biSubtract(t, i)),</span><br><span class="line">    i.digits[0] == 0 &amp;&amp; biHighIndex(i) == 0 &amp;&amp; (i.isNeg = !1),</span><br><span class="line">    [r, i]</span><br><span class="line">}</span><br><span class="line">function biDivide(n, t) {</span><br><span class="line">    return biDivideModulo(n, t)[0]</span><br><span class="line">}</span><br><span class="line">function biModulo(n, t) {</span><br><span class="line">    return biDivideModulo(n, t)[1]</span><br><span class="line">}</span><br><span class="line">function biMultiplyMod(n, t, i) {</span><br><span class="line">    return biModulo(biMultiply(n, t), i)</span><br><span class="line">}</span><br><span class="line">function biPow(n, t) {</span><br><span class="line">    for (var r = bigOne, i = n; ; ) {</span><br><span class="line">        if ((t &amp; 1) != 0 &amp;&amp; (r = biMultiply(r, i)),</span><br><span class="line">        t &gt;&gt;= 1,</span><br><span class="line">        t == 0)</span><br><span class="line">            break;</span><br><span class="line">        i = biMultiply(i, i)</span><br><span class="line">    }</span><br><span class="line">    return r</span><br><span class="line">}</span><br><span class="line">function biPowMod(n, t, i) {</span><br><span class="line">    for (var f = bigOne, u = n, r = t; ; ) {</span><br><span class="line">        if ((r.digits[0] &amp; 1) != 0 &amp;&amp; (f = biMultiplyMod(f, u, i)),</span><br><span class="line">        r = biShiftRight(r, 1),</span><br><span class="line">        r.digits[0] == 0 &amp;&amp; biHighIndex(r) == 0)</span><br><span class="line">            break;</span><br><span class="line">        u = biMultiplyMod(u, u, i)</span><br><span class="line">    }</span><br><span class="line">    return f</span><br><span class="line">}</span><br><span class="line">function BarrettMu(n) {</span><br><span class="line">    this.modulus = biCopy(n);</span><br><span class="line">    this.k = biHighIndex(this.modulus) + 1;</span><br><span class="line">    var t = new BigInt;</span><br><span class="line">    t.digits[2 * this.k] = 1;</span><br><span class="line">    this.mu = biDivide(t, this.modulus);</span><br><span class="line">    this.bkplus1 = new BigInt;</span><br><span class="line">    this.bkplus1.digits[this.k + 1] = 1;</span><br><span class="line">    this.modulo = BarrettMu_modulo;</span><br><span class="line">    this.multiplyMod = BarrettMu_multiplyMod;</span><br><span class="line">    this.powMod = BarrettMu_powMod</span><br><span class="line">}</span><br><span class="line">function BarrettMu_modulo(n) {</span><br><span class="line">    var r = biDivideByRadixPower(n, this.k - 1), u = biMultiply(r, this.mu), f = biDivideByRadixPower(u, this.k + 1), e = biModuloByRadixPower(n, this.k + 1), o = biMultiply(f, this.modulus), s = biModuloByRadixPower(o, this.k + 1), t = biSubtract(e, s), i;</span><br><span class="line">    for (t.isNeg &amp;&amp; (t = biAdd(t, this.bkplus1)),</span><br><span class="line">    i = biCompare(t, this.modulus) &gt;= 0; i; )</span><br><span class="line">        t = biSubtract(t, this.modulus),</span><br><span class="line">        i = biCompare(t, this.modulus) &gt;= 0;</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function BarrettMu_multiplyMod(n, t) {</span><br><span class="line">    var i = biMultiply(n, t);</span><br><span class="line">    return this.modulo(i)</span><br><span class="line">}</span><br><span class="line">function BarrettMu_powMod(n, t) {</span><br><span class="line">    var u = new BigInt, r, i;</span><br><span class="line">    for (u.digits[0] = 1,</span><br><span class="line">    r = n,</span><br><span class="line">    i = t; ; ) {</span><br><span class="line">        if ((i.digits[0] &amp; 1) != 0 &amp;&amp; (u = this.multiplyMod(u, r)),</span><br><span class="line">        i = biShiftRight(i, 1),</span><br><span class="line">        i.digits[0] == 0 &amp;&amp; biHighIndex(i) == 0)</span><br><span class="line">            break;</span><br><span class="line">        r = this.multiplyMod(r, r)</span><br><span class="line">    }</span><br><span class="line">    return u</span><br><span class="line">}</span><br><span class="line">function RSAKeyPair(n, t, i) {</span><br><span class="line">    this.e = biFromHex(n);</span><br><span class="line">    this.d = biFromHex(t);</span><br><span class="line">    this.m = biFromHex(i);</span><br><span class="line">    this.digitSize = 2 * biHighIndex(this.m) + 2;</span><br><span class="line">    this.chunkSize = this.digitSize - 11;</span><br><span class="line">    this.radix = 16;</span><br><span class="line">    this.barrett = new BarrettMu(this.m)</span><br><span class="line">}</span><br><span class="line">function twoDigit(n) {</span><br><span class="line">    return (n &lt; 10 ? "0" : "") + String(n)</span><br><span class="line">}</span><br><span class="line">function encryptedString(n, t) {</span><br><span class="line">    var e, o, s, h, c, i, f, u, v, l, y;</span><br><span class="line">    if (n.chunkSize &gt; n.digitSize - 11)</span><br><span class="line">        return "Error";</span><br><span class="line">    for (var a = [], p = t.length, r = 0; r &lt; p; )</span><br><span class="line">        a[r] = t.charCodeAt(r),</span><br><span class="line">        r++;</span><br><span class="line">    for (e = a.length,</span><br><span class="line">    o = "",</span><br><span class="line">    r = 0; r &lt; e; r += n.chunkSize) {</span><br><span class="line">        for (c = new BigInt,</span><br><span class="line">        s = 0,</span><br><span class="line">        f = r + n.chunkSize &gt; e ? e % n.chunkSize : n.chunkSize,</span><br><span class="line">        u = [],</span><br><span class="line">        i = 0; i &lt; f; i++)</span><br><span class="line">            u[i] = a[r + f - 1 - i];</span><br><span class="line">        for (u[f] = 0,</span><br><span class="line">        v = Math.max(8, n.digitSize - 3 - f),</span><br><span class="line">        i = 0; i &lt; v; i++)</span><br><span class="line">            u[f + 1 + i] = Math.floor(Math.random() * 254) + 1;</span><br><span class="line">        for (u[n.digitSize - 2] = 2,</span><br><span class="line">        u[n.digitSize - 1] = 0,</span><br><span class="line">        h = 0; h &lt; n.digitSize; ++s)</span><br><span class="line">            c.digits[s] = u[h++],</span><br><span class="line">            c.digits[s] += u[h++] &lt;&lt; 8;</span><br><span class="line">        l = n.barrett.powMod(c, n.e);</span><br><span class="line">        y = n.radix == 16 ? biToHex(l) : biToString(l, n.radix);</span><br><span class="line">        o += y + " "</span><br><span class="line">    }</span><br><span class="line">    return o.substring(0, o.length - 1)</span><br><span class="line">}</span><br><span class="line">function decryptedString(n, t) {</span><br><span class="line">    for (var e = t.split(" "), i = "", r, u, o, f = 0; f &lt; e.length; ++f)</span><br><span class="line">        for (o = n.radix == 16 ? biFromHex(e[f]) : biFromString(e[f], n.radix),</span><br><span class="line">        u = n.barrett.powMod(o, n.d),</span><br><span class="line">        r = 0; r &lt;= biHighIndex(u); ++r)</span><br><span class="line">            i += String.fromCharCode(u.digits[r] &amp; 255, u.digits[r] &gt;&gt; 8);</span><br><span class="line">    return i.charCodeAt(i.length - 1) == 0 &amp;&amp; (i = i.substring(0, i.length - 1)),</span><br><span class="line">    i</span><br><span class="line">}</span><br><span class="line">var biRadixBase = 2, biRadixBits = 16, bitsPerDigit = biRadixBits, biRadix = 65536, biHalfRadix = biRadix &gt;&gt;&gt; 1, biRadixSquared = biRadix * biRadix, maxDigitVal = biRadix - 1, maxInteger = 9999999999999998, maxDigits, ZERO_ARRAY, bigZero, bigOne, dpl10, lr10, hexatrigesimalToChar, hexToChar, highBitMasks, lowBitMasks;</span><br><span class="line">setMaxDigits(20);</span><br><span class="line">dpl10 = 15;</span><br><span class="line">lr10 = biFromNumber(1e15);</span><br><span class="line">hexatrigesimalToChar = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];</span><br><span class="line">hexToChar = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];</span><br><span class="line">highBitMasks = [0, 32768, 49152, 57344, 61440, 63488, 64512, 65024, 65280, 65408, 65472, 65504, 65520, 65528, 65532, 65534, 65535];</span><br><span class="line">lowBitMasks = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535];</span><br><span class="line">setMaxDigits(129);</span><br></pre></td></tr></tbody></table></figure>

<p>全部代码:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function setMaxDigits(n) {</span><br><span class="line">    maxDigits = n;</span><br><span class="line">    ZERO_ARRAY = new Array(maxDigits);</span><br><span class="line">    for (var t = 0; t &lt; ZERO_ARRAY.length; t++)</span><br><span class="line">        ZERO_ARRAY[t] = 0;</span><br><span class="line">    bigZero = new BigInt;</span><br><span class="line">    bigOne = new BigInt;</span><br><span class="line">    bigOne.digits[0] = 1</span><br><span class="line">}</span><br><span class="line">function BigInt(n) {</span><br><span class="line">    this.digits = typeof n == "boolean" &amp;&amp; n == !0 ? null : ZERO_ARRAY.slice(0);</span><br><span class="line">    this.isNeg = !1</span><br><span class="line">}</span><br><span class="line">function biFromDecimal(n) {</span><br><span class="line">    for (var u = n.charAt(0) == "-", t = u ? 1 : 0, i, f, r; t &lt; n.length &amp;&amp; n.charAt(t) == "0"; )</span><br><span class="line">        ++t;</span><br><span class="line">    if (t == n.length)</span><br><span class="line">        i = new BigInt;</span><br><span class="line">    else {</span><br><span class="line">        for (f = n.length - t,</span><br><span class="line">                 r = f % dpl10,</span><br><span class="line">             r == 0 &amp;&amp; (r = dpl10),</span><br><span class="line">                 i = biFromNumber(Number(n.substr(t, r))),</span><br><span class="line">                 t += r; t &lt; n.length; )</span><br><span class="line">            i = biAdd(biMultiply(i, lr10), biFromNumber(Number(n.substr(t, dpl10)))),</span><br><span class="line">                t += dpl10;</span><br><span class="line">        i.isNeg = u</span><br><span class="line">    }</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line">function biCopy(n) {</span><br><span class="line">    var t = new BigInt(!0);</span><br><span class="line">    return t.digits = n.digits.slice(0),</span><br><span class="line">        t.isNeg = n.isNeg,</span><br><span class="line">        t</span><br><span class="line">}</span><br><span class="line">function biFromNumber(n) {</span><br><span class="line">    var t = new BigInt, i;</span><br><span class="line">    for (t.isNeg = n &lt; 0,</span><br><span class="line">             n = Math.abs(n),</span><br><span class="line">             i = 0; n &gt; 0; )</span><br><span class="line">        t.digits[i++] = n &amp; maxDigitVal,</span><br><span class="line">            n = Math.floor(n / biRadix);</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function reverseStr(n) {</span><br><span class="line">    for (var i = "", t = n.length - 1; t &gt; -1; --t)</span><br><span class="line">        i += n.charAt(t);</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line">function biToString(n, t) {</span><br><span class="line">    var r = new BigInt, i, u;</span><br><span class="line">    for (r.digits[0] = t,</span><br><span class="line">             i = biDivideModulo(n, r),</span><br><span class="line">             u = hexatrigesimalToChar[i[1].digits[0]]; biCompare(i[0], bigZero) == 1; )</span><br><span class="line">        i = biDivideModulo(i[0], r),</span><br><span class="line">            digit = i[1].digits[0],</span><br><span class="line">            u += hexatrigesimalToChar[i[1].digits[0]];</span><br><span class="line">    return (n.isNeg ? "-" : "") + reverseStr(u)</span><br><span class="line">}</span><br><span class="line">function biToDecimal(n) {</span><br><span class="line">    var i = new BigInt, t, r;</span><br><span class="line">    for (i.digits[0] = 10,</span><br><span class="line">             t = biDivideModulo(n, i),</span><br><span class="line">             r = String(t[1].digits[0]); biCompare(t[0], bigZero) == 1; )</span><br><span class="line">        t = biDivideModulo(t[0], i),</span><br><span class="line">            r += String(t[1].digits[0]);</span><br><span class="line">    return (n.isNeg ? "-" : "") + reverseStr(r)</span><br><span class="line">}</span><br><span class="line">function digitToHex(n) {</span><br><span class="line">    var t = "";</span><br><span class="line">    for (i = 0; i &lt; 4; ++i)</span><br><span class="line">        t += hexToChar[n &amp; 15],</span><br><span class="line">            n &gt;&gt;&gt;= 4;</span><br><span class="line">    return reverseStr(t)</span><br><span class="line">}</span><br><span class="line">function biToHex(n) {</span><br><span class="line">    for (var i = "", r = biHighIndex(n), t = biHighIndex(n); t &gt; -1; --t)</span><br><span class="line">        i += digitToHex(n.digits[t]);</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line">function charToHex(n) {</span><br><span class="line">    var t = 48</span><br><span class="line">        , u = t + 9</span><br><span class="line">        , i = 97</span><br><span class="line">        , f = i + 25</span><br><span class="line">        , r = 65;</span><br><span class="line">    return n &gt;= t &amp;&amp; n &lt;= u ? n - t : n &gt;= r &amp;&amp; n &lt;= 90 ? 10 + n - r : n &gt;= i &amp;&amp; n &lt;= f ? 10 + n - i : 0</span><br><span class="line">}</span><br><span class="line">function hexToDigit(n) {</span><br><span class="line">    for (var t = 0, r = Math.min(n.length, 4), i = 0; i &lt; r; ++i)</span><br><span class="line">        t &lt;&lt;= 4,</span><br><span class="line">            t |= charToHex(n.charCodeAt(i));</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function biFromHex(n) {</span><br><span class="line">    for (var i = new BigInt, u = n.length, t = u, r = 0; t &gt; 0; t -= 4,</span><br><span class="line">        ++r)</span><br><span class="line">        i.digits[r] = hexToDigit(n.substr(Math.max(t - 4, 0), Math.min(t, 4)));</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line">function biFromString(n, t) {</span><br><span class="line">    var f = n.charAt(0) == "-", e = f ? 1 : 0, i = new BigInt, r = new BigInt, u;</span><br><span class="line">    for (r.digits[0] = 1,</span><br><span class="line">             u = n.length - 1; u &gt;= e; u--) {</span><br><span class="line">        var o = n.charCodeAt(u)</span><br><span class="line">            , s = charToHex(o)</span><br><span class="line">            , h = biMultiplyDigit(r, s);</span><br><span class="line">        i = biAdd(i, h);</span><br><span class="line">        r = biMultiplyDigit(r, t)</span><br><span class="line">    }</span><br><span class="line">    return i.isNeg = f,</span><br><span class="line">        i</span><br><span class="line">}</span><br><span class="line">function biDump(n) {</span><br><span class="line">    return (n.isNeg ? "-" : "") + n.digits.join(" ")</span><br><span class="line">}</span><br><span class="line">function biAdd(n, t) {</span><br><span class="line">    var r, u, f, i;</span><br><span class="line">    if (n.isNeg != t.isNeg)</span><br><span class="line">        t.isNeg = !t.isNeg,</span><br><span class="line">            r = biSubtract(n, t),</span><br><span class="line">            t.isNeg = !t.isNeg;</span><br><span class="line">    else {</span><br><span class="line">        for (r = new BigInt,</span><br><span class="line">                 u = 0,</span><br><span class="line">                 i = 0; i &lt; n.digits.length; ++i)</span><br><span class="line">            f = n.digits[i] + t.digits[i] + u,</span><br><span class="line">                r.digits[i] = f % biRadix,</span><br><span class="line">                u = Number(f &gt;= biRadix);</span><br><span class="line">        r.isNeg = n.isNeg</span><br><span class="line">    }</span><br><span class="line">    return r</span><br><span class="line">}</span><br><span class="line">function biSubtract(n, t) {</span><br><span class="line">    var r, f, u, i;</span><br><span class="line">    if (n.isNeg != t.isNeg)</span><br><span class="line">        t.isNeg = !t.isNeg,</span><br><span class="line">            r = biAdd(n, t),</span><br><span class="line">            t.isNeg = !t.isNeg;</span><br><span class="line">    else {</span><br><span class="line">        for (r = new BigInt,</span><br><span class="line">                 u = 0,</span><br><span class="line">                 i = 0; i &lt; n.digits.length; ++i)</span><br><span class="line">            f = n.digits[i] - t.digits[i] + u,</span><br><span class="line">                r.digits[i] = f % biRadix,</span><br><span class="line">            r.digits[i] &lt; 0 &amp;&amp; (r.digits[i] += biRadix),</span><br><span class="line">                u = 0 - Number(f &lt; 0);</span><br><span class="line">        if (u == -1) {</span><br><span class="line">            for (u = 0,</span><br><span class="line">                     i = 0; i &lt; n.digits.length; ++i)</span><br><span class="line">                f = 0 - r.digits[i] + u,</span><br><span class="line">                    r.digits[i] = f % biRadix,</span><br><span class="line">                r.digits[i] &lt; 0 &amp;&amp; (r.digits[i] += biRadix),</span><br><span class="line">                    u = 0 - Number(f &lt; 0);</span><br><span class="line">            r.isNeg = !n.isNeg</span><br><span class="line">        } else</span><br><span class="line">            r.isNeg = n.isNeg</span><br><span class="line">    }</span><br><span class="line">    return r</span><br><span class="line">}</span><br><span class="line">function biHighIndex(n) {</span><br><span class="line">    for (var t = n.digits.length - 1; t &gt; 0 &amp;&amp; n.digits[t] == 0; )</span><br><span class="line">        --t;</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function biNumBits(n) {</span><br><span class="line">    for (var i = biHighIndex(n), r = n.digits[i], u = (i + 1) * bitsPerDigit, t = u; t &gt; u - bitsPerDigit; --t) {</span><br><span class="line">        if ((r &amp; 32768) != 0)</span><br><span class="line">            break;</span><br><span class="line">        r &lt;&lt;= 1</span><br><span class="line">    }</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function biMultiply(n, t) {</span><br><span class="line">    for (var i = new BigInt, u, o = biHighIndex(n), s = biHighIndex(t), e, f, r = 0; r &lt;= s; ++r) {</span><br><span class="line">        for (u = 0,</span><br><span class="line">                 f = r,</span><br><span class="line">                 j = 0; j &lt;= o; ++j,</span><br><span class="line">                 ++f)</span><br><span class="line">            e = i.digits[f] + n.digits[j] * t.digits[r] + u,</span><br><span class="line">                i.digits[f] = e &amp; maxDigitVal,</span><br><span class="line">                u = e &gt;&gt;&gt; biRadixBits;</span><br><span class="line">        i.digits[r + o + 1] = u</span><br><span class="line">    }</span><br><span class="line">    return i.isNeg = n.isNeg != t.isNeg,</span><br><span class="line">        i</span><br><span class="line">}</span><br><span class="line">function biMultiplyDigit(n, t) {</span><br><span class="line">    var u, r, f, i;</span><br><span class="line">    for (result = new BigInt,</span><br><span class="line">             u = biHighIndex(n),</span><br><span class="line">             r = 0,</span><br><span class="line">             i = 0; i &lt;= u; ++i)</span><br><span class="line">        f = result.digits[i] + n.digits[i] * t + r,</span><br><span class="line">            result.digits[i] = f &amp; maxDigitVal,</span><br><span class="line">            r = f &gt;&gt;&gt; biRadixBits;</span><br><span class="line">    return result.digits[1 + u] = r,</span><br><span class="line">        result</span><br><span class="line">}</span><br><span class="line">function arrayCopy(n, t, i, r, u) {</span><br><span class="line">    for (var o = Math.min(t + u, n.length), f = t, e = r; f &lt; o; ++f,</span><br><span class="line">        ++e)</span><br><span class="line">        i[e] = n[f]</span><br><span class="line">}</span><br><span class="line">function biShiftLeft(n, t) {</span><br><span class="line">    var e = Math.floor(t / bitsPerDigit), i = new BigInt, u, o, r, f;</span><br><span class="line">    for (arrayCopy(n.digits, 0, i.digits, e, i.digits.length - e),</span><br><span class="line">             u = t % bitsPerDigit,</span><br><span class="line">             o = bitsPerDigit - u,</span><br><span class="line">             r = i.digits.length - 1,</span><br><span class="line">             f = r - 1; r &gt; 0; --r,</span><br><span class="line">             --f)</span><br><span class="line">        i.digits[r] = i.digits[r] &lt;&lt; u &amp; maxDigitVal | (i.digits[f] &amp; highBitMasks[u]) &gt;&gt;&gt; o;</span><br><span class="line">    return i.digits[0] = i.digits[r] &lt;&lt; u &amp; maxDigitVal,</span><br><span class="line">        i.isNeg = n.isNeg,</span><br><span class="line">        i</span><br><span class="line">}</span><br><span class="line">function biShiftRight(n, t) {</span><br><span class="line">    var e = Math.floor(t / bitsPerDigit), i = new BigInt, u, o, r, f;</span><br><span class="line">    for (arrayCopy(n.digits, e, i.digits, 0, n.digits.length - e),</span><br><span class="line">             u = t % bitsPerDigit,</span><br><span class="line">             o = bitsPerDigit - u,</span><br><span class="line">             r = 0,</span><br><span class="line">             f = r + 1; r &lt; i.digits.length - 1; ++r,</span><br><span class="line">             ++f)</span><br><span class="line">        i.digits[r] = i.digits[r] &gt;&gt;&gt; u | (i.digits[f] &amp; lowBitMasks[u]) &lt;&lt; o;</span><br><span class="line">    return i.digits[i.digits.length - 1] &gt;&gt;&gt;= u,</span><br><span class="line">        i.isNeg = n.isNeg,</span><br><span class="line">        i</span><br><span class="line">}</span><br><span class="line">function biMultiplyByRadixPower(n, t) {</span><br><span class="line">    var i = new BigInt;</span><br><span class="line">    return arrayCopy(n.digits, 0, i.digits, t, i.digits.length - t),</span><br><span class="line">        i</span><br><span class="line">}</span><br><span class="line">function biDivideByRadixPower(n, t) {</span><br><span class="line">    var i = new BigInt;</span><br><span class="line">    return arrayCopy(n.digits, t, i.digits, 0, i.digits.length - t),</span><br><span class="line">        i</span><br><span class="line">}</span><br><span class="line">function biModuloByRadixPower(n, t) {</span><br><span class="line">    var i = new BigInt;</span><br><span class="line">    return arrayCopy(n.digits, 0, i.digits, 0, t),</span><br><span class="line">        i</span><br><span class="line">}</span><br><span class="line">function biCompare(n, t) {</span><br><span class="line">    if (n.isNeg != t.isNeg)</span><br><span class="line">        return 1 - 2 * Number(n.isNeg);</span><br><span class="line">    for (var i = n.digits.length - 1; i &gt;= 0; --i)</span><br><span class="line">        if (n.digits[i] != t.digits[i])</span><br><span class="line">            return n.isNeg ? 1 - 2 * Number(n.digits[i] &gt; t.digits[i]) : 1 - 2 * Number(n.digits[i] &lt; t.digits[i]);</span><br><span class="line">    return 0</span><br><span class="line">}</span><br><span class="line">function biDivideModulo(n, t) {</span><br><span class="line">    var a = biNumBits(n), s = biNumBits(t), v = t.isNeg, r, i, u, e, h, o, f, y, p;</span><br><span class="line">    if (a &lt; s)</span><br><span class="line">        return n.isNeg ? (r = biCopy(bigOne),</span><br><span class="line">            r.isNeg = !t.isNeg,</span><br><span class="line">            n.isNeg = !1,</span><br><span class="line">            t.isNeg = !1,</span><br><span class="line">            i = biSubtract(t, n),</span><br><span class="line">            n.isNeg = !0,</span><br><span class="line">            t.isNeg = v) : (r = new BigInt,</span><br><span class="line">            i = biCopy(n)),</span><br><span class="line">            [r, i];</span><br><span class="line">    for (r = new BigInt,</span><br><span class="line">             i = n,</span><br><span class="line">             u = Math.ceil(s / bitsPerDigit) - 1,</span><br><span class="line">             e = 0; t.digits[u] &lt; biHalfRadix; )</span><br><span class="line">        t = biShiftLeft(t, 1),</span><br><span class="line">            ++e,</span><br><span class="line">            ++s,</span><br><span class="line">            u = Math.ceil(s / bitsPerDigit) - 1;</span><br><span class="line">    for (i = biShiftLeft(i, e),</span><br><span class="line">             a += e,</span><br><span class="line">             h = Math.ceil(a / bitsPerDigit) - 1,</span><br><span class="line">             o = biMultiplyByRadixPower(t, h - u); biCompare(i, o) != -1; )</span><br><span class="line">        ++r.digits[h - u],</span><br><span class="line">            i = biSubtract(i, o);</span><br><span class="line">    for (f = h; f &gt; u; --f) {</span><br><span class="line">        var c = f &gt;= i.digits.length ? 0 : i.digits[f]</span><br><span class="line">            , w = f - 1 &gt;= i.digits.length ? 0 : i.digits[f - 1]</span><br><span class="line">            , b = f - 2 &gt;= i.digits.length ? 0 : i.digits[f - 2]</span><br><span class="line">            , l = u &gt;= t.digits.length ? 0 : t.digits[u]</span><br><span class="line">            , k = u - 1 &gt;= t.digits.length ? 0 : t.digits[u - 1];</span><br><span class="line">        for (r.digits[f - u - 1] = c == l ? maxDigitVal : Math.floor((c * biRadix + w) / l),</span><br><span class="line">                 y = r.digits[f - u - 1] * (l * biRadix + k),</span><br><span class="line">                 p = c * biRadixSquared + (w * biRadix + b); y &gt; p; )</span><br><span class="line">            --r.digits[f - u - 1],</span><br><span class="line">                y = r.digits[f - u - 1] * (l * biRadix | k),</span><br><span class="line">                p = c * biRadix * biRadix + (w * biRadix + b);</span><br><span class="line">        o = biMultiplyByRadixPower(t, f - u - 1);</span><br><span class="line">        i = biSubtract(i, biMultiplyDigit(o, r.digits[f - u - 1]));</span><br><span class="line">        i.isNeg &amp;&amp; (i = biAdd(i, o),</span><br><span class="line">            --r.digits[f - u - 1])</span><br><span class="line">    }</span><br><span class="line">    return i = biShiftRight(i, e),</span><br><span class="line">        r.isNeg = n.isNeg != v,</span><br><span class="line">    n.isNeg &amp;&amp; (r = v ? biAdd(r, bigOne) : biSubtract(r, bigOne),</span><br><span class="line">        t = biShiftRight(t, e),</span><br><span class="line">        i = biSubtract(t, i)),</span><br><span class="line">    i.digits[0] == 0 &amp;&amp; biHighIndex(i) == 0 &amp;&amp; (i.isNeg = !1),</span><br><span class="line">        [r, i]</span><br><span class="line">}</span><br><span class="line">function biDivide(n, t) {</span><br><span class="line">    return biDivideModulo(n, t)[0]</span><br><span class="line">}</span><br><span class="line">function biModulo(n, t) {</span><br><span class="line">    return biDivideModulo(n, t)[1]</span><br><span class="line">}</span><br><span class="line">function biMultiplyMod(n, t, i) {</span><br><span class="line">    return biModulo(biMultiply(n, t), i)</span><br><span class="line">}</span><br><span class="line">function biPow(n, t) {</span><br><span class="line">    for (var r = bigOne, i = n; ; ) {</span><br><span class="line">        if ((t &amp; 1) != 0 &amp;&amp; (r = biMultiply(r, i)),</span><br><span class="line">            t &gt;&gt;= 1,</span><br><span class="line">        t == 0)</span><br><span class="line">            break;</span><br><span class="line">        i = biMultiply(i, i)</span><br><span class="line">    }</span><br><span class="line">    return r</span><br><span class="line">}</span><br><span class="line">function biPowMod(n, t, i) {</span><br><span class="line">    for (var f = bigOne, u = n, r = t; ; ) {</span><br><span class="line">        if ((r.digits[0] &amp; 1) != 0 &amp;&amp; (f = biMultiplyMod(f, u, i)),</span><br><span class="line">            r = biShiftRight(r, 1),</span><br><span class="line">        r.digits[0] == 0 &amp;&amp; biHighIndex(r) == 0)</span><br><span class="line">            break;</span><br><span class="line">        u = biMultiplyMod(u, u, i)</span><br><span class="line">    }</span><br><span class="line">    return f</span><br><span class="line">}</span><br><span class="line">function BarrettMu(n) {</span><br><span class="line">    this.modulus = biCopy(n);</span><br><span class="line">    this.k = biHighIndex(this.modulus) + 1;</span><br><span class="line">    var t = new BigInt;</span><br><span class="line">    t.digits[2 * this.k] = 1;</span><br><span class="line">    this.mu = biDivide(t, this.modulus);</span><br><span class="line">    this.bkplus1 = new BigInt;</span><br><span class="line">    this.bkplus1.digits[this.k + 1] = 1;</span><br><span class="line">    this.modulo = BarrettMu_modulo;</span><br><span class="line">    this.multiplyMod = BarrettMu_multiplyMod;</span><br><span class="line">    this.powMod = BarrettMu_powMod</span><br><span class="line">}</span><br><span class="line">function BarrettMu_modulo(n) {</span><br><span class="line">    var r = biDivideByRadixPower(n, this.k - 1), u = biMultiply(r, this.mu), f = biDivideByRadixPower(u, this.k + 1), e = biModuloByRadixPower(n, this.k + 1), o = biMultiply(f, this.modulus), s = biModuloByRadixPower(o, this.k + 1), t = biSubtract(e, s), i;</span><br><span class="line">    for (t.isNeg &amp;&amp; (t = biAdd(t, this.bkplus1)),</span><br><span class="line">             i = biCompare(t, this.modulus) &gt;= 0; i; )</span><br><span class="line">        t = biSubtract(t, this.modulus),</span><br><span class="line">            i = biCompare(t, this.modulus) &gt;= 0;</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line">function BarrettMu_multiplyMod(n, t) {</span><br><span class="line">    var i = biMultiply(n, t);</span><br><span class="line">    return this.modulo(i)</span><br><span class="line">}</span><br><span class="line">function BarrettMu_powMod(n, t) {</span><br><span class="line">    var u = new BigInt, r, i;</span><br><span class="line">    for (u.digits[0] = 1,</span><br><span class="line">             r = n,</span><br><span class="line">             i = t; ; ) {</span><br><span class="line">        if ((i.digits[0] &amp; 1) != 0 &amp;&amp; (u = this.multiplyMod(u, r)),</span><br><span class="line">            i = biShiftRight(i, 1),</span><br><span class="line">        i.digits[0] == 0 &amp;&amp; biHighIndex(i) == 0)</span><br><span class="line">            break;</span><br><span class="line">        r = this.multiplyMod(r, r)</span><br><span class="line">    }</span><br><span class="line">    return u</span><br><span class="line">}</span><br><span class="line">function RSAKeyPair(n, t, i) {</span><br><span class="line">    this.e = biFromHex(n);</span><br><span class="line">    this.d = biFromHex(t);</span><br><span class="line">    this.m = biFromHex(i);</span><br><span class="line">    this.digitSize = 2 * biHighIndex(this.m) + 2;</span><br><span class="line">    this.chunkSize = this.digitSize - 11;</span><br><span class="line">    this.radix = 16;</span><br><span class="line">    this.barrett = new BarrettMu(this.m)</span><br><span class="line">}</span><br><span class="line">function twoDigit(n) {</span><br><span class="line">    return (n &lt; 10 ? "0" : "") + String(n)</span><br><span class="line">}</span><br><span class="line">function encryptedString(n, t) {</span><br><span class="line">    var e, o, s, h, c, i, f, u, v, l, y;</span><br><span class="line">    if (n.chunkSize &gt; n.digitSize - 11)</span><br><span class="line">        return "Error";</span><br><span class="line">    for (var a = [], p = t.length, r = 0; r &lt; p; )</span><br><span class="line">        a[r] = t.charCodeAt(r),</span><br><span class="line">            r++;</span><br><span class="line">    for (e = a.length,</span><br><span class="line">             o = "",</span><br><span class="line">             r = 0; r &lt; e; r += n.chunkSize) {</span><br><span class="line">        for (c = new BigInt,</span><br><span class="line">                 s = 0,</span><br><span class="line">                 f = r + n.chunkSize &gt; e ? e % n.chunkSize : n.chunkSize,</span><br><span class="line">                 u = [],</span><br><span class="line">                 i = 0; i &lt; f; i++)</span><br><span class="line">            u[i] = a[r + f - 1 - i];</span><br><span class="line">        for (u[f] = 0,</span><br><span class="line">                 v = Math.max(8, n.digitSize - 3 - f),</span><br><span class="line">                 i = 0; i &lt; v; i++)</span><br><span class="line">            u[f + 1 + i] = Math.floor(Math.random() * 254) + 1;</span><br><span class="line">        for (u[n.digitSize - 2] = 2,</span><br><span class="line">                 u[n.digitSize - 1] = 0,</span><br><span class="line">                 h = 0; h &lt; n.digitSize; ++s)</span><br><span class="line">            c.digits[s] = u[h++],</span><br><span class="line">                c.digits[s] += u[h++] &lt;&lt; 8;</span><br><span class="line">        l = n.barrett.powMod(c, n.e);</span><br><span class="line">        y = n.radix == 16 ? biToHex(l) : biToString(l, n.radix);</span><br><span class="line">        o += y + " "</span><br><span class="line">    }</span><br><span class="line">    return o.substring(0, o.length - 1)</span><br><span class="line">}</span><br><span class="line">function decryptedString(n, t) {</span><br><span class="line">    for (var e = t.split(" "), i = "", r, u, o, f = 0; f &lt; e.length; ++f)</span><br><span class="line">        for (o = n.radix == 16 ? biFromHex(e[f]) : biFromString(e[f], n.radix),</span><br><span class="line">                 u = n.barrett.powMod(o, n.d),</span><br><span class="line">                 r = 0; r &lt;= biHighIndex(u); ++r)</span><br><span class="line">            i += String.fromCharCode(u.digits[r] &amp; 255, u.digits[r] &gt;&gt; 8);</span><br><span class="line">    return i.charCodeAt(i.length - 1) == 0 &amp;&amp; (i = i.substring(0, i.length - 1)),</span><br><span class="line">        i</span><br><span class="line">}</span><br><span class="line">var biRadixBase = 2, biRadixBits = 16, bitsPerDigit = biRadixBits, biRadix = 65536, biHalfRadix = biRadix &gt;&gt;&gt; 1, biRadixSquared = biRadix * biRadix, maxDigitVal = biRadix - 1, maxInteger = 9999999999999998, maxDigits, ZERO_ARRAY, bigZero, bigOne, dpl10, lr10, hexatrigesimalToChar, hexToChar, highBitMasks, lowBitMasks;</span><br><span class="line">setMaxDigits(20);</span><br><span class="line">dpl10 = 15;</span><br><span class="line">lr10 = biFromNumber(1e15);</span><br><span class="line">hexatrigesimalToChar = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];</span><br><span class="line">hexToChar = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];</span><br><span class="line">highBitMasks = [0, 32768, 49152, 57344, 61440, 63488, 64512, 65024, 65280, 65408, 65472, 65504, 65520, 65528, 65532, 65534, 65535];</span><br><span class="line">lowBitMasks = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535];</span><br><span class="line">setMaxDigits(129);</span><br><span class="line"></span><br><span class="line">var key_to_encode = new RSAKeyPair("010001", "", "978C0A92D2173439707498F0944AA476B1B62595877DD6FA87F6E2AC6DCB3D0BF0B82857439C99B5091192BC134889DFF60C562EC54EFBA4FF2F9D55ADBCCEA4A2FBA80CB398ED501280A007C83AF30C3D1A142D6133C63012B90AB26AC60C898FB66EDC3192C3EC4FF66925A64003B72496099F4F09A9FB72A2CF9E4D770C41");</span><br><span class="line"></span><br><span class="line">function encryptedString(n, t) {</span><br><span class="line">    var e, o, s, h, c, i, f, u, v, l, y;</span><br><span class="line">    if (n.chunkSize &gt; n.digitSize - 11)</span><br><span class="line">        return "Error";</span><br><span class="line">    for (var a = [], p = t.length, r = 0; r &lt; p; )</span><br><span class="line">        a[r] = t.charCodeAt(r),</span><br><span class="line">            r++;</span><br><span class="line">    for (e = a.length,</span><br><span class="line">             o = "",</span><br><span class="line">             r = 0; r &lt; e; r += n.chunkSize) {</span><br><span class="line">        for (c = new BigInt,</span><br><span class="line">                 s = 0,</span><br><span class="line">                 f = r + n.chunkSize &gt; e ? e % n.chunkSize : n.chunkSize,</span><br><span class="line">                 u = [],</span><br><span class="line">                 i = 0; i &lt; f; i++)</span><br><span class="line">            u[i] = a[r + f - 1 - i];</span><br><span class="line">        for (u[f] = 0,</span><br><span class="line">                 v = Math.max(8, n.digitSize - 3 - f),</span><br><span class="line">                 i = 0; i &lt; v; i++)</span><br><span class="line">            u[f + 1 + i] = Math.floor(Math.random() * 254) + 1;</span><br><span class="line">        for (u[n.digitSize - 2] = 2,</span><br><span class="line">                 u[n.digitSize - 1] = 0,</span><br><span class="line">                 h = 0; h &lt; n.digitSize; ++s)</span><br><span class="line">            c.digits[s] = u[h++],</span><br><span class="line">                c.digits[s] += u[h++] &lt;&lt; 8;</span><br><span class="line">        l = n.barrett.powMod(c, n.e);</span><br><span class="line">        y = n.radix == 16 ? biToHex(l) : biToString(l, n.radix);</span><br><span class="line">        o += y + " "</span><br><span class="line">    }</span><br><span class="line">    return o.substring(0, o.length - 1)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var password= encryptedString(key_to_encode, "11111111111")</span><br><span class="line">console.log(password)</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>python面向对象基础</title>
    <url>/2022/09/08/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%20/</url>
    <content><![CDATA[<html><head></head><body><h1 id="python面向对象基础"><a href="#python面向对象基础" class="headerlink" title="python面向对象基础"></a>python面向对象基础</h1><h2 id="init-方法"><a href="#init-方法" class="headerlink" title="init_()方法"></a><em>init</em>_()方法</h2><p><em>init</em><em>()方法又被称为“构造函数”，它有以下4个特性。<br>（1）该方法很特殊。init前后均有双下画线“__”，它的<u>第一个参数必须是“self”</u>，其意义同其他方法一样，而其他参数用于设置实例的属性，数量不限。该方法不能使用return语句。<br>（2）__init</em>_()方法可在类中的任何位置被定义。<br>（3）在由类创建一个新的实例时，该方法被自动调用一次。即每创建一个实例，该方法都会被调用一次。<br>（4）常用该方法定义实例的属性，但定义实例的属性不局限于该方法。换言之，在其他方法中同样可以定义实例的属性。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>实例方法是类中定义的没有加任何装饰符的一般方法，即不加@classmethod和@staticmethod标记的方法。<strong>如果实例方法有n个形式参数，那么在由类调用时，实际参数必须为n个；而在由实例调用时，实际参数则只需要n-1个，因为第一个参数被系统默认为实例本身。由于这个规定，所以，如果实例方法是无参数函数，那么实例无法调用该方法，只有类可以调用它</strong>。因此，实例方法一般至少需要一个参数self，它代表类的对象（实例）</p>
<h2 id="类方法及其装饰符——-classmethod"><a href="#类方法及其装饰符——-classmethod" class="headerlink" title="类方法及其装饰符——@classmethod"></a>类方法及其装饰符——@classmethod</h2><p>@classmethod是一个函数装饰符，用它装饰的方法不是实例方法，而是类方法。类方法只能被类调用，而不能被实例调用，常被用于方法重载。<br>类方法的第一个参数必须是cls，表示类本身；而实例方法的第一个参数是self，表示该类的一个实例。当类由子类继承时，在调用类方法时，传入的类变量cls的实际参数是子类，而非父类。对于类方法，既可由类调用，也可由类的实例调用。<br>假设类方法有n个形式参数，如果由类调用它，则需要传递的实际参数只能为n-1个，第一个参数默认为类本身；如果由实例调用它，则需要传递的实际参数为n个。</p>
<h2 id="静态方法及其装饰符——-staticmethod"><a href="#静态方法及其装饰符——-staticmethod" class="headerlink" title="静态方法及其装饰符——@staticmethod"></a>静态方法及其装饰符——@staticmethod</h2><p>@staticmethod也是一个函数装饰符，用它装饰的方法是静态方法。静态方法属于类方法，不是实例方法，可将它理解成全局函数，因此可被类或类的实例调用。在调用时，它不会被隐式地传入任何参数。也就是说，静态方法可以没有任何参数。例如，举例5中的静态方法show_help()，它在程序中的作用是实现一个类的简单帮助功能。<br>由于静态方法无内定的隐性参数，所以，调用静态方法时的实际参数个数必须与形式参数个数严格一致。<br>为什么要引入静态方法？有时候需要将一组逻辑上相关的函数放在一个类里，便于组织代码。例如，可将类中被其他多个方法调用的通用方法定义为静态方法。一般而言，如果一个方法不需要使用self参数，它就适合被定义为静态方法。</p>
<h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><p>由类的定义可知，如果要向实例传递参数，则必须定义和使用“构造函数”。由此可见构造函数的重要性！<br>那么，构造函数能否被继承、该如何被继承，子类又如何定义自己的属性呢？<br>解决上述问题的办法是，在定义子类的构造函数中显式地调用父类的构造函数，一般来说有两种方式。</p>
<h3 id="1-继承构造函数的第一种方式"><a href="#1-继承构造函数的第一种方式" class="headerlink" title="1.继承构造函数的第一种方式"></a>1.继承构造函数的第一种方式</h3><p>第一种方式是经典方式，它的形式如下：<br>其中，括号内的第一个参数必须为self ，余下的参数即父类的实例属性。例如，Animal.<strong>init</strong>(self,name,sex,classtype)。<br>要特别提醒的是，当以这种方式调用时，第一个参数self必须被显式传递，它不会被隐式传递，即必须为self，如果被省略，则将报错；其余参数则为父类的实例属性，直接复制父类的实例属性即可。<br>此方式既可被用在单继承场合，也可被用在多继承场合。</p>
<h3 id="2-继承构造函数的第二种方式"><a href="#2-继承构造函数的第二种方式" class="headerlink" title="2.继承构造函数的第二种方式"></a>2.继承构造函数的第二种方式</h3><p>第二种方式为新式方式，它的形式如下：<br>其中，内置函数super(子类,self)用于表示子类的父类，它有两个参数——子类与self；而__init__(参数1,参数2, )为构造函数，与第一种方式不同的是，它不需要self参数，所有参数均为父类的实例属性。<br>例如，super(Bird,self).<strong>init</strong>(name,sex,classtype)，此处，<strong>super()的第一个参数是子类，也就是正在定义构造函数的类；第二个参数必须为self，它代表子类的对象。很显然，此方式过于烦琐</strong>，所幸的是，Python 3将上述方式改为更简洁的形式，但两者完全等效，如下：<br>换言之，Python 3的第二种方式采用以下形式：<br>以下简单地介绍内置函数super()的语法形式。<br>其中，<br>· type：类，是一个子类。<br>· object-or-type：一般为self。</p>
<h3 id="3-关于继承的一个重要特性"><a href="#3-关于继承的一个重要特性" class="headerlink" title="3.关于继承的一个重要特性"></a>3.关于继承的一个重要特性</h3><p>如果只是简单地在<strong>子类中定义一个构造函数而不调用父类的构造函数，那么此方式被称为“重构”</strong>。以此方式定义的子类通常无法继承父类的属性和方法。<strong>但是，如果子类不引用父类的任何属性，那么父类的方法可被继承和引用</strong>。<br>举例25：<br>运行上述程序后，得到如下结果：<br>由举例25可知，虽然子类并没有继承父类的构造函数，但由于父类的方法describe()不引用任何属性，因此它可被子类对象b1所调用。<br>综上所述，在定义子类的构造函数时，一般应继承父类的构造函数，这样子类也能拥有父类的所有属性和方法。<br>子类的构造函数继承父类的构造函数的原理（执行过程）如下：<br>实例化对象a → a调用子类__init__() → 子类__init__()继承父类__init__() → 调用父类__init__()。<br>再举一个单继承的例子，以对类的继承问题进行归纳。通过该例，可进一步理解继承的概念及其有关要点。</p>
</body></html>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python逆向_粉笔网</title>
    <url>/2022/09/09/python%E9%80%86%E5%90%91_%E7%B2%89%E7%AC%94%E7%BD%91/</url>
    <content><![CDATA[<html><head></head><body><h1 id="粉笔网密码加密分析"><a href="#粉笔网密码加密分析" class="headerlink" title="粉笔网密码加密分析"></a>粉笔网密码加密分析</h1><p><a href="https://www.fenbi.com/page/home">网址地址</a></p>
<p><img src="https://img1.imgtp.com/2022/09/09/kEeAw9ZO.png" alt="image-20220909184617024.png"></p>
<p>全局搜索password:</p>
<p>会发现会有三个文件此时的判断方法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">这里有两种方法判断加密位置：</span><br><span class="line"></span><br><span class="line">给所有搜索到的结果打上断点，再次刷新看看进入到哪个断点当中</span><br><span class="line"></span><br><span class="line">阅读上下文，分析大概的代码逻辑</span><br></pre></td></tr></tbody></table></figure>

<p>打上断点后定位到：</p>
<p><img src="https://img1.imgtp.com/2022/09/09/rUfazV5K.png" alt="image-20220909185149241.png"></p>
<p>js代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">password: this.encrypt(this.password)</span><br></pre></td></tr></tbody></table></figure>

<p>在控制台打印this.password：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">结果:'123456'</span><br></pre></td></tr></tbody></table></figure>

<p>进入到encrypt后</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">encrypt(n) {</span><br><span class="line">     return window.encrypt(this.publicKey, n)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在控制台打印this.publicKey</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var publicKey = "ANKi9PWuvDOsagwIVvrPx77mXNV0APmjySsYjB1/GtUTY6cyKNRl2RCTt608m9nYk5VeCG2EAZRQmQNQTyfZkw0Uo+MytAkjj17BXOpY4o6+BToi7rRKfTGl6J60/XBZcGSzN1XVZ80ElSjaGE8Ocg8wbPN18tbmsy761zN5SuIl"</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>通过搜索发现这个this.publicKey是写死了的</p>
<p>把鼠标放到这个encrypt上面跳转到一个js文件将其全部复制</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(function(av) {</span><br><span class="line">    function l() {</span><br><span class="line">        this.i = 0;</span><br><span class="line">        this.j = 0;</span><br><span class="line">        this.S = new Array()</span><br><span class="line">    }</span><br><span class="line">    function f(aI) {</span><br><span class="line">        var aH, z, aG;</span><br><span class="line">        for (aH = 0; aH &lt; 256; ++aH) {</span><br><span class="line">            this.S[aH] = aH</span><br><span class="line">        }</span><br><span class="line">        z = 0;</span><br><span class="line">        for (aH = 0; aH &lt; 256; ++aH) {</span><br><span class="line">            z = (z + this.S[aH] + aI[aH % aI.length]) &amp; 255;</span><br><span class="line">            aG = this.S[aH];</span><br><span class="line">            this.S[aH] = this.S[z];</span><br><span class="line">            this.S[z] = aG</span><br><span class="line">        }</span><br><span class="line">        this.i = 0;</span><br><span class="line">        this.j = 0</span><br><span class="line">    }</span><br><span class="line">    function b() {</span><br><span class="line">        var z;</span><br><span class="line">        this.i = (this.i + 1) &amp; 255;</span><br><span class="line">        this.j = (this.j + this.S[this.i]) &amp; 255;</span><br><span class="line">        z = this.S[this.i];</span><br><span class="line">        this.S[this.i] = this.S[this.j];</span><br><span class="line">        this.S[this.j] = z;</span><br><span class="line">        return this.S[(z + this.S[this.i]) &amp; 255]</span><br><span class="line">    }</span><br><span class="line">    l.prototype.init = f;</span><br><span class="line">    l.prototype.next = b;</span><br><span class="line">    function au() {</span><br><span class="line">        return new l()</span><br><span class="line">    }</span><br><span class="line">    var O = 256;</span><br><span class="line">    var n;</span><br><span class="line">    var V;</span><br><span class="line">    var ag;</span><br><span class="line">    function d(t) {</span><br><span class="line">        V[ag++] ^= t &amp; 255;</span><br><span class="line">        V[ag++] ^= (t &gt;&gt; 8) &amp; 255;</span><br><span class="line">        V[ag++] ^= (t &gt;&gt; 16) &amp; 255;</span><br><span class="line">        V[ag++] ^= (t &gt;&gt; 24) &amp; 255;</span><br><span class="line">        if (ag &gt;= O) {</span><br><span class="line">            ag -= O</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function U() {</span><br><span class="line">        d(new Date().getTime())</span><br><span class="line">    }</span><br><span class="line">    if (V == null) {</span><br><span class="line">        V = new Array();</span><br><span class="line">        ag = 0;</span><br><span class="line">        var K;</span><br><span class="line">        if (navigator.appName == "Netscape" &amp;&amp; navigator.appVersion &lt; "5" &amp;&amp; av.crypto) {</span><br><span class="line">            var H = av.crypto.random(32);</span><br><span class="line">            for (K = 0; K &lt; H.length; ++K) {</span><br><span class="line">                V[ag++] = H.charCodeAt(K) &amp; 255</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        while (ag &lt; O) {</span><br><span class="line">            K = Math.floor(65536 * Math.random());</span><br><span class="line">            V[ag++] = K &gt;&gt;&gt; 8;</span><br><span class="line">            V[ag++] = K &amp; 255</span><br><span class="line">        }</span><br><span class="line">        ag = 0;</span><br><span class="line">        U()</span><br><span class="line">    }</span><br><span class="line">    function E() {</span><br><span class="line">        if (n == null) {</span><br><span class="line">            U();</span><br><span class="line">            n = au();</span><br><span class="line">            n.init(V);</span><br><span class="line">            for (ag = 0; ag &lt; V.length; ++ag) {</span><br><span class="line">                V[ag] = 0</span><br><span class="line">            }</span><br><span class="line">            ag = 0</span><br><span class="line">        }</span><br><span class="line">        return n.next()</span><br><span class="line">    }</span><br><span class="line">    function aB(z) {</span><br><span class="line">        var t;</span><br><span class="line">        for (t = 0; t &lt; z.length; ++t) {</span><br><span class="line">            z[t] = E()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function ah() {}</span><br><span class="line">    ah.prototype.nextBytes = aB;</span><br><span class="line">    var aC;</span><br><span class="line">    var an = 244837814094590;</span><br><span class="line">    var ac = ((an &amp; 16777215) == 15715070);</span><br><span class="line">    function ay(z, t, aG) {</span><br><span class="line">        if (z != null) {</span><br><span class="line">            if ("number" == typeof z) {</span><br><span class="line">                this.fromNumber(z, t, aG)</span><br><span class="line">            } else {</span><br><span class="line">                if (t == null &amp;&amp; "string" != typeof z) {</span><br><span class="line">                    this.fromString(z, 256)</span><br><span class="line">                } else {</span><br><span class="line">                    this.fromString(z, t)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function i() {</span><br><span class="line">        return new ay(null)</span><br><span class="line">    }</span><br><span class="line">    function c(aI, t, z, aH, aK, aJ) {</span><br><span class="line">        while (--aJ &gt;= 0) {</span><br><span class="line">            var aG = t * this[aI++] + z[aH] + aK;</span><br><span class="line">            aK = Math.floor(aG / 67108864);</span><br><span class="line">            z[aH++] = aG &amp; 67108863</span><br><span class="line">        }</span><br><span class="line">        return aK</span><br><span class="line">    }</span><br><span class="line">    function aE(aI, aN, aO, aH, aL, t) {</span><br><span class="line">        var aK = aN &amp; 32767</span><br><span class="line">          , aM = aN &gt;&gt; 15;</span><br><span class="line">        while (--t &gt;= 0) {</span><br><span class="line">            var aG = this[aI] &amp; 32767;</span><br><span class="line">            var aJ = this[aI++] &gt;&gt; 15;</span><br><span class="line">            var z = aM * aG + aJ * aK;</span><br><span class="line">            aG = aK * aG + ((z &amp; 32767) &lt;&lt; 15) + aO[aH] + (aL &amp; 1073741823);</span><br><span class="line">            aL = (aG &gt;&gt;&gt; 30) + (z &gt;&gt;&gt; 15) + aM * aJ + (aL &gt;&gt;&gt; 30);</span><br><span class="line">            aO[aH++] = aG &amp; 1073741823</span><br><span class="line">        }</span><br><span class="line">        return aL</span><br><span class="line">    }</span><br><span class="line">    function aD(aI, aN, aO, aH, aL, t) {</span><br><span class="line">        var aK = aN &amp; 16383</span><br><span class="line">          , aM = aN &gt;&gt; 14;</span><br><span class="line">        while (--t &gt;= 0) {</span><br><span class="line">            var aG = this[aI] &amp; 16383;</span><br><span class="line">            var aJ = this[aI++] &gt;&gt; 14;</span><br><span class="line">            var z = aM * aG + aJ * aK;</span><br><span class="line">            aG = aK * aG + ((z &amp; 16383) &lt;&lt; 14) + aO[aH] + aL;</span><br><span class="line">            aL = (aG &gt;&gt; 28) + (z &gt;&gt; 14) + aM * aJ;</span><br><span class="line">            aO[aH++] = aG &amp; 268435455</span><br><span class="line">        }</span><br><span class="line">        return aL</span><br><span class="line">    }</span><br><span class="line">    if (ac &amp;&amp; (navigator.appName == "Microsoft Internet Explorer")) {</span><br><span class="line">        ay.prototype.am = aE;</span><br><span class="line">        aC = 30</span><br><span class="line">    } else {</span><br><span class="line">        if (ac &amp;&amp; (navigator.appName != "Netscape")) {</span><br><span class="line">            ay.prototype.am = c;</span><br><span class="line">            aC = 26</span><br><span class="line">        } else {</span><br><span class="line">            ay.prototype.am = aD;</span><br><span class="line">            aC = 28</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ay.prototype.DB = aC;</span><br><span class="line">    ay.prototype.DM = ((1 &lt;&lt; aC) - 1);</span><br><span class="line">    ay.prototype.DV = (1 &lt;&lt; aC);</span><br><span class="line">    var ae = 52;</span><br><span class="line">    ay.prototype.FV = Math.pow(2, ae);</span><br><span class="line">    ay.prototype.F1 = ae - aC;</span><br><span class="line">    ay.prototype.F2 = 2 * aC - ae;</span><br><span class="line">    var aj = "0123456789abcdefghijklmnopqrstuvwxyz";</span><br><span class="line">    var al = new Array();</span><br><span class="line">    var aw, x;</span><br><span class="line">    aw = "0".charCodeAt(0);</span><br><span class="line">    for (x = 0; x &lt;= 9; ++x) {</span><br><span class="line">        al[aw++] = x</span><br><span class="line">    }</span><br><span class="line">    aw = "a".charCodeAt(0);</span><br><span class="line">    for (x = 10; x &lt; 36; ++x) {</span><br><span class="line">        al[aw++] = x</span><br><span class="line">    }</span><br><span class="line">    aw = "A".charCodeAt(0);</span><br><span class="line">    for (x = 10; x &lt; 36; ++x) {</span><br><span class="line">        al[aw++] = x</span><br><span class="line">    }</span><br><span class="line">    function aF(t) {</span><br><span class="line">        return aj.charAt(t)</span><br><span class="line">    }</span><br><span class="line">    function C(z, t) {</span><br><span class="line">        var aG = al[z.charCodeAt(t)];</span><br><span class="line">        return (aG == null) ? -1 : aG</span><br><span class="line">    }</span><br><span class="line">    function ab(z) {</span><br><span class="line">        for (var t = this.t - 1; t &gt;= 0; --t) {</span><br><span class="line">            z[t] = this[t]</span><br><span class="line">        }</span><br><span class="line">        z.t = this.t;</span><br><span class="line">        z.s = this.s</span><br><span class="line">    }</span><br><span class="line">    function o(t) {</span><br><span class="line">        this.t = 1;</span><br><span class="line">        this.s = (t &lt; 0) ? -1 : 0;</span><br><span class="line">        if (t &gt; 0) {</span><br><span class="line">            this[0] = t</span><br><span class="line">        } else {</span><br><span class="line">            if (t &lt; -1) {</span><br><span class="line">                this[0] = t + DV</span><br><span class="line">            } else {</span><br><span class="line">                this.t = 0</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function e(t) {</span><br><span class="line">        var z = i();</span><br><span class="line">        z.fromInt(t);</span><br><span class="line">        return z</span><br><span class="line">    }</span><br><span class="line">    function y(aK, z) {</span><br><span class="line">        var aH;</span><br><span class="line">        if (z == 16) {</span><br><span class="line">            aH = 4</span><br><span class="line">        } else {</span><br><span class="line">            if (z == 8) {</span><br><span class="line">                aH = 3</span><br><span class="line">            } else {</span><br><span class="line">                if (z == 256) {</span><br><span class="line">                    aH = 8</span><br><span class="line">                } else {</span><br><span class="line">                    if (z == 2) {</span><br><span class="line">                        aH = 1</span><br><span class="line">                    } else {</span><br><span class="line">                        if (z == 32) {</span><br><span class="line">                            aH = 5</span><br><span class="line">                        } else {</span><br><span class="line">                            if (z == 4) {</span><br><span class="line">                                aH = 2</span><br><span class="line">                            } else {</span><br><span class="line">                                this.fromRadix(aK, z);</span><br><span class="line">                                return</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        this.t = 0;</span><br><span class="line">        this.s = 0;</span><br><span class="line">        var aJ = aK.length</span><br><span class="line">          , aG = false</span><br><span class="line">          , aI = 0;</span><br><span class="line">        while (--aJ &gt;= 0) {</span><br><span class="line">            var t = (aH == 8) ? aK[aJ] &amp; 255 : C(aK, aJ);</span><br><span class="line">            if (t &lt; 0) {</span><br><span class="line">                if (aK.charAt(aJ) == "-") {</span><br><span class="line">                    aG = true</span><br><span class="line">                }</span><br><span class="line">                continue</span><br><span class="line">            }</span><br><span class="line">            aG = false;</span><br><span class="line">            if (aI == 0) {</span><br><span class="line">                this[this.t++] = t</span><br><span class="line">            } else {</span><br><span class="line">                if (aI + aH &gt; this.DB) {</span><br><span class="line">                    this[this.t - 1] |= (t &amp; ((1 &lt;&lt; (this.DB - aI)) - 1)) &lt;&lt; aI;</span><br><span class="line">                    this[this.t++] = (t &gt;&gt; (this.DB - aI))</span><br><span class="line">                } else {</span><br><span class="line">                    this[this.t - 1] |= t &lt;&lt; aI</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            aI += aH;</span><br><span class="line">            if (aI &gt;= this.DB) {</span><br><span class="line">                aI -= this.DB</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if (aH == 8 &amp;&amp; (aK[0] &amp; 128) != 0) {</span><br><span class="line">            this.s = -1;</span><br><span class="line">            if (aI &gt; 0) {</span><br><span class="line">                this[this.t - 1] |= ((1 &lt;&lt; (this.DB - aI)) - 1) &lt;&lt; aI</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        this.clamp();</span><br><span class="line">        if (aG) {</span><br><span class="line">            ay.ZERO.subTo(this, this)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function Q() {</span><br><span class="line">        var t = this.s &amp; this.DM;</span><br><span class="line">        while (this.t &gt; 0 &amp;&amp; this[this.t - 1] == t) {</span><br><span class="line">            --this.t</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function r(z) {</span><br><span class="line">        if (this.s &lt; 0) {</span><br><span class="line">            return "-" + this.negate().toString(z)</span><br><span class="line">        }</span><br><span class="line">        var aG;</span><br><span class="line">        if (z == 16) {</span><br><span class="line">            aG = 4</span><br><span class="line">        } else {</span><br><span class="line">            if (z == 8) {</span><br><span class="line">                aG = 3</span><br><span class="line">            } else {</span><br><span class="line">                if (z == 2) {</span><br><span class="line">                    aG = 1</span><br><span class="line">                } else {</span><br><span class="line">                    if (z == 32) {</span><br><span class="line">                        aG = 5</span><br><span class="line">                    } else {</span><br><span class="line">                        if (z == 4) {</span><br><span class="line">                            aG = 2</span><br><span class="line">                        } else {</span><br><span class="line">                            return this.toRadix(z)</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        var aI = (1 &lt;&lt; aG) - 1, aL, t = false, aJ = "", aH = this.t;</span><br><span class="line">        var aK = this.DB - (aH * this.DB) % aG;</span><br><span class="line">        if (aH-- &gt; 0) {</span><br><span class="line">            if (aK &lt; this.DB &amp;&amp; (aL = this[aH] &gt;&gt; aK) &gt; 0) {</span><br><span class="line">                t = true;</span><br><span class="line">                aJ = aF(aL)</span><br><span class="line">            }</span><br><span class="line">            while (aH &gt;= 0) {</span><br><span class="line">                if (aK &lt; aG) {</span><br><span class="line">                    aL = (this[aH] &amp; ((1 &lt;&lt; aK) - 1)) &lt;&lt; (aG - aK);</span><br><span class="line">                    aL |= this[--aH] &gt;&gt; (aK += this.DB - aG)</span><br><span class="line">                } else {</span><br><span class="line">                    aL = (this[aH] &gt;&gt; (aK -= aG)) &amp; aI;</span><br><span class="line">                    if (aK &lt;= 0) {</span><br><span class="line">                        aK += this.DB;</span><br><span class="line">                        --aH</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                if (aL &gt; 0) {</span><br><span class="line">                    t = true</span><br><span class="line">                }</span><br><span class="line">                if (t) {</span><br><span class="line">                    aJ += aF(aL)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return t ? aJ : "0"</span><br><span class="line">    }</span><br><span class="line">    function T() {</span><br><span class="line">        var t = i();</span><br><span class="line">        ay.ZERO.subTo(this, t);</span><br><span class="line">        return t</span><br><span class="line">    }</span><br><span class="line">    function aq() {</span><br><span class="line">        return (this.s &lt; 0) ? this.negate() : this</span><br><span class="line">    }</span><br><span class="line">    function I(t) {</span><br><span class="line">        var aG = this.s - t.s;</span><br><span class="line">        if (aG != 0) {</span><br><span class="line">            return aG</span><br><span class="line">        }</span><br><span class="line">        var z = this.t;</span><br><span class="line">        aG = z - t.t;</span><br><span class="line">        if (aG != 0) {</span><br><span class="line">            return aG</span><br><span class="line">        }</span><br><span class="line">        while (--z &gt;= 0) {</span><br><span class="line">            if ((aG = this[z] - t[z]) != 0) {</span><br><span class="line">                return aG</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line">    function k(z) {</span><br><span class="line">        var aH = 1, aG;</span><br><span class="line">        if ((aG = z &gt;&gt;&gt; 16) != 0) {</span><br><span class="line">            z = aG;</span><br><span class="line">            aH += 16</span><br><span class="line">        }</span><br><span class="line">        if ((aG = z &gt;&gt; 8) != 0) {</span><br><span class="line">            z = aG;</span><br><span class="line">            aH += 8</span><br><span class="line">        }</span><br><span class="line">        if ((aG = z &gt;&gt; 4) != 0) {</span><br><span class="line">            z = aG;</span><br><span class="line">            aH += 4</span><br><span class="line">        }</span><br><span class="line">        if ((aG = z &gt;&gt; 2) != 0) {</span><br><span class="line">            z = aG;</span><br><span class="line">            aH += 2</span><br><span class="line">        }</span><br><span class="line">        if ((aG = z &gt;&gt; 1) != 0) {</span><br><span class="line">            z = aG;</span><br><span class="line">            aH += 1</span><br><span class="line">        }</span><br><span class="line">        return aH</span><br><span class="line">    }</span><br><span class="line">    function w() {</span><br><span class="line">        if (this.t &lt;= 0) {</span><br><span class="line">            return 0</span><br><span class="line">        }</span><br><span class="line">        return this.DB * (this.t - 1) + k(this[this.t - 1] ^ (this.s &amp; this.DM))</span><br><span class="line">    }</span><br><span class="line">    function ax(aG, z) {</span><br><span class="line">        var t;</span><br><span class="line">        for (t = this.t - 1; t &gt;= 0; --t) {</span><br><span class="line">            z[t + aG] = this[t]</span><br><span class="line">        }</span><br><span class="line">        for (t = aG - 1; t &gt;= 0; --t) {</span><br><span class="line">            z[t] = 0</span><br><span class="line">        }</span><br><span class="line">        z.t = this.t + aG;</span><br><span class="line">        z.s = this.s</span><br><span class="line">    }</span><br><span class="line">    function aa(aG, z) {</span><br><span class="line">        for (var t = aG; t &lt; this.t; ++t) {</span><br><span class="line">            z[t - aG] = this[t]</span><br><span class="line">        }</span><br><span class="line">        z.t = Math.max(this.t - aG, 0);</span><br><span class="line">        z.s = this.s</span><br><span class="line">    }</span><br><span class="line">    function u(aL, aH) {</span><br><span class="line">        var z = aL % this.DB;</span><br><span class="line">        var t = this.DB - z;</span><br><span class="line">        var aJ = (1 &lt;&lt; t) - 1;</span><br><span class="line">        var aI = Math.floor(aL / this.DB), aK = (this.s &lt;&lt; z) &amp; this.DM, aG;</span><br><span class="line">        for (aG = this.t - 1; aG &gt;= 0; --aG) {</span><br><span class="line">            aH[aG + aI + 1] = (this[aG] &gt;&gt; t) | aK;</span><br><span class="line">            aK = (this[aG] &amp; aJ) &lt;&lt; z</span><br><span class="line">        }</span><br><span class="line">        for (aG = aI - 1; aG &gt;= 0; --aG) {</span><br><span class="line">            aH[aG] = 0</span><br><span class="line">        }</span><br><span class="line">        aH[aI] = aK;</span><br><span class="line">        aH.t = this.t + aI + 1;</span><br><span class="line">        aH.s = this.s;</span><br><span class="line">        aH.clamp()</span><br><span class="line">    }</span><br><span class="line">    function m(aK, aH) {</span><br><span class="line">        aH.s = this.s;</span><br><span class="line">        var aI = Math.floor(aK / this.DB);</span><br><span class="line">        if (aI &gt;= this.t) {</span><br><span class="line">            aH.t = 0;</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        var z = aK % this.DB;</span><br><span class="line">        var t = this.DB - z;</span><br><span class="line">        var aJ = (1 &lt;&lt; z) - 1;</span><br><span class="line">        aH[0] = this[aI] &gt;&gt; z;</span><br><span class="line">        for (var aG = aI + 1; aG &lt; this.t; ++aG) {</span><br><span class="line">            aH[aG - aI - 1] |= (this[aG] &amp; aJ) &lt;&lt; t;</span><br><span class="line">            aH[aG - aI] = this[aG] &gt;&gt; z</span><br><span class="line">        }</span><br><span class="line">        if (z &gt; 0) {</span><br><span class="line">            aH[this.t - aI - 1] |= (this.s &amp; aJ) &lt;&lt; t</span><br><span class="line">        }</span><br><span class="line">        aH.t = this.t - aI;</span><br><span class="line">        aH.clamp()</span><br><span class="line">    }</span><br><span class="line">    function af(z, aH) {</span><br><span class="line">        var aG = 0</span><br><span class="line">          , aI = 0</span><br><span class="line">          , t = Math.min(z.t, this.t);</span><br><span class="line">        while (aG &lt; t) {</span><br><span class="line">            aI += this[aG] - z[aG];</span><br><span class="line">            aH[aG++] = aI &amp; this.DM;</span><br><span class="line">            aI &gt;&gt;= this.DB</span><br><span class="line">        }</span><br><span class="line">        if (z.t &lt; this.t) {</span><br><span class="line">            aI -= z.s;</span><br><span class="line">            while (aG &lt; this.t) {</span><br><span class="line">                aI += this[aG];</span><br><span class="line">                aH[aG++] = aI &amp; this.DM;</span><br><span class="line">                aI &gt;&gt;= this.DB</span><br><span class="line">            }</span><br><span class="line">            aI += this.s</span><br><span class="line">        } else {</span><br><span class="line">            aI += this.s;</span><br><span class="line">            while (aG &lt; z.t) {</span><br><span class="line">                aI -= z[aG];</span><br><span class="line">                aH[aG++] = aI &amp; this.DM;</span><br><span class="line">                aI &gt;&gt;= this.DB</span><br><span class="line">            }</span><br><span class="line">            aI -= z.s</span><br><span class="line">        }</span><br><span class="line">        aH.s = (aI &lt; 0) ? -1 : 0;</span><br><span class="line">        if (aI &lt; -1) {</span><br><span class="line">            aH[aG++] = this.DV + aI</span><br><span class="line">        } else {</span><br><span class="line">            if (aI &gt; 0) {</span><br><span class="line">                aH[aG++] = aI</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        aH.t = aG;</span><br><span class="line">        aH.clamp()</span><br><span class="line">    }</span><br><span class="line">    function F(z, aH) {</span><br><span class="line">        var t = this.abs()</span><br><span class="line">          , aI = z.abs();</span><br><span class="line">        var aG = t.t;</span><br><span class="line">        aH.t = aG + aI.t;</span><br><span class="line">        while (--aG &gt;= 0) {</span><br><span class="line">            aH[aG] = 0</span><br><span class="line">        }</span><br><span class="line">        for (aG = 0; aG &lt; aI.t; ++aG) {</span><br><span class="line">            aH[aG + t.t] = t.am(0, aI[aG], aH, aG, 0, t.t)</span><br><span class="line">        }</span><br><span class="line">        aH.s = 0;</span><br><span class="line">        aH.clamp();</span><br><span class="line">        if (this.s != z.s) {</span><br><span class="line">            ay.ZERO.subTo(aH, aH)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function S(aG) {</span><br><span class="line">        var t = this.abs();</span><br><span class="line">        var z = aG.t = 2 * t.t;</span><br><span class="line">        while (--z &gt;= 0) {</span><br><span class="line">            aG[z] = 0</span><br><span class="line">        }</span><br><span class="line">        for (z = 0; z &lt; t.t - 1; ++z) {</span><br><span class="line">            var aH = t.am(z, t[z], aG, 2 * z, 0, 1);</span><br><span class="line">            if ((aG[z + t.t] += t.am(z + 1, 2 * t[z], aG, 2 * z + 1, aH, t.t - z - 1)) &gt;= t.DV) {</span><br><span class="line">                aG[z + t.t] -= t.DV;</span><br><span class="line">                aG[z + t.t + 1] = 1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if (aG.t &gt; 0) {</span><br><span class="line">            aG[aG.t - 1] += t.am(z, t[z], aG, 2 * z, 0, 1)</span><br><span class="line">        }</span><br><span class="line">        aG.s = 0;</span><br><span class="line">        aG.clamp()</span><br><span class="line">    }</span><br><span class="line">    function G(aO, aL, aK) {</span><br><span class="line">        var aU = aO.abs();</span><br><span class="line">        if (aU.t &lt;= 0) {</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        var aM = this.abs();</span><br><span class="line">        if (aM.t &lt; aU.t) {</span><br><span class="line">            if (aL != null) {</span><br><span class="line">                aL.fromInt(0)</span><br><span class="line">            }</span><br><span class="line">            if (aK != null) {</span><br><span class="line">                this.copyTo(aK)</span><br><span class="line">            }</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        if (aK == null) {</span><br><span class="line">            aK = i()</span><br><span class="line">        }</span><br><span class="line">        var aI = i()</span><br><span class="line">          , z = this.s</span><br><span class="line">          , aN = aO.s;</span><br><span class="line">        var aT = this.DB - k(aU[aU.t - 1]);</span><br><span class="line">        if (aT &gt; 0) {</span><br><span class="line">            aU.lShiftTo(aT, aI);</span><br><span class="line">            aM.lShiftTo(aT, aK)</span><br><span class="line">        } else {</span><br><span class="line">            aU.copyTo(aI);</span><br><span class="line">            aM.copyTo(aK)</span><br><span class="line">        }</span><br><span class="line">        var aQ = aI.t;</span><br><span class="line">        var aG = aI[aQ - 1];</span><br><span class="line">        if (aG == 0) {</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        var aP = aG * (1 &lt;&lt; this.F1) + ((aQ &gt; 1) ? aI[aQ - 2] &gt;&gt; this.F2 : 0);</span><br><span class="line">        var aX = this.FV / aP</span><br><span class="line">          , aW = (1 &lt;&lt; this.F1) / aP</span><br><span class="line">          , aV = 1 &lt;&lt; this.F2;</span><br><span class="line">        var aS = aK.t</span><br><span class="line">          , aR = aS - aQ</span><br><span class="line">          , aJ = (aL == null) ? i() : aL;</span><br><span class="line">        aI.dlShiftTo(aR, aJ);</span><br><span class="line">        if (aK.compareTo(aJ) &gt;= 0) {</span><br><span class="line">            aK[aK.t++] = 1;</span><br><span class="line">            aK.subTo(aJ, aK)</span><br><span class="line">        }</span><br><span class="line">        ay.ONE.dlShiftTo(aQ, aJ);</span><br><span class="line">        aJ.subTo(aI, aI);</span><br><span class="line">        while (aI.t &lt; aQ) {</span><br><span class="line">            aI[aI.t++] = 0</span><br><span class="line">        }</span><br><span class="line">        while (--aR &gt;= 0) {</span><br><span class="line">            var aH = (aK[--aS] == aG) ? this.DM : Math.floor(aK[aS] * aX + (aK[aS - 1] + aV) * aW);</span><br><span class="line">            if ((aK[aS] += aI.am(0, aH, aK, aR, 0, aQ)) &lt; aH) {</span><br><span class="line">                aI.dlShiftTo(aR, aJ);</span><br><span class="line">                aK.subTo(aJ, aK);</span><br><span class="line">                while (aK[aS] &lt; --aH) {</span><br><span class="line">                    aK.subTo(aJ, aK)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if (aL != null) {</span><br><span class="line">            aK.drShiftTo(aQ, aL);</span><br><span class="line">            if (z != aN) {</span><br><span class="line">                ay.ZERO.subTo(aL, aL)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        aK.t = aQ;</span><br><span class="line">        aK.clamp();</span><br><span class="line">        if (aT &gt; 0) {</span><br><span class="line">            aK.rShiftTo(aT, aK)</span><br><span class="line">        }</span><br><span class="line">        if (z &lt; 0) {</span><br><span class="line">            ay.ZERO.subTo(aK, aK)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function P(t) {</span><br><span class="line">        var z = i();</span><br><span class="line">        this.abs().divRemTo(t, null, z);</span><br><span class="line">        if (this.s &lt; 0 &amp;&amp; z.compareTo(ay.ZERO) &gt; 0) {</span><br><span class="line">            t.subTo(z, z)</span><br><span class="line">        }</span><br><span class="line">        return z</span><br><span class="line">    }</span><br><span class="line">    function M(t) {</span><br><span class="line">        this.m = t</span><br><span class="line">    }</span><br><span class="line">    function X(t) {</span><br><span class="line">        if (t.s &lt; 0 || t.compareTo(this.m) &gt;= 0) {</span><br><span class="line">            return t.mod(this.m)</span><br><span class="line">        } else {</span><br><span class="line">            return t</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function ap(t) {</span><br><span class="line">        return t</span><br><span class="line">    }</span><br><span class="line">    function L(t) {</span><br><span class="line">        t.divRemTo(this.m, null, t)</span><br><span class="line">    }</span><br><span class="line">    function J(t, aG, z) {</span><br><span class="line">        t.multiplyTo(aG, z);</span><br><span class="line">        this.reduce(z)</span><br><span class="line">    }</span><br><span class="line">    function aA(t, z) {</span><br><span class="line">        t.squareTo(z);</span><br><span class="line">        this.reduce(z)</span><br><span class="line">    }</span><br><span class="line">    M.prototype.convert = X;</span><br><span class="line">    M.prototype.revert = ap;</span><br><span class="line">    M.prototype.reduce = L;</span><br><span class="line">    M.prototype.mulTo = J;</span><br><span class="line">    M.prototype.sqrTo = aA;</span><br><span class="line">    function D() {</span><br><span class="line">        if (this.t &lt; 1) {</span><br><span class="line">            return 0</span><br><span class="line">        }</span><br><span class="line">        var t = this[0];</span><br><span class="line">        if ((t &amp; 1) == 0) {</span><br><span class="line">            return 0</span><br><span class="line">        }</span><br><span class="line">        var z = t &amp; 3;</span><br><span class="line">        z = (z * (2 - (t &amp; 15) * z)) &amp; 15;</span><br><span class="line">        z = (z * (2 - (t &amp; 255) * z)) &amp; 255;</span><br><span class="line">        z = (z * (2 - (((t &amp; 65535) * z) &amp; 65535))) &amp; 65535;</span><br><span class="line">        z = (z * (2 - t * z % this.DV)) % this.DV;</span><br><span class="line">        return (z &gt; 0) ? this.DV - z : -z</span><br><span class="line">    }</span><br><span class="line">    function g(t) {</span><br><span class="line">        this.m = t;</span><br><span class="line">        this.mp = t.invDigit();</span><br><span class="line">        this.mpl = this.mp &amp; 32767;</span><br><span class="line">        this.mph = this.mp &gt;&gt; 15;</span><br><span class="line">        this.um = (1 &lt;&lt; (t.DB - 15)) - 1;</span><br><span class="line">        this.mt2 = 2 * t.t</span><br><span class="line">    }</span><br><span class="line">    function ao(t) {</span><br><span class="line">        var z = i();</span><br><span class="line">        t.abs().dlShiftTo(this.m.t, z);</span><br><span class="line">        z.divRemTo(this.m, null, z);</span><br><span class="line">        if (t.s &lt; 0 &amp;&amp; z.compareTo(ay.ZERO) &gt; 0) {</span><br><span class="line">            this.m.subTo(z, z)</span><br><span class="line">        }</span><br><span class="line">        return z</span><br><span class="line">    }</span><br><span class="line">    function az(t) {</span><br><span class="line">        var z = i();</span><br><span class="line">        t.copyTo(z);</span><br><span class="line">        this.reduce(z);</span><br><span class="line">        return z</span><br><span class="line">    }</span><br><span class="line">    function R(t) {</span><br><span class="line">        while (t.t &lt;= this.mt2) {</span><br><span class="line">            t[t.t++] = 0</span><br><span class="line">        }</span><br><span class="line">        for (var aG = 0; aG &lt; this.m.t; ++aG) {</span><br><span class="line">            var z = t[aG] &amp; 32767;</span><br><span class="line">            var aH = (z * this.mpl + (((z * this.mph + (t[aG] &gt;&gt; 15) * this.mpl) &amp; this.um) &lt;&lt; 15)) &amp; t.DM;</span><br><span class="line">            z = aG + this.m.t;</span><br><span class="line">            t[z] += this.m.am(0, aH, t, aG, 0, this.m.t);</span><br><span class="line">            while (t[z] &gt;= t.DV) {</span><br><span class="line">                t[z] -= t.DV;</span><br><span class="line">                t[++z]++</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        t.clamp();</span><br><span class="line">        t.drShiftTo(this.m.t, t);</span><br><span class="line">        if (t.compareTo(this.m) &gt;= 0) {</span><br><span class="line">            t.subTo(this.m, t)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function ar(t, z) {</span><br><span class="line">        t.squareTo(z);</span><br><span class="line">        this.reduce(z)</span><br><span class="line">    }</span><br><span class="line">    function B(t, aG, z) {</span><br><span class="line">        t.multiplyTo(aG, z);</span><br><span class="line">        this.reduce(z)</span><br><span class="line">    }</span><br><span class="line">    g.prototype.convert = ao;</span><br><span class="line">    g.prototype.revert = az;</span><br><span class="line">    g.prototype.reduce = R;</span><br><span class="line">    g.prototype.mulTo = B;</span><br><span class="line">    g.prototype.sqrTo = ar;</span><br><span class="line">    function j() {</span><br><span class="line">        return ((this.t &gt; 0) ? (this[0] &amp; 1) : this.s) == 0</span><br><span class="line">    }</span><br><span class="line">    function A(aL, aM) {</span><br><span class="line">        if (aL &gt; 4294967295 || aL &lt; 1) {</span><br><span class="line">            return ay.ONE</span><br><span class="line">        }</span><br><span class="line">        var aK = i()</span><br><span class="line">          , aG = i()</span><br><span class="line">          , aJ = aM.convert(this)</span><br><span class="line">          , aI = k(aL) - 1;</span><br><span class="line">        aJ.copyTo(aK);</span><br><span class="line">        while (--aI &gt;= 0) {</span><br><span class="line">            aM.sqrTo(aK, aG);</span><br><span class="line">            if ((aL &amp; (1 &lt;&lt; aI)) &gt; 0) {</span><br><span class="line">                aM.mulTo(aG, aJ, aK)</span><br><span class="line">            } else {</span><br><span class="line">                var aH = aK;</span><br><span class="line">                aK = aG;</span><br><span class="line">                aG = aH</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return aM.revert(aK)</span><br><span class="line">    }</span><br><span class="line">    function at(aG, t) {</span><br><span class="line">        var aH;</span><br><span class="line">        if (aG &lt; 256 || t.isEven()) {</span><br><span class="line">            aH = new M(t)</span><br><span class="line">        } else {</span><br><span class="line">            aH = new g(t)</span><br><span class="line">        }</span><br><span class="line">        return this.exp(aG, aH)</span><br><span class="line">    }</span><br><span class="line">    ay.prototype.copyTo = ab;</span><br><span class="line">    ay.prototype.fromInt = o;</span><br><span class="line">    ay.prototype.fromString = y;</span><br><span class="line">    ay.prototype.clamp = Q;</span><br><span class="line">    ay.prototype.dlShiftTo = ax;</span><br><span class="line">    ay.prototype.drShiftTo = aa;</span><br><span class="line">    ay.prototype.lShiftTo = u;</span><br><span class="line">    ay.prototype.rShiftTo = m;</span><br><span class="line">    ay.prototype.subTo = af;</span><br><span class="line">    ay.prototype.multiplyTo = F;</span><br><span class="line">    ay.prototype.squareTo = S;</span><br><span class="line">    ay.prototype.divRemTo = G;</span><br><span class="line">    ay.prototype.invDigit = D;</span><br><span class="line">    ay.prototype.isEven = j;</span><br><span class="line">    ay.prototype.exp = A;</span><br><span class="line">    ay.prototype.toString = r;</span><br><span class="line">    ay.prototype.negate = T;</span><br><span class="line">    ay.prototype.abs = aq;</span><br><span class="line">    ay.prototype.compareTo = I;</span><br><span class="line">    ay.prototype.bitLength = w;</span><br><span class="line">    ay.prototype.mod = P;</span><br><span class="line">    ay.prototype.modPowInt = at;</span><br><span class="line">    ay.ZERO = e(0);</span><br><span class="line">    ay.ONE = e(1);</span><br><span class="line">    function h(z, t) {</span><br><span class="line">        return new ay(z,t)</span><br><span class="line">    }</span><br><span class="line">    function am(aG, aH) {</span><br><span class="line">        var t = "";</span><br><span class="line">        var z = 0;</span><br><span class="line">        while (z + aH &lt; aG.length) {</span><br><span class="line">            t += aG.substring(z, z + aH) + "\n";</span><br><span class="line">            z += aH</span><br><span class="line">        }</span><br><span class="line">        return t + aG.substring(z, aG.length)</span><br><span class="line">    }</span><br><span class="line">    function s(t) {</span><br><span class="line">        if (t &lt; 16) {</span><br><span class="line">            return "0" + t.toString(16)</span><br><span class="line">        } else {</span><br><span class="line">            return t.toString(16)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function ak(aH, aK) {</span><br><span class="line">        if (aK &lt; aH.length + 11) {</span><br><span class="line">            alert("Message too long for RSA");</span><br><span class="line">            return null</span><br><span class="line">        }</span><br><span class="line">        var aJ = new Array();</span><br><span class="line">        var aG = aH.length - 1;</span><br><span class="line">        while (aG &gt;= 0 &amp;&amp; aK &gt; 0) {</span><br><span class="line">            var aI = aH.charCodeAt(aG--);</span><br><span class="line">            if (aI &lt; 128) {</span><br><span class="line">                aJ[--aK] = aI</span><br><span class="line">            } else {</span><br><span class="line">                if ((aI &gt; 127) &amp;&amp; (aI &lt; 2048)) {</span><br><span class="line">                    aJ[--aK] = (aI &amp; 63) | 128;</span><br><span class="line">                    aJ[--aK] = (aI &gt;&gt; 6) | 192</span><br><span class="line">                } else {</span><br><span class="line">                    aJ[--aK] = (aI &amp; 63) | 128;</span><br><span class="line">                    aJ[--aK] = ((aI &gt;&gt; 6) &amp; 63) | 128;</span><br><span class="line">                    aJ[--aK] = (aI &gt;&gt; 12) | 224</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        aJ[--aK] = 0;</span><br><span class="line">        var z = new ah();</span><br><span class="line">        var t = new Array();</span><br><span class="line">        while (aK &gt; 2) {</span><br><span class="line">            t[0] = 0;</span><br><span class="line">            while (t[0] == 0) {</span><br><span class="line">                z.nextBytes(t)</span><br><span class="line">            }</span><br><span class="line">            aJ[--aK] = t[0]</span><br><span class="line">        }</span><br><span class="line">        aJ[--aK] = 2;</span><br><span class="line">        aJ[--aK] = 0;</span><br><span class="line">        return new ay(aJ)</span><br><span class="line">    }</span><br><span class="line">    function N() {</span><br><span class="line">        this.n = null;</span><br><span class="line">        this.e = 0;</span><br><span class="line">        this.d = null;</span><br><span class="line">        this.p = null;</span><br><span class="line">        this.q = null;</span><br><span class="line">        this.dmp1 = null;</span><br><span class="line">        this.dmq1 = null;</span><br><span class="line">        this.coeff = null</span><br><span class="line">    }</span><br><span class="line">    function p(z, t) {</span><br><span class="line">        if (z != null &amp;&amp; t != null &amp;&amp; z.length &gt; 0 &amp;&amp; t.length &gt; 0) {</span><br><span class="line">            this.n = h(z, 16);</span><br><span class="line">            this.e = parseInt(t, 16)</span><br><span class="line">        } else {</span><br><span class="line">            alert("Invalid RSA public key")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    function Z(t) {</span><br><span class="line">        return t.modPowInt(this.e, this.n)</span><br><span class="line">    }</span><br><span class="line">    function q(aG) {</span><br><span class="line">        var t = ak(aG, (this.n.bitLength() + 7) &gt;&gt; 3);</span><br><span class="line">        if (t == null) {</span><br><span class="line">            return null</span><br><span class="line">        }</span><br><span class="line">        var aH = this.doPublic(t);</span><br><span class="line">        if (aH == null) {</span><br><span class="line">            return null</span><br><span class="line">        }</span><br><span class="line">        var z = aH.toString(16);</span><br><span class="line">        if ((z.length &amp; 1) == 0) {</span><br><span class="line">            return z</span><br><span class="line">        } else {</span><br><span class="line">            return "0" + z</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    N.prototype.doPublic = Z;</span><br><span class="line">    N.prototype.setPublic = p;</span><br><span class="line">    N.prototype.encrypt = q;</span><br><span class="line">    var ad = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";</span><br><span class="line">    var Y = "=";</span><br><span class="line">    function ai(aG) {</span><br><span class="line">        var z;</span><br><span class="line">        var aH;</span><br><span class="line">        var t = "";</span><br><span class="line">        for (z = 0; z + 3 &lt;= aG.length; z += 3) {</span><br><span class="line">            aH = parseInt(aG.substring(z, z + 3), 16);</span><br><span class="line">            t += ad.charAt(aH &gt;&gt; 6) + ad.charAt(aH &amp; 63)</span><br><span class="line">        }</span><br><span class="line">        if (z + 1 == aG.length) {</span><br><span class="line">            aH = parseInt(aG.substring(z, z + 1), 16);</span><br><span class="line">            t += ad.charAt(aH &lt;&lt; 2)</span><br><span class="line">        } else {</span><br><span class="line">            if (z + 2 == aG.length) {</span><br><span class="line">                aH = parseInt(aG.substring(z, z + 2), 16);</span><br><span class="line">                t += ad.charAt(aH &gt;&gt; 2) + ad.charAt((aH &amp; 3) &lt;&lt; 4)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        while ((t.length &amp; 3) &gt; 0) {</span><br><span class="line">            t += Y</span><br><span class="line">        }</span><br><span class="line">        return t</span><br><span class="line">    }</span><br><span class="line">    function a(aI) {</span><br><span class="line">        var aG = "";</span><br><span class="line">        var aH;</span><br><span class="line">        var t = 0;</span><br><span class="line">        var z;</span><br><span class="line">        for (aH = 0; aH &lt; aI.length; ++aH) {</span><br><span class="line">            if (aI.charAt(aH) == Y) {</span><br><span class="line">                break</span><br><span class="line">            }</span><br><span class="line">            v = ad.indexOf(aI.charAt(aH));</span><br><span class="line">            if (v &lt; 0) {</span><br><span class="line">                continue</span><br><span class="line">            }</span><br><span class="line">            if (t == 0) {</span><br><span class="line">                aG += aF(v &gt;&gt; 2);</span><br><span class="line">                z = v &amp; 3;</span><br><span class="line">                t = 1</span><br><span class="line">            } else {</span><br><span class="line">                if (t == 1) {</span><br><span class="line">                    aG += aF((z &lt;&lt; 2) | (v &gt;&gt; 4));</span><br><span class="line">                    z = v &amp; 15;</span><br><span class="line">                    t = 2</span><br><span class="line">                } else {</span><br><span class="line">                    if (t == 2) {</span><br><span class="line">                        aG += aF(z);</span><br><span class="line">                        aG += aF(v &gt;&gt; 2);</span><br><span class="line">                        z = v &amp; 3;</span><br><span class="line">                        t = 3</span><br><span class="line">                    } else {</span><br><span class="line">                        aG += aF((z &lt;&lt; 2) | (v &gt;&gt; 4));</span><br><span class="line">                        aG += aF(v &amp; 15);</span><br><span class="line">                        t = 0</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if (t == 1) {</span><br><span class="line">            aG += aF(z &lt;&lt; 2)</span><br><span class="line">        }</span><br><span class="line">        return aG</span><br><span class="line">    }</span><br><span class="line">    function W(aH) {</span><br><span class="line">        var aG = a(aH);</span><br><span class="line">        var z;</span><br><span class="line">        var t = new Array();</span><br><span class="line">        for (z = 0; 2 * z &lt; aG.length; ++z) {</span><br><span class="line">            t[z] = parseInt(aG.substring(2 * z, 2 * z + 2), 16)</span><br><span class="line">        }</span><br><span class="line">        return t</span><br><span class="line">    }</span><br><span class="line">    av.encrypt = function(aG, z) {</span><br><span class="line">        var t = new N();</span><br><span class="line">        t.setPublic(a(aG), "10001");</span><br><span class="line">        return ai(t.encrypt(z))</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">)(window);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>完整代码:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var window = {}</span><br><span class="line">var navigator = {}</span><br><span class="line">!(function(av) {</span><br><span class="line">        function l() {</span><br><span class="line">            this.i = 0;</span><br><span class="line">            this.j = 0;</span><br><span class="line">            this.S = new Array()</span><br><span class="line">        }</span><br><span class="line">        function f(aI) {</span><br><span class="line">            var aH, z, aG;</span><br><span class="line">            for (aH = 0; aH &lt; 256; ++aH) {</span><br><span class="line">                this.S[aH] = aH</span><br><span class="line">            }</span><br><span class="line">            z = 0;</span><br><span class="line">            for (aH = 0; aH &lt; 256; ++aH) {</span><br><span class="line">                z = (z + this.S[aH] + aI[aH % aI.length]) &amp; 255;</span><br><span class="line">                aG = this.S[aH];</span><br><span class="line">                this.S[aH] = this.S[z];</span><br><span class="line">                this.S[z] = aG</span><br><span class="line">            }</span><br><span class="line">            this.i = 0;</span><br><span class="line">            this.j = 0</span><br><span class="line">        }</span><br><span class="line">        function b() {</span><br><span class="line">            var z;</span><br><span class="line">            this.i = (this.i + 1) &amp; 255;</span><br><span class="line">            this.j = (this.j + this.S[this.i]) &amp; 255;</span><br><span class="line">            z = this.S[this.i];</span><br><span class="line">            this.S[this.i] = this.S[this.j];</span><br><span class="line">            this.S[this.j] = z;</span><br><span class="line">            return this.S[(z + this.S[this.i]) &amp; 255]</span><br><span class="line">        }</span><br><span class="line">        l.prototype.init = f;</span><br><span class="line">        l.prototype.next = b;</span><br><span class="line">        function au() {</span><br><span class="line">            return new l()</span><br><span class="line">        }</span><br><span class="line">        var O = 256;</span><br><span class="line">        var n;</span><br><span class="line">        var V;</span><br><span class="line">        var ag;</span><br><span class="line">        function d(t) {</span><br><span class="line">            V[ag++] ^= t &amp; 255;</span><br><span class="line">            V[ag++] ^= (t &gt;&gt; 8) &amp; 255;</span><br><span class="line">            V[ag++] ^= (t &gt;&gt; 16) &amp; 255;</span><br><span class="line">            V[ag++] ^= (t &gt;&gt; 24) &amp; 255;</span><br><span class="line">            if (ag &gt;= O) {</span><br><span class="line">                ag -= O</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function U() {</span><br><span class="line">            d(new Date().getTime())</span><br><span class="line">        }</span><br><span class="line">        if (V == null) {</span><br><span class="line">            V = new Array();</span><br><span class="line">            ag = 0;</span><br><span class="line">            var K;</span><br><span class="line">            if (navigator.appName == "Netscape" &amp;&amp; navigator.appVersion &lt; "5" &amp;&amp; av.crypto) {</span><br><span class="line">                var H = av.crypto.random(32);</span><br><span class="line">                for (K = 0; K &lt; H.length; ++K) {</span><br><span class="line">                    V[ag++] = H.charCodeAt(K) &amp; 255</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            while (ag &lt; O) {</span><br><span class="line">                K = Math.floor(65536 * Math.random());</span><br><span class="line">                V[ag++] = K &gt;&gt;&gt; 8;</span><br><span class="line">                V[ag++] = K &amp; 255</span><br><span class="line">            }</span><br><span class="line">            ag = 0;</span><br><span class="line">            U()</span><br><span class="line">        }</span><br><span class="line">        function E() {</span><br><span class="line">            if (n == null) {</span><br><span class="line">                U();</span><br><span class="line">                n = au();</span><br><span class="line">                n.init(V);</span><br><span class="line">                for (ag = 0; ag &lt; V.length; ++ag) {</span><br><span class="line">                    V[ag] = 0</span><br><span class="line">                }</span><br><span class="line">                ag = 0</span><br><span class="line">            }</span><br><span class="line">            return n.next()</span><br><span class="line">        }</span><br><span class="line">        function aB(z) {</span><br><span class="line">            var t;</span><br><span class="line">            for (t = 0; t &lt; z.length; ++t) {</span><br><span class="line">                z[t] = E()</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function ah() {}</span><br><span class="line">        ah.prototype.nextBytes = aB;</span><br><span class="line">        var aC;</span><br><span class="line">        var an = 244837814094590;</span><br><span class="line">        var ac = ((an &amp; 16777215) == 15715070);</span><br><span class="line">        function ay(z, t, aG) {</span><br><span class="line">            if (z != null) {</span><br><span class="line">                if ("number" == typeof z) {</span><br><span class="line">                    this.fromNumber(z, t, aG)</span><br><span class="line">                } else {</span><br><span class="line">                    if (t == null &amp;&amp; "string" != typeof z) {</span><br><span class="line">                        this.fromString(z, 256)</span><br><span class="line">                    } else {</span><br><span class="line">                        this.fromString(z, t)</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function i() {</span><br><span class="line">            return new ay(null)</span><br><span class="line">        }</span><br><span class="line">        function c(aI, t, z, aH, aK, aJ) {</span><br><span class="line">            while (--aJ &gt;= 0) {</span><br><span class="line">                var aG = t * this[aI++] + z[aH] + aK;</span><br><span class="line">                aK = Math.floor(aG / 67108864);</span><br><span class="line">                z[aH++] = aG &amp; 67108863</span><br><span class="line">            }</span><br><span class="line">            return aK</span><br><span class="line">        }</span><br><span class="line">        function aE(aI, aN, aO, aH, aL, t) {</span><br><span class="line">            var aK = aN &amp; 32767</span><br><span class="line">                , aM = aN &gt;&gt; 15;</span><br><span class="line">            while (--t &gt;= 0) {</span><br><span class="line">                var aG = this[aI] &amp; 32767;</span><br><span class="line">                var aJ = this[aI++] &gt;&gt; 15;</span><br><span class="line">                var z = aM * aG + aJ * aK;</span><br><span class="line">                aG = aK * aG + ((z &amp; 32767) &lt;&lt; 15) + aO[aH] + (aL &amp; 1073741823);</span><br><span class="line">                aL = (aG &gt;&gt;&gt; 30) + (z &gt;&gt;&gt; 15) + aM * aJ + (aL &gt;&gt;&gt; 30);</span><br><span class="line">                aO[aH++] = aG &amp; 1073741823</span><br><span class="line">            }</span><br><span class="line">            return aL</span><br><span class="line">        }</span><br><span class="line">        function aD(aI, aN, aO, aH, aL, t) {</span><br><span class="line">            var aK = aN &amp; 16383</span><br><span class="line">                , aM = aN &gt;&gt; 14;</span><br><span class="line">            while (--t &gt;= 0) {</span><br><span class="line">                var aG = this[aI] &amp; 16383;</span><br><span class="line">                var aJ = this[aI++] &gt;&gt; 14;</span><br><span class="line">                var z = aM * aG + aJ * aK;</span><br><span class="line">                aG = aK * aG + ((z &amp; 16383) &lt;&lt; 14) + aO[aH] + aL;</span><br><span class="line">                aL = (aG &gt;&gt; 28) + (z &gt;&gt; 14) + aM * aJ;</span><br><span class="line">                aO[aH++] = aG &amp; 268435455</span><br><span class="line">            }</span><br><span class="line">            return aL</span><br><span class="line">        }</span><br><span class="line">        if (ac &amp;&amp; (navigator.appName == "Microsoft Internet Explorer")) {</span><br><span class="line">            ay.prototype.am = aE;</span><br><span class="line">            aC = 30</span><br><span class="line">        } else {</span><br><span class="line">            if (ac &amp;&amp; (navigator.appName != "Netscape")) {</span><br><span class="line">                ay.prototype.am = c;</span><br><span class="line">                aC = 26</span><br><span class="line">            } else {</span><br><span class="line">                ay.prototype.am = aD;</span><br><span class="line">                aC = 28</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ay.prototype.DB = aC;</span><br><span class="line">        ay.prototype.DM = ((1 &lt;&lt; aC) - 1);</span><br><span class="line">        ay.prototype.DV = (1 &lt;&lt; aC);</span><br><span class="line">        var ae = 52;</span><br><span class="line">        ay.prototype.FV = Math.pow(2, ae);</span><br><span class="line">        ay.prototype.F1 = ae - aC;</span><br><span class="line">        ay.prototype.F2 = 2 * aC - ae;</span><br><span class="line">        var aj = "0123456789abcdefghijklmnopqrstuvwxyz";</span><br><span class="line">        var al = new Array();</span><br><span class="line">        var aw, x;</span><br><span class="line">        aw = "0".charCodeAt(0);</span><br><span class="line">        for (x = 0; x &lt;= 9; ++x) {</span><br><span class="line">            al[aw++] = x</span><br><span class="line">        }</span><br><span class="line">        aw = "a".charCodeAt(0);</span><br><span class="line">        for (x = 10; x &lt; 36; ++x) {</span><br><span class="line">            al[aw++] = x</span><br><span class="line">        }</span><br><span class="line">        aw = "A".charCodeAt(0);</span><br><span class="line">        for (x = 10; x &lt; 36; ++x) {</span><br><span class="line">            al[aw++] = x</span><br><span class="line">        }</span><br><span class="line">        function aF(t) {</span><br><span class="line">            return aj.charAt(t)</span><br><span class="line">        }</span><br><span class="line">        function C(z, t) {</span><br><span class="line">            var aG = al[z.charCodeAt(t)];</span><br><span class="line">            return (aG == null) ? -1 : aG</span><br><span class="line">        }</span><br><span class="line">        function ab(z) {</span><br><span class="line">            for (var t = this.t - 1; t &gt;= 0; --t) {</span><br><span class="line">                z[t] = this[t]</span><br><span class="line">            }</span><br><span class="line">            z.t = this.t;</span><br><span class="line">            z.s = this.s</span><br><span class="line">        }</span><br><span class="line">        function o(t) {</span><br><span class="line">            this.t = 1;</span><br><span class="line">            this.s = (t &lt; 0) ? -1 : 0;</span><br><span class="line">            if (t &gt; 0) {</span><br><span class="line">                this[0] = t</span><br><span class="line">            } else {</span><br><span class="line">                if (t &lt; -1) {</span><br><span class="line">                    this[0] = t + DV</span><br><span class="line">                } else {</span><br><span class="line">                    this.t = 0</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function e(t) {</span><br><span class="line">            var z = i();</span><br><span class="line">            z.fromInt(t);</span><br><span class="line">            return z</span><br><span class="line">        }</span><br><span class="line">        function y(aK, z) {</span><br><span class="line">            var aH;</span><br><span class="line">            if (z == 16) {</span><br><span class="line">                aH = 4</span><br><span class="line">            } else {</span><br><span class="line">                if (z == 8) {</span><br><span class="line">                    aH = 3</span><br><span class="line">                } else {</span><br><span class="line">                    if (z == 256) {</span><br><span class="line">                        aH = 8</span><br><span class="line">                    } else {</span><br><span class="line">                        if (z == 2) {</span><br><span class="line">                            aH = 1</span><br><span class="line">                        } else {</span><br><span class="line">                            if (z == 32) {</span><br><span class="line">                                aH = 5</span><br><span class="line">                            } else {</span><br><span class="line">                                if (z == 4) {</span><br><span class="line">                                    aH = 2</span><br><span class="line">                                } else {</span><br><span class="line">                                    this.fromRadix(aK, z);</span><br><span class="line">                                    return</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            this.t = 0;</span><br><span class="line">            this.s = 0;</span><br><span class="line">            var aJ = aK.length</span><br><span class="line">                , aG = false</span><br><span class="line">                , aI = 0;</span><br><span class="line">            while (--aJ &gt;= 0) {</span><br><span class="line">                var t = (aH == 8) ? aK[aJ] &amp; 255 : C(aK, aJ);</span><br><span class="line">                if (t &lt; 0) {</span><br><span class="line">                    if (aK.charAt(aJ) == "-") {</span><br><span class="line">                        aG = true</span><br><span class="line">                    }</span><br><span class="line">                    continue</span><br><span class="line">                }</span><br><span class="line">                aG = false;</span><br><span class="line">                if (aI == 0) {</span><br><span class="line">                    this[this.t++] = t</span><br><span class="line">                } else {</span><br><span class="line">                    if (aI + aH &gt; this.DB) {</span><br><span class="line">                        this[this.t - 1] |= (t &amp; ((1 &lt;&lt; (this.DB - aI)) - 1)) &lt;&lt; aI;</span><br><span class="line">                        this[this.t++] = (t &gt;&gt; (this.DB - aI))</span><br><span class="line">                    } else {</span><br><span class="line">                        this[this.t - 1] |= t &lt;&lt; aI</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                aI += aH;</span><br><span class="line">                if (aI &gt;= this.DB) {</span><br><span class="line">                    aI -= this.DB</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            if (aH == 8 &amp;&amp; (aK[0] &amp; 128) != 0) {</span><br><span class="line">                this.s = -1;</span><br><span class="line">                if (aI &gt; 0) {</span><br><span class="line">                    this[this.t - 1] |= ((1 &lt;&lt; (this.DB - aI)) - 1) &lt;&lt; aI</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            this.clamp();</span><br><span class="line">            if (aG) {</span><br><span class="line">                ay.ZERO.subTo(this, this)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function Q() {</span><br><span class="line">            var t = this.s &amp; this.DM;</span><br><span class="line">            while (this.t &gt; 0 &amp;&amp; this[this.t - 1] == t) {</span><br><span class="line">                --this.t</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function r(z) {</span><br><span class="line">            if (this.s &lt; 0) {</span><br><span class="line">                return "-" + this.negate().toString(z)</span><br><span class="line">            }</span><br><span class="line">            var aG;</span><br><span class="line">            if (z == 16) {</span><br><span class="line">                aG = 4</span><br><span class="line">            } else {</span><br><span class="line">                if (z == 8) {</span><br><span class="line">                    aG = 3</span><br><span class="line">                } else {</span><br><span class="line">                    if (z == 2) {</span><br><span class="line">                        aG = 1</span><br><span class="line">                    } else {</span><br><span class="line">                        if (z == 32) {</span><br><span class="line">                            aG = 5</span><br><span class="line">                        } else {</span><br><span class="line">                            if (z == 4) {</span><br><span class="line">                                aG = 2</span><br><span class="line">                            } else {</span><br><span class="line">                                return this.toRadix(z)</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            var aI = (1 &lt;&lt; aG) - 1, aL, t = false, aJ = "", aH = this.t;</span><br><span class="line">            var aK = this.DB - (aH * this.DB) % aG;</span><br><span class="line">            if (aH-- &gt; 0) {</span><br><span class="line">                if (aK &lt; this.DB &amp;&amp; (aL = this[aH] &gt;&gt; aK) &gt; 0) {</span><br><span class="line">                    t = true;</span><br><span class="line">                    aJ = aF(aL)</span><br><span class="line">                }</span><br><span class="line">                while (aH &gt;= 0) {</span><br><span class="line">                    if (aK &lt; aG) {</span><br><span class="line">                        aL = (this[aH] &amp; ((1 &lt;&lt; aK) - 1)) &lt;&lt; (aG - aK);</span><br><span class="line">                        aL |= this[--aH] &gt;&gt; (aK += this.DB - aG)</span><br><span class="line">                    } else {</span><br><span class="line">                        aL = (this[aH] &gt;&gt; (aK -= aG)) &amp; aI;</span><br><span class="line">                        if (aK &lt;= 0) {</span><br><span class="line">                            aK += this.DB;</span><br><span class="line">                            --aH</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    if (aL &gt; 0) {</span><br><span class="line">                        t = true</span><br><span class="line">                    }</span><br><span class="line">                    if (t) {</span><br><span class="line">                        aJ += aF(aL)</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            return t ? aJ : "0"</span><br><span class="line">        }</span><br><span class="line">        function T() {</span><br><span class="line">            var t = i();</span><br><span class="line">            ay.ZERO.subTo(this, t);</span><br><span class="line">            return t</span><br><span class="line">        }</span><br><span class="line">        function aq() {</span><br><span class="line">            return (this.s &lt; 0) ? this.negate() : this</span><br><span class="line">        }</span><br><span class="line">        function I(t) {</span><br><span class="line">            var aG = this.s - t.s;</span><br><span class="line">            if (aG != 0) {</span><br><span class="line">                return aG</span><br><span class="line">            }</span><br><span class="line">            var z = this.t;</span><br><span class="line">            aG = z - t.t;</span><br><span class="line">            if (aG != 0) {</span><br><span class="line">                return aG</span><br><span class="line">            }</span><br><span class="line">            while (--z &gt;= 0) {</span><br><span class="line">                if ((aG = this[z] - t[z]) != 0) {</span><br><span class="line">                    return aG</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            return 0</span><br><span class="line">        }</span><br><span class="line">        function k(z) {</span><br><span class="line">            var aH = 1, aG;</span><br><span class="line">            if ((aG = z &gt;&gt;&gt; 16) != 0) {</span><br><span class="line">                z = aG;</span><br><span class="line">                aH += 16</span><br><span class="line">            }</span><br><span class="line">            if ((aG = z &gt;&gt; 8) != 0) {</span><br><span class="line">                z = aG;</span><br><span class="line">                aH += 8</span><br><span class="line">            }</span><br><span class="line">            if ((aG = z &gt;&gt; 4) != 0) {</span><br><span class="line">                z = aG;</span><br><span class="line">                aH += 4</span><br><span class="line">            }</span><br><span class="line">            if ((aG = z &gt;&gt; 2) != 0) {</span><br><span class="line">                z = aG;</span><br><span class="line">                aH += 2</span><br><span class="line">            }</span><br><span class="line">            if ((aG = z &gt;&gt; 1) != 0) {</span><br><span class="line">                z = aG;</span><br><span class="line">                aH += 1</span><br><span class="line">            }</span><br><span class="line">            return aH</span><br><span class="line">        }</span><br><span class="line">        function w() {</span><br><span class="line">            if (this.t &lt;= 0) {</span><br><span class="line">                return 0</span><br><span class="line">            }</span><br><span class="line">            return this.DB * (this.t - 1) + k(this[this.t - 1] ^ (this.s &amp; this.DM))</span><br><span class="line">        }</span><br><span class="line">        function ax(aG, z) {</span><br><span class="line">            var t;</span><br><span class="line">            for (t = this.t - 1; t &gt;= 0; --t) {</span><br><span class="line">                z[t + aG] = this[t]</span><br><span class="line">            }</span><br><span class="line">            for (t = aG - 1; t &gt;= 0; --t) {</span><br><span class="line">                z[t] = 0</span><br><span class="line">            }</span><br><span class="line">            z.t = this.t + aG;</span><br><span class="line">            z.s = this.s</span><br><span class="line">        }</span><br><span class="line">        function aa(aG, z) {</span><br><span class="line">            for (var t = aG; t &lt; this.t; ++t) {</span><br><span class="line">                z[t - aG] = this[t]</span><br><span class="line">            }</span><br><span class="line">            z.t = Math.max(this.t - aG, 0);</span><br><span class="line">            z.s = this.s</span><br><span class="line">        }</span><br><span class="line">        function u(aL, aH) {</span><br><span class="line">            var z = aL % this.DB;</span><br><span class="line">            var t = this.DB - z;</span><br><span class="line">            var aJ = (1 &lt;&lt; t) - 1;</span><br><span class="line">            var aI = Math.floor(aL / this.DB), aK = (this.s &lt;&lt; z) &amp; this.DM, aG;</span><br><span class="line">            for (aG = this.t - 1; aG &gt;= 0; --aG) {</span><br><span class="line">                aH[aG + aI + 1] = (this[aG] &gt;&gt; t) | aK;</span><br><span class="line">                aK = (this[aG] &amp; aJ) &lt;&lt; z</span><br><span class="line">            }</span><br><span class="line">            for (aG = aI - 1; aG &gt;= 0; --aG) {</span><br><span class="line">                aH[aG] = 0</span><br><span class="line">            }</span><br><span class="line">            aH[aI] = aK;</span><br><span class="line">            aH.t = this.t + aI + 1;</span><br><span class="line">            aH.s = this.s;</span><br><span class="line">            aH.clamp()</span><br><span class="line">        }</span><br><span class="line">        function m(aK, aH) {</span><br><span class="line">            aH.s = this.s;</span><br><span class="line">            var aI = Math.floor(aK / this.DB);</span><br><span class="line">            if (aI &gt;= this.t) {</span><br><span class="line">                aH.t = 0;</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line">            var z = aK % this.DB;</span><br><span class="line">            var t = this.DB - z;</span><br><span class="line">            var aJ = (1 &lt;&lt; z) - 1;</span><br><span class="line">            aH[0] = this[aI] &gt;&gt; z;</span><br><span class="line">            for (var aG = aI + 1; aG &lt; this.t; ++aG) {</span><br><span class="line">                aH[aG - aI - 1] |= (this[aG] &amp; aJ) &lt;&lt; t;</span><br><span class="line">                aH[aG - aI] = this[aG] &gt;&gt; z</span><br><span class="line">            }</span><br><span class="line">            if (z &gt; 0) {</span><br><span class="line">                aH[this.t - aI - 1] |= (this.s &amp; aJ) &lt;&lt; t</span><br><span class="line">            }</span><br><span class="line">            aH.t = this.t - aI;</span><br><span class="line">            aH.clamp()</span><br><span class="line">        }</span><br><span class="line">        function af(z, aH) {</span><br><span class="line">            var aG = 0</span><br><span class="line">                , aI = 0</span><br><span class="line">                , t = Math.min(z.t, this.t);</span><br><span class="line">            while (aG &lt; t) {</span><br><span class="line">                aI += this[aG] - z[aG];</span><br><span class="line">                aH[aG++] = aI &amp; this.DM;</span><br><span class="line">                aI &gt;&gt;= this.DB</span><br><span class="line">            }</span><br><span class="line">            if (z.t &lt; this.t) {</span><br><span class="line">                aI -= z.s;</span><br><span class="line">                while (aG &lt; this.t) {</span><br><span class="line">                    aI += this[aG];</span><br><span class="line">                    aH[aG++] = aI &amp; this.DM;</span><br><span class="line">                    aI &gt;&gt;= this.DB</span><br><span class="line">                }</span><br><span class="line">                aI += this.s</span><br><span class="line">            } else {</span><br><span class="line">                aI += this.s;</span><br><span class="line">                while (aG &lt; z.t) {</span><br><span class="line">                    aI -= z[aG];</span><br><span class="line">                    aH[aG++] = aI &amp; this.DM;</span><br><span class="line">                    aI &gt;&gt;= this.DB</span><br><span class="line">                }</span><br><span class="line">                aI -= z.s</span><br><span class="line">            }</span><br><span class="line">            aH.s = (aI &lt; 0) ? -1 : 0;</span><br><span class="line">            if (aI &lt; -1) {</span><br><span class="line">                aH[aG++] = this.DV + aI</span><br><span class="line">            } else {</span><br><span class="line">                if (aI &gt; 0) {</span><br><span class="line">                    aH[aG++] = aI</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            aH.t = aG;</span><br><span class="line">            aH.clamp()</span><br><span class="line">        }</span><br><span class="line">        function F(z, aH) {</span><br><span class="line">            var t = this.abs()</span><br><span class="line">                , aI = z.abs();</span><br><span class="line">            var aG = t.t;</span><br><span class="line">            aH.t = aG + aI.t;</span><br><span class="line">            while (--aG &gt;= 0) {</span><br><span class="line">                aH[aG] = 0</span><br><span class="line">            }</span><br><span class="line">            for (aG = 0; aG &lt; aI.t; ++aG) {</span><br><span class="line">                aH[aG + t.t] = t.am(0, aI[aG], aH, aG, 0, t.t)</span><br><span class="line">            }</span><br><span class="line">            aH.s = 0;</span><br><span class="line">            aH.clamp();</span><br><span class="line">            if (this.s != z.s) {</span><br><span class="line">                ay.ZERO.subTo(aH, aH)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function S(aG) {</span><br><span class="line">            var t = this.abs();</span><br><span class="line">            var z = aG.t = 2 * t.t;</span><br><span class="line">            while (--z &gt;= 0) {</span><br><span class="line">                aG[z] = 0</span><br><span class="line">            }</span><br><span class="line">            for (z = 0; z &lt; t.t - 1; ++z) {</span><br><span class="line">                var aH = t.am(z, t[z], aG, 2 * z, 0, 1);</span><br><span class="line">                if ((aG[z + t.t] += t.am(z + 1, 2 * t[z], aG, 2 * z + 1, aH, t.t - z - 1)) &gt;= t.DV) {</span><br><span class="line">                    aG[z + t.t] -= t.DV;</span><br><span class="line">                    aG[z + t.t + 1] = 1</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            if (aG.t &gt; 0) {</span><br><span class="line">                aG[aG.t - 1] += t.am(z, t[z], aG, 2 * z, 0, 1)</span><br><span class="line">            }</span><br><span class="line">            aG.s = 0;</span><br><span class="line">            aG.clamp()</span><br><span class="line">        }</span><br><span class="line">        function G(aO, aL, aK) {</span><br><span class="line">            var aU = aO.abs();</span><br><span class="line">            if (aU.t &lt;= 0) {</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line">            var aM = this.abs();</span><br><span class="line">            if (aM.t &lt; aU.t) {</span><br><span class="line">                if (aL != null) {</span><br><span class="line">                    aL.fromInt(0)</span><br><span class="line">                }</span><br><span class="line">                if (aK != null) {</span><br><span class="line">                    this.copyTo(aK)</span><br><span class="line">                }</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line">            if (aK == null) {</span><br><span class="line">                aK = i()</span><br><span class="line">            }</span><br><span class="line">            var aI = i()</span><br><span class="line">                , z = this.s</span><br><span class="line">                , aN = aO.s;</span><br><span class="line">            var aT = this.DB - k(aU[aU.t - 1]);</span><br><span class="line">            if (aT &gt; 0) {</span><br><span class="line">                aU.lShiftTo(aT, aI);</span><br><span class="line">                aM.lShiftTo(aT, aK)</span><br><span class="line">            } else {</span><br><span class="line">                aU.copyTo(aI);</span><br><span class="line">                aM.copyTo(aK)</span><br><span class="line">            }</span><br><span class="line">            var aQ = aI.t;</span><br><span class="line">            var aG = aI[aQ - 1];</span><br><span class="line">            if (aG == 0) {</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line">            var aP = aG * (1 &lt;&lt; this.F1) + ((aQ &gt; 1) ? aI[aQ - 2] &gt;&gt; this.F2 : 0);</span><br><span class="line">            var aX = this.FV / aP</span><br><span class="line">                , aW = (1 &lt;&lt; this.F1) / aP</span><br><span class="line">                , aV = 1 &lt;&lt; this.F2;</span><br><span class="line">            var aS = aK.t</span><br><span class="line">                , aR = aS - aQ</span><br><span class="line">                , aJ = (aL == null) ? i() : aL;</span><br><span class="line">            aI.dlShiftTo(aR, aJ);</span><br><span class="line">            if (aK.compareTo(aJ) &gt;= 0) {</span><br><span class="line">                aK[aK.t++] = 1;</span><br><span class="line">                aK.subTo(aJ, aK)</span><br><span class="line">            }</span><br><span class="line">            ay.ONE.dlShiftTo(aQ, aJ);</span><br><span class="line">            aJ.subTo(aI, aI);</span><br><span class="line">            while (aI.t &lt; aQ) {</span><br><span class="line">                aI[aI.t++] = 0</span><br><span class="line">            }</span><br><span class="line">            while (--aR &gt;= 0) {</span><br><span class="line">                var aH = (aK[--aS] == aG) ? this.DM : Math.floor(aK[aS] * aX + (aK[aS - 1] + aV) * aW);</span><br><span class="line">                if ((aK[aS] += aI.am(0, aH, aK, aR, 0, aQ)) &lt; aH) {</span><br><span class="line">                    aI.dlShiftTo(aR, aJ);</span><br><span class="line">                    aK.subTo(aJ, aK);</span><br><span class="line">                    while (aK[aS] &lt; --aH) {</span><br><span class="line">                        aK.subTo(aJ, aK)</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            if (aL != null) {</span><br><span class="line">                aK.drShiftTo(aQ, aL);</span><br><span class="line">                if (z != aN) {</span><br><span class="line">                    ay.ZERO.subTo(aL, aL)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            aK.t = aQ;</span><br><span class="line">            aK.clamp();</span><br><span class="line">            if (aT &gt; 0) {</span><br><span class="line">                aK.rShiftTo(aT, aK)</span><br><span class="line">            }</span><br><span class="line">            if (z &lt; 0) {</span><br><span class="line">                ay.ZERO.subTo(aK, aK)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function P(t) {</span><br><span class="line">            var z = i();</span><br><span class="line">            this.abs().divRemTo(t, null, z);</span><br><span class="line">            if (this.s &lt; 0 &amp;&amp; z.compareTo(ay.ZERO) &gt; 0) {</span><br><span class="line">                t.subTo(z, z)</span><br><span class="line">            }</span><br><span class="line">            return z</span><br><span class="line">        }</span><br><span class="line">        function M(t) {</span><br><span class="line">            this.m = t</span><br><span class="line">        }</span><br><span class="line">        function X(t) {</span><br><span class="line">            if (t.s &lt; 0 || t.compareTo(this.m) &gt;= 0) {</span><br><span class="line">                return t.mod(this.m)</span><br><span class="line">            } else {</span><br><span class="line">                return t</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function ap(t) {</span><br><span class="line">            return t</span><br><span class="line">        }</span><br><span class="line">        function L(t) {</span><br><span class="line">            t.divRemTo(this.m, null, t)</span><br><span class="line">        }</span><br><span class="line">        function J(t, aG, z) {</span><br><span class="line">            t.multiplyTo(aG, z);</span><br><span class="line">            this.reduce(z)</span><br><span class="line">        }</span><br><span class="line">        function aA(t, z) {</span><br><span class="line">            t.squareTo(z);</span><br><span class="line">            this.reduce(z)</span><br><span class="line">        }</span><br><span class="line">        M.prototype.convert = X;</span><br><span class="line">        M.prototype.revert = ap;</span><br><span class="line">        M.prototype.reduce = L;</span><br><span class="line">        M.prototype.mulTo = J;</span><br><span class="line">        M.prototype.sqrTo = aA;</span><br><span class="line">        function D() {</span><br><span class="line">            if (this.t &lt; 1) {</span><br><span class="line">                return 0</span><br><span class="line">            }</span><br><span class="line">            var t = this[0];</span><br><span class="line">            if ((t &amp; 1) == 0) {</span><br><span class="line">                return 0</span><br><span class="line">            }</span><br><span class="line">            var z = t &amp; 3;</span><br><span class="line">            z = (z * (2 - (t &amp; 15) * z)) &amp; 15;</span><br><span class="line">            z = (z * (2 - (t &amp; 255) * z)) &amp; 255;</span><br><span class="line">            z = (z * (2 - (((t &amp; 65535) * z) &amp; 65535))) &amp; 65535;</span><br><span class="line">            z = (z * (2 - t * z % this.DV)) % this.DV;</span><br><span class="line">            return (z &gt; 0) ? this.DV - z : -z</span><br><span class="line">        }</span><br><span class="line">        function g(t) {</span><br><span class="line">            this.m = t;</span><br><span class="line">            this.mp = t.invDigit();</span><br><span class="line">            this.mpl = this.mp &amp; 32767;</span><br><span class="line">            this.mph = this.mp &gt;&gt; 15;</span><br><span class="line">            this.um = (1 &lt;&lt; (t.DB - 15)) - 1;</span><br><span class="line">            this.mt2 = 2 * t.t</span><br><span class="line">        }</span><br><span class="line">        function ao(t) {</span><br><span class="line">            var z = i();</span><br><span class="line">            t.abs().dlShiftTo(this.m.t, z);</span><br><span class="line">            z.divRemTo(this.m, null, z);</span><br><span class="line">            if (t.s &lt; 0 &amp;&amp; z.compareTo(ay.ZERO) &gt; 0) {</span><br><span class="line">                this.m.subTo(z, z)</span><br><span class="line">            }</span><br><span class="line">            return z</span><br><span class="line">        }</span><br><span class="line">        function az(t) {</span><br><span class="line">            var z = i();</span><br><span class="line">            t.copyTo(z);</span><br><span class="line">            this.reduce(z);</span><br><span class="line">            return z</span><br><span class="line">        }</span><br><span class="line">        function R(t) {</span><br><span class="line">            while (t.t &lt;= this.mt2) {</span><br><span class="line">                t[t.t++] = 0</span><br><span class="line">            }</span><br><span class="line">            for (var aG = 0; aG &lt; this.m.t; ++aG) {</span><br><span class="line">                var z = t[aG] &amp; 32767;</span><br><span class="line">                var aH = (z * this.mpl + (((z * this.mph + (t[aG] &gt;&gt; 15) * this.mpl) &amp; this.um) &lt;&lt; 15)) &amp; t.DM;</span><br><span class="line">                z = aG + this.m.t;</span><br><span class="line">                t[z] += this.m.am(0, aH, t, aG, 0, this.m.t);</span><br><span class="line">                while (t[z] &gt;= t.DV) {</span><br><span class="line">                    t[z] -= t.DV;</span><br><span class="line">                    t[++z]++</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            t.clamp();</span><br><span class="line">            t.drShiftTo(this.m.t, t);</span><br><span class="line">            if (t.compareTo(this.m) &gt;= 0) {</span><br><span class="line">                t.subTo(this.m, t)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function ar(t, z) {</span><br><span class="line">            t.squareTo(z);</span><br><span class="line">            this.reduce(z)</span><br><span class="line">        }</span><br><span class="line">        function B(t, aG, z) {</span><br><span class="line">            t.multiplyTo(aG, z);</span><br><span class="line">            this.reduce(z)</span><br><span class="line">        }</span><br><span class="line">        g.prototype.convert = ao;</span><br><span class="line">        g.prototype.revert = az;</span><br><span class="line">        g.prototype.reduce = R;</span><br><span class="line">        g.prototype.mulTo = B;</span><br><span class="line">        g.prototype.sqrTo = ar;</span><br><span class="line">        function j() {</span><br><span class="line">            return ((this.t &gt; 0) ? (this[0] &amp; 1) : this.s) == 0</span><br><span class="line">        }</span><br><span class="line">        function A(aL, aM) {</span><br><span class="line">            if (aL &gt; 4294967295 || aL &lt; 1) {</span><br><span class="line">                return ay.ONE</span><br><span class="line">            }</span><br><span class="line">            var aK = i()</span><br><span class="line">                , aG = i()</span><br><span class="line">                , aJ = aM.convert(this)</span><br><span class="line">                , aI = k(aL) - 1;</span><br><span class="line">            aJ.copyTo(aK);</span><br><span class="line">            while (--aI &gt;= 0) {</span><br><span class="line">                aM.sqrTo(aK, aG);</span><br><span class="line">                if ((aL &amp; (1 &lt;&lt; aI)) &gt; 0) {</span><br><span class="line">                    aM.mulTo(aG, aJ, aK)</span><br><span class="line">                } else {</span><br><span class="line">                    var aH = aK;</span><br><span class="line">                    aK = aG;</span><br><span class="line">                    aG = aH</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            return aM.revert(aK)</span><br><span class="line">        }</span><br><span class="line">        function at(aG, t) {</span><br><span class="line">            var aH;</span><br><span class="line">            if (aG &lt; 256 || t.isEven()) {</span><br><span class="line">                aH = new M(t)</span><br><span class="line">            } else {</span><br><span class="line">                aH = new g(t)</span><br><span class="line">            }</span><br><span class="line">            return this.exp(aG, aH)</span><br><span class="line">        }</span><br><span class="line">        ay.prototype.copyTo = ab;</span><br><span class="line">        ay.prototype.fromInt = o;</span><br><span class="line">        ay.prototype.fromString = y;</span><br><span class="line">        ay.prototype.clamp = Q;</span><br><span class="line">        ay.prototype.dlShiftTo = ax;</span><br><span class="line">        ay.prototype.drShiftTo = aa;</span><br><span class="line">        ay.prototype.lShiftTo = u;</span><br><span class="line">        ay.prototype.rShiftTo = m;</span><br><span class="line">        ay.prototype.subTo = af;</span><br><span class="line">        ay.prototype.multiplyTo = F;</span><br><span class="line">        ay.prototype.squareTo = S;</span><br><span class="line">        ay.prototype.divRemTo = G;</span><br><span class="line">        ay.prototype.invDigit = D;</span><br><span class="line">        ay.prototype.isEven = j;</span><br><span class="line">        ay.prototype.exp = A;</span><br><span class="line">        ay.prototype.toString = r;</span><br><span class="line">        ay.prototype.negate = T;</span><br><span class="line">        ay.prototype.abs = aq;</span><br><span class="line">        ay.prototype.compareTo = I;</span><br><span class="line">        ay.prototype.bitLength = w;</span><br><span class="line">        ay.prototype.mod = P;</span><br><span class="line">        ay.prototype.modPowInt = at;</span><br><span class="line">        ay.ZERO = e(0);</span><br><span class="line">        ay.ONE = e(1);</span><br><span class="line">        function h(z, t) {</span><br><span class="line">            return new ay(z,t)</span><br><span class="line">        }</span><br><span class="line">        function am(aG, aH) {</span><br><span class="line">            var t = "";</span><br><span class="line">            var z = 0;</span><br><span class="line">            while (z + aH &lt; aG.length) {</span><br><span class="line">                t += aG.substring(z, z + aH) + "\n";</span><br><span class="line">                z += aH</span><br><span class="line">            }</span><br><span class="line">            return t + aG.substring(z, aG.length)</span><br><span class="line">        }</span><br><span class="line">        function s(t) {</span><br><span class="line">            if (t &lt; 16) {</span><br><span class="line">                return "0" + t.toString(16)</span><br><span class="line">            } else {</span><br><span class="line">                return t.toString(16)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function ak(aH, aK) {</span><br><span class="line">            if (aK &lt; aH.length + 11) {</span><br><span class="line">                alert("Message too long for RSA");</span><br><span class="line">                return null</span><br><span class="line">            }</span><br><span class="line">            var aJ = new Array();</span><br><span class="line">            var aG = aH.length - 1;</span><br><span class="line">            while (aG &gt;= 0 &amp;&amp; aK &gt; 0) {</span><br><span class="line">                var aI = aH.charCodeAt(aG--);</span><br><span class="line">                if (aI &lt; 128) {</span><br><span class="line">                    aJ[--aK] = aI</span><br><span class="line">                } else {</span><br><span class="line">                    if ((aI &gt; 127) &amp;&amp; (aI &lt; 2048)) {</span><br><span class="line">                        aJ[--aK] = (aI &amp; 63) | 128;</span><br><span class="line">                        aJ[--aK] = (aI &gt;&gt; 6) | 192</span><br><span class="line">                    } else {</span><br><span class="line">                        aJ[--aK] = (aI &amp; 63) | 128;</span><br><span class="line">                        aJ[--aK] = ((aI &gt;&gt; 6) &amp; 63) | 128;</span><br><span class="line">                        aJ[--aK] = (aI &gt;&gt; 12) | 224</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            aJ[--aK] = 0;</span><br><span class="line">            var z = new ah();</span><br><span class="line">            var t = new Array();</span><br><span class="line">            while (aK &gt; 2) {</span><br><span class="line">                t[0] = 0;</span><br><span class="line">                while (t[0] == 0) {</span><br><span class="line">                    z.nextBytes(t)</span><br><span class="line">                }</span><br><span class="line">                aJ[--aK] = t[0]</span><br><span class="line">            }</span><br><span class="line">            aJ[--aK] = 2;</span><br><span class="line">            aJ[--aK] = 0;</span><br><span class="line">            return new ay(aJ)</span><br><span class="line">        }</span><br><span class="line">        function N() {</span><br><span class="line">            this.n = null;</span><br><span class="line">            this.e = 0;</span><br><span class="line">            this.d = null;</span><br><span class="line">            this.p = null;</span><br><span class="line">            this.q = null;</span><br><span class="line">            this.dmp1 = null;</span><br><span class="line">            this.dmq1 = null;</span><br><span class="line">            this.coeff = null</span><br><span class="line">        }</span><br><span class="line">        function p(z, t) {</span><br><span class="line">            if (z != null &amp;&amp; t != null &amp;&amp; z.length &gt; 0 &amp;&amp; t.length &gt; 0) {</span><br><span class="line">                this.n = h(z, 16);</span><br><span class="line">                this.e = parseInt(t, 16)</span><br><span class="line">            } else {</span><br><span class="line">                alert("Invalid RSA public key")</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        function Z(t) {</span><br><span class="line">            return t.modPowInt(this.e, this.n)</span><br><span class="line">        }</span><br><span class="line">        function q(aG) {</span><br><span class="line">            var t = ak(aG, (this.n.bitLength() + 7) &gt;&gt; 3);</span><br><span class="line">            if (t == null) {</span><br><span class="line">                return null</span><br><span class="line">            }</span><br><span class="line">            var aH = this.doPublic(t);</span><br><span class="line">            if (aH == null) {</span><br><span class="line">                return null</span><br><span class="line">            }</span><br><span class="line">            var z = aH.toString(16);</span><br><span class="line">            if ((z.length &amp; 1) == 0) {</span><br><span class="line">                return z</span><br><span class="line">            } else {</span><br><span class="line">                return "0" + z</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        N.prototype.doPublic = Z;</span><br><span class="line">        N.prototype.setPublic = p;</span><br><span class="line">        N.prototype.encrypt = q;</span><br><span class="line">        var ad = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";</span><br><span class="line">        var Y = "=";</span><br><span class="line">        function ai(aG) {</span><br><span class="line">            var z;</span><br><span class="line">            var aH;</span><br><span class="line">            var t = "";</span><br><span class="line">            for (z = 0; z + 3 &lt;= aG.length; z += 3) {</span><br><span class="line">                aH = parseInt(aG.substring(z, z + 3), 16);</span><br><span class="line">                t += ad.charAt(aH &gt;&gt; 6) + ad.charAt(aH &amp; 63)</span><br><span class="line">            }</span><br><span class="line">            if (z + 1 == aG.length) {</span><br><span class="line">                aH = parseInt(aG.substring(z, z + 1), 16);</span><br><span class="line">                t += ad.charAt(aH &lt;&lt; 2)</span><br><span class="line">            } else {</span><br><span class="line">                if (z + 2 == aG.length) {</span><br><span class="line">                    aH = parseInt(aG.substring(z, z + 2), 16);</span><br><span class="line">                    t += ad.charAt(aH &gt;&gt; 2) + ad.charAt((aH &amp; 3) &lt;&lt; 4)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            while ((t.length &amp; 3) &gt; 0) {</span><br><span class="line">                t += Y</span><br><span class="line">            }</span><br><span class="line">            return t</span><br><span class="line">        }</span><br><span class="line">        function a(aI) {</span><br><span class="line">            var aG = "";</span><br><span class="line">            var aH;</span><br><span class="line">            var t = 0;</span><br><span class="line">            var z;</span><br><span class="line">            for (aH = 0; aH &lt; aI.length; ++aH) {</span><br><span class="line">                if (aI.charAt(aH) == Y) {</span><br><span class="line">                    break</span><br><span class="line">                }</span><br><span class="line">                v = ad.indexOf(aI.charAt(aH));</span><br><span class="line">                if (v &lt; 0) {</span><br><span class="line">                    continue</span><br><span class="line">                }</span><br><span class="line">                if (t == 0) {</span><br><span class="line">                    aG += aF(v &gt;&gt; 2);</span><br><span class="line">                    z = v &amp; 3;</span><br><span class="line">                    t = 1</span><br><span class="line">                } else {</span><br><span class="line">                    if (t == 1) {</span><br><span class="line">                        aG += aF((z &lt;&lt; 2) | (v &gt;&gt; 4));</span><br><span class="line">                        z = v &amp; 15;</span><br><span class="line">                        t = 2</span><br><span class="line">                    } else {</span><br><span class="line">                        if (t == 2) {</span><br><span class="line">                            aG += aF(z);</span><br><span class="line">                            aG += aF(v &gt;&gt; 2);</span><br><span class="line">                            z = v &amp; 3;</span><br><span class="line">                            t = 3</span><br><span class="line">                        } else {</span><br><span class="line">                            aG += aF((z &lt;&lt; 2) | (v &gt;&gt; 4));</span><br><span class="line">                            aG += aF(v &amp; 15);</span><br><span class="line">                            t = 0</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            if (t == 1) {</span><br><span class="line">                aG += aF(z &lt;&lt; 2)</span><br><span class="line">            }</span><br><span class="line">            return aG</span><br><span class="line">        }</span><br><span class="line">        function W(aH) {</span><br><span class="line">            var aG = a(aH);</span><br><span class="line">            var z;</span><br><span class="line">            var t = new Array();</span><br><span class="line">            for (z = 0; 2 * z &lt; aG.length; ++z) {</span><br><span class="line">                t[z] = parseInt(aG.substring(2 * z, 2 * z + 2), 16)</span><br><span class="line">            }</span><br><span class="line">            return t</span><br><span class="line">        }</span><br><span class="line">        av.encrypt = function(aG, z) {</span><br><span class="line">            var t = new N();</span><br><span class="line">            t.setPublic(a(aG), "10001");</span><br><span class="line">            return ai(t.encrypt(z))</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">)(window);</span><br><span class="line"></span><br><span class="line">function get_pwd() {</span><br><span class="line">    var publicKey = "ANKi9PWuvDOsagwIVvrPx77mXNV0APmjySsYjB1/GtUTY6cyKNRl2RCTt608m9nYk5VeCG2EAZRQmQNQTyfZkw0Uo+MytAkjj17BXOpY4o6+BToi7rRKfTGl6J60/XBZcGSzN1XVZ80ElSjaGE8Ocg8wbPN18tbmsy761zN5SuIl"</span><br><span class="line"></span><br><span class="line">    var pwd = window.encrypt(publicKey, '11111111111')</span><br><span class="line"></span><br><span class="line">    console.log(pwd)</span><br><span class="line">}</span><br><span class="line">get_pwd()</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算_基本概念</title>
    <url>/2022/09/07/%E4%BA%91%E8%AE%A1%E7%AE%97_%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<html><head></head><body><h1 id="云计算-基本概念"><a href="#云计算-基本概念" class="headerlink" title="云计算_基本概念"></a>云计算_基本概念</h1><h2 id="大数据概念"><a href="#大数据概念" class="headerlink" title="大数据概念:"></a>大数据概念:</h2><p><strong>一是海量数据，指其量大，或</strong>者称为全数据；二是指分析方法，指的是对所有数据进行分析</p>
<p>特点：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">大 量</span><br><span class="line"></span><br><span class="line">高 速</span><br><span class="line"></span><br><span class="line">多样</span><br><span class="line"></span><br><span class="line">价值</span><br><span class="line"></span><br><span class="line">真实性</span><br></pre></td></tr></tbody></table></figure>

<h2 id="大数据关键技术"><a href="#大数据关键技术" class="headerlink" title="大数据关键技术:"></a>大数据关键技术:</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">大数据采集技术-&gt; 获得的各种类型的结构化、半结构化（或称之为弱结构化）及非结构化的海</span><br><span class="line">量数据，是大数据知识服务模型的根本。</span><br><span class="line"></span><br><span class="line">大数据预处理技术-&gt;</span><br><span class="line">主要完成对已接收数据的辨析、抽取、清洗等操作。</span><br><span class="line"></span><br><span class="line">大数据存储及管理技术-&gt;</span><br><span class="line">大数据存储与管理要用存储器把采集到的数据存储起来，</span><br><span class="line">建立相应的数据库，并进行管理和调用。重点解决复杂</span><br><span class="line">结构化、半结构化和非结构化大数据管理与处理技术。</span><br><span class="line"></span><br><span class="line">大数据分析与挖掘技术-&gt;</span><br><span class="line">从大量的、不完全的、有噪声的、模糊的、随机的实际</span><br><span class="line">应用数据中，ᨀ取隐含在其中的、人们事先不知道的、</span><br><span class="line">但又是潜在有用的信息和知识的过程。</span><br><span class="line"></span><br><span class="line">大数据展现与应用技术-&gt;</span><br><span class="line">重点应用于以下三大领域：商业</span><br><span class="line">智能、政府决策、公共服务。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="云计算概述"><a href="#云计算概述" class="headerlink" title="云计算概述"></a>云计算概述</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">数据在云端</span><br><span class="line">软件在云端</span><br><span class="line">无所不在的计算</span><br></pre></td></tr></tbody></table></figure>

<p>云计算是一种商业计算模型。它将计算任务分布</p>
<p>在大量计算机构成的资源池上，使各种应用系统能够</p>
<p>根据需要获取计算力、存储空间和各种软件服务</p>
<h2 id="云计算的三种服务模式"><a href="#云计算的三种服务模式" class="headerlink" title="云计算的三种服务模式"></a>云计算的三种服务模式</h2><h3 id="软件即服务-SaaS"><a href="#软件即服务-SaaS" class="headerlink" title="软件即服务(SaaS)"></a>软件即服务(SaaS)</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">是最常见的云计算服务，位于云计算3层服务的顶端。用户通过标准的Web浏览器来使用Internet上的软件。服务供应商负责维护和管理软硬件设施，并以免费（供商可以从网络广告之类的项目中生成收入）或按需租用方式向最终用户供服务。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="平台即服务-PaaS"><a href="#平台即服务-PaaS" class="headerlink" title="平台即服务(PaaS)"></a>平台即服务(PaaS)</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">位于云计算3层服务的最中间。通常也称为"云计算操作系统"。它ᨀ供给终端用户基于互联网的应用开发环境，</span><br><span class="line">包括应用编程接口和运行平台等，并且支持应用从创建到运行整个生命周期所需的各种软硬件资源和工具。</span><br></pre></td></tr></tbody></table></figure>

<p>举例:你力扣上面刷题正是这样子的</p>
<h2 id="基础设施即服务-IaaS"><a href="#基础设施即服务-IaaS" class="headerlink" title="基础设施即服务(IaaS)"></a>基础设施即服务(IaaS)</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">位于云计算3层服务的最底端。也是云计算狭义定义所覆盖的范围，就是把IT基础设施像水、电一样以服务的形式供给用户，以服务形式ᨀ供基于服务器和存储等硬件资源的可高度扩展和按需变化的IT能力。通常按照所消耗资源的成本进行收费。</span><br></pre></td></tr></tbody></table></figure>

<p>举例:就像你需要把SpringBoot项目部署到网上，需要一台服务器</p>
<h2 id="云计算的4种部署形式"><a href="#云计算的4种部署形式" class="headerlink" title="云计算的4种部署形式"></a>云计算的4种部署形式</h2><h2 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h2><p><strong>公有云是云基础设施由一个ᨀ供云计算服务的运营商</strong></p>
<p><strong>或称云供应商所拥有，该运营商再将云计算服务销售给一</strong></p>
<p><strong>般大众或广大的中小企业群体所共有，是现在最主流的，</strong></p>
<p><strong>也是最受欢迎的一种云计算部署模式。</strong></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">规模大</span><br><span class="line">价格低廉</span><br><span class="line">灵活(容量)</span><br><span class="line">功能全面</span><br></pre></td></tr></tbody></table></figure>

<h2 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h2><p><strong>私有云主要是为企业内部ᨀ供云服务，不对公众开放，</strong></p>
<p><strong>大多在企业的防火墙内工作，并且企业IT人员能对其数据、</strong></p>
<p><strong>安全性和服务质量进行有效的控制。</strong></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">数据安全</span><br><span class="line"></span><br><span class="line">服务质量(因为私有云一般在企业内部，而不是在某个遥远的数据中心，所以当公司员工访问那些基于私有云的应用时，它的服务质量应该会非常稳定，这样就不会受到远程网络偶然发生异常的影响。)</span><br><span class="line"></span><br><span class="line">充分利用现有硬件资源</span><br><span class="line"></span><br><span class="line">支持定制和遗留应用</span><br></pre></td></tr></tbody></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">成本开支高</span><br><span class="line"></span><br><span class="line">持续运营成本偏高</span><br></pre></td></tr></tbody></table></figure>

<h2 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h2><p><strong>混合云是云基础设施由两种或以上的云（私有云、公有云或行业云）组成，每种云仍然保持独立实体，但用标准的或专有的技术将它们组合起来，具有数据和应用程序的可移植性可通过负载均衡技术来应对处理突发负载(Cloudburst)等</strong></p>
</body></html>]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的递归遍历_二叉树01</title>
    <url>/2022/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9101/</url>
    <content><![CDATA[<html><head></head><body><h1 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h1><blockquote>
<p>一看就会，一写就废！</p>
</blockquote>
<p>这次我们要好好谈一谈递归，为什么很多同学看递归算法都是“一看就会，一写就废”。</p>
<p>主要是对递归不成体系，没有方法论，<strong>每次写递归算法 ，都是靠玄学来写代码</strong>，代码能不能编过都靠运气。</p>
<p><strong>本篇将介绍前后中序的递归写法，一些同学可能会感觉很简单，其实不然，我们要通过简单题目把方法论确定下来，有了方法论，后面才能应付复杂的递归。</strong></p>
<p>这里帮助大家确定下来递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p>好了，我们确认了递归的三要素，接下来就来练练手：</p>
<p><strong>以下以前序遍历为例：</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br></pre></td></tr></tbody></table></figure>

<p>单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：</p>
<p>前序遍历：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>那么前序遍历写出来之后，中序和后序遍历就不难理解了，代码如下：</p>
<p>中序遍历：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>后序遍历：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时大家可以做一做leetcode上三道题目，分别是：</p>
<ul>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历(opens new window)</a></li>
</ul>
<p>可能有同学感觉前后中序遍历的递归太简单了，要打迭代法（非递归），别急，我们明天打迭代法，打个通透！</p>
<h3 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">proTravesal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Travesal(root,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Travesal</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    Travesal(root.left,result);</span><br><span class="line">    Travesal(root.right,result);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Travesal</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Travesal(root.left,result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    Travesal(root.right,result);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Travesal</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Travesal(root.left,result);</span><br><span class="line">    Travesal(root.right,result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的迭代遍历_二叉树02</title>
    <url>/2022/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9102/</url>
    <content><![CDATA[<html><head></head><body><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><blockquote>
<p>听说还可以用非递归的方式</p>
</blockquote>
<p>看完本篇大家可以使用迭代法，再重新解决如下三道leetcode上的题目：</p>
<ul>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历(opens new window)</a></li>
</ul>
<p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p>
<p>我们在<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">栈与队列：匹配问题都是栈的强项 (opens new window)</a>中提到了，<strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。</p>
<h2 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="#前序遍历（迭代法）"></a><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>前序遍历（迭代法）</h2><p>我们先看一下前序遍历。</p>
<p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p>
<p>此时会发现貌似使用迭代法写出前序遍历并不难，确实不难。</p>
<p><strong>此时是不是想改一点前序遍历代码顺序就把中序遍历搞出来了？</strong></p>
<p>其实还真不行！</p>
<p>但接下来，<strong>再用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。</strong></p>
<h2 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="#中序遍历（迭代法）"></a><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>中序遍历（迭代法）</h2><p>为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：</p>
<ol>
<li><strong>处理：将元素放进result数组中</strong></li>
<li><strong>访问：遍历节点</strong></li>
</ol>
<p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p>
<p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p>
<p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" alt="二叉树中序遍历（迭代法）"></p>
<p><strong>中序遍历，可以写出如下代码：</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) { <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="#后序遍历（迭代法）"></a><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>后序遍历（迭代法）</h2><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200808200338924.png" alt="前序到后序"></p>
<p><strong>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E6%80%BB%E7%BB%93">#</a>总结</h1><p>此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。</p>
<p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p>
<p>上面这句话，可能一些同学不太理解，建议自己亲手用迭代法，先写出来前序，再试试能不能写出中序，就能理解了。</p>
<p><strong>那么问题又来了，难道 二叉树前后中序遍历的迭代法实现，就不能风格统一么（即前序遍历 改变代码顺序就可以实现中序 和 后序）？</strong></p>
<p>当然可以，这种写法，还不是很好理解，我们将在下一篇文章里重点讲解，敬请期待！</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.pop();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.push(temp.right);</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.push(temp.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">// 先把最左边的节点全都压入栈当中 如果没有左孩子节点了的话 栈弹出一个元素 再看弹出元素的右孩子</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !que.isEmpty()) {</span><br><span class="line">                	<span class="keyword">if</span>(cur != <span class="literal">null</span>) {</span><br><span class="line">                         que.push(cur);</span><br><span class="line">                         cur = cur.left;</span><br><span class="line">                    }</span><br><span class="line">                	<span class="keyword">else</span> {</span><br><span class="line">                        cur = que.pop();</span><br><span class="line">                        res.add(cur.val);</span><br><span class="line">                        cur = cur.right;</span><br><span class="line">                    }</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">// 中左右 -&gt; 中右左 -&gt; Collections.reverse</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.pop();</span><br><span class="line">            res.add(node.val); </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) que.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) que.push(node.right);</span><br><span class="line">        }</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树层序遍历登场_二叉树03</title>
    <url>/2022/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9103%20/</url>
    <content><![CDATA[<html><head></head><body><h1 id="二叉树层序遍历登场！"><a href="#二叉树层序遍历登场！" class="headerlink" title="二叉树层序遍历登场！"></a>二叉树层序遍历登场！</h1><p>学会二叉树的层序遍历，可以一口气打完以下十题：</p>
<ul>
<li>102.二叉树的层序遍历</li>
<li>107.二叉树的层次遍历II</li>
<li>199.二叉树的右视图</li>
<li>637.二叉树的层平均值</li>
<li>429.N叉树的层序遍历</li>
<li>515.在每个树行中找最大值</li>
<li>116.填充每个节点的下一个右侧节点指针</li>
<li>117.填充每个节点的下一个右侧节点指针II</li>
<li>104.二叉树的最大深度</li>
<li>111.二叉树的最小深度</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnadnltbpjg309603w4qp.gif" alt="我要打十个"></p>
<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">力扣题目链接(opens new window)</a></p>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144842988.png" alt="102.二叉树的层序遍历"></p>
<p>思路：</p>
<p>我们之前讲过了三篇关于二叉树的深度优先遍历的文章：</p>
<ul>
<li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树：前中后序递归法(opens new window)</a></li>
<li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：前中后序迭代法(opens new window)</a></li>
<li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代方式统一写法(opens new window)</a></li>
</ul>
<p>接下来我们再来介绍二叉树的另一种遍历方式：层序遍历。</p>
<p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p>
<p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p>
<p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p>
<p>使用队列实现二叉树广度优先遍历，动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif" alt="102二叉树的层序遍历"></p>
<p>这样就实现了层序从左到右遍历二叉树。</p>
<p>代码如下：<strong>这份代码也可以作为二叉树层序遍历的模板，打十个就靠它了</strong>。</p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; res_01 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                res_01.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) que.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) que.offer(node.right);</span><br><span class="line">            }</span><br><span class="line">            res.add(res_01);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>对称二叉树_二叉树05</title>
    <url>/2022/08/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9105/</url>
    <content><![CDATA[<html><head></head><body><h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144607387.png" alt="101. 对称二叉树"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p><strong>首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！</strong></p>
<p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p>
<p>那么如果比较呢？</p>
<p>比较的是两个子树的里侧和外侧的元素是否相等。如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144624414.png" alt="101. 对称二叉树1"></p>
<p>那么遍历的顺序应该是什么样的呢？</p>
<p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p>
<p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p>
<p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p>
<p>其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。</p>
<p>说到这大家可能感觉我有点啰嗦，哪有这么多道理，上来就干就完事了。别急，我说的这些在下面的代码讲解中都有身影。</p>
<p>那么我们先来看看递归法的代码应该怎么写。</p>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="#递归法"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">#</a>递归法</h2><p>递归三部曲</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p>
<p>返回值自然是bool类型。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">bool compare(TreeNode* left, TreeNode* right)</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定终止条件</li>
</ol>
<p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p>
<p>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
<p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意这里我没有使用else</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意上面最后一种情况，我没有使用else，而是elseif， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p>
<ol>
<li>确定单层递归的逻辑</li>
</ol>
<p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内测是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中（逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></tbody></table></figure>

<p>如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。</p>
<p>最后递归的C++整体代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>{</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>我给出的代码并不简洁，但是把每一步判断的逻辑都清楚的描绘出来了。</strong></p>
<p>如果上来就看网上各种简洁的代码，看起来真的很简单，但是很多逻辑都掩盖掉了，而题解可能也没有把掩盖掉的逻辑说清楚。</p>
<p><strong>盲目的照着抄，结果就是：发现这是一道“简单题”，稀里糊涂的就过了，但是真正的每一步判断逻辑未必想到清楚。</strong></p>
<p>当然我可以把如上代码整理如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">compare</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这个代码就很简洁了，但隐藏了很多逻辑，条理不清晰，而且递归三部曲，在这里完全体现不出来。</strong></p>
<p><strong>所以建议大家做题的时候，一定要想清楚逻辑，每一步做什么。把道题目所有情况想到位，相应的代码写出来之后，再去追求简洁代码的效果。</strong></p>
<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="#迭代法"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>迭代法</h2><p>这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。</p>
<p>这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（<strong>注意这不是层序遍历</strong>）</p>
<h3 id="使用队列"><a href="#使用队列" class="headerlink" title="#使用队列"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97">#</a>使用队列</h3><p>通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif" alt="101.对称二叉树"></p>
<p>如下的条件判断和递归的逻辑是一样的。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);   <span class="comment">// 将左子树头结点加入队列</span></span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);  <span class="comment">// 将右子树头结点加入队列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {  <span class="comment">// 接下来就要判断这两个树是否相互翻转</span></span><br><span class="line">            TreeNode* leftNode = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* rightNode = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!leftNode &amp;&amp; !rightNode) {  <span class="comment">// 左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;left);   <span class="comment">// 加入左节点左孩子</span></span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;right); <span class="comment">// 加入右节点右孩子</span></span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;right);  <span class="comment">// 加入左节点右孩子</span></span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;left);  <span class="comment">// 加入右节点左孩子</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用栈"><a href="#使用栈" class="headerlink" title="#使用栈"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BD%BF%E7%94%A8%E6%A0%88">#</a>使用栈</h3><p>细心的话，其实可以发现，这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的。</p>
<p>只要把队列原封不动的改成栈就可以了，我下面也给出了代码。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; st; <span class="comment">// 这里改成了栈</span></span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode* leftNode = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* rightNode = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!leftNode &amp;&amp; !rightNode) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            st.<span class="built_in">push</span>(leftNode-&gt;left);</span><br><span class="line">            st.<span class="built_in">push</span>(rightNode-&gt;right);</span><br><span class="line">            st.<span class="built_in">push</span>(leftNode-&gt;right);</span><br><span class="line">            st.<span class="built_in">push</span>(rightNode-&gt;left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>这次我们又深度剖析了一道二叉树的“简单题”，大家会发现，真正的把题目搞清楚其实并不简单，leetcode上accept了和真正掌握了还是有距离的。</p>
<p>我们介绍了递归法和迭代法，递归依然通过递归三部曲来解决了这道题目，如果只看精简的代码根本看不出来递归三部曲是如果解题的。</p>
<p>在迭代法中我们使用了队列，需要注意的是这不是层序遍历，而且仅仅通过一个容器来成对的存放我们要比较的元素，知道这一本质之后就发现，用队列，用栈，甚至用数组，都是可以的。</p>
<p>如果已经做过这道题目的同学，读完文章可以再去看看这道题目，思考一下，会有不一样的发现！</p>
<h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="#相关题目推荐"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%8E%A8%E8%8D%90">#</a>相关题目推荐</h2><p>这两道题目基本和本题是一样的，只要稍加修改就可以AC。</p>
<ul>
<li>100.相同的树</li>
<li>572.另一个树的子树</li>
</ul>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><p>递归法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric1</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span> {</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 此时可以知道目前的左右节点相等</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较左节点的左节点和右节点的右节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">A</span> <span class="operator">=</span> compare(left.left,right.right);</span><br><span class="line">        <span class="comment">// 比较右节点的左节点和左节点的右节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">B</span> <span class="operator">=</span> compare(left.right,right.left);</span><br><span class="line">        <span class="keyword">return</span> A &amp;&amp; B;</span><br><span class="line">        </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>迭代法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric2</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">	Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	que.offer(root.left);</span><br><span class="line">	que.offer(root.right);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.isEmpty()) {</span><br><span class="line">		left = que.poll();</span><br><span class="line">		right = que.poll();</span><br><span class="line">		<span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span> || left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        que.offer(left.left);</span><br><span class="line">        que.offer(right.right);</span><br><span class="line">        que.offer(left.right);</span><br><span class="line">        que.offer(right.left);</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最大深度_二叉树04</title>
    <url>/2022/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9104/</url>
    <content><![CDATA[<html><head></head><body><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p>
<p><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度"></p>
<p>返回它的最大深度 3 。</p>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="#递归法"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95">#</a>递归法</h2><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p>
<p><strong>而根节点的高度就是二叉树的最大深度</strong>，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。</p>
<p>这一点其实是很多同学没有想清楚的，很多题解同样没有讲清楚。</p>
<p>我先用后序遍历（左右中）来计算树的高度。</p>
<ol>
<li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(treenode* node)</span></span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定终止条件：如果为空节点的话，就返回0，表示高度为0。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line"><span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line"><span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></tbody></table></figure>

<p>所以整体c++代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(treenode* node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>代码精简之后c++代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxdepth</span>(root-&gt;left), <span class="built_in">maxdepth</span>(root-&gt;right));</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>精简之后的代码根本看不出是哪种遍历方式，也看不出递归三部曲的步骤，所以如果对二叉树的操作还不熟练，尽量不要直接照着精简代码来学。</strong></p>
<p>本题当然也可以使用前序，代码如下：(<strong>充分表现出求深度回溯的过程</strong>)</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getdepth</span><span class="params">(treenode* node, <span class="type">int</span> depth)</span> </span>{</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) { <span class="comment">// 左</span></span><br><span class="line">            depth++;    <span class="comment">// 深度+1</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;left, depth);</span><br><span class="line">            depth--;    <span class="comment">// 回溯，深度-1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) { <span class="comment">// 右</span></span><br><span class="line">            depth++;    <span class="comment">// 深度+1</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;right, depth);</span><br><span class="line">            depth--;    <span class="comment">// 回溯，深度-1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>{</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getdepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>可以看出使用了前序（中左右）的遍历顺序，这才是真正求深度的逻辑！</strong></p>
<p>注意以上代码是为了把细节体现出来，简化一下代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getdepth</span><span class="params">(treenode* node, <span class="type">int</span> depth)</span> </span>{</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) { <span class="comment">// 左</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) { <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>{</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getdepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="#迭代法"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>迭代法</h2><p>使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p>
<p>在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200810193056585.png" alt="层序遍历"></p>
<p>所以这道题的迭代法就是一道模板题，可以使用二叉树层序遍历的模板来解决的。</p>
<p>如果对层序遍历还不清楚的话，可以看这篇：<a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">二叉树：层序遍历登场！(opens new window)</a></p>
<p>c++代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;treenode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                treenode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>rust:</p>
<figure class="highlight rust"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">max_depth</span>(root: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">        <span class="keyword">if</span> root.<span class="title function_ invoke__">is_none</span>(){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_depth</span>: <span class="type">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="built_in">vec!</span>[root.<span class="title function_ invoke__">unwrap</span>()];</span><br><span class="line">        <span class="keyword">while</span> !stack.<span class="title function_ invoke__">is_empty</span>() {</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num</span> = stack.<span class="title function_ invoke__">len</span>();</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_i</span> <span class="keyword">in</span> <span class="number">0</span>..num{</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">top</span> = stack.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> top.<span class="title function_ invoke__">borrow_mut</span>().left.<span class="title function_ invoke__">is_some</span>(){</span><br><span class="line">                    stack.<span class="title function_ invoke__">push</span>(top.<span class="title function_ invoke__">borrow_mut</span>().left.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> top.<span class="title function_ invoke__">borrow_mut</span>().right.<span class="title function_ invoke__">is_some</span>(){</span><br><span class="line">                    stack.<span class="title function_ invoke__">push</span>(top.<span class="title function_ invoke__">borrow_mut</span>().right.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            max_depth+=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        max_depth</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>那么我们可以顺便解决一下n叉树的最大深度问题</p>
<h1 id="559-n叉树的最大深度"><a href="#559-n叉树的最大深度" class="headerlink" title="#559.n叉树的最大深度"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#_559-n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">#</a>559.n叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个 n 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>例如，给定一个 3叉树 :</p>
<p><img src="https://img-blog.csdnimg.cn/2021020315313214.png" alt="559.n叉树的最大深度"></p>
<p>我们应返回其最大深度，3。</p>
<p>思路：</p>
<p>依然可以提供递归法和迭代法，来解决这个问题，思路是和二叉树思路一样的，直接给出代码如下：</p>
<h2 id="递归法-1"><a href="#递归法-1" class="headerlink" title="#递归法"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95-2">#</a>递归法</h2><p>c++代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            depth = <span class="built_in">max</span> (depth, <span class="built_in">maxdepth</span>(root-&gt;children[i]));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="#迭代法"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E8%BF%AD%E4%BB%A3%E6%B3%95-2">#</a>迭代法</h2><p>依然是层序遍历，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(node* root)</span> </span>{</span><br><span class="line">        queue&lt;node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; node-&gt;children.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[j]) que.<span class="built_in">push</span>(node-&gt;children[j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="其他语言版本"><a href="#其他语言版本" class="headerlink" title="#其他语言版本"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">#</a>其他语言版本</h1><h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><p>递归法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(left,right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>迭代法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">   que.offer(root); </span><br><span class="line">   <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!que.isEmpty()) {</span><br><span class="line">       res++;</span><br><span class="line">       <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++) {</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="literal">null</span>) que.offer(node.left);</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="literal">null</span>) que.offer(node.right);</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="n叉树的最大深度"><a href="#n叉树的最大深度" class="headerlink" title="n叉树的最大深度"></a>n叉树的最大深度</h3></body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>完全二叉树_二叉树06</title>
    <url>/2022/08/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9106/</url>
    <content><![CDATA[<html><head></head><body><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>以上方法都是按照普通二叉树来做的，对于完全二叉树特性不了解的同学可以看这篇 <a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于二叉树，你该了解这些！ (opens new window)</a>，这篇详细介绍了各种二叉树的特性。</p>
<p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p>
<p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p>
<p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p>
<p>完全二叉树（一）如图： <img src="https://img-blog.csdnimg.cn/20201124092543662.png" alt="222.完全二叉树的节点个数"></p>
<p>完全二叉树（二）如图： <img src="https://img-blog.csdnimg.cn/20201124092634138.png" alt="222.完全二叉树的节点个数1"></p>
<p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量</p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="keyword">while</span>(leftNode != <span class="literal">null</span>) {</span><br><span class="line">            left++;</span><br><span class="line">            leftNode = leftNode.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(rightNode != <span class="literal">null</span>) {</span><br><span class="line">            right++;</span><br><span class="line">            rightNode = rightNode.right;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left == right) {</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (left+<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>左叶子之和_二叉树08</title>
    <url>/2022/08/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9108/</url>
    <content><![CDATA[<html><head></head><body><h1 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">力扣题目链接(opens new window)</a></p>
<p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151927654.png" alt="404.左叶子之和1"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p>
<p>因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：<strong>如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子</strong></p>
<p>大家思考一下如下图中二叉树，左叶子之和究竟是多少？</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151949672.png" alt="404.左叶子之和"></p>
<p><strong>其实是0，因为这棵树根本没有左叶子！</strong></p>
<p>那么<strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p>
<p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (node-&gt;left != NULL &amp;&amp; node-&gt;left-&gt;left == NULL &amp;&amp; node-&gt;left-&gt;right == NULL) {</span><br><span class="line">    左叶子节点处理逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。。</p>
<p>递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int</p>
<p>使用题目中给出的函数就可以了。</p>
<ol>
<li>确定终止条件</li>
</ol>
<p>依然是</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (root == NULL) return 0;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定单层递归的逻辑</li>
</ol>
<p>当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"><span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                                                <span class="comment">// 中</span></span><br><span class="line"><span class="type">int</span> midValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) {</span><br><span class="line">    midValue = root-&gt;left-&gt;val;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> sum = midValue + leftValue + rightValue;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></tbody></table></figure>

<p>整体递归代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="type">int</span> midValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) { <span class="comment">// 中</span></span><br><span class="line">            midValue = root-&gt;left-&gt;val;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> sum = midValue + leftValue + rightValue;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码精简之后如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> midValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) {</span><br><span class="line">            midValue = root-&gt;left-&gt;val;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> midValue + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) {</span><br><span class="line">            value = root.left.val;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left + right + value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="迭代法："><a href="#迭代法：" class="headerlink" title="迭代法："></a>迭代法：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		que.offer(root);</span><br><span class="line">		<span class="keyword">while</span>(!que.isEmpty()) {</span><br><span class="line">			<span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">			<span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>) res += node.left.val;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) que.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) que.offer(node.right);</span><br><span class="line">		}</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>找树左下角的值_二叉树09</title>
    <url>/2022/08/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9109/</url>
    <content><![CDATA[<html><head></head><body><h1 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<p>示例 1:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204152956836.png" alt="513.找树左下角的值"></p>
<p>示例 2:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153017586.png" alt="513.找树左下角的值1"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本地要找出树的最后一行找到最左边的值。此时大家应该想起用层序遍历是非常简单的了，反而用递归的话会比较难一点。</p>
<p>我们依然还是先介绍递归法。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？</p>
<p>没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。</p>
<p>我们来分析一下题目：在树的<strong>最后一行</strong>找到<strong>最左边的值</strong>。</p>
<p>首先要是最后一行，然后是最左边的值。</p>
<p>如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。</p>
<p>如果对二叉树深度和高度还有点疑惑的话，请看：<a href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html">110.平衡二叉树 (opens new window)</a>。</p>
<p>所以要找深度最大的叶子节点。</p>
<p><strong>那么如果找最左边的呢？可以使用前序遍历，这样才先优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。</strong></p>
<p>递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。</p>
<p>本题还需要类里的两个全局变量，maxLen用来记录最大深度，maxleftValue记录最大深度最左节点的数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxLen = INT_MIN;   <span class="comment">// 全局变量 记录最大深度</span></span><br><span class="line"><span class="type">int</span> maxleftValue;       <span class="comment">// 全局变量 最大深度最左节点的数值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> leftLen)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>有的同学可能疑惑，为啥不能递归函数的返回值返回最长深度呢？</p>
<p>其实很多同学都对递归函数什么时候要有返回值，什么时候不能有返回值很迷茫。</p>
<p><strong>如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！</strong></p>
<p>初学者可能对这个结论不太理解，别急，后面我会安排一道题目专门讲递归函数的返回值问题。这里大家暂时先了解一下。</p>
<p>本题我们是要遍历整个树找到最深的叶子节点，需要遍历整棵树，所以递归函数没有返回值。</p>
<ol>
<li>确定终止条件</li>
</ol>
<p>当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="keyword">if</span> (leftLen &gt; maxLen) {</span><br><span class="line">        maxLen = leftLen;           <span class="comment">// 更新最大深度</span></span><br><span class="line">        maxleftValue = root-&gt;val;   <span class="comment">// 最大深度最左面的数值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定单层递归的逻辑</li>
</ol>
<p>在找最大深度的时候，递归的过程中依然要使用回溯，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">                    <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;left) {   <span class="comment">// 左</span></span><br><span class="line">    leftLen++; <span class="comment">// 深度加一</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, leftLen);</span><br><span class="line">    leftLen--; <span class="comment">// 回溯，深度减一</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right) { <span class="comment">// 右</span></span><br><span class="line">    leftLen++; <span class="comment">// 深度加一</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, leftLen);</span><br><span class="line">    leftLen--; <span class="comment">// 回溯，深度减一</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>完整代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">	<span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        findLeftValue(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findLeftValue</span> <span class="params">(TreeNode root,<span class="type">int</span> left)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span>(left &gt; deep) {</span><br><span class="line">                value = root.val;</span><br><span class="line">                deep = left;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) findLeftValue(root.left,left + <span class="number">1</span>);<span class="comment">// 细节</span></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) findLeftValue(root.right,left + <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>跌代法就很简单 就是一个层序遍历 这里就不写了</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>路径总和_二叉树10</title>
    <url>/2022/08/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9110/</url>
    <content><![CDATA[<html><head></head><body><h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h1><p><a href="https://leetcode.cn/problems/path-sum/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: 给定如下二叉树，以及目标和 sum = 22，</p>
<p><img src="https://img-blog.csdnimg.cn/20210203160355234.png" alt="112.路径总和1"></p>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我们要遍历从根节点到叶子节点的的路径看看总和是不是目标和。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树</p>
<ol>
<li>确定递归函数的参数和返回类型</li>
</ol>
<p>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。</p>
<p>再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li>
</ul>
<p>而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2021020316051216.png" alt="112.路径总和"></p>
<p>图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。</p>
<p>所以代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">bool traversal(treenode* cur, int count)   // 注意函数的返回类型</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定终止条件</li>
</ol>
<p>首先计数器如何统计这一条路径的和呢？</p>
<p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p>
<p>如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。</p>
<p>如果遍历到了叶子节点，count不为0，就是没找到。</p>
<p>递归终止条件代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == 0) return true; // 遇到叶子节点，并且计数为0</span><br><span class="line">if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return false; // 遇到叶子节点而没有找到合适的边，直接返回</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定单层递归的逻辑</li>
</ol>
<p>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。</p>
<p>递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) { <span class="comment">// 左 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count - cur-&gt;left-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) { <span class="comment">// 右 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count - cur-&gt;right-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。</p>
<p>回溯隐藏在<code>traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)</code>这里， 因为把<code>count - cur-&gt;left-&gt;val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p>
<p>为了把回溯的过程体现出来，可以改为如下代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) { <span class="comment">// 左</span></span><br><span class="line">    count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) { <span class="comment">// 右</span></span><br><span class="line">    count -= cur-&gt;right-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;right-&gt;val;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="整体代码如下："><a href="#整体代码如下：" class="headerlink" title="整体代码如下："></a>整体代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> Isfind(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Isfind</span><span class="params">(TreeNode root,<span class="type">int</span> count)</span> {</span><br><span class="line">     <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">         count -= root.val;</span><br><span class="line">         <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">if</span>(root.left != <span class="literal">null</span>) {</span><br><span class="line">         <span class="keyword">return</span> Isfind(root.left,count - root.val);</span><br><span class="line">     } </span><br><span class="line">     <span class="keyword">if</span>(root.right != <span class="literal">null</span>) {</span><br><span class="line">         <span class="keyword">return</span> Isfind(root.right,count - root.val);</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="迭代法："><a href="#迭代法：" class="headerlink" title="迭代法："></a>迭代法：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	Deque&lt;TreeNode&gt; que0 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; que1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que0.push(root);</span><br><span class="line">        que1.push(root.val);</span><br><span class="line">        <span class="keyword">while</span>(!que0.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que0.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> que1.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; sum == targeSum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) {</span><br><span class="line">                que0.push(node.left);</span><br><span class="line">                que1.push(sum+node.left.val);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) {</span><br><span class="line">                que0.push(node.right);</span><br><span class="line">                que1.push(sum+node.right.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>从中序与后序遍历序列构造二叉树_二叉树11</title>
    <url>/2022/08/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9111/</url>
    <content><![CDATA[<html><head></head><body><h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接(opens new window)</a></p>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意: 你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154316774.png" alt="106. 从中序与后序遍历序列构造二叉树1"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。</p>
<p>如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。</p>
<p>流程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树"></p>
<p>那么代码应该怎么写呢？</p>
<p>说到一层一层切割，就应该想到了递归。</p>
<p>来看一下一共分几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;  <span class="comment">// 方便根据数值查找位置</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> {</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先把中序遍历的所有元素位置存入map</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++) {</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 直接返回调用函数</span></span><br><span class="line">        <span class="keyword">return</span> findNode(inorder,<span class="number">0</span>,inorder.length,postorder,<span class="number">0</span>,postorder.length);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> begin01,<span class="type">int</span> end01,<span class="type">int</span>[] postorder,<span class="type">int</span> begin02,<span class="type">int</span> end02)</span> {</span><br><span class="line">        <span class="comment">// 遵循左闭右开的原则</span></span><br><span class="line">        <span class="keyword">if</span>(begin01 &gt;= end01 || begin02 &gt;= end02) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 找到在中序的数组中的元素 进行或许的切割</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> map.get(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">LenOfleft</span> <span class="operator">=</span> target - begin01; <span class="comment">// 左边数组的长度</span></span><br><span class="line">        <span class="comment">// 切割左数组</span></span><br><span class="line">        root.left = findNode(inorder,begin01,target,postorder,begin02,begin02+LenOfleft);</span><br><span class="line">        root.right = fintNode(inorder,target+<span class="number">1</span>,end01,postorder,begin02+LenOfleft,end02-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">相关题</a></p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>合并二叉树_二叉树12</title>
    <url>/2022/08/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9112/</url>
    <content><![CDATA[<html><head></head><body><h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">力扣题目链接(opens new window)</a></p>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153634809.png" alt="617.合并二叉树"></p>
<p>注意: 合并必须从两个树的根节点开始。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？</p>
<p>其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="#递归"></a><a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92">#</a>递归</h2><p>二叉树使用递归，就要想使用前中后哪种遍历方式？</p>
<p><strong>本题使用哪种遍历都是可以的！</strong></p>
<p>我们下面以前序遍历为例。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjjq8h16g30e20cwnpd.gif" alt="617.合并二叉树"></p>
<p>那么我们来按照递归三部曲来解决：</p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong></li>
</ol>
<p>首先那么要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>确定终止条件：</strong></li>
</ol>
<p>因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。</p>
<p>反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2</span><br><span class="line">if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>确定单层递归的逻辑：</strong></li>
</ol>
<p>单层递归的逻辑就比较好些了，这里我们用重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。</p>
<p>那么单层递归中，就要把两棵树的元素加到一起。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">t1-&gt;val += t2-&gt;val;</span><br></pre></td></tr></tbody></table></figure>

<p>接下来t1 的左子树是：合并 t1左子树 t2左子树之后的左子树。</p>
<p>t1 的右子树：是 合并 t1右子树 t2右子树之后的右子树。</p>
<p>最终t1就是合并之后的根节点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合并二叉树，也是二叉树操作的经典题目，如果没有接触过的话，其实并不简单，因为我们习惯了操作一个二叉树，一起操作两个二叉树，还会有点懵懵的。</p>
<p>这不是我们第一次操作两棵二叉树了，在<a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html">二叉树：我对称么？ (opens new window)</a>中也一起操作了两棵二叉树。</p>
<p>迭代法中，一般一起操作两个树都是使用队列模拟类似层序遍历，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。</p>
<p>最后拓展中，我给了一个操作指针的野路子，大家随便看看就行了，如果学习C++的话，可以在去研究研究。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><p>递归法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> {</span><br><span class="line">	<span class="keyword">if</span>(root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">	<span class="keyword">if</span>(root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">	root1.val += root2.val;</span><br><span class="line">    root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">    root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的所有路径_二叉树07</title>
    <url>/2022/08/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9107/</url>
    <content><![CDATA[<html><head></head><body><h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: <img src="https://img-blog.csdnimg.cn/2021020415161576.png" alt="257.二叉树的所有路径1"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。</p>
<p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。</p>
<p>前序遍历以及回溯的过程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151702443.png" alt="257.二叉树的所有路径"></p>
<p>我们先使用递归的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="#递归"></a><a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E9%80%92%E5%BD%92">#</a>递归</h2><ol>
<li>递归函数函数参数以及返回值</li>
</ol>
<p>要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result)</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定递归终止条件</li>
</ol>
<p>再写递归的时候都习惯了这么写：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (cur == NULL) {</span><br><span class="line">    终止处理逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。</p>
<p><strong>那么什么时候算是找到了叶子节点？</strong> 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。</p>
<p>所以本题的终止条件是：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) {</span><br><span class="line">    终止处理逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。</p>
<p>再来看一下终止处理的逻辑。</p>
<p>这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，在把这个string 放进 result里。</p>
<p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p>
<p>可能有的同学问了，我看有些人的代码也没有回溯啊。</p>
<p><strong>其实是有回溯的，只不过隐藏在函数调用时的参数赋值里</strong>，下文我还会提到。</p>
<p>这里我们先使用vector结构的path容器来记录路径，那么终止处理逻辑如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) { <span class="comment">// 遇到叶子节点</span></span><br><span class="line">    string sPath;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) { <span class="comment">// 将path里记录的路径转为string格式</span></span><br><span class="line">        sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">        sPath += <span class="string">"-&gt;"</span>;</span><br><span class="line">    }</span><br><span class="line">    sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 记录最后一个节点（叶子节点）</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(sPath); <span class="comment">// 收集一个路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定单层递归逻辑</li>
</ol>
<p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">path.push_back(cur-&gt;val);</span><br></pre></td></tr></tbody></table></figure>

<p>然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。</p>
<p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (cur-&gt;left) {</span><br><span class="line">    traversal(cur-&gt;left, path, result);</span><br><span class="line">}</span><br><span class="line">if (cur-&gt;right) {</span><br><span class="line">    traversal(cur-&gt;right, path, result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。</p>
<p>那么回溯要怎么回溯呢，一些同学会这么写，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) {</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) {</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">}</span><br><span class="line">path.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>这个回溯就要很大的问题，我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong>，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。</p>
<p><strong>所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！</strong></p>
<p>那么代码应该这么写：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) {</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) {</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>那么本题整体代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;   </span><br><span class="line">    List&lt;Integer&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    traversal(root,paths,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span> {</span><br><span class="line">    paths.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuidler</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;paths.size() - <span class="number">1</span>;i++) {</span><br><span class="line">            sb.append(paths.get(i)).append(<span class="string">"-&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line">        sb.append(paths.get(paths.size() - <span class="number">1</span>));</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span>) {</span><br><span class="line">        traversal(root.left,paths,res);</span><br><span class="line">        paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span>) {</span><br><span class="line">        traversal(root.right,paths,res);</span><br><span class="line">        paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉搜索树_二叉树13</title>
    <url>/2022/08/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9113/</url>
    <content><![CDATA[<html><head></head><body><h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210203144334501.png" alt="98.验证二叉搜索树"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p>
<p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">traversal</span>(root);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">    <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vec.<span class="built_in">clear</span>(); <span class="comment">// 不加这句在leetcode上也可以过，但最好加上</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。</p>
<p>这道题目比较容易陷入两个陷阱：</p>
<ul>
<li>陷阱1</li>
</ul>
<p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。</p>
<p>写出了类似这样的代码：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) {</span><br><span class="line">    return true;</span><br><span class="line">} else {</span><br><span class="line">    return false;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。</strong>所以以上代码的判断逻辑是错误的。</p>
<p>例如： [10,5,15,null,null,6,20] 这个case：</p>
<p><img src="https://img-blog.csdnimg.cn/20200812191501419.png" alt="二叉搜索树"></p>
<p>节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！</p>
<ul>
<li>陷阱2</li>
</ul>
<p>样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。</p>
<p>此时可以初始化比较元素为longlong的最小值。</p>
<p>问题可以进一步演进：如果样例中根节点的val 可能是longlong的最小值 又要怎么办呢？文中会解答。</p>
<p>了解这些陷阱之后我们来看一下代码应该怎么写：</p>
<p>递归三部曲：</p>
<ul>
<li>确定递归函数，返回值以及参数</li>
</ul>
<p>要定义一个longlong的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有int最小值，所以定义为longlong的类型，初始化为longlong最小值。</p>
<p>注意递归函数要有bool类型的返回值， 我们在<a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有bool类型的返回值。</p>
<p>其实本题是同样的道理，我们在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值</span><br><span class="line">bool isValidBST(TreeNode* root)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>如果是空节点 是不是二叉搜索树呢？</p>
<p>是的，二叉搜索树也可以为空！</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (root == NULL) return true;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>中序遍历，一直更新maxVal，一旦发现maxVal &gt;= root-&gt;val，就返回false，注意元素相同时候也要返回false。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><p>递归法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">TreeNode max;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">   <span class="keyword">if</span>(!left) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(max != <span class="literal">null</span> &amp;&amp; max.val &gt;= root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	max = root;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBst(root.right);</span><br><span class="line">	<span class="keyword">return</span> right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>迭代法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span> || !que.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">null</span>) {</span><br><span class="line">            que.push(cur);</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> que.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur.val &gt;= pre.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>删除二叉搜索树中的节点_二叉树16</title>
    <url>/2022/08/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9116/</url>
    <content><![CDATA[<html><head></head><body><h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。</p>
<p>示例:</p>
<p><img src="https://img-blog.csdnimg.cn/20201020171048265.png" alt="450.删除二叉搜索树中的节点"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>搜索树的节点删除要比节点增加复杂的多，有很多情况需要考虑，做好心里准备。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归三部曲：</p>
<ul>
<li>确定递归函数参数以及返回值</li>
</ul>
<p>说道递归函数的返回值，在<a href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html">二叉树：搜索树中的插入操作 (opens new window)</a>中通过递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">TreeNode* deleteNode(TreeNode* root, int key)</span><br></pre></td></tr></tbody></table></figure>

<p>1</p>
<ul>
<li>确定终止条件</li>
</ul>
<p>遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (root == nullptr) return root;</span><br></pre></td></tr></tbody></table></figure>

<p>1</p>
<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>这里就把二叉搜索树中删除节点遇到的情况都搞清楚。</p>
<p>有以下五种情况：</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p>第五种情况有点难以理解，看下面动画：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p>
<p>动画中棵二叉搜索树中，删除元素7， 那么删除节点（元素7）的左孩子就是5，删除节点（元素7）的右子树的最左面节点是元素8。</p>
<p>将删除节点（元素7）的左孩子放到删除节点（元素7）的右子树的最左面节点（元素8）的左孩子上，就是把5为根节点的子树移到了8的左孩子的位置。</p>
<p>要删除的节点（元素7）的右孩子（元素9）为新的根节点。.</p>
<p>这样就完成删除元素7的逻辑，最好动手画一个图，尝试删除一个节点试试。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> {</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> delete(root,key);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">delete</span><span class="params">(TreeNode root,<span class="type">int</span> key)</span> {</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(root.val &gt; key) root.left = delete(root.left,key);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key) <span class="type">root</span> <span class="variable">right</span> <span class="operator">=</span> delete(root.right,key);</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">	<span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.right;</span><br><span class="line">		<span class="keyword">while</span>(tmp.left != <span class="literal">null</span>) {</span><br><span class="line">			tmp = tmp.left;</span><br><span class="line">		}</span><br><span class="line">		tmp.left = root.left;</span><br><span class="line">		<span class="keyword">return</span> root.right;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。</p>
<p><strong>因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整</strong>。</p>
<p>这里我们依然使用递归函数的返回值来完成把节点从二叉树中移除的操作。</p>
<p><strong>这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚</strong>。</p>
<p>而且就算想清楚了，对应的代码也未必可以写出来，所以<strong>这道题目即考察思维逻辑，也考察代码能力</strong>。</p>
<p>递归中我给出了两种写法，推荐大家学会第一种（利用搜索树的特性）就可以了，第二种递归写法其实是比较绕的。</p>
<p>最后我也给出了相应的迭代法，就是模拟递归法中的逻辑来删除节点，但需要一个pre记录cur的父节点，方便做删除操作。</p>
<p>迭代法其实不太容易写出来，所以如果是初学者的话，彻底掌握第一种递归写法就够了</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的最小绝对差_二叉树14</title>
    <url>/2022/08/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9114/</url>
    <content><![CDATA[<html><head></head><body><h1 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">力扣题目链接(opens new window)</a></p>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20201014223400123.png" alt="530二叉搜索树的最小绝对差"></p>
<p>提示：树中至少有 2 个节点。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p>
<p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p>
<p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p>
<p><strong>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</strong></p>
<p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) { <span class="comment">// 统计有序数组的最小差值</span></span><br><span class="line">            result = <span class="built_in">min</span>(result, vec[i] - vec[i<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p>
<p>需要用一个pre节点记录一下cur节点的前一个节点。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153247458.png" alt="530.二叉搜索树的最小绝对差"></p>
<p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> result = INT_MAX;</span><br><span class="line">TreeNode* pre;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left);   <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span>){       <span class="comment">// 中</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">    }</span><br><span class="line">    pre = cur; <span class="comment">// 记录前一个</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>是不是看上去也并不复杂！</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>看过这两篇<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：听说递归能做的，栈也能做！ (opens new window)</a>，<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代方式的写法就不能统一一下么？ (opens new window)</a>文章之后，不难写出两种中序遍历的迭代法。</p>
<p>下面我给出其中的一种中序遍历的迭代法，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) { <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) {              <span class="comment">// 中</span></span><br><span class="line">                    result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">                }</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。</strong></p>
<p>同时要学会在递归遍历的过程中如何记录前后两个指针，这也是一个小技巧，学会了还是很受用的。</p>
<p>后面我将继续介绍一系列利用二叉搜索树特性的题目。</p>
<p>Java代码如下：</p>
<p>递归法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">TreeNode pre;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	pre = <span class="literal">null</span>;</span><br><span class="line">	travesal(root);</span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travesal</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	travesal(root.left)</span><br><span class="line">	<span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; min &gt; Math.abs(root.val - pre.val)) {</span><br><span class="line">		min = Math.abs(root.val - pre.val);</span><br><span class="line">	}</span><br><span class="line">	pre = root;</span><br><span class="line">	travesal(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>迭代法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(cur !=<span class="literal">null</span> || !que.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">null</span>) {</span><br><span class="line">            que.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            cur = que.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; min &gt; Math.abs(pre.val - cur.val)) {</span><br><span class="line">                min = Math.abs(pre.val - cur.val);</span><br><span class="line">            }</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划理论基础_动态规划01</title>
    <url>/2022/08/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201/</url>
    <content><![CDATA[<html><head></head><body><h1 id="动态规划理论基础"><a href="#动态规划理论基础" class="headerlink" title="动态规划理论基础"></a>动态规划理论基础</h1><p>动态规划刷题大纲</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg" alt="img"></p>
<h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="#什么是动态规划"></a><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">#</a>什么是动态规划</h2><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p>
<p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，</p>
<p>在<a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于贪心算法，你该了解这些！ (opens new window)</a>中我举了一个背包问题的例子。</p>
<p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p>
<p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p>
<p>所以贪心解决不了动态规划的问题。</p>
<p><strong>其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了</strong>。</p>
<p>而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。</p>
<p>大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p>
<p>上述提到的背包问题，后序会详细讲解。</p>
<h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="#动态规划的解题步骤"></a><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4">#</a>动态规划的解题步骤</h2><p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。</p>
<p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中</strong>。</p>
<p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p>
<p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<ol>
<li><strong>确定dp数组（dp table）以及下标的含义</strong></li>
<li><strong>确定递推公式</strong></li>
<li><strong>dp数组如何初始化</strong></li>
<li><strong>确定遍历顺序</strong></li>
<li><strong>举例推导dp数组</strong></li>
</ol>
<p>一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？</p>
<p><strong>因为一些情况是递推公式决定了dp数组要如何初始化！</strong></p>
<p>后面的讲解中我都是围绕着这五点来进行讲解。</p>
<p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p>
<p>其实 确定递推公式 仅仅是解题里的一步而已！</p>
<p>一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p>
<p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p>
<h2 id="动态规划应该如何debug"><a href="#动态规划应该如何debug" class="headerlink" title="#动态规划应该如何debug"></a><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95debug">#</a>动态规划应该如何debug</h2><p>相信动规的题目，很大部分同学都是这样做的。</p>
<p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。</p>
<p>写动规题目，代码出问题很正常！</p>
<p><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p>
<p>一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p>
<p>这是一个很不好的习惯！</p>
<p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p>
<p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p>
<p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p>
<p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p>
<p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了</strong>。</p>
<p>这也是我为什么在动规五步曲里强调推导dp数组的重要性。</p>
<p>举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？</p>
<p>发出这样的问题之前，其实可以自己先思考这三个问题：</p>
<ul>
<li>这道题目我举例推导状态转移公式了么？</li>
<li>我打印dp数组的日志了么？</li>
<li>打印出来了dp数组和我想的一样么？</li>
</ul>
<p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。</p>
<p>然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。</p>
<p><strong>注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！</strong></p>
<p><strong>大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！</strong></p>
<p>如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。</p>
<p>所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何debug。</p>
<p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p>
<p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的01背包，leetcode上的题目都是01背包的应用，而没有纯01背包的问题，那么就需要在把对应的理论知识讲解一下。</p>
<p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p>
<p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。</p>
<p>今天我们开始新的征程了，你准备好了么？</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先_二叉树15</title>
    <url>/2022/08/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9115/</url>
    <content><![CDATA[<html><head></head><body><h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://img-blog.csdnimg.cn/20201016173414722.png" alt="236. 二叉树的最近公共祖先"></p>
<p>示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p>示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p>
<p>那么二叉树如何可以自底向上查找呢？</p>
<p>回溯啊，二叉树回溯的过程就是从低到上。</p>
<p>后序遍历就是天然的回溯过程，最先处理的一定是叶子节点。</p>
<p>接下来就看如何判断一个节点是节点q和节点p的公共公共祖先呢。</p>
<p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong></p>
<p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong></p>
<p>使用后序遍历，回溯的过程，就是从低向上遍历节点，一旦发现满足第一种情况的节点，就是最近公共节点了。</p>
<p><strong>但是如果p或者q本身就是最近公共祖先呢？其实只需要找到一个节点是p或者q的时候，直接返回当前节点，无需继续递归子树。如果接下来的遍历中找到了后继节点满足第一种情况则修改返回值为后继节点，否则，继续返回已找到的节点即可。为什么满足第一种情况的节点一定是p或q的后继节点呢?大家可以仔细思考一下。</strong></p>
<p>递归三部曲：</p>
<ul>
<li>确定递归函数返回值以及参数</li>
</ul>
<p>需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。</p>
<p>但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode * ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>如果找到了 节点p或者q，或者遇到空节点，就返回。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (root == q || root == p || root == NULL) return root;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>确定单层递归逻辑</li>
</ul>
<p>值得注意的是 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。</p>
<p>我们在<a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>中说了 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！</p>
<p>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</p>
<p>搜索一条边的写法：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (递归函数(root-&gt;left)) return ;</span><br><span class="line"></span><br><span class="line">if (递归函数(root-&gt;right)) return ;</span><br></pre></td></tr></tbody></table></figure>

<p>搜索整个树写法：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></tbody></table></figure>

<p>看出区别了没？</p>
<p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong>。</p>
<p>那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2021020415105872.png" alt="236.二叉树的最近公共祖先"></p>
<p>就像图中一样直接返回7，多美滋滋。</p>
<p>但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。</p>
<p>因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></tbody></table></figure>

<p>所以此时大家要知道我们要遍历整棵树。知道这一点，对本题就有一定深度的理解了。</p>
<p>那么先用left和right接住左子树和右子树的返回值，代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解</strong></p>
<p><strong>如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然</strong>。</p>
<p>这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢？</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p>
<p>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</p>
<p>这里点也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p>
<p>那么如果left和right都为空，则返回left或者right都是可以的，也就是返回空。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span>  { <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>那么寻找最小公共祖先，完整流程图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/202102041512582.png" alt="236.二叉树的最近公共祖先2"></p>
<p><strong>从图中，大家可以看到，我们是如何回溯遍历整棵二叉树，将结果返回给头结点的！</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题目刷过的同学未必真正了解这里面回溯的过程，以及结果是如何一层一层传上去的。</p>
<p><strong>那么我给大家归纳如下三点</strong>：</p>
<ol>
<li>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。</li>
<li>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</li>
<li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</li>
</ol>
<p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p>
<p>本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">    	<span class="keyword">if</span>(p == root || q == root || root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    	<span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">   		<span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    	<span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数_动态规划02</title>
    <url>/2022/08/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9202/</url>
    <content><![CDATA[<html><head></head><body><h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h1><p><a href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接(opens new window)</a></p>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p>
<p>示例 1：</p>
<ul>
<li>输入：2</li>
<li>输出：1</li>
<li>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：3</li>
<li>输出：2</li>
<li>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</li>
</ul>
<p>示例 3：</p>
<ul>
<li>输入：4</li>
<li>输出：3</li>
<li>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</li>
</ul>
<p>提示：</p>
<ul>
<li>0 &lt;= n &lt;= 30</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>斐波那契数列大家应该非常熟悉不过了，非常适合作为动规第一道题目来练练手。</p>
<p>因为这道题目比较简单，可能一些同学并不需要做什么分析，直接顺手一写就过了。</p>
<p><strong>但「代码随想录」的风格是：简单题目是用来加深对解题方法论的理解的</strong>。</p>
<p>通过这道题目让大家可以初步认识到，按照动规五部曲是如何解题的。</p>
<p>对于动规，如果没有方法论的话，可能简单题目可以顺手一写就过，难一点就不知道如何下手了。</p>
<p>所以我总结的动规五部曲，是要用来贯穿整个动态规划系列的，就像之前讲过<a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树系列的递归三部曲 (opens new window)</a>，<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">回溯法系列的回溯三部曲 (opens new window)</a>一样。后面慢慢大家就会体会到，动规五部曲方法的重要性。</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="#动态规划"></a><a href="https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">#</a>动态规划</h3><p>动规五部曲：</p>
<p>这里我们要用一个一维dp数组来保存递归的结果</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>为什么这是一道非常简单的入门题目呢？</p>
<p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">dp[0] = 0;</span><br><span class="line">dp[1] = 1;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定遍历顺序</li>
</ol>
<p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>
<p>0 1 1 2 3 5 8 13 21 34 55</p>
<p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><h3 id="递归打法"><a href="#递归打法" class="headerlink" title="递归打法"></a>递归打法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="动态规划打法"><a href="#动态规划打法" class="headerlink" title="动态规划打法:"></a>动态规划打法:</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="comment">// 首先知道dp的含义是什么？ 以及下标是什么意思</span></span><br><span class="line">	<span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; n;i++) {</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; n;i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径_动态规划05</title>
    <url>/2022/08/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9205/</url>
    <content><![CDATA[<html><head></head><body><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接(opens new window)</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例 1：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110174033215.png" alt="img"></p>
<ul>
<li>输入：m = 3, n = 7</li>
<li>输出：28</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：m = 2, n = 3</li>
<li>输出：3</li>
</ul>
<p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p>示例 3：</p>
<ul>
<li>输入：m = 7, n = 3</li>
<li>输出：28</li>
</ul>
<p>示例 4：</p>
<ul>
<li>输入：m = 3, n = 3</li>
<li>输出：6</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= m, n &lt;= 100</li>
<li>题目数据保证答案小于等于 2 * 10^9</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。</p>
<p>按照动规五部曲来分析：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。</p>
<p>此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。</p>
<p>那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。</p>
<ol>
<li>dp数组的初始化</li>
</ol>
<p>如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。</p>
<p>所以初始化代码为：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定遍历顺序</li>
</ol>
<p>这里要看一下递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p>
<p>这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p>
<h2 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="comment">// dp[i][j] 在(0,0) 位置到(i,j)不同的路径数量</span></span><br><span class="line">	<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;m;i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;n;j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 遍历方式  从上到下 从左到右</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++) {</span><br><span class="line">            <span class="comment">// 递推公式</span></span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>使用最小花费爬楼梯_动态规划04</title>
    <url>/2022/08/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9204/</url>
    <content><![CDATA[<html><head></head><body><h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h1><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接(opens new window)</a></p>
<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<p>示例 1：</p>
<p>输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。  示例 2：</p>
<p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p>
<p>提示：</p>
<ul>
<li>cost 的长度范围是 [2, 1000]。</li>
<li>cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>这道题目可以说是昨天<a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html">动态规划：爬楼梯 (opens new window)</a>的花费版本。</p>
<p><strong>注意题目描述：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯</strong></p>
<p>所以示例1中只花费一个15 就可以到阶梯顶，最后一步可以理解为 不用花费。</p>
<p>读完题大家应该知道指定需要动态规划的，贪心是不可能了。</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。</p>
<p>**dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]**。（注意这里认为是第一步一定是要花费）</p>
<p><strong>对于dp数组的定义，大家一定要清晰！</strong></p>
<ol>
<li>确定递推公式</li>
</ol>
<p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p>
<p>那么究竟是选dp[i-1]还是dp[i-2]呢？</p>
<p>一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</p>
<p><strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong>，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>根据dp数组的定义，dp数组初始化其实是比较难的，因为不可能初始化为第i台阶所花费的最少体力。</p>
<p>那么看一下递归公式，dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。</p>
<p>所以初始化代码为：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;int&gt; dp(cost.size());</span><br><span class="line">dp[0] = cost[0];</span><br><span class="line">dp[1] = cost[1];</span><br></pre></td></tr></tbody></table></figure>

<p>1<br>2<br>3</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>最后一步，递归公式有了，初始化有了，如何遍历呢？</p>
<p>本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。</p>
<p>因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。</p>
<p><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。</p>
<p>例如：01背包，都知道两个for循环，一个for遍历物品嵌套一个for遍历背包容量，那么为什么不是一个for遍历背包容量嵌套一个for遍历物品呢？ 以及在使用一维dp数组的时候遍历背包容量为什么要倒序呢？</p>
<p><strong>这些都是遍历顺序息息相关。当然背包问题后续「代码随想录」都会重点讲解的！</strong></p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021010621363669.png" alt="746.使用最小花费爬楼梯"></p>
<p>如果大家代码写出来有问题，就把dp数组打印出来，看看和如上推导的是不是一样的。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这道题描述也确实有点魔幻。</p>
<p>题目描述为：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>示例1：</p>
<p>输入：cost = [10, 15, 20] 输出：15</p>
<p><strong>从题目描述可以看出：要不是第一步不需要花费体力，要不就是第最后一步不需要花费体力，我个人理解：题意说的其实是第一步是要支付费用的！</strong>。因为是当你爬上一个台阶就要花费对应的体力值！</p>
<p>所以我定义的dp[i]意思是也是第一步是要花费体力的，最后一步不用花费体力了，因为已经支付了。</p>
<p>当然也可以样，定义dp[i]为:第一步是不花费体力，最后一步是花费体力的。</p>
<h2 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> {</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length];</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length;i++) {</span><br><span class="line">        dp[i] = Math.min(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]) + cost[i];</span><br><span class="line">        System.out.println(dp[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[cost.length-<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯_动态规划03</title>
    <url>/2022/08/23/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9203/</url>
    <content><![CDATA[<html><head></head><body><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h1><p><a href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接(opens new window)</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<ul>
<li>输入： 2</li>
<li>输出： 2</li>
<li>解释： 有两种方法可以爬到楼顶。<ul>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ul>
</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入： 3</li>
<li>输出： 3</li>
<li>解释： 有三种方法可以爬到楼顶。<ul>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ul>
</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。</p>
<p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p>
<p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p>
<p>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p>
<p>我们来分析一下，动规五部曲：</p>
<p>定义一个一维数组来记录不同楼层的状态</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>如果可以推出dp[i]呢？</p>
<p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p>
<p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p>
<p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p>
<p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p>
<p>所以dp[i] = dp[i - 1] + dp[i - 2] 。</p>
<p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</p>
<p>这体现出确定dp数组以及下标的含义的重要性！</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。</p>
<p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。</p>
<p>例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。</p>
<p>但总有点牵强的成分。</p>
<p>那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.</p>
<p><strong>其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1</strong>。</p>
<p>从dp数组定义的角度上来说，dp[0] = 0 也能说得通。</p>
<p>需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。</p>
<p>所以本题其实就不应该讨论dp[0]的初始化！</p>
<p>我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。</p>
<p>所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>举例当n为5的时候，dp table（dp数组）应该是这样的</p>
<p><img src="https://img-blog.csdnimg.cn/20210105202546299.png" alt="70.爬楼梯"></p>
<p>如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。</p>
<p><strong>此时大家应该发现了，这不就是斐波那契数列么！</strong></p>
<p>唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！</p>
<h2 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="comment">// 知道下标和数组本身的意义</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 确定遍历顺序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++) {</span><br><span class="line">        <span class="comment">// 递推公式</span></span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 自个打印日志康康</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径(II)_动态规划06</title>
    <url>/2022/08/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9206/</url>
    <content><![CDATA[<html><head></head><body><h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h1><p><a href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接(opens new window)</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="https://img-blog.csdnimg.cn/20210111204901338.png" alt="img"></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>示例 1：</p>
<p><img src="https://img-blog.csdnimg.cn/20210111204939971.png" alt="img"></p>
<ul>
<li>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</li>
<li>输出：2 解释：</li>
<li>3x3 网格的正中间有一个障碍物。</li>
<li>从左上角到右下角一共有 2 条不同的路径：<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
</li>
</ul>
<p>示例 2：</p>
<p><img src="https://img-blog.csdnimg.cn/20210111205857918.png" alt="img"></p>
<ul>
<li>输入：obstacleGrid = [[0,1],[0,0]]</li>
<li>输出：1</li>
</ul>
<p>提示：</p>
<ul>
<li>m == obstacleGrid.length</li>
<li>n == obstacleGrid[i].length</li>
<li>1 &lt;= m, n &lt;= 100</li>
<li>obstacleGrid[i][j] 为 0 或 1</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>这道题相对于<a href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html">62.不同路径 (opens new window)</a>就是有了障碍。</p>
<p>第一次接触这种题目的同学可能会有点懵，这有障碍了，应该怎么算呢？</p>
<p><a href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html">62.不同路径 (opens new window)</a>中我们已经详细分析了没有障碍的情况，有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了。</p>
<p>动规五部曲：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>递推公式和62.不同路径一样，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]。</p>
<p>但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。</p>
<p>所以代码为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) { <span class="comment">// 当(i, j)没有障碍的时候，再推导dp[i][j]</span></span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>dp数组如何初始化</li>
</ol>
<p>在<a href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html">62.不同路径 (opens new window)</a>不同路径中我们给出如下的初始化：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 初始值为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>因为从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i][0]一定为1，dp[0][j]也同理。</p>
<p>但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i][0]应该还是初始值0。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210104114513928.png" alt="63.不同路径II"></p>
<p>下标(0, j)的初始化情况同理。</p>
<p>所以本题初始化代码为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意代码里for循环的终止条件，一旦遇到obstacleGrid[i][0] == 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理</strong></p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>从递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 中可以看出，一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>举例推导dp数组</li>
</ol>
<p>拿示例1来举例如题：</p>
<p><img src="https://img-blog.csdnimg.cn/20210104114548983.png" alt="63.不同路径II1"></p>
<p>对应的dp table 如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210104114610256.png" alt="63.不同路径II2"></p>
<p>如果这个图看不同，建议在理解一下递归公式，然后照着文章中说的遍历顺序，自己推导一下！</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> {</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> dp.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dp[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++) {</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++) {</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 遍历方式 从上到下 从左到右</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++) {</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>]dp[n-<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>不同的二叉搜索树_动态规划08</title>
    <url>/2022/08/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9208/</url>
    <content><![CDATA[<html><head></head><body><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h1><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p><img src="https://img-blog.csdnimg.cn/20210113161941835.png" alt="img"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>这道题目描述很简短，但估计大部分同学看完都是懵懵的状态，这得怎么统计呢？</p>
<p>关于什么是二叉搜索树，我们之前在讲解二叉树专题的时候已经详细讲解过了，也可以看看这篇<a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉树：二叉搜索树登场！ (opens new window)</a>再回顾一波。</p>
<p>了解了二叉搜索树之后，我们应该先举几个例子，画画图，看看有没有什么规律，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093106367.png" alt="96.不同的二叉搜索树"></p>
<p>n为1的时候有一棵树，n为2有两棵树，这个是很直观的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093129889.png" alt="96.不同的二叉搜索树1"></p>
<p>来看看n为3的时候，有哪几种情况。</p>
<p>当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！</p>
<p>（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）</p>
<p>当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！</p>
<p>当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！</p>
<p>发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。</p>
<p>思考到这里，这道题目就有眉目了。</p>
<p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<p>元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p>
<p>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p>
<p>元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p>
<p>有2个元素的搜索树数量就是dp[2]。</p>
<p>有1个元素的搜索树数量就是dp[1]。</p>
<p>有0个元素的搜索树数量就是dp[0]。</p>
<p>所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093226241.png" alt="96.不同的二叉搜索树2"></p>
<p>此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍。</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。</p>
<p>也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p>
<p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p>
<p>j相当于是头结点的元素，从1遍历到i为止。</p>
<p>所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p>
<p>那么dp[0]应该是多少呢？</p>
<p>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p>
<p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p>
<p>所以初始化dp[0] = 1</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p>
<p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) {</span><br><span class="line">        dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>举例推导dp数组</li>
</ol>
<p>n为5时候的dp数组状态如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" alt="96.不同的二叉搜索树3"></p>
<p>当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。</p>
<p><strong>我这里列到了n为5的情况，是为了方便大家 debug代码的时候，把dp数组打出来，看看哪里有问题</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题目虽然在力扣上标记是中等难度，但可以算是困难了！</p>
<p>首先这道题想到用动规的方法来解决，就不太好想，需要举例，画图，分析，才能找到递推的关系。</p>
<p>然后难点就是确定递推公式了，如果把递推公式想清楚了，遍历顺序和初始化，就是自然而然的事情了。</p>
<p>可以看出我依然还是用动规五部曲来进行分析，会把题目的方方面面都覆盖到！</p>
<p><strong>而且具体这五部分析是我自己平时总结的经验，找不出来第二个的，可能过一阵子 其他题解也会有动规五部曲了，哈哈</strong>。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="comment">// i个元素的二叉搜索数总量</span></span><br><span class="line">	  <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i; j++) {</span><br><span class="line">            <span class="comment">// 给我的感觉有点像和尚师傅上面的珠子一样 一粒一粒的划过</span></span><br><span class="line">            dp[i] += dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>整数拆分_动态规划07</title>
    <url>/2022/08/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9207/</url>
    <content><![CDATA[<html><head></head><body><h1 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h1><p><a href="https://leetcode.cn/problems/integer-break/">力扣题目链接(opens new window)</a></p>
<p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>示例 1:</p>
<ul>
<li>输入: 2</li>
<li>输出: 1</li>
<li>解释: 2 = 1 + 1, 1 × 1 = 1。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: 10</li>
<li>输出: 36</li>
<li>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</li>
<li>说明: 你可以假设 n 不小于 2 且不大于 58。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>看到这道题目，都会想拆成两个呢，还是三个呢，还是四个….</p>
<p>我们来看一下如何使用动规来解决。</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="#动态规划"></a><a href="https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">#</a>动态规划</h3><p>动规五部曲，分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p>
<p>dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>可以想 dp[i]最大乘积是怎么得到的呢？</p>
<p>其实可以从1遍历j，然后有两种渠道得到dp[i].</p>
<p>一个是j * (i - j) 直接相乘。</p>
<p>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。</p>
<p><strong>那有同学问了，j怎么就不拆分呢？</strong></p>
<p>j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</p>
<p>也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。</p>
<p>如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。</p>
<p>所以递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});</p>
<p>那么在取最大值的时候，为什么还要比较dp[i]呢？</p>
<p>因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。</p>
<ol>
<li>dp的初始化</li>
</ol>
<p>不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？</p>
<p>有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p>
<p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p>
<p>拆分0和拆分1的最大乘积是多少？</p>
<p>这是无解的。</p>
<p>这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</p>
<p>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p>
<p>枚举j的时候，是从1开始的。i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。</p>
<p>所以遍历顺序为：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">for (int i = 3; i &lt;= n ; i++) {</span><br><span class="line">    for (int j = 1; j &lt; i - 1; j++) {</span><br><span class="line">        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>举例推导dp数组</li>
</ol>
<p>举例当n为10 的时候，dp数组里的数值，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210104173021581.png" alt="343.整数拆分"></p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="comment">// 整数i的最大乘积dp[i]</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历顺序 从前往后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i-<span class="number">1</span>; j++) {</span><br><span class="line">            dp[i] = Math.max(dp[i],Math.max(dp[i-j] * j,j*(i-j)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>关于01背包问题_动态规划09</title>
    <url>/2022/09/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9209/</url>
    <content><![CDATA[<html><head></head><body><h1 id="动态规划：关于01背包问题"><a href="#动态规划：关于01背包问题" class="headerlink" title="动态规划：关于01背包问题"></a>动态规划：关于01背包问题</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><p><strong>这个01背包问题，你要是不去把递归公式推一遍，哭死你</strong></p>
<p>这周我们正式开始讲解背包问题！</p>
<p>背包问题的经典资料当然是：背包九讲。在公众号「代码随想录」后台回复：背包九讲，就可以获得背包九讲的pdf。</p>
<p>但说实话，背包九讲对于小白来说确实不太友好，看起来还是有点费劲的，而且都是伪代码理解起来也吃力。</p>
<p>对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。</p>
<p>如果这几种背包，分不清，我这里画了一个图，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p>
<p>至于背包九讲其其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。</p>
<p>而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。</p>
<p><strong>所以背包问题的理论基础重中之重是01背包，一定要理解透！</strong></p>
<p>leetcode上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。</p>
<p><strong>所以我先通过纯01背包问题，把01背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为01背包问题了</strong>。</p>
<p>之前可能有些录友已经可以熟练写出背包了，但只要把这个文章仔细看完，相信你会意外收获！</p>
<h2 id="01-背包"><a href="#01-背包" class="headerlink" title="#01 背包"></a><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85">#</a>01 背包</h2><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><img src="https://img-blog.csdnimg.cn/20210117175428387.jpg" alt="动态规划-背包问题"></p>
<p>这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。</p>
<p>这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？</p>
<p>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p>
<p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p>
<p>在下面的讲解中，我举一个例子：</p>
<p>背包最大重量为4。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<p>以下讲解和图示中出现的数字都是以这个例子为例。</p>
<h2 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="#二维dp数组01背包"></a><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85">#</a>二维dp数组01背包</h2><p>依然动规五部曲分析一波。</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<p>只看这个二维数组的定义，大家一定会有点懵，看下面这个图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103003361.png" alt="动态规划-背包问题1"></p>
<p><strong>要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的</strong>，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p>那么可以有两个方向推出来dp[i][j]，</p>
<ul>
<li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li>
<li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<p>所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2021011010304192.png" alt="动态规划-背包问题2"></p>
<p>在看其他情况。</p>
<p>状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>
<p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>
<p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>
<p>当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p>
<p>代码初始化如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">for (int j = 0 ; j &lt; weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br><span class="line">    dp[0][j] = 0;</span><br><span class="line">}</span><br><span class="line">// 正序遍历</span><br><span class="line">for (int j = weight[0]; j &lt;= bagweight; j++) {</span><br><span class="line">    dp[0][j] = value[0];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时dp数组初始化情况如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103109140.png" alt="动态规划-背包问题7"></p>
<p>1.<br>   确定遍历顺序</p>
<p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p>
<p><img src="https://img-blog.csdnimg.cn/2021011010314055.png" alt="动态规划-背包问题3"></p>
<p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p>
<p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p>
<p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">// weight数组的大小 就是物品个数</span><br><span class="line">for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品</span><br><span class="line">    for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量</span><br><span class="line">        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; </span><br><span class="line">        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）</strong></p>
<p>例如这样：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">// weight数组的大小 就是物品个数</span><br><span class="line">for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量</span><br><span class="line">    for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品</span><br><span class="line">        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j];</span><br><span class="line">        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为什么也是可以的呢？</p>
<p><strong>要理解递归的本质和递推的方向</strong>。</p>
<p>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。</p>
<p>dp[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/202101101032124.png" alt="动态规划-背包问题5"></p>
<p>再来看看先遍历背包，再遍历物品呢，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103244701.png" alt="动态规划-背包问题6"></p>
<p><strong>大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！</strong></p>
<p>但先遍历物品再遍历背包这个顺序更好理解。</p>
<p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>来看一下对应的dp数组的数值，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" alt="动态规划-背包问题4"></p>
<p>最终结果就是dp[2][4]。</p>
<p>建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。</p>
<p><strong>做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！</strong></p>
<p>很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。</p>
<p>主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了</p>
<h2 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">weightbagproblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagsize)</span>{</span><br><span class="line">	<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[weight.length][bagsize+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 其实这一步不用也可以</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; weight.length;i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= bagsize;j++) {</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= weight[<span class="number">0</span>]) dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]; </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 确定遍历顺序 先物品再重量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; weight.length;i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= bagsize;j++) {</span><br><span class="line">            <span class="keyword">if</span>(j &lt; weight[i]) dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-weight[i]] + value[i])</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[weight.length-<span class="number">1</span>][bagsize];</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>关于01背包问题（滚动数组）_动态规划10</title>
    <url>/2022/09/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9210/</url>
    <content><![CDATA[<html><head></head><body><h1 id="关于01背包问题（滚动数组）"><a href="#关于01背包问题（滚动数组）" class="headerlink" title="关于01背包问题（滚动数组）"></a>关于01背包问题（滚动数组）</h1><p>昨天<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">动态规划：关于01背包问题，你该了解这些！ (opens new window)</a>中是用二维dp数组来讲解01背包。</p>
<p>今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。</p>
<p>那么我们通过01背包，来彻底讲一讲滚动数组！</p>
<p>接下来还是用如下这个例子来进行讲解</p>
<p>背包最大重量为4。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<h2 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h2><p>对于背包问题其实状态都是可以压缩的。</p>
<p>在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>
<p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</strong></p>
<p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>
<p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>
<p>读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。</p>
<p><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<p>一定要时刻记住这里i和j的含义，要不然很容易看懵了。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组的定义</li>
</ol>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<ol>
<li>一维dp数组的递推公式</li>
</ol>
<p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p>所以递归公式为：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p>
<ol>
<li>一维dp数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>
<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>
<ol>
<li>一维dp数组遍历顺序</li>
</ol>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品</span><br><span class="line">    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p>
<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<p>为什么呢？</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p>
<p>如果正序遍历</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
<p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p>
<p>因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！</p>
<p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p>
<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>
<p>不可以！</p>
<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p>
<p>（这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p>
<p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103614769.png" alt="动态规划-背包问题9"></p>
<h2 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">WeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagWeight)</span>{</span><br><span class="line">	<span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagweight+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; weight.length;i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagweight;j &gt;= weight[i];j--) {</span><br><span class="line">            dp[j] = Math.max(dp[j-weight[i]] + value[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 打印dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= bagWeight;j++) {</span><br><span class="line">        System.out.println(dp[j] +<span class="string">" "</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>分割等和子集_动态规划11</title>
    <url>/2022/09/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9211/</url>
    <content><![CDATA[<html><head></head><body><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">力扣题目链接(opens new window)</a></p>
<p>题目难易：中等</p>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p>
<p>示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].</p>
<p>示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.</p>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 200</li>
<li>1 &lt;= nums[i] &lt;= 100</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>这道题目初步看，是如下两题几乎是一样的，大家可以用回溯法，解决如下两题</p>
<ul>
<li>698.划分为k个相等的子集</li>
<li>473.火柴拼正方形</li>
</ul>
<p>这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p>
<p>本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。</p>
<p>如果对01背包不够了解，建议仔细看完如下两篇：</p>
<ul>
<li><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">动态规划：关于01背包问题，你该了解这些！(opens new window)</a></li>
<li><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）(opens new window)</a></li>
</ul>
<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="#01背包问题"></a><a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html#_01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">#</a>01背包问题</h2><p>背包问题，大家都知道，有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。</strong></p>
<p>要注意题目描述中商品是不是可以重复放入。</p>
<p><strong>即一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包，写法还是不一样的。</strong></p>
<p><strong>要明确本题中我们要使用的是01背包，因为元素我们只能用一次。</strong></p>
<p>回归主题：首先，本题要求集合里能否出现总和为 sum / 2 的子集。</p>
<p>那么来一一对应一下本题，看看背包问题如果来解决。</p>
<p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p>
<ul>
<li>背包的体积为sum / 2</li>
<li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li>
<li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<p>以上分析完，我们就可以套用01背包，来解决这个问题了。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p>**套到本题，dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]**。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p>
<p>所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>在01背包，一维dp如何初始化，已经讲过，</p>
<p>从dp[j]的定义来看，首先dp[0]一定是0。</p>
<p>如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line"><span class="comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>确定遍历顺序</li>
</ol>
<p>在<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 开始 01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= nums[i]; j--) { <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>举例推导dp数组</li>
</ol>
<p>dp[j]的数值一定是小于等于j的。</p>
<p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p>
<p>用例1，输入[1,5,11,5] 为例，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110104240545.png" alt="416.分割等和子集2"></p>
<p>最后dp[11] == 11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题目就是一道01背包应用类的题目，需要我们拆解题目，然后套入01背包的场景。</p>
<p>01背包相对于本题，主要要理解，题目中物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2。</p>
<p>看代码的话，就可以发现，基本就是按照01背包的写法来的。</p>
<h3 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target;j &gt;= nums[i];j--) {</span><br><span class="line">            dp[j] = Math.max(dp[j],dp[j-nums[i]] + nums[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数组在哈希表中的应用</title>
    <url>/2022/07/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<html><head></head><body><h1 id="数组在哈希表中的应用"><a href="#数组在哈希表中的应用" class="headerlink" title="数组在哈希表中的应用"></a>数组在哈希表中的应用</h1><p><a href="https://leetcode.cn/problems/valid-anagram/">题目链接</a></p>
<h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><p>伪代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">方法名：String t,string s</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">hash</span>[<span class="number">26</span>] <span class="number">0</span>~<span class="number">25</span> -&gt; a~z</span><br><span class="line"><span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(t)</span>:</span><br><span class="line">	hash[t[i] - <span class="string">'a'</span>] += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j in <span class="title function_">range</span><span class="params">(s)</span>:</span><br><span class="line">	hash[s[i] - <span class="string">'a'</span>] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:hash){</span><br><span class="line">	<span class="keyword">if</span> i!=<span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>不同的二叉搜索树_动态规划08</title>
    <url>/2022/09/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9212/</url>
    <content><![CDATA[<html><head></head><body></body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A801/</url>
    <content><![CDATA[<html><head></head><body><h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接(opens new window)</a></p>
<p>题意：给定两个数组，编写一个函数来计算它们的交集。</p>
<p><img src="https://s2.loli.net/2022/07/22/x4yNsaYlTSwroHL.png" alt="349. 两个数组的交集"></p>
<p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>关于本题，我录制了讲解视频：<a href="https://www.bilibili.com/video/BV1ba411S7wu">学透哈希表，set使用有技巧！Leetcode：349. 两个数组的交集 (opens new window)</a>，看视频配合题解，事半功倍。</p>
<p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p>
<p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</strong></p>
<p>这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。</p>
<p>那么用数组来做哈希表也是不错的选择，例如<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词(opens new window)</a></p>
<p>但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p>
<p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p>
<p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p>
<p>此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：</p>
<ul>
<li>std::set</li>
<li>std::multiset</li>
<li>std::unordered_set</li>
</ul>
<p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p>
<p>思路如图所示：</p>
<p><img src="https://s2.loli.net/2022/07/22/6RG3uhyqpUTOLN8.png" alt="set哈希法"></p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) {</span><br><span class="line">    		<span class="comment">// 通过两个hashSet 分别来存储nums1中出现的元素，返回结果</span></span><br><span class="line">    		Set&lt;Integer&gt; hash1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    		Set&lt;Integer&gt; hash2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> i:nums1) {</span><br><span class="line">                hash1.add(i);</span><br><span class="line">            }</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> i:nums2) {</span><br><span class="line">                <span class="keyword">if</span>(hash1.contains(i)) {</span><br><span class="line">                    hash2.add(i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">           <span class="comment">//将结果几何转为数组</span></span><br><span class="line">        	<span class="keyword">return</span> hash2.stream().mapToInt(x -&gt; x).toArray();;</span><br><span class="line">            </span><br><span class="line">    }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐数_哈希表</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A802/</url>
    <content><![CDATA[<html><head></head><body><h1 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1><p><a href="https://leetcode.cn/problems/happy-number/">力扣题目链接(opens new window)</a></p>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p><strong>示例：</strong></p>
<p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目看上去貌似一道数学问题，其实并不是！</p>
<p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p>
<p>正如：<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！ (opens new window)</a>中所说，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p>
<p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<p>判断sum是否重复出现就可以使用unordered_set。</p>
<p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">    public boolean isHappy(int n) {</span><br><span class="line">    	// 构建哈希表 来存储每一次的sum 如果sum重复出现即为死循环 就退出</span><br><span class="line">    	Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();</span><br><span class="line">    	</span><br><span class="line">    	while(n!=1 &amp;&amp; !hashSet.contains(n)){</span><br><span class="line">    		hashSet.add(n);</span><br><span class="line">    	    int n = getNextNumber(n);</span><br><span class="line">    	}</span><br><span class="line">    	return n == 1;</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public int getNextNumber(int n) {</span><br><span class="line">    	int res = 0;</span><br><span class="line">    	while(n&gt;0) {</span><br><span class="line">    		int tail = n % 10;</span><br><span class="line">    		res += tail*tail;</span><br><span class="line">    		int n /= 10;</span><br><span class="line">    	}</span><br><span class="line">    	return res;</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>赎金信_哈希表</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A805/</url>
    <content><![CDATA[<html><head></head><body><h1 id="赎金信-哈希表"><a href="#赎金信-哈希表" class="headerlink" title="赎金信_哈希表"></a>赎金信_哈希表</h1><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接(opens new window)</a></p>
<p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<p><strong>注意：</strong></p>
<p>你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目和<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词 (opens new window)</a>很像，<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词 (opens new window)</a>相当于求 字符串a 和 字符串b 是否可以相互组成 ，而这道题目是求 字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。</p>
<p>本题判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，但是这里需要注意两点。</p>
<ul>
<li>第一点“为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思” 这里<em>说明杂志里面的字母不可重复使用。</em></li>
<li>第二点 “你可以假设两个字符串均只含有小写字母。” <em>说明只有小写字母</em>，这一点很重要</li>
</ul>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>那么第一个思路其实就是暴力枚举了，两层for循环，不断去寻找，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">length</span>(); j++) {</span><br><span class="line">                <span class="comment">// 在ransomNote中找到和magazine相同的字符</span></span><br><span class="line">                <span class="keyword">if</span> (magazine[i] == ransomNote[j]) {</span><br><span class="line">                    ransomNote.<span class="built_in">erase</span>(ransomNote.<span class="built_in">begin</span>() + j); <span class="comment">// ransomNote删除这个字符</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果ransomNote为空，则说明magazine的字符可以组成ransomNote</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">length</span>() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>这里时间复杂度是比较高的，而且里面还有一个字符串删除也就是erase的操作，也是费时的，当然这段代码也可以过这道题。</p>
<h3 id="哈希解法"><a href="#哈希解法" class="headerlink" title="哈希解法"></a>哈希解法</h3><p>因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。</p>
<p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p>
<p>依然是数组在哈希法中的应用。</p>
<p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> {</span><br><span class="line">   			<span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">   			<span class="keyword">while</span>(<span class="type">char</span> c:magazine) {</span><br><span class="line">   				nums[c - <span class="string">'a'</span>]++;</span><br><span class="line">   			}</span><br><span class="line">   			<span class="keyword">while</span>(<span class="type">char</span> c:ransomNote) {</span><br><span class="line">   				nums[c - <span class="string">'a'</span>]--;</span><br><span class="line">   			}</span><br><span class="line">   			<span class="keyword">while</span>(<span class="type">int</span> i:nums) {</span><br><span class="line">   				<span class="keyword">if</span>(i&lt;<span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">   			}</span><br><span class="line">   			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和_哈希表</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A803/</url>
    <content><![CDATA[<html><head></head><body><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>
<p>所以返回 [0, 1]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>建议看一下我录的这期视频：<a href="https://www.bilibili.com/video/BV1aT41177mK">梦开始的地方，Leetcode：1.两数之和 (opens new window)</a>，结合本题解来学习，事半功倍。</p>
<p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p>
<p>建议大家做这道题目之前，先做一下这两道</p>
<ul>
<li><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词(opens new window)</a></li>
<li><a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集(opens new window)</a></li>
</ul>
<p><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词 (opens new window)</a>这道题目是用数组作为哈希表来解决哈希问题，<a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集 (opens new window)</a>这道题目是通过set作为哈希表来解决哈希问题。</p>
<p>首先我在强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p>
<p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p>
<p>那么我们就应该想到使用哈希法了。</p>
<p>因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p>再来看一下使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
<li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li>
</ul>
<p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。</p>
<p>C++中map，有三种类型：</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。</p>
<p>同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 更多哈希表的理论知识请看<a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！ (opens new window)</a>。</p>
<p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</strong> 使用其他语言的录友注意了解一下自己所用语言的数据结构就行。</p>
<p>接下来需要明确两点：</p>
<ul>
<li><strong>map用来做什么</strong></li>
<li><strong>map中key和value分别表示什么</strong></li>
</ul>
<p>map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下表，这样才能找到与当前元素相匹配的（也就是相加等于target）</p>
<p>接下来是map中key和value分别表示什么。</p>
<p>这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。</p>
<p>那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。</p>
<p>所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下表}。</p>
<p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素比配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p>
<p>过程如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一"></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202708.png" alt="过程二"></p>
<h3 id="java代码："><a href="#java代码：" class="headerlink" title="java代码："></a>java代码：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">    	<span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">		Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) {</span><br><span class="line">			temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp)) {</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                resp[<span class="number">1</span>] = map.get(temp);</span><br><span class="line">            }</span><br><span class="line">			map.put(nums[i],i);</span><br><span class="line">		}</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和_哈希表</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A806/</url>
    <content><![CDATA[<html><head></head><body><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接(opens new window)</a></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>注意[0， 0， 0， 0] 这组数据</strong></p>
<h3 id="哈希解法"><a href="#哈希解法" class="headerlink" title="哈希解法"></a>哈希解法</h3><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。</p>
<p>把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。</p>
<p>去重的过程不好处理，有很多小细节，如果在面试中很难想到位。</p>
<p>时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。</p>
<p>大家可以尝试使用哈希法写一写，就知道其困难的程度了。</p>
<p>哈希法C++代码:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[j], c = -(a + b)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) { <span class="comment">//三元组元素a去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">2</span></span><br><span class="line">                        &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]</span><br><span class="line">                        &amp;&amp; nums[j<span class="number">-1</span>] == nums[j<span class="number">-2</span>]) { <span class="comment">// 三元组元素b去重</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="type">int</span> c = <span class="number">0</span> - (nums[i] + nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (set.<span class="built_in">find</span>(c) != set.<span class="built_in">end</span>()) {</span><br><span class="line">                    result.<span class="built_in">push_back</span>({nums[i], nums[j], c});</span><br><span class="line">                    set.<span class="built_in">erase</span>(c);<span class="comment">// 三元组元素c去重</span></span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    set.<span class="built_in">insert</span>(nums[j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。</p>
<p>而且使用哈希法 在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也是可以在leetcode上通过，但是程序的执行时间依然比较长 。</p>
<p>接下来我来介绍另一个解法：双指针法，<strong>这道题目使用双指针法 要比哈希法高效一些</strong>，那么来讲解一下具体实现的思路。</p>
<p>动画效果如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p>
<p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p>
<p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p>
<p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p>
<p>时间复杂度：O(n^2)。</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        	List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">HashList</span>&lt;&gt;();</span><br><span class="line">        	Arrays.sort(nums);</span><br><span class="line">    		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    		<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) {</span><br><span class="line">    				left = i+<span class="number">1</span>;</span><br><span class="line">    				right = nums.length-<span class="number">1</span>;</span><br><span class="line">    				<span class="keyword">while</span>(left &lt; right) {</span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">    					temp = nums[i] + nums[left] + nums[right];</span><br><span class="line">    					<span class="keyword">if</span>(temp &lt; <span class="number">0</span>) {</span><br><span class="line">                            left++;</span><br><span class="line">                        }<span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; <span class="number">0</span>) {</span><br><span class="line">                            right--;</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                            left++;</span><br><span class="line">                            right--;</span><br><span class="line">                        }</span><br><span class="line">    				}</span><br><span class="line">    		}</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法理论基础_回溯01</title>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<html><head></head><body><h1 id="回溯算法理论基础"><a href="#回溯算法理论基础" class="headerlink" title="回溯算法理论基础"></a>回溯算法理论基础</h1><h2 id="题目分类大纲如下："><a href="#题目分类大纲如下：" class="headerlink" title="#题目分类大纲如下："></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B">#</a>题目分类大纲如下：</h2><p><img src="https://img-blog.csdnimg.cn/20210219192050666.png" alt="回溯算法大纲"></p>
<p>可以配合我的B站视频：<a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇） (opens new window)</a>一起学习！</p>
<h2 id="什么是回溯法"><a href="#什么是回溯法" class="headerlink" title="#什么是回溯法"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%BA%AF%E6%B3%95">#</a>什么是回溯法</h2><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p>
<p>在二叉树系列中，我们已经不止一次，提到了回溯，例如<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E9%80%92%E5%BD%92%E5%B8%A6%E7%9D%80%E5%9B%9E%E6%BA%AF.html">二叉树：以为使用了递归，其实还隐藏着回溯 (opens new window)</a>。</p>
<p>回溯是递归的副产品，只要有递归就会有回溯。</p>
<p><strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong>。</p>
<h2 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="#回溯法的效率"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87">#</a>回溯法的效率</h2><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p>
<p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<p>那么既然回溯法并不高效为什么还要用它呢？</p>
<p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p>
<p>此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。</p>
<h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="#回溯法解决的问题"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">#</a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><strong>相信大家看着这些之后会发现，每个问题，都不简单！</strong></p>
<p>另外，会有一些同学可能分不清什么是组合，什么是排列？</p>
<p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p>
<p>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p>
<p>记住组合无序，排列有序，就可以了。</p>
<h2 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="#如何理解回溯法"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E6%B3%95">#</a>如何理解回溯法</h2><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p>
<p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p>
<p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
<p>这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。</p>
<h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="#回溯法模板"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF">#</a>回溯法模板</h2><p>这里给出Carl总结的回溯算法模板。</p>
<p>在讲<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归 (opens new window)</a>中我们说了递归三部曲，这里我再给大家列出回溯三部曲。</p>
<ul>
<li>回溯函数模板返回值以及参数</li>
</ul>
<p>在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。</p>
<p>回溯算法中函数返回值一般为void。</p>
<p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p>
<p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p>
<p>回溯函数伪代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">void backtracking(参数)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>回溯函数终止条件</li>
</ul>
<p>既然是树形结构，那么我们在讲解<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归 (opens new window)</a>的时候，就知道遍历树形结构一定要有终止条件。</p>
<p>所以回溯也有要终止条件。</p>
<p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p>
<p>所以回溯函数终止条件伪代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (终止条件) {</span><br><span class="line">    存放结果;</span><br><span class="line">    return;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>回溯搜索的遍历过程</li>
</ul>
<p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210130173631174.png" alt="回溯算法理论基础"></p>
<p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p>
<p>回溯函数遍历过程伪代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); // 递归</span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p>
<p>backtracking这里自己调用自己，实现递归。</p>
<p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p>
<p>分析完过程，回溯算法模板框架如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">void backtracking(参数) {</span><br><span class="line">    if (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p>
<p>如果从来没有学过回溯算法的录友们，看到这里会有点懵，后面开始讲解具体题目的时候就会好一些了，已经做过回溯法题目的录友，看到这里应该会感同身受了。</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>组合_回溯02</title>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF01/</url>
    <content><![CDATA[<html><head></head><body><h1 id="第77题-组合"><a href="#第77题-组合" class="headerlink" title="第77题. 组合"></a>第77题. 组合</h1><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接(opens new window)</a></p>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p>
<p>也可以直接看我的B站视频：<a href="https://www.bilibili.com/video/BV1ti4y1L7cv#reply3733925949">带你学透回溯算法-组合问题（对应力扣题目：77.组合）(opens new window)</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>本题这是回溯法的经典题目。</p>
<p>直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输入：n = 100, k = 3 那么就三层for循环，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = j + <span class="number">1</span>; u &lt;= n; n++) {</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span> &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>如果n为100，k为50呢，那就50层for循环，是不是开始窒息</strong>。</p>
<p><strong>此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来！</strong></p>
<p>咋整？</p>
<p>回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望。</p>
<p>那么回溯法怎么暴力搜呢？</p>
<p>上面我们说了<strong>要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题</strong>。</p>
<p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p>
<p>此时递归的层数大家应该知道了，例如：n为100，k为50的情况下，就是递归50层。</p>
<p>一些同学本来对递归就懵，回溯法中递归还要嵌套for循环，可能就直接晕倒了！</p>
<p>如果脑洞模拟回溯搜索的过程，绝对可以让人窒息，所以需要抽象图形结构来进一步理解。</p>
<p><strong>我们在<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>中说道回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了</strong>。</p>
<p>那么我把组合问题抽象为如下树形结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195223940.png" alt="77.组合"></p>
<p>可以看出这个棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不在重复取。</p>
<p>第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。</p>
<p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p>
<p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p>
<p>那么如何在这个树上遍历，然后收集到我们要的结果集呢？</p>
<p><strong>图中每次搜索到了叶子节点，我们就找到了一个结果</strong>。</p>
<p>相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。</p>
<p>在<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>中我们提到了回溯法三部曲，那么我们按照回溯法三部曲开始正式讲解代码了。</p>
<h2 id="回溯法三部曲"><a href="#回溯法三部曲" class="headerlink" title="#回溯法三部曲"></a><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯法三部曲</h2><ul>
<li>递归函数的返回值以及参数</li>
</ul>
<p>在这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br></pre></td></tr></tbody></table></figure>

<p>其实不定义这两个全局遍历也是可以的，把这两个变量放进递归函数的参数里，但函数里参数太多影响可读性，所以我定义全局变量了。</p>
<p>函数里一定有两个参数，既然是集合n里面取k的数，那么n和k是两个int型的参数。</p>
<p>然后还需要一个参数，为int型变量startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n] ）。</p>
<p>为什么要有这个startIndex呢？</p>
<p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</strong>。</p>
<p>从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢，靠的就是startIndex。</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195328976.png" alt="77.组合2"></p>
<p>所以需要startIndex来记录下一层递归，搜索的起始位置。</p>
<p>那么整体代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件单一结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>回溯函数终止条件</li>
</ul>
<p>什么时候到达所谓的叶子节点了呢？</p>
<p>path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。</p>
<p>如图红色部分：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195407907.png" alt="77.组合3"></p>
<p>此时用result二维数组，把path保存起来，并终止本层递归。</p>
<p>所以终止条件代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) {</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的过程</li>
</ul>
<p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195242899.png" alt="77.组合1"></p>
<p>如此我们才遍历完图中的这棵树。</p>
<p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) { <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点 </span></span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。</p>
<p>backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。</p>
<p>关键地方都讲完了，组合问题C++完整代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) {</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) {</span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点 </span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) {</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不写</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不写</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>还记得我们在<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>中给出的回溯法模板么？</p>
<p>如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">void backtracking(参数) {</span><br><span class="line">    if (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>对比一下本题的代码，是不是发现有点像！</strong> 所以有了这个模板，就有解题的大体方向，不至于毫无头绪。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>组合问题是回溯法解决的经典问题，我们开始的时候给大家列举一个很形象的例子，就是n为100，k为50的话，直接想法就需要50层for循环。</p>
<p>从而引出了回溯法就是解决这种k层for循环嵌套的问题。</p>
<p>然后进一步把回溯法的搜索过程抽象为树形结构，可以直观的看出搜索的过程。</p>
<p>接着用回溯法三部曲，逐步分析了函数参数、终止条件和单层搜索的过程。</p>
<h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>我们说过，回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。</p>
<p>在遍历的过程中有如下代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) {</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个遍历的范围是可以剪枝优化的，怎么优化呢？</p>
<p>来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。</p>
<p>这么说有点抽象，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210130194335207.png" alt="77.组合4"></p>
<p>图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。</p>
<p><strong>所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置</strong>。</p>
<p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p>
<p>注意代码中i，就是for循环里选择的起始位置。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">for (int i = startIndex; i &lt;= n; i++) {</span><br></pre></td></tr></tbody></table></figure>

<p>接下来看一下优化过程如下：</p>
<ol>
<li>已经选择的元素个数：path.size();</li>
<li>还需要的元素个数为: k - path.size();</li>
<li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。</p>
<p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p>
<p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p>
<p>所以优化之后的for循环是：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置</span><br></pre></td></tr></tbody></table></figure>

<p>优化后整体代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) {</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) { <span class="comment">// 优化的地方</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) {</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="剪枝总结"><a href="#剪枝总结" class="headerlink" title="#剪枝总结"></a><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%89%AA%E6%9E%9D%E6%80%BB%E7%BB%93">#</a>剪枝总结</h2><p>本篇我们准对求组合问题的回溯法代码做了剪枝优化，这个优化如果不画图的话，其实不好理解，也不好讲清楚。</p>
<p>所以我依然是把整个回溯过程抽象为一棵树形结构，然后可以直观的看出，剪枝究竟是剪的哪里</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkdeList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span> {</span><br><span class="line">	backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span> {</span><br><span class="line">       <span class="keyword">if</span>(path.size() == k) {</span><br><span class="line">           res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;=n - (k - path.size()) + <span class="number">1</span>;i++) { <span class="comment">// 其实这个剪枝我还是不太明白</span></span><br><span class="line">           path.add(i);</span><br><span class="line">           backtracking(n,k,i + <span class="number">1</span>);</span><br><span class="line">           path.removeLast();</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和III_回溯03</title>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF02/</url>
    <content><![CDATA[<html><head></head><body><h1 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h1><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣题目链接(opens new window)</a></p>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</p>
<p>示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题就是在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合。</p>
<p>相对于<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>，无非就是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,…,9]。</p>
<p>想到这一点了，做过<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>之后，本题是简单一些了。</p>
<p>本题k相当于了树的深度，9（因为整个集合就是9个数）就是树的宽度。</p>
<p>例如 k = 2，n = 4的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） = 2, n（和） = 4的组合。</p>
<p>选取过程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195717975.png" alt="216.组合总和III"></p>
<p>图中，可以看出，只有最后取到集合（1，3）和为4 符合条件。</p>
<h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h2><ul>
<li><strong>确定递归函数参数</strong></li>
</ul>
<p>和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>一样，依然需要一维数组path来存放符合条件的结果，二维数组result来存放结果集。</p>
<p>这里我依然定义path 和 result为全局变量。</p>
<p>至于为什么取名为path？从上面树形结构中，可以看出，结果其实就是一条根节点到叶子节点的路径。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br></pre></td></tr></tbody></table></figure>

<p>接下来还需要如下参数：</p>
<ul>
<li>targetSum（int）目标和，也就是题目中的n。</li>
<li>k（int）就是题目中要求k个数的集合。</li>
<li>sum（int）为已经收集的元素的总和，也就是path里元素的总和。</li>
<li>startIndex（int）为下一层for循环搜索的起始位置。</li>
</ul>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>其实这里sum这个参数也可以省略，每次targetSum减去选取的元素数值，然后判断如果targetSum为0了，说明收集到符合条件的结果了，我这里为了直观便于理解，还是加一个sum参数。</p>
<p>还要强调一下，回溯法中递归函数参数很难一次性确定下来，一般先写逻辑，需要啥参数了，填什么参数。</p>
<ul>
<li>确定终止条件</li>
</ul>
<p>什么时候终止呢？</p>
<p>在上面已经说了，k其实就已经限制树的深度，因为就取k个元素，树再往下深了没有意义。</p>
<p>所以如果path.size() 和 k相等了，就终止。</p>
<p>如果此时path里收集到的元素和（sum） 和targetSum（就是题目描述的n）相同了，就用result收集当前的结果。</p>
<p>所以 终止代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) {</span><br><span class="line">    <span class="keyword">if</span> (sum == targetSum) result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>单层搜索过程</strong></li>
</ul>
<p>本题和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>区别之一就是集合固定的就是9个数[1,…,9]，所以for循环固定i&lt;=9</p>
<p>如图： <img src="https://img-blog.csdnimg.cn/20201123195717975.png" alt="216.组合总和III"></p>
<p>处理过程就是 path收集每次选取的元素，相当于树型结构里的边，sum来统计path里元素的总和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">    sum += i;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">    sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>别忘了处理过程 和 回溯过程是一一对应的，处理有加，回溯就要有减！</strong></p>
<p>参照<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>中的模板，不难写出如下C++代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="comment">// targetSum：目标和，也就是题目中的n。</span></span><br><span class="line">    <span class="comment">// k：题目中要求k个数的集合。</span></span><br><span class="line">    <span class="comment">// sum：已经收集的元素的总和，也就是path里元素的总和。</span></span><br><span class="line">    <span class="comment">// startIndex：下一层for循环搜索的起始位置。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) {</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">            sum += i; <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">            sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) {</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="#剪枝"></a><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E5%89%AA%E6%9E%9D">#</a>剪枝</h2><p>这道题目，剪枝操作其实是很容易想到了，想必大家看上面的树形图的时候已经想到了。</p>
<p>如图： <img src="https://img-blog.csdnimg.cn/2020112319580476.png" alt="216.组合总和III1"></p>
<p>已选元素总和如果已经大于n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉。</p>
<p>那么剪枝的地方一定是在递归终止的地方剪，剪枝代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; targetSum) { <span class="comment">// 剪枝操作</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.html">回溯算法：组合问题再剪剪枝 (opens new window)</a>一样，for循环的范围也可以剪枝，i &lt;= 9 - (k - path.size()) + 1就可以了。</p>
<p>最后C++代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; targetSum) { <span class="comment">// 剪枝操作</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) {</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) { <span class="comment">// 剪枝</span></span><br><span class="line">            sum += i; <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">            sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) {</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E6%80%BB%E7%BB%93">#</a>总结</h1><p>开篇就介绍了本题与<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>的区别，相对来说加了元素总和的限制，如果做完<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>再做本题在合适不过。</p>
<p>分析完区别，依然把问题抽象为树形结构，按照回溯三部曲进行讲解，最后给出剪枝的优化。</p>
<p>相信做完本题，大家对组合问题应该有初步了解了</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> { <span class="comment">// k 个数组成和为n k的范围为1~9</span></span><br><span class="line">    backtracking(k,n,<span class="number">1</span>)；</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> {</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 剪枝细节</span></span><br><span class="line">    <span class="keyword">if</span>(path.size() == k) {</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>) res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;= <span class="number">9</span>;i++) {</span><br><span class="line">        path.add(i);</span><br><span class="line">        sum -= i;</span><br><span class="line">        backtracking(k,sum,startIndex+<span class="number">1</span>);</span><br><span class="line">        sum += i;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>电话号码的字母组合_回溯04</title>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF03/</url>
    <content><![CDATA[<html><head></head><body><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣题目链接(opens new window)</a></p>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://img-blog.csdnimg.cn/2020102916424043.png" alt="17.电话号码的字母组合"></p>
<p>示例: 输入：”23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>从示例上来说，输入”23”，最直接的想法就是两层for循环遍历了吧，正好把组合的情况都输出了。</p>
<p>如果输入”233”呢，那么就三层for循环，如果”2333”呢，就四层for循环…….</p>
<p>大家应该感觉出和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>遇到的一样的问题，就是这for循环的层数如何写出来，此时又是回溯法登场的时候了。</p>
<p>理解本题后，要解决如下三个问题：</p>
<ol>
<li>数字和字母如何映射</li>
<li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来</li>
<li>输入1 * #按键等等异常情况</li>
</ol>
<h2 id="数字和字母如何映射"><a href="#数字和字母如何映射" class="headerlink" title="#数字和字母如何映射"></a><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84">#</a>数字和字母如何映射</h2><p>可以使用map或者定义一个二维数组，例如：string letterMap[10]，来做映射，我这里定义一个二维数组，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>] = {</span><br><span class="line">    <span class="string">""</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">""</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">"abc"</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">"def"</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">"ghi"</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">"jkl"</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">"mno"</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">"pqrs"</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">"tuv"</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">"wxyz"</span>, <span class="comment">// 9</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="回溯法来解决n个for循环的问题"><a href="#回溯法来解决n个for循环的问题" class="headerlink" title="#回溯法来解决n个for循环的问题"></a><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%9D%A5%E8%A7%A3%E5%86%B3n%E4%B8%AAfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98">#</a>回溯法来解决n个for循环的问题</h2><p>对于回溯法还不了解的同学看这篇：<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！(opens new window)</a></p>
<p>例如：输入：”23”，抽象为树形结构，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123200304469.png" alt="17. 电话号码的字母组合"></p>
<p>图中可以看出遍历的深度，就是输入”23”的长度，而叶子节点就是我们要收集的结果，输出[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p>
<p>回溯三部曲：</p>
<ul>
<li>确定回溯函数参数</li>
</ul>
<p>首先需要一个字符串s来收集叶子节点的结果，然后用一个字符串数组result保存起来，这两个变量我依然定义为全局。</p>
<p>再来看参数，参数指定是有题目中给的string digits，然后还要有一个参数就是int型的index。</p>
<p>注意这个index可不是 <a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>中的startIndex了。</p>
<p>这个index是记录遍历第几个数字了，就是用来遍历digits的（题目中给出数字字符串），同时index也表示树的深度。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;string&gt; result;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; digits, <span class="type">int</span> index)</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>例如输入用例”23”，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。</p>
<p>那么终止条件就是如果index 等于 输入的数字个数（digits.size）了（本来index就是用来遍历digits的）。</p>
<p>然后收集结果，结束本层递归。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) {</span><br><span class="line">    result.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>确定单层遍历逻辑</li>
</ul>
<p>首先要取index指向的数字，并找到对应的字符集（手机键盘的字符集）。</p>
<p>然后for循环来处理这个字符集，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> digit = digits[index] - <span class="string">'0'</span>;        <span class="comment">// 将index指向的数字转为int</span></span><br><span class="line">string letters = letterMap[digit];      <span class="comment">// 取数字对应的字符集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    s.<span class="built_in">push_back</span>(letters[i]);            <span class="comment">// 处理</span></span><br><span class="line">    <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);    <span class="comment">// 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">    s.<span class="built_in">pop_back</span>();                       / 回溯</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意这里for循环，可不像是在<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！ (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">回溯算法：求组合总和！ (opens new window)</a>中从startIndex开始遍历的</strong>。</p>
<p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>都是是求同一个集合中的组合！</strong></p>
<p>注意：输入1 * #按键等等异常情况</p>
<p>代码中最好考虑这些异常情况，但题目的测试数据中应该没有异常情况的数据，所以我就没有加了。</p>
<p><strong>但是要知道会有这些异常，如果是现场面试中，一定要考虑到！</strong></p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> {</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        String [] Stringnums = {<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>};</span><br><span class="line">        backtracking(Stringnums,digits,<span class="number">1</span>); <span class="comment">// index记录深度</span></span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String[] Stringnums,String digits,<span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">if</span>(index == digits.size()) {</span><br><span class="line">        res.add(sb);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> Stringnums[digits.charAt(index) - <span class="string">'0'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tmp.length();i++) {</span><br><span class="line">        sb.append(tmp.charAt(i));</span><br><span class="line">       	backtracking(stringnums,digits,index+<span class="number">1</span>); <span class="comment">// 回溯细节</span></span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和_回溯05</title>
    <url>/2022/08/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF04/</url>
    <content><![CDATA[<html><head></head><body><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p><a href="https://leetcode.cn/problems/combination-sum/">力扣题目链接(opens new window)</a></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</p>
<p>示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [  [2,2,2,2],  [2,3,3],  [3,5] ]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><a href="https://www.bilibili.com/video/BV1KT4y1M7HJ">B站视频讲解-组合总和(opens new window)</a></p>
<p>题目中的<strong>无限制重复被选取，吓得我赶紧想想 出现0 可咋办</strong>，然后看到下面提示：1 &lt;= candidates[i] &lt;= 200，我就放心了。</p>
<p>本题和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>和区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p>
<p>本题搜索的过程抽象成树形结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201223170730367.png" alt="39.组合总和"> 注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！</p>
<p>而在<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>中都可以知道要递归K层，因为要取k个元素的组合。</p>
<h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h2><ul>
<li>递归函数参数</li>
</ul>
<p>这里依然是定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。（这两个变量可以作为函数参数传入）</p>
<p>首先是题目中给出的参数，集合candidates, 和目标值target。</p>
<p>此外我还定义了int型的sum变量来统计单一结果path里的总和，其实这个sum也可以不用，用target做相应的减法就可以了，最后如何target==0就说明找到符合的结果了，但为了代码逻辑清晰，我依然用了sum。</p>
<p><strong>本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？</strong></p>
<p>我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>。</p>
<p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">17.电话号码的字母组合(opens new window)</a></p>
<p><strong>注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍</strong>。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p>在如下树形结构中：</p>
<p><img src="https://img-blog.csdnimg.cn/20201223170730367.png" alt="39.组合总和"></p>
<p>从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。</p>
<p>sum等于target的时候，需要收集结果，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; target) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (sum == target) {</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>单层for循环依然是从startIndex开始，搜索candidates集合。</p>
<p><strong>注意本题和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>、<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>的一个区别是：本题元素为可重复选取的</strong>。</p>
<p>如何重复选取呢，看代码，注释部分：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    sum += candidates[i];</span><br><span class="line">    path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(candidates, target, sum, i); <span class="comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">    sum -= candidates[i];   <span class="comment">// 回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();        <span class="comment">// 回溯</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>在这个树形结构中：</p>
<p><img src="https://img-blog.csdnimg.cn/20201223170730367.png" alt="39.组合总和"></p>
<p>以及上面的版本一的代码大家可以看到，对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum &gt; target的话就返回。</p>
<p>其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。</p>
<p>那么可以在for循环的搜索范围上做做文章了。</p>
<p><strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历</strong>。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201223170809182.png" alt="39.组合总和1"></p>
<p>for循环剪枝代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++)</span><br></pre></td></tr></tbody></table></figure>

<h1 id="JAVA关键代码如下："><a href="#JAVA关键代码如下：" class="headerlink" title="JAVA关键代码如下："></a>JAVA关键代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">    Arrays.sort(candidates); <span class="comment">// 不排序也可以</span></span><br><span class="line">	backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> {</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">0</span>) {</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;candidates.length &amp;&amp; sum - candidates[i] &gt;= <span class="number">0</span>;i++) { <span class="comment">// 剪枝</span></span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        backtracking(candidates,sum,i);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        path.remove(candidates.size() -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h1><p><a href="https://leetcode.cn/problems/combination-sum-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p>
<p>示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p>
<p>示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>区别在于解集不能包含重复的组合，也就是说树枝可以有重复的，但是每一层不能有重复的，说明需要提前把数组给排序，然后通过startIndex 来进行剪枝</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>分割回文串_回溯06</title>
    <url>/2022/08/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF05/</url>
    <content><![CDATA[<html><head></head><body><h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h1><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>关于本题，大家也可以看我在B站的视频讲解：<a href="https://www.bilibili.com/video/BV1c54y1e7k6">131.分割回文串（B站视频）(opens new window)</a></p>
<p>本题这涉及到两个关键问题：</p>
<ol>
<li>切割问题，有不同的切割方式</li>
<li>判断回文</li>
</ol>
<p>相信这里不同的切割方式可以搞懵很多同学了。</p>
<p>这种题目，想用for循环暴力解法，可能都不那么容易写出来，所以要换一种暴力的方式，就是回溯。</p>
<p>一些同学可能想不清楚 回溯究竟是如何切割字符串呢？</p>
<p>我们来分析一下切割，<strong>其实切割问题类似组合问题</strong>。</p>
<p>例如对于字符串abcdef：</p>
<ul>
<li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li>
<li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li>
</ul>
<p>感受出来了不？</p>
<p>所以切割问题，也可以抽象为一棵树形结构，如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p>
<p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p>
<p>此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p>
<h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h2><ul>
<li>递归函数参数</li>
</ul>
<p>全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 （这两个参数可以放到函数参数里）</p>
<p>本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。</p>
<p>在<a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">回溯算法：求组合总和（二） (opens new window)</a>中我们深入探讨了组合问题什么时候需要startIndex，什么时候不需要startIndex。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">vector&lt;string&gt; path; <span class="comment">// 放已经回文的子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span> </span>{</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归函数终止条件</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p>
<p>从树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止终止条件。</p>
<p><strong>那么在代码里什么是切割线呢？</strong></p>
<p>在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。</p>
<p>所以终止条件代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) {</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p><strong>来看看在递归循环，中如何截取子串呢？</strong></p>
<p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。</p>
<p>首先判断这个子串是不是回文，如果是回文，就加入在<code>vector&lt;string&gt; path</code>中，path用来记录切割过的回文子串。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i)) { <span class="comment">// 是回文子串</span></span><br><span class="line">        <span class="comment">// 获取[startIndex,i]在s中的子串</span></span><br><span class="line">        string str = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">push_back</span>(str);</span><br><span class="line">    } <span class="keyword">else</span> {                <span class="comment">// 如果不是则直接跳过</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>); <span class="comment">// 寻找i+1为起始位置的子串</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();        <span class="comment">// 回溯过程，弹出本次已经填在的子串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1</strong>。</p>
<h2 id="判断回文子串"><a href="#判断回文子串" class="headerlink" title="#判断回文子串"></a><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">#</a>判断回文子串</h2><p>最后我们看一下回文子串要如何判断了，判断一个字符串是否是回文。</p>
<p>可以使用双指针法，一个指针从前向后，一个指针从后先前，如果前后指针所指向的元素是相等的，就是回文字符串了。</p>
<p>那么判断回文的C++代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) {</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题目在leetcode上是中等，但可以说是hard的题目了，但是代码其实就是按照模板的样子来的。</p>
<p>那么难究竟难在什么地方呢？</p>
<p><strong>我列出如下几个难点：</strong></p>
<ul>
<li>切割问题可以抽象为组合问题</li>
<li>如何模拟那些切割线</li>
<li>切割问题中递归如何终止</li>
<li>在递归循环中如何截取子串</li>
<li>如何判断回文</li>
</ul>
<p><strong>我们平时在做难题的时候，总结出来难究竟难在哪里也是一种需要锻炼的能力</strong>。</p>
<p>一些同学可能遇到题目比较难，但是不知道题目难在哪里，反正就是很难。其实这样还是思维不够清晰，这种总结的能力需要多接触多锻炼。</p>
<p><strong>本题我相信很多同学主要卡在了第一个难点上：就是不知道如何切割，甚至知道要用回溯法，也不知道如何用。也就是没有体会到按照求组合问题的套路就可以解决切割</strong>。</p>
<p>如果意识到这一点，算是重大突破了。接下来就可以对着模板照葫芦画瓢。</p>
<p><strong>但接下来如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了</strong>。</p>
<p>关于模拟切割线，其实就是index是上一层已经确定了的分割线，i是这一层试图寻找的新分割线</p>
<p>除了这些难点，<strong>本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1</strong>。</p>
<p>所以本题应该是一个道hard题目了。</p>
<p><strong>可能刷过这道题目的录友都没感受到自己原来克服了这么多难点，就把这道题目AC了</strong>，这应该叫做无招胜有招，人码合一，哈哈哈。</p>
<h1 id="JAVA代码如下："><a href="#JAVA代码如下：" class="headerlink" title="JAVA代码如下："></a>JAVA代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> {</span><br><span class="line">       backTracking(s, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> lists;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">       <span class="keyword">if</span>(startIndex &gt;= s.length()) {</span><br><span class="line">           res.add(path);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;s.length();i++) {</span><br><span class="line">           <span class="keyword">if</span>(isHuiwen(s,startIndex,i)) {</span><br><span class="line">               <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(startIndex,i+<span class="number">1</span>);</span><br><span class="line">               path.add(tmp);</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           backtracking(s,i+<span class="number">1</span>);</span><br><span class="line">           path.remove(path.size() -<span class="number">1</span>);</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">   }</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isHuiwen</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> end)</span> {</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex, j = end; i &lt; j; i++, j--) {</span><br><span class="line">           <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) {</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>复原IP地址_回溯07</title>
    <url>/2022/08/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF06/</url>
    <content><![CDATA[<html><head></head><body><h1 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h1><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接(opens new window)</a></p>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1">192.168@1.1</a>“ 是 无效的 IP 地址。</p>
<p>示例 1：</p>
<ul>
<li>输入：s = “25525511135”</li>
<li>输出：[“255.255.11.135”,”255.255.111.35”]</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：s = “0000”</li>
<li>输出：[“0.0.0.0”]</li>
</ul>
<p>示例 3：</p>
<ul>
<li>输入：s = “1111”</li>
<li>输出：[“1.1.1.1”]</li>
</ul>
<p>示例 4：</p>
<ul>
<li>输入：s = “010010”</li>
<li>输出：[“0.10.0.10”,”0.100.1.0”]</li>
</ul>
<p>示例 5：</p>
<ul>
<li>输入：s = “101023”</li>
<li>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</li>
</ul>
<p>提示：</p>
<ul>
<li>0 &lt;= s.length &lt;= 3000</li>
<li>s 仅由数字组成</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>做这道题目之前，最好先把<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>这个做了。</p>
<p>这道题目相信大家刚看的时候，应该会一脸茫然。</p>
<p>其实只要意识到这是切割问题，<strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>，和刚做过的<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>就十分类似了。</p>
<p>切割问题可以抽象为树型结构，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p>
<h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h2><ul>
<li>递归参数</li>
</ul>
<p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>中我们就提到切割问题类似组合问题。</p>
<p>startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。</p>
<p>本题我们还需要一个变量pointNum，记录添加逗点的数量。</p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;string&gt; result;<span class="comment">// 记录结果</span></span><br><span class="line"><span class="comment">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> </span>{</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p>终止条件和<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>情况就不同了，本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。</p>
<p>pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。</p>
<p>然后验证一下第四段是否合法，如果合法就加入到结果集里</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pointNum == <span class="number">3</span>) { <span class="comment">// 逗点数量为3时，分隔结束</span></span><br><span class="line">    <span class="comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) {</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>中已经讲过在循环遍历中如何截取子串。</p>
<p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中 [startIndex, i] 这个区间就是截取的子串，需要判断这个子串是否合法。</p>
<p>如果合法就在字符串后面加上符号<code>.</code>表示已经分割。</p>
<p>如果不合法就结束本层循环，如图中剪掉的分支：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p>
<p>然后就是递归和回溯的过程：</p>
<p>递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符<code>.</code>），同时记录分割符的数量pointNum 要 +1。</p>
<p>回溯的时候，就将刚刚加入的分隔符<code>.</code> 删掉就可以了，pointNum也要-1。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, i)) { <span class="comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span></span><br><span class="line">        s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">'.'</span>);  <span class="comment">// 在i的后面插入一个逗点</span></span><br><span class="line">        pointNum++;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, i + <span class="number">2</span>, pointNum);   <span class="comment">// 插入逗点之后下一个子串的起始位置为i+2</span></span><br><span class="line">        pointNum--;                         <span class="comment">// 回溯</span></span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);         <span class="comment">// 回溯删掉逗点</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 不合法，直接结束本层循环</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="判断子串是否合法"><a href="#判断子串是否合法" class="headerlink" title="#判断子串是否合法"></a><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E5%88%A4%E6%96%AD%E5%AD%90%E4%B8%B2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95">#</a>判断子串是否合法</h2><p>最后就是在写一个判断段位是否是有效段位了。</p>
<p>主要考虑到如下三点：</p>
<ul>
<li>段位以0为开头的数字不合法</li>
<li>段位里有非正整数字符不合法</li>
<li>段位如果大于255了不合法</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s[start] == <span class="string">'0'</span> &amp;&amp; start != end) { <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) {</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; <span class="string">'9'</span> || s[i] &lt; <span class="string">'0'</span>) { <span class="comment">// 遇到非数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        num = num * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) { <span class="comment">// 如果大于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>中我列举的分割字符串的难点，本题都覆盖了。</p>
<p>而且本题还需要操作字符串添加逗号作为分隔符，并验证区间的合法性。</p>
<p>可以说是<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>的加强版。</p>
<p>在本文的树形结构图中，我已经把详细的分析思路都画了出来，相信大家看了之后一定会思路清晰不少！</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> result; <span class="comment">// 算是剪枝了</span></span><br><span class="line">        backTrack(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// startIndex: 搜索的起始位置， pointNum:添加逗点的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> {</span><br><span class="line">    	<span class="keyword">if</span>(pointNum == <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">if</span>(isValid(s,startIndex,s.length() -<span class="number">1</span>)) result.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;s.length();i++) {</span><br><span class="line">            <span class="keyword">if</span>(isVaild(s,startIndex,i)) {</span><br><span class="line">                s = s.substring(<span class="number">0</span>,i+<span class="number">1</span>) +<span class="string">"."</span>+substring(i+<span class="number">1</span>);</span><br><span class="line">                pointNum++;</span><br><span class="line">                backtracking(s,i+<span class="number">2</span>,pointNum);</span><br><span class="line">                pointNum--;</span><br><span class="line">                s = s.substring(<span class="number">0</span>,i+<span class="number">1</span>)+s.substring(i+<span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s,<span class="type">int</span> start;<span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span> &amp;&amp; start != end) { <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">'9'</span> || s.charAt(i) &lt; <span class="string">'0'</span>) { <span class="comment">// 遇到⾮数字字符不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) { <span class="comment">// 如果⼤于255了不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>子集问题（二）_回溯08</title>
    <url>/2022/08/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF07/</url>
    <content><![CDATA[<html><head></head><body><h1 id="子集问题（二）"><a href="#子集问题（二）" class="headerlink" title="子集问题（二）"></a>子集问题（二）</h1><h2 id="90-子集II"><a href="#90-子集II" class="headerlink" title="#90.子集II"></a><a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html#_90-%E5%AD%90%E9%9B%86ii">#</a>90.子集II</h2><p><a href="https://leetcode.cn/problems/subsets-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<ul>
<li>输入: [1,2,2]</li>
<li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>做本题之前一定要先做<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集 (opens new window)</a>。</p>
<p>这道题目和<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集 (opens new window)</a>区别就是集合里有重复元素了，而且求取的子集要去重。</p>
<p>那么关于回溯算法中的去重问题，<strong>在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II (opens new window)</a>中已经详细讲解过了，和本题是一个套路</strong>。</p>
<p><strong>剧透一下，后期要讲解的排列问题里去重也是这个套路，所以理解“树层去重”和“树枝去重”非常重要</strong>。</p>
<p>用示例中的[1, 2, 2] 来举例，如图所示： （<strong>注意去重需要先对集合排序</strong>）</p>
<p><img src="https://img-blog.csdnimg.cn/20201124195411977.png" alt="90.子集II"></p>
<p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p>
<p>本题就是其实就是<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">回溯算法：求子集问题！ (opens new window)</a>的基础上加上了去重，去重我们在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">回溯算法：求组合总和（三） (opens new window)</a>也讲过了</p>
<h1 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h1><p>本题也可以不使用used数组来去重，因为递归的时候下一个startIndex是i+1而不是0。</p>
<p>如果要是全排列的话，每次要从0开始遍历，为了跳过已入栈的元素，需要使用used。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下"></a>Java代码如下</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">( <span class="type">int</span>[] nums )</span> {</span><br><span class="line">	Arrays.sort(nums);</span><br><span class="line">    backtracking( nums, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">( <span class="type">int</span>[] nums, <span class="type">int</span> startIndex )</span> {</span><br><span class="line">	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;nums.length;i++) {</span><br><span class="line">		<span class="keyword">if</span>(i &gt; startIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">		path.add(nums[i]);</span><br><span class="line">		backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">		path.remove(path.size() -<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列_回溯09</title>
    <url>/2022/08/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF08/</url>
    <content><![CDATA[<html><head></head><body><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h1><p><a href="https://leetcode.cn/problems/permutations/">力扣题目链接(opens new window)</a></p>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<ul>
<li>输入: [1,2,3]</li>
<li>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>**如果对回溯算法基础还不了解的话，我还特意录制了一期视频：<a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇） (opens new window)</a>**可以结合题解和视频一起看，希望对大家理解回溯算法有所帮助。</p>
<p>此时我们已经学习了<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合问题 (opens new window)</a>、 <a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>和<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集问题 (opens new window)</a>，接下来看一看排列问题。</p>
<p>相信这个排列问题就算是让你用for循环暴力把结果搜索出来，这个暴力也不是很好写。</p>
<p>所以正如我们在<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>所讲的为什么回溯法是暴力搜索，效率这么低，还要用它？</p>
<p><strong>因为一些问题能暴力搜出来就已经很不错了！</strong></p>
<p>我以[1,2,3]为例，抽象成树形结构如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p>
<h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h3><ul>
<li>递归函数参数</li>
</ul>
<p><strong>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方</strong>。</p>
<p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。</p>
<p>但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201209174225145.png" alt="46.全排列"></p>
<p>可以看出叶子节点，就是收割结果的地方。</p>
<p>那么什么时候，算是到达叶子节点呢？</p>
<p>当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 此时说明找到了一组</span></span><br><span class="line"><span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) {</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>这里和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合问题 (opens new window)</a>、<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.切割问题 (opens new window)</a>和<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集问题 (opens new window)</a>最大的不同就是for循环里不用startIndex了。</p>
<p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p>
<p><strong>而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">    used[i] = <span class="literal">true</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    used[i] = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">   LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">   <span class="type">boolean</span>[] used;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">       <span class="keyword">if</span> (nums.length == <span class="number">0</span>){</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       }</span><br><span class="line">       used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">       backtracking(nums);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   }</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">      	<span class="keyword">if</span>(path.size() == nums.length) {</span><br><span class="line">           res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++) {</span><br><span class="line">           <span class="keyword">if</span>(used[i]) {</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           used[i] = <span class="literal">true</span>;</span><br><span class="line">           path.add(nums[i]);</span><br><span class="line">           backtracking(nums);</span><br><span class="line">           path.removeLast();</span><br><span class="line">           used[i] = <span class="literal">false</span>;</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>重新安排行程_回溯11</title>
    <url>/2022/08/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF10/</url>
    <content><![CDATA[<html><head></head><body><h1 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h1><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/">力扣题目链接(opens new window)</a></p>
<p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p>
<p>提示：</p>
<ul>
<li>如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前</li>
<li>所有的机场都用三个大写字母表示（机场代码）。</li>
<li>假定所有机票至少存在一种合理的行程。</li>
<li>所有的机票必须都用一次 且 只能用一次。</li>
</ul>
<p>示例 1：</p>
<ul>
<li>输入：[[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]</li>
<li>输出：[“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：[[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]</li>
<li>输出：[“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]</li>
<li>解释：另一种有效的行程是 [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]。但是它自然排序更大更靠后。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目还是很难的，之前我们用回溯法解决了如下问题：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">组合问题 (opens new window)</a>，<a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html">分割问题 (opens new window)</a>，<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">子集问题 (opens new window)</a>，<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">排列问题 (opens new window)</a>。</p>
<p>直觉上来看 这道题和回溯法没有什么关系，更像是图论中的深度优先搜索。</p>
<p>实际上确实是深搜，但这是深搜中使用了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。</p>
<p>所以我倾向于说本题应该使用回溯法，那么我也用回溯法的思路来讲解本题，其实深搜一般都使用了回溯法的思路，在图论系列中我会再详细讲解深搜。</p>
<p><strong>这里就是先给大家拓展一下，原来回溯法还可以这么玩！</strong></p>
<p><strong>这道题目有几个难点：</strong></p>
<ol>
<li>一个行程中，如果航班处理不好容易变成一个圈，成为死循环</li>
<li>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</li>
<li>使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？</li>
<li>搜索的过程中，如何遍历一个机场所对应的所有机场。</li>
</ol>
<p>针对以上问题我来逐一解答！</p>
<h2 id="如何理解死循环"><a href="#如何理解死循环" class="headerlink" title="#如何理解死循环"></a><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%AD%BB%E5%BE%AA%E7%8E%AF">#</a>如何理解死循环</h2><p>对于死循环，我来举一个有重复机场的例子：</p>
<p><img src="https://img-blog.csdnimg.cn/20201115180537865.png" alt="332.重新安排行程"></p>
<p>为什么要举这个例子呢，就是告诉大家，出发机场和到达机场也会重复的，<strong>如果在解题的过程中没有对集合元素处理好，就会死循环。</strong></p>
<h2 id="该记录映射关系"><a href="#该记录映射关系" class="headerlink" title="#该记录映射关系"></a><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E8%AF%A5%E8%AE%B0%E5%BD%95%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB">#</a>该记录映射关系</h2><p>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</p>
<p>一个机场映射多个机场，机场之间要靠字母序排列，一个机场映射多个机场，可以使用std::unordered_map，如果让多个机场之间再有顺序的话，就是用std::map 或者std::multimap 或者 std::multiset。</p>
<p>如果对map 和 set 的实现机制不太了解，也不清楚为什么 map、multimap就是有序的同学，可以看这篇文章<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！ (opens new window)</a>。</p>
<p>这样存放映射关系可以定义为 <code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code> 或者 <code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>。</p>
<p>含义如下：</p>
<p>unordered_map&lt;string, multiset&gt; targets：unordered_map&lt;出发机场, 到达机场的集合&gt; targets</p>
<p>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets：unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</p>
<p>这两个结构，我选择了后者，因为如果使用<code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code> 遍历multiset的时候，不能删除元素，一旦删除元素，迭代器就失效了。</p>
<p><strong>再说一下为什么一定要增删元素呢，正如开篇我给出的图中所示，出发机场和到达机场是会重复的，搜索的过程没及时删除目的机场就会死循环。</strong></p>
<p>所以搜索的过程中就是要不断的删multiset里的元素，那么推荐使用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>。</p>
<p>在遍历 <code>unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</code>的过程中，<strong>可以使用”航班次数”这个字段的数字做相应的增减，来标记到达机场是否使用过了。</strong></p>
<p>如果“航班次数”大于零，说明目的地还可以飞，如果如果“航班次数”等于零说明目的地不能飞了，而不用对集合做删除元素或者增加元素的操作。</p>
<p><strong>相当于说我不删，我就做一个标记！</strong></p>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="#回溯法"></a><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%9B%9E%E6%BA%AF%E6%B3%95">#</a>回溯法</h2><p>这道题目我使用回溯法，那么下面按照我总结的回溯模板来：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">void backtracking(参数) {</span><br><span class="line">    if (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>本题以输入：[[“JFK”, “KUL”], [“JFK”, “NRT”], [“NRT”, “JFK”]为例，抽象为树形结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2020111518065555.png" alt="332.重新安排行程1"></p>
<p>开始回溯三部曲讲解：</p>
<ul>
<li>递归函数参数</li>
</ul>
<p>在讲解映射关系的时候，已经讲过了，使用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;</code> 来记录航班的映射关系，我定义为全局变量。</p>
<p>当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度。</p>
<p>参数里还需要ticketNum，表示有多少个航班（终止条件会用上）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span></span><br><span class="line">unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>{</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意函数返回值我用的是bool！</strong></p>
<p>我们之前讲解回溯算法的时候，一般函数返回值都是void，这次为什么是bool呢？</p>
<p>因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2020111518065555.png" alt="332.重新安排行程1"></p>
<p>所以找到了这个叶子节点了直接返回，这个递归函数的返回值问题我们在讲解二叉树的系列的时候，在这篇<a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>详细介绍过。</p>
<p>当然本题的targets和result都需要初始化，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> vector&lt;string&gt;&amp; vec : tickets) {</span><br><span class="line">    targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]]++; <span class="comment">// 记录映射关系</span></span><br><span class="line">}</span><br><span class="line">result.<span class="built_in">push_back</span>(<span class="string">"JFK"</span>); <span class="comment">// 起始机场</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p>拿题目中的示例为例，输入: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]] ，这是有4个航班，那么只要找出一种行程，行程里的机场个数是5就可以了。</p>
<p>所以终止条件是：我们回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>已经看习惯回溯法代码的同学，到叶子节点了习惯性的想要收集结果，但发现并不需要，本题的result相当于 <a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">回溯算法：求组合总和！ (opens new window)</a>中的path，也就是本题的result就是记录路径的（就一条），在如下单层搜索的逻辑中result就添加元素了。</p>
<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>回溯的过程中，如何遍历一个机场所对应的所有机场呢？</p>
<p><strong>可以说本题既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效</strong>。</p>
<p>所以我选择了<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code> 来做机场之间的映射。</p>
<p>遍历过程如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) {</span><br><span class="line">    <span class="keyword">if</span> (target.second &gt; <span class="number">0</span> ) { <span class="comment">// 记录到达机场是否飞过了</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">        target.second--;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        result.<span class="built_in">pop_back</span>();</span><br><span class="line">        target.second++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题其实可以算是一道hard的题目了，关于本题的难点我在文中已经列出了。</p>
<p><strong>如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上</strong>。</p>
<p>本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，<strong>算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归</strong>。</p>
<p>如果最终代码，发现照着回溯法模板画的话好像也能画出来，但难就难如何知道可以使用回溯，以及如果套进去，所以我再写了这么长的一篇来详细讲解。</p>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;String,Map&lt;String,Integer&gt;&gt; map;</span><br><span class="line">    Deque&lt;String&gt; res;</span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> {</span><br><span class="line">		map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Map&lt;String,Integer&gt;&gt;();</span><br><span class="line">        res = LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; t:tickets) {</span><br><span class="line">            Map&lt;String,Integer&gt; tmp;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(t.get(<span class="number">0</span>))) {</span><br><span class="line">                tmp = map.get(t.get(<span class="number">0</span>));</span><br><span class="line">                tmp.put(t.get(<span class="number">1</span>), tmp.getOrDefault(t.get(<span class="number">1</span>),<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                tmp = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">                tmp.put(t.get(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            map.put(t.get(<span class="number">0</span>),tmp);</span><br><span class="line">        }</span><br><span class="line">        res.push(<span class="string">"JFK"</span>);</span><br><span class="line">        backtracking(tickets.size());</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> ticketsNum)</span> {</span><br><span class="line">        <span class="keyword">if</span>(res.size() == ticketsNum + <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> res.getLast();</span><br><span class="line">       	<span class="keyword">if</span>(map.containsKey(last)) {</span><br><span class="line">            <span class="keyword">for</span>(Map,Entry&lt;String,Integer&gt; target:map.get(last).entrySet()) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> target.getValue();</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>) {</span><br><span class="line">                    res.add(target.getKey());</span><br><span class="line">                    target.setValue(count -<span class="number">1</span>); <span class="comment">// 处处都有回溯</span></span><br><span class="line">                    <span class="keyword">if</span>(backtracking(ticketsNum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    res.removeLast();</span><br><span class="line">                    target.setValue(count);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列_回溯10</title>
    <url>/2022/08/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF09/</url>
    <content><![CDATA[<html><head></head><body><h1 id="排列问题（二）"><a href="#排列问题（二）" class="headerlink" title="排列问题（二）"></a>排列问题（二）</h1><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="#47.全排列 II"></a><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#_47-%E5%85%A8%E6%8E%92%E5%88%97-ii">#</a>47.全排列 II</h2><p><a href="https://leetcode.cn/problems/permutations-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>示例 1：</p>
<ul>
<li>输入：nums = [1,1,2]</li>
<li>输出： [[1,1,2], [1,2,1], [2,1,1]]</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：nums = [1,2,3]</li>
<li>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 8</li>
<li>-10 &lt;= nums[i] &lt;= 10</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>**如果对回溯算法基础还不了解的话，我还特意录制了一期视频：<a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇） (opens new window)</a>**可以结合题解和视频一起看，希望对大家理解回溯算法有所帮助。</p>
<p>这道题目和<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列 (opens new window)</a>的区别在与<strong>给定一个可包含重复数字的序列</strong>，要返回<strong>所有不重复的全排列</strong>。</p>
<p>这里又涉及到去重了。</p>
<p>在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II (opens new window)</a>、<a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a>我们分别详细讲解了组合问题和子集问题如何去重。</p>
<p>那么排列问题其实也是一样的套路。</p>
<p><strong>还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</p>
<p>我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124201331223.png" alt="47.全排列II1"></p>
<p>图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p>
<p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p>
<p>在<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列 (opens new window)</a>中已经详解讲解了排列问题的写法，在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II (opens new window)</a>、<a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a>中详细讲解的去重的写法，所以这次我就不用回溯三部曲分析了，直接给出代码，如下：</p>
<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="#C++代码"></a><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#c-%E4%BB%A3%E7%A0%81">#</a>C++代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>{</span><br><span class="line">        <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) {</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) {</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="#拓展"></a><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%8B%93%E5%B1%95">#</a>拓展</h2><p>大家发现，去重最为关键的代码为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) {</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>**如果改成 <code>used[i - 1] == true</code>， 也是正确的!**，去重代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">true</span>) {</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p>
<p><strong>对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！</strong></p>
<p>这么说是不是有点抽象？</p>
<p>来来来，我就用输入: [1,1,1] 来举一个例子。</p>
<p>树层上去重(used[i - 1] == false)，的树形结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124201406192.png" alt="47.全排列II2"></p>
<p>树枝上去重（used[i - 1] == true）的树型结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124201431571.png" alt="47.全排列II3"></p>
<p>大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//存放结果</span></span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//暂存结果</span></span><br><span class="line">  List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">      <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      backtracking(nums);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  	</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) {</span><br><span class="line">          <span class="comment">// used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过</span></span><br><span class="line">          <span class="comment">// used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过</span></span><br><span class="line">          <span class="comment">// 如果同⼀树层nums[i - 1]使⽤过则直接跳过</span></span><br><span class="line">          <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; used[i -<span class="number">1</span>] == <span class="literal">false</span>) {</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span>(used[i] == <span class="literal">false</span>) {</span><br><span class="line">              used[i] = <span class="literal">true</span>;</span><br><span class="line">              path.add(nums[i]);</span><br><span class="line">          	backtracking(nums);</span><br><span class="line">          	path.remove(path.size() -<span class="number">1</span>);</span><br><span class="line">              used[i] = <span class="literal">false</span>;</span><br><span class="line">          }</span><br><span class="line">        </span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>N皇后_回溯12</title>
    <url>/2022/08/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF11/</url>
    <content><![CDATA[<html><head></head><body><h1 id="第51题-N皇后"><a href="#第51题-N皇后" class="headerlink" title="第51题. N皇后"></a>第51题. N皇后</h1><p><a href="https://leetcode.cn/problems/n-queens/">力扣题目链接(opens new window)</a></p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例 1：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211020232201.png" alt="img"></p>
<ul>
<li>输入：n = 4</li>
<li>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</li>
<li>解释：如上图所示，4 皇后问题存在两个不同的解法。</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：n = 1</li>
<li>输出：[[“Q”]]</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>**如果对回溯算法基础还不了解的话，我还特意录制了一期视频：<a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇） (opens new window)</a>**可以结合题解和视频一起看，希望对大家理解回溯算法有所帮助。</p>
<p>都知道n皇后问题是回溯算法解决的经典问题，但是用回溯解决多了组合、切割、子集、排列问题之后，遇到这种二维矩阵还会有点不知所措。</p>
<p>首先来看一下皇后们的约束条件：</p>
<ol>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线</li>
</ol>
<p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p>
<p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后"></p>
<p>从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p>
<p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p>
<h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h3><p>按照我总结的如下回溯模板，我们来依次分析：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">void backtracking(参数) {</span><br><span class="line">    if (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归函数参数</li>
</ul>
<p>我依然是定义全局变量二维数组result来记录最终结果。</p>
<p>参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span> </span>{</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p>在如下树形结构中： <img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后"></p>
<p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (row == n) {</span><br><span class="line">    result.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</p>
<p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col, chessboard, n)) { <span class="comment">// 验证合法就可以放</span></span><br><span class="line">        chessboard[row][col] = <span class="string">'Q'</span>; <span class="comment">// 放置皇后</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, row + <span class="number">1</span>, chessboard);</span><br><span class="line">        chessboard[row][col] = <span class="string">'.'</span>; <span class="comment">// 回溯，撤销皇后</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>验证棋盘是否合法</li>
</ul>
<p>按照如下标准去重：</p>
<ol>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线 （45度和135度角）</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) { <span class="comment">// 这是一个剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][col] == <span class="string">'Q'</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查 45度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) {</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查 135度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) {</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p>
<p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : chessboard) {</span><br><span class="line">            Arrays.fill(c, <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line">        backtracking(n,<span class="number">0</span>,chessborad); <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">Array2List</span><span class="params">(<span class="type">char</span>[][] chessboard)</span> {</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : chessboard) {</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> row,<span class="type">char</span>[][] chessboard)</span> {</span><br><span class="line">        <span class="comment">// 终止条件为 row = n的时候 因为n-1的位置还是需要放’Q‘皇后</span></span><br><span class="line">        <span class="keyword">if</span>(n == row) {</span><br><span class="line">            res.add(Array2List(chessborad));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从列开始 for循环 每次都从0开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col&lt;n;col++) {</span><br><span class="line">            <span class="comment">// 检验合格性 1.不能有重复行列 2.不能在同一条斜线上面(45度,以及135度)</span></span><br><span class="line">            <span class="keyword">if</span>(isValid(row,col,chessboard)) {</span><br><span class="line">                <span class="comment">// 合格的话此位置就加入'Q'皇后 </span></span><br><span class="line">                chessboard[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                backtracking(n,row + <span class="number">1</span>,chessboard);</span><br><span class="line">                <span class="comment">// 调回'.'</span></span><br><span class="line">                chessboard[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span>[][] chessboard)</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++) {</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col,<span class="type">int</span> j=row;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;j--,i--) {</span><br><span class="line">            <span class="keyword">if</span>(chessboard[j][i] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col,<span class="type">int</span> j=row;i&lt;n&amp;&amp;j&gt;=<span class="number">0</span>;i++,j--) {</span><br><span class="line">            <span class="keyword">if</span>(chessboard[j][i] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串_字符串01</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B201/</url>
    <content><![CDATA[<html><head></head><body><h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接(opens new window)</a></p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p>
<p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先说一说题外话：</p>
<p>对于这道题目一些同学直接用C++里的一个库函数 reverse，调一下直接完事了， 相信每一门编程语言都有这样的库函数。</p>
<p>如果这么做题的话，这样大家不会清楚反转字符串的实现原理了。</p>
<p>但是也不是说库函数就不能用，是要分场景的。</p>
<p>如果在现场面试中，我们什么时候使用库函数，什么时候不要用库函数呢？</p>
<p><strong>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</strong></p>
<p>毕竟面试官一定不是考察你对库函数的熟悉程度， 如果使用python和java 的同学更需要注意这一点，因为python、java提供的库函数十分丰富。</p>
<p><strong>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</strong></p>
<p>建议大家平时在leetcode上练习算法的时候本着这样的原则去练习，这样才有助于我们对算法的理解。</p>
<p>不要沉迷于使用库函数一行代码解决题目之类的技巧，不是说这些技巧不好，而是说这些技巧可以用来娱乐一下。</p>
<p>真正自己写的时候，要保证理解可以实现是相应的功能。</p>
<p>接下来再来讲一下如何解决反转字符串的问题。</p>
<p>大家应该还记得，我们已经讲过了<a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">206.反转链表 (opens new window)</a>。</p>
<p>在反转链表中，使用了双指针的方法。</p>
<p>那么反转字符串依然是使用双指针的方法，只不过对于字符串的反转，其实要比链表简单一些。</p>
<p>因为字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。</p>
<p>如果对数组和链表原理不清楚的同学，可以看这两篇，<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于链表，你该了解这些！ (opens new window)</a>，<a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">必须掌握的数组理论知识 (opens new window)</a>。</p>
<p>对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p>
<p>以字符串<code>hello</code>为例，过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp0fvi91pfg30de0akwnq.gif" alt="344.反转字符串"></p>
<p>不难写出如下C++代码:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>()/<span class="number">2</span>; i++, j--) {</span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>循环里只要做交换s[i] 和s[j]操作就可以了，那么我这里使用了swap 这个库函数。大家可以使用。</p>
<p>因为相信大家都知道交换函数如何实现，而且这个库函数仅仅是解题中的一部分， 所以这里使用库函数也是可以的。</p>
<p>swap可以有两种实现。</p>
<p>一种就是常见的交换数值：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp = s[i];</span><br><span class="line">s[i] = s[j];</span><br><span class="line">s[j] = tmp;</span><br></pre></td></tr></tbody></table></figure>

<p>一种就是通过位运算：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">s[i] ^= s[j];</span><br><span class="line">s[j] ^= s[i];</span><br><span class="line">s[i] ^= s[j];</span><br></pre></td></tr></tbody></table></figure>

<p>这道题目还是比较简单的，但是我正好可以通过这道题目说一说在刷题的时候，使用库函数的原则。</p>
<p>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</p>
<p>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</p>
<p>本着这样的原则，我没有使用reverse库函数，而使用swap库函数。</p>
<p><strong>在字符串相关的题目中，库函数对大家的诱惑力是非常大的，因为会有各种反转，切割取词之类的操作</strong>，这也是为什么字符串的库函数这么丰富的原因。</p>
<p>相信大家本着我所讲述的原则来做字符串相关的题目，在选择库函数的角度上会有所原则，也会有所收获。</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> {</span><br><span class="line">    	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">'a'</span>;</span><br><span class="line">    	<span class="keyword">while</span>(i&lt;j) {</span><br><span class="line">    		temp = s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">    	}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格_字符串03</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B203/</url>
    <content><![CDATA[<html><head></head><body><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">力扣题目链接(opens new window)</a></p>
<p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1： 输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果想把这道题目做到极致，就不要只用额外的辅助空间了！</p>
<p>首先扩充数组到每个空格替换成”%20”之后的大小。</p>
<p>然后从后向前替换空格，也就是双指针法，过程如下：</p>
<p>i指向新长度的末尾，j指向旧长度的末尾。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1go6qmevhgpg20du09m4qp.gif" alt="替换空格"></p>
<p>有同学问了，为什么要从后向前填充，从前向后填充不行么？</p>
<p>从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。</p>
<p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p>
<p>这么做有两个好处：</p>
<ol>
<li>不用申请新数组。</li>
<li>从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。</li>
</ol>
<p>时间复杂度，空间复杂度均超过100%的用户。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.png" alt="img"></p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> {</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">null</span> || s.length() == <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="type">char</span> c:s.toCharArray()) {</span><br><span class="line">    	<span class="keyword">if</span>(c == <span class="string">' '</span>) {</span><br><span class="line">    		sb.append(<span class="string">'   '</span>)</span><br><span class="line">    	}</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">    s += sb.toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span>(arr[left] == <span class="string">' '</span>) {</span><br><span class="line">            arr[right--] = <span class="string">'0'</span>;</span><br><span class="line">            arr[right--] = <span class="string">'2'</span>;</span><br><span class="line">            arr[right] = <span class="string">'%'</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        }</span><br><span class="line">        left--;</span><br><span class="line">        right--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串II_字符串02</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B202/</url>
    <content><![CDATA[<html><head></head><body><h1 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目其实也是模拟，实现题目中规定的反转规则就可以了。</p>
<p>一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。</p>
<p>其实在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p>
<p>因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。</p>
<p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p>
<p>性能如下： <img src="https://code-thinking.cdn.bcebos.com/pics/541_%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.png" alt="img"></p>
<p>那么这里具体反转的逻辑我们要不要使用库函数呢，其实用不用都可以，使用reverse来实现反转也没毛病，毕竟不是解题关键部分。</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length;i+=<span class="number">2</span>*k) {</span><br><span class="line">            start = i;</span><br><span class="line">            end = Math.min(start+k-<span class="number">1</span>,arr.length-<span class="number">1</span>);<span class="comment">// 关键代码</span></span><br><span class="line">            reverse(arr,start,end);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr,<span class="type">int</span> start,<span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end) {</span><br><span class="line">            temp = arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转字符串里的单词_字符串04</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B204/</url>
    <content><![CDATA[<html><head></head><body><h1 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h1><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p>
<p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：<br>输入: “a good  example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>这道题目可以说是综合考察了字符串的多种操作。</strong></p>
<p>一些同学会使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。</p>
<p>所以这里我还是提高一下本题的难度：<strong>不要使用辅助空间，空间复杂度要求为O(1)。</strong></p>
<p>不能使用辅助空间之后，那么只能在原字符串上下功夫了。</p>
<p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p>
<p>所以解题思路如下：</p>
<ul>
<li>移除多余空格</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ul>
<p>举个例子，源字符串为：”the sky is blue “</p>
<ul>
<li>移除多余空格 : “the sky is blue”</li>
<li>字符串反转：”eulb si yks eht”</li>
<li>单词反转：”blue is sky the”</li>
</ul>
<p>这样我们就完成了翻转字符串里的单词。</p>
<p>思路很明确了，我们说一说代码的实现细节，就拿移除多余空格来说，一些同学会上来写如下代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>] &amp;&amp; s[i] == <span class="string">' '</span>) {</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 删除字符串最后面的空格</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">' '</span>) {</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 删除字符串最前面的空格</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">' '</span>) {</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>逻辑很简单，从前向后遍历，遇到空格了就erase。</p>
<p>如果不仔细琢磨一下erase的时间复杂度，还以为以上的代码是O(n)的时间复杂度呢。</p>
<p>想一下真正的时间复杂度是多少，一个erase本来就是O(n)的操作，erase实现原理题目：<a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">数组：就移除个元素很难么？ (opens new window)</a>，最优的算法来移除元素也要O(n)。</p>
<p>erase操作上面还套了一个for循环，那么以上代码移除冗余空格的代码时间复杂度为O(n^2)。</p>
<p>那么使用双指针法来去移除空格，最后resize（重新设置）一下字符串的大小，就可以做到O(n)的时间复杂度。</p>
<p>如果对这个操作比较生疏了，可以再看一下这篇文章：<a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">数组：就移除个元素很难么？ (opens new window)</a>是如何移除元素的。</p>
<p>那么使用双指针来移除冗余空格代码如下： fastIndex走的快，slowIndex走的慢，最后slowIndex就标记着移除多余空格后新字符串的长度。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>{</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>, fastIndex = <span class="number">0</span>; <span class="comment">// 定义快指针，慢指针</span></span><br><span class="line">    <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; fastIndex &lt; s.<span class="built_in">size</span>() &amp;&amp; s[fastIndex] == <span class="string">' '</span>) {</span><br><span class="line">        fastIndex++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (; fastIndex &lt; s.<span class="built_in">size</span>(); fastIndex++) {</span><br><span class="line">        <span class="comment">// 去掉字符串中间部分的冗余空格</span></span><br><span class="line">        <span class="keyword">if</span> (fastIndex - <span class="number">1</span> &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; s[fastIndex - <span class="number">1</span>] == s[fastIndex]</span><br><span class="line">                &amp;&amp; s[fastIndex] == <span class="string">' '</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            s[slowIndex++] = s[fastIndex];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (slowIndex - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[slowIndex - <span class="number">1</span>] == <span class="string">' '</span>) { <span class="comment">// 去掉字符串末尾的空格</span></span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex - <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex); <span class="comment">// 重新设置字符串大小</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有的同学可能发现用erase来移除空格，在leetcode上性能也还行。主要是以下几点；：</p>
<ol>
<li>leetcode上的测试集里，字符串的长度不够长，如果足够长，性能差距会非常明显。</li>
<li>leetcode的测程序耗时不是很准确的。</li>
</ol>
<p>此时我们已经实现了removeExtraSpaces函数来移除冗余空格。</p>
<p>还做实现反转字符串的功能，支持反转字符串子区间，这个实现我们分别在<a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">344.反转字符串 (opens new window)</a>和<a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">541.反转字符串II (opens new window)</a>里已经讲过了。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">// 反转字符串s中左闭又闭的区间[start, end]</span><br><span class="line">void reverse(string&amp; s, int start, int end) {</span><br><span class="line">    for (int i = start, j = end; i &lt; j; i++, j--) {</span><br><span class="line">        swap(s[i], s[j]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> {</span><br><span class="line">		<span class="comment">// 取出空余 </span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> removeEmpty(s);</span><br><span class="line">		<span class="comment">// 先整体 再局部翻转</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">		reverse(sb,start,end);</span><br><span class="line">        <span class="comment">// 局部翻转 单词</span></span><br><span class="line">        reverseWord(sb);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">public</span> StringBuilder <span class="title function_">reverse</span><span class="params">(StringBuilder sb,<span class="type">int</span> start,<span class="type">int</span> end)</span> {</span><br><span class="line">		<span class="keyword">while</span>(start&lt;end) {</span><br><span class="line">			<span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(end);</span><br><span class="line">			sb.setChar(start,temp);</span><br><span class="line">			sb.setChar(end,temp);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEmpty</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		start = <span class="number">0</span>;</span><br><span class="line">		end = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(start)==<span class="string">' '</span>)start++;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(end)==<span class="string">' '</span>)end--;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="string">' '</span> || sb.charAt(sb.length()-<span class="number">1</span>) != <span class="string">' '</span>) {</span><br><span class="line">                sb.append(tmp);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseWord</span><span class="params">(StringBuilder sb)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="keyword">while</span>(start &lt; n) {</span><br><span class="line">            <span class="keyword">while</span>(end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">' '</span>) {</span><br><span class="line">                end++;</span><br><span class="line">            }</span><br><span class="line">            reverseString(sb,start,end-<span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>实现 strStr()_字符串06</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B206/</url>
    <content><![CDATA[<html><head></head><body><h1 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h1><p><a href="https://leetcode.cn/problems/implement-strstr/">力扣题目链接(opens new window)</a></p>
<p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p>
<p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p>
<p>示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1</p>
<p>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题是KMP 经典题目。</p>
<p>以下文字如果看不进去，可以看我的B站视频：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1PD4y1o7nd/">帮你把KMP算法学个通透！B站（理论篇）(opens new window)</a></li>
<li><a href="https://www.bilibili.com/video/BV1M5411j7Xx">帮你把KMP算法学个通透！（求next数组代码篇）(opens new window)</a></li>
</ul>
<p>KMP的经典思想就是:<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</strong></p>
<p>本篇将以如下顺序来讲解KMP，</p>
<ul>
<li>什么是KMP</li>
<li>KMP有什么用</li>
<li>什么是前缀表</li>
<li>为什么一定要用前缀表</li>
<li>如何计算前缀表</li>
<li>前缀表与next数组</li>
<li>使用next数组来匹配</li>
<li>时间复杂度分析</li>
<li>构造next数组</li>
<li>使用next数组来做匹配</li>
<li>前缀表统一减一 C++代码实现</li>
<li>前缀表（不减一）C++实现</li>
<li>总结</li>
</ul>
<p>读完本篇可以顺便把leetcode上28.实现strStr()题目做了。</p>
<h3 id="什么是KMP"><a href="#什么是KMP" class="headerlink" title="什么是KMP"></a>什么是KMP</h3><p>说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。</p>
<p>因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP</p>
<h3 id="KMP有什么用"><a href="#KMP有什么用" class="headerlink" title="KMP有什么用"></a>KMP有什么用</h3><p>KMP主要应用在字符串匹配上。</p>
<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p>
<p>其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。</p>
<p>没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。</p>
<p>不仅面试的时候可能写不出来，如果面试官问：<strong>next数组里的数字表示的是什么，为什么这么表示？</strong></p>
<p>估计大多数候选人都是懵逼的。</p>
<p>下面Carl就带大家把KMP的精髓，next数组弄清楚。</p>
<h3 id="什么是前缀表"><a href="#什么是前缀表" class="headerlink" title="什么是前缀表"></a>什么是前缀表</h3><p>写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？</p>
<p>next数组就是一个前缀表（prefix table）。</p>
<p>前缀表有什么作用呢？</p>
<p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p>
<p>为了清楚的了解前缀表的来历，我们来举一个例子：</p>
<p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>
<p>请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：</p>
<p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>
<p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>
<p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>
<p>如动画所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p>
<p>动画里，我特意把 子串<code>aa</code> 标记上了，这是有原因的，大家先注意一下，后面还会说道。</p>
<p>可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，会发现不匹配，此时就要从头匹配了。</p>
<p>但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。</p>
<p>此时就要问了<strong>前缀表是如何记录的呢？</strong></p>
<p>首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p>
<p>那么什么是前缀表：<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p>
<h3 id="最长公共前后缀？"><a href="#最长公共前后缀？" class="headerlink" title="最长公共前后缀？"></a>最长公共前后缀？</h3><p>文章中字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p>
<p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p>
<p><strong>正确理解什么是前缀什么是后缀很重要</strong>!</p>
<p>那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？</p>
<p>我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。</p>
<p><strong>因为前缀表要求的就是相同前后缀的长度。</strong></p>
<p>而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。</p>
<p>所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等…..。</p>
<h3 id="为什么一定要用前缀表"><a href="#为什么一定要用前缀表" class="headerlink" title="为什么一定要用前缀表"></a>为什么一定要用前缀表</h3><p>这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？</p>
<p>回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B21.png" alt="KMP精讲1"></p>
<p>然后就找到了下标2，指向b，继续匹配：如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B22.png" alt="KMP精讲2"></p>
<p>以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！</p>
<p><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。</strong></p>
<p>所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p>
<p><strong>很多介绍KMP的文章或者视频并没有把为什么要用前缀表？这个问题说清楚，而是直接默认使用前缀表。</strong></p>
<h3 id="如何计算前缀表"><a href="#如何计算前缀表" class="headerlink" title="如何计算前缀表"></a>如何计算前缀表</h3><p>接下来就要说一说怎么计算前缀表。</p>
<p>如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B25.png" alt="KMP精讲5"></p>
<p>长度为前1个字符的子串<code>a</code>，最长相同前后缀的长度为0。（注意字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>；<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。）</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B26.png" alt="KMP精讲6"> 长度为前2个字符的子串<code>aa</code>，最长相同前后缀的长度为1。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B27.png" alt="KMP精讲7"> 长度为前3个字符的子串<code>aab</code>，最长相同前后缀的长度为0。</p>
<p>以此类推： 长度为前4个字符的子串<code>aaba</code>，最长相同前后缀的长度为1。 长度为前5个字符的子串<code>aabaa</code>，最长相同前后缀的长度为2。 长度为前6个字符的子串<code>aabaaf</code>，最长相同前后缀的长度为0。</p>
<p>那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png" alt="KMP精讲8"></p>
<p>可以看出模式串与前缀表对应位置的数字表示的就是：<strong>下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p>
<p>再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"></p>
<p>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。</p>
<p>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p>
<p>所以要看前一位的 前缀表的数值。</p>
<p>前一个字符的前缀表的数值是2， 所有把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。</p>
<p>最后就在文本串中找到了和模式串匹配的子串了。</p>
<h3 id="前缀表与next数组"><a href="#前缀表与next数组" class="headerlink" title="前缀表与next数组"></a>前缀表与next数组</h3><p>很多KMP算法的时间都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？</p>
<p>next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。</p>
<p>为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。</p>
<p>其实<strong>这并不涉及到KMP的原理，而是具体实现，next数组即可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</strong></p>
<p>后面我会提供两种不同的实现代码，大家就明白了。</p>
<h3 id="使用next数组来匹配"><a href="#使用next数组来匹配" class="headerlink" title="使用next数组来匹配"></a>使用next数组来匹配</h3><p><strong>以下我们以前缀表统一减一之后的next数组来做演示</strong>。</p>
<p>有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。</p>
<p>注意next数组是新前缀表（旧前缀表统一减一了）。</p>
<p>匹配过程动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif" alt="KMP精讲4"></p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。</p>
<p>暴力的解法显而易见是O(n × m)，所以<strong>KMP在字符串匹配中极大的提高的搜索的效率。</strong></p>
<p>为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。</p>
<p>都知道使用KMP算法，一定要构造next数组。</p>
<h3 id="构造next数组"><a href="#构造next数组" class="headerlink" title="构造next数组"></a>构造next数组</h3><p>我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">void getNext(int* next, const string&amp; s)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>构造next数组其实就是计算模式串s，前缀表的过程。</strong> 主要有如下三步：</p>
<ol>
<li>初始化</li>
<li>处理前后缀不相同的情况</li>
<li>处理前后缀相同的情况</li>
</ol>
<p>接下来我们详解详解一下。</p>
<ol>
<li>初始化：</li>
</ol>
<p>定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。</p>
<p>然后还要对next数组进行初始化赋值，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br></pre></td></tr></tbody></table></figure>

<p>j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。</p>
<p>next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）</p>
<p>所以初始化next[0] = j 。</p>
<ol>
<li>处理前后缀不相同的情况</li>
</ol>
<p>因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。</p>
<p>所以遍历模式串s的循环下标i 要从 1开始，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) {</span><br></pre></td></tr></tbody></table></figure>

<p>如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。</p>
<p>怎么回退呢？</p>
<p>next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。</p>
<p>那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。</p>
<p>所以，处理前后缀不相同的情况代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) { <span class="comment">// 前后缀不相同了</span></span><br><span class="line">    j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>处理前后缀相同的情况</li>
</ol>
<p>如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">if (s[i] == s[j + 1]) { // 找到相同的前后缀</span><br><span class="line">    j++;</span><br><span class="line">}</span><br><span class="line">next[i] = j;</span><br></pre></td></tr></tbody></table></figure>

<p>最后整体构建next数组的函数代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>{</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) { <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) { <span class="comment">// 前后缀不相同了</span></span><br><span class="line">            j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) { <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码构造next数组的逻辑流程动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt="KMP精讲3"></p>
<p>得到了next数组之后，就要用这个来做匹配了。</p>
<h3 id="使用next数组来做匹配"><a href="#使用next数组来做匹配" class="headerlink" title="使用next数组来做匹配"></a>使用next数组来做匹配</h3><p>在文本串s里 找是否出现过模式串t。</p>
<p>定义两个下标j 指向模式串起始位置，i指向文本串起始位置。</p>
<p>那么j初始值依然为-1，为什么呢？ <strong>依然因为next数组里记录的起始位置为-1。</strong></p>
<p>i就从0开始，遍历文本串，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) </span><br></pre></td></tr></tbody></table></figure>

<p>接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。</p>
<p>如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>]) {</span><br><span class="line">    j = next[j];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == t[j + <span class="number">1</span>]) {</span><br><span class="line">    j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。</p>
<p>本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == (t.<span class="built_in">size</span>() - <span class="number">1</span>) ) {</span><br><span class="line">    <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>那么使用next数组，用模式串匹配文本串的整体代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// 因为next数组里记录的起始位置为-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) { <span class="comment">// 注意i就从0开始</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>]) { <span class="comment">// 不匹配</span></span><br><span class="line">        j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j + <span class="number">1</span>]) { <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">        j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j == (t.<span class="built_in">size</span>() - <span class="number">1</span>) ) { <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">        <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下：</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。</p>
<p>接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。</p>
<p>其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。</p>
<p>然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。</p>
<p>又给出了直接用前缀表作为next数组，来做匹配的实现代码。</p>
<p>可以说把KMP的每一个细微的细节都扣了出来，毫无遮掩的展示给大家了！</p>
<h3 id="java代码："><a href="#java代码：" class="headerlink" title="java代码："></a>java代码：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String s)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="comment">// 前缀 和 后缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++) {</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j+<span class="number">1</span>)) {</span><br><span class="line">                j = next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(j+<span class="number">1</span>)) {</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> {</span><br><span class="line">        <span class="keyword">if</span>(needle == <span class="literal">null</span> || needle.length() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(haystack.length() &lt; needle.length()) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> [] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next,needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.length();i++) {</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j+<span class="number">1</span>)) {</span><br><span class="line">                j = next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(hasystack.charAt(i) == needle.charAt(j+<span class="number">1</span>)) {</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(j == needle.length() -<span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> (i - needle.length() + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>重复的子字符串_字符串07</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B207/</url>
    <content><![CDATA[<html><head></head><body><h1 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接(opens new window)</a></p>
<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p>
<p>示例 2:<br>输入: “aba”<br>输出: False</p>
<p>示例 3:<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这又是一道标准的KMP的题目。</p>
<p>如果KMP还不够了解，可以看我的B站：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1PD4y1o7nd/">帮你把KMP算法学个通透！（理论篇）(opens new window)</a></li>
<li><a href="https://www.bilibili.com/video/BV1M5411j7Xx">帮你把KMP算法学个通透！（求next数组代码篇）(opens new window)</a></li>
</ul>
<p>我们在<a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">字符串：KMP算法精讲 (opens new window)</a>里提到了，在一个串中查找是否出现过另一个串，这是KMP的看家本领。</p>
<p>那么寻找重复子串怎么也涉及到KMP算法了呢？</p>
<p>这里就要说一说next数组了，next 数组记录的就是最长相同前后缀( <a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">字符串：KMP算法精讲 (opens new window)</a>这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。</p>
<p>最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1)</p>
<p>数组长度为：len。</p>
<p>如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。</p>
<p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p>
<p><strong>强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法</strong></p>
<p>如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2_1.png" alt="459.重复的子字符串_1"></p>
<p>next[len - 1] = 7，next[len - 1] + 1 = 8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。</p>
<p>(len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> {</span><br><span class="line">    		<span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    		<span class="comment">// next数组</span></span><br><span class="line">    		getNext(next,s);</span><br><span class="line">    		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> s.length() - (next[s.length()-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    		<span class="keyword">return</span> s.length()%a == <span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next,String s)</span> {</span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++) {</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s.charAt(j+<span class="number">1</span>) != s.charAt(i)) {</span><br><span class="line">                j = next[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j+<span class="number">1</span>) == s.charAt(i)) {</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串_字符串05</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B205/</url>
    <content><![CDATA[<html><head></head><body><h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接(opens new window)</a></p>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p>
<p>示例 2：<br>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p>
<p>限制：<br>1 &lt;= k &lt; s.length &lt;= 10000</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了让本题更有意义，提升一下本题难度：<strong>不能申请额外空间，只能在本串上操作</strong>。</p>
<p>不能使用额外空间的话，模拟在本串操作要实现左旋转字符串的功能还是有点困难的。</p>
<p>那么我们可以想一下上一题目<a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">字符串：花式反转还不够！ (opens new window)</a>中讲过，使用整体反转+局部反转就可以实现，反转单词顺序的目的。</p>
<p>这道题目也非常类似，依然可以通过局部反转+整体反转 达到左旋转的目的。</p>
<p>具体步骤为：</p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<p>最后就可以得到左旋n的目的，而不用定义新的字符串，完全在本串上操作。</p>
<p>例如 ：示例1中 输入：字符串abcdefg，n=2</p>
<p>如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="img"></p>
<p>最终得到左旋2个单元的字符串：cdefgab</p>
<p>思路明确之后，那么代码实现就很简单了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时我们已经反转好多次字符串了，来一起回顾一下吧。</p>
<p>在这篇文章<a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">344.反转字符串 (opens new window)</a>，第一次讲到反转一个字符串应该怎么做，使用了双指针法。</p>
<p>然后发现<a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">541. 反转字符串II (opens new window)</a>，这里开始给反转加上了一些条件，当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</p>
<p>后来在<a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">151.翻转字符串里的单词 (opens new window)</a>中，要对一句话里的单词顺序进行反转，发现先整体反转再局部反转 是一个很妙的思路。</p>
<p>最后再讲到本题，本题则是先局部反转再 整体反转，与<a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">151.翻转字符串里的单词 (opens new window)</a>类似，但是也是一种新的思路。</p>
<p>好了，反转字符串一共就介绍到这里，相信大家此时对反转字符串的常见操作已经很了解了。</p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>一些同学热衷于使用substr，来做这道题。 其实使用substr 和 反转 时间复杂度是一样的 ，都是O(n)，但是使用substr申请了额外空间，所以空间复杂度是O(n)，而反转方法的空间复杂度是O(1)。</p>
<p><strong>如果想让这套题目有意义，就不要申请额外空间。</strong></p>
<p>java代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">    public String reverseLeftWords(String s, int n) {</span><br><span class="line">    	StringBuilder sb = new StringBuilder(s);</span><br><span class="line">    	// 先局部</span><br><span class="line">    	reverse(sb,0,n-1);</span><br><span class="line">    	reverse(sb,n,sb.length()-1);</span><br><span class="line">    	// 整体</span><br><span class="line">    	reverse(sb,0,sb.length()-1);</span><br><span class="line">    	return new String(sb);</span><br><span class="line">	}</span><br><span class="line">	public void reverse(StringBuilder sb,int start,int end) {</span><br><span class="line">		char temp = 'a';</span><br><span class="line">		while(start &lt; end) {</span><br><span class="line">			temp = sb.charAt(temp);</span><br><span class="line">			sb.setChar(start,temp);</span><br><span class="line">			sb.setChar(end,sb.charAt(temp));</span><br><span class="line">			start++;</span><br><span class="line">			end--;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_代码随想列题</title>
    <url>/2022/07/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%8401/</url>
    <content><![CDATA[<html><head></head><body><h1 id="数组-代码随想列题"><a href="#数组-代码随想列题" class="headerlink" title="数组_代码随想列题"></a>数组_代码随想列题</h1><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>[题目链接](<a href="https://leetcode.cn/problems/binary-search/">Loading Question… - 力扣（LeetCode）</a>)</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4     </span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1  </span><br></pre></td></tr></tbody></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了易于大家理解，我还录制了视频，可以看这里：<a href="https://www.bilibili.com/video/BV1fA4y1o715">手把手带你撕出正确的二分法(opens new window)</a></p>
<p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p>
<p>下面我用这两种区间的定义分别讲解两种不同的二分写法。</p>
<h3 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h3><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210311153055723.jpg" alt="704.二分查找"></p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 版本一</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) {</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]</span><br><span class="line">        while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;=</span><br><span class="line">            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2</span><br><span class="line">            if (nums[middle] &gt; target) {</span><br><span class="line">                right = middle - 1; // target 在左区间，所以[left, middle - 1]</span><br><span class="line">            } else if (nums[middle] &lt; target) {</span><br><span class="line">                left = middle + 1; // target 在右区间，所以[middle + 1, right]</span><br><span class="line">            } else { // nums[middle] == target</span><br><span class="line">                return middle; // 数组中找到目标值，直接返回下标</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        // 未找到目标值</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h3><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<p>在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（<strong>注意和方法一的区别</strong>）</p>
<p><img src="https://img-blog.csdnimg.cn/20210311153123632.jpg" alt="704.二分查找1"></p>
<p>代码如下：（详细注释）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) { <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) {</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) {</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二分法是非常重要的基础算法，为什么很多同学对于二分法都是<strong>一看就会，一写就废</strong>？</p>
<p>其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。</p>
<p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p>
<p>本篇根据两种常见的区间定义，给出了两种二分法的写法，每一个边界为什么这么处理，都根据区间的定义做了详细介绍。</p>
<p>相信看完本篇应该对二分法有更深刻的理解了。</p>
<h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><p>左边第一个目标值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">方法名 (nums数组,目标值){</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) {</span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= target) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left || right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>右边第一个目标值：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">方法名 (nums数组,目标值){</span><br><span class="line">	int left = 0;</span><br><span class="line">	int right = nums.length - 1;</span><br><span class="line">	while(left &lt; right) {</span><br><span class="line">		mid = 1+(left+right)/2;</span><br><span class="line">		if(nums[mid]&lt;=target) left = mid;</span><br><span class="line">		else right = mid-1;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_代码随想列题02</title>
    <url>/2022/07/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%8402/</url>
    <content><![CDATA[<html><head></head><body><h1 id="代码随想录-数组02"><a href="#代码随想录-数组02" class="headerlink" title="代码随想录_数组02"></a>代码随想录_数组02</h1><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>[题目链接](<a href="https://leetcode.cn/problems/remove-element/">力扣 (leetcode.cn)</a>)</p>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len = removeElement(nums, val);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p>
<p>示例 1：</p>
<p>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。<br>示例 2：</p>
<p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br>输出：5, nums = [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="https://www.bilibili.com/video/BV12A4y1Z7LP">本题B站视频讲解(opens new window)</a></p>
<p>有的同学可能说了，多余的元素，删掉不就得了。</p>
<p><strong>要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</p>
<p>删除过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrc7x9tjg30du09m1ky.gif" alt="27.移除元素-暴力解法"></p>
<p>很明显暴力解法的时间复杂度是O(n^2)，这道题目暴力解法在leetcode上是可以过的。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 时间复杂度：O(n^2)</span><br><span class="line">// 空间复杂度：O(1)</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) {</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) {</span><br><span class="line">            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位</span><br><span class="line">                for (int j = i + 1; j &lt; size; j++) {</span><br><span class="line">                    nums[j - 1] = nums[j];</span><br><span class="line">                }</span><br><span class="line">                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span><br><span class="line">                size--; // 此时数组的大小-1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return size;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p>很多同学这道题目做的很懵，就是不理解 快慢指针究竟都是什么含义，所以一定要明确含义，后面的思路就更容易理解了。</p>
<p>删除过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p>
<p>很多同学不了解</p>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<p>后续都会一一介绍到，本题代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">	<span class="keyword">public</span> in <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span> [] nums,<span class="type">int</span> val)</span> {</span><br><span class="line">	<span class="comment">//快指针</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(fastIndex&lt;nums.length) {</span><br><span class="line">		<span class="keyword">if</span>(nums[fastIndex] != val) {</span><br><span class="line">            nums[slowIndex++] = nums[fastIndex]</span><br><span class="line">        }</span><br><span class="line">		fastIndex++;</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">return</span> slowIndex;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_代码随想列题03</title>
    <url>/2022/07/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%8403/</url>
    <content><![CDATA[<html><head></head><body><h1 id="代码随想录-数组03"><a href="#代码随想录-数组03" class="headerlink" title="代码随想录_数组03"></a>代码随想录_数组03</h1><h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接(opens new window)</a></p>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了易于大家理解，我还特意录制了视频，<a href="https://www.bilibili.com/video/BV1QB4y1D7ep">本题视频讲解(opens new window)</a></p>
<h3 id="暴力排序"><a href="#暴力排序" class="headerlink" title="暴力排序"></a>暴力排序</h3><p>最直观的想法，莫过于：每个数平方之后，排个序，美滋滋，代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) {</span><br><span class="line">        for (int i = 0; i &lt; A.size(); i++) {</span><br><span class="line">            A[i] *= A[i];</span><br><span class="line">        }</span><br><span class="line">        sort(A.begin(), A.end()); // 快速排序</span><br><span class="line">        return A;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>这个时间复杂度是 O(n + nlogn)， 可以说是O(nlogn)的时间复杂度，但为了和下面双指针法算法时间复杂度有鲜明对比，我记为 O(n + nlog n)。</p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p>
<p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p>
<p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p>
<p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p>
<p>如动画所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="img"></p>
<p>不难写出如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) {</span><br><span class="line">		<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] new_nums =<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">new_index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(left &lt;= right) {</span><br><span class="line">			<span class="keyword">if</span>(nums[left]*nums[left] &lt; nums[right]*nums[right]) {</span><br><span class="line">                new_nums[new_index++] = nums[left]*nums[left];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                new_nums[new_index++] = nums[right]*nums[right];</span><br><span class="line">            }</span><br><span class="line">		}</span><br><span class="line">       <span class="keyword">return</span> new_nums;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时的时间复杂度为O(n)，相对于暴力排序的解法O(n + nlog n)还是提升不少的。</p>
<p><strong>这里还是说一下，大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。</strong></p>
<p>做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，</p>
<p>一样的代码多提交几次可能就击败百分之百了…..</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_代码随想列题04</title>
    <url>/2022/07/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%8404/</url>
    <content><![CDATA[<html><head></head><body><h1 id="代码随想录-数组04"><a href="#代码随想录-数组04" class="headerlink" title="代码随想录_数组04"></a>代码随想录_数组04</h1><h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接(opens new window)</a></p>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>为了易于大家理解，我特意录制了B站视频<a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">拿下滑动窗口！ | LeetCode 209 长度最小的子数组(opens new window)</a></p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {</span><br><span class="line">        int result = INT32_MAX; // 最终的结果</span><br><span class="line">        int sum = 0; // 子序列的数值之和</span><br><span class="line">        int subLength = 0; // 子序列的长度</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) { // 设置子序列起点为i</span><br><span class="line">            sum = 0;</span><br><span class="line">            for (int j = i; j &lt; nums.size(); j++) { // 设置子序列终止位置为j</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                if (sum &gt;= s) { // 一旦发现子序列和超过了s，更新result</span><br><span class="line">                    subLength = j - i + 1; // 取子序列的长度</span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br><span class="line">        return result == INT32_MAX ? 0 : result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p>
<p>那么滑动窗口如何用一个for循环来完成这个操作呢。</p>
<p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p>
<p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p>
<p>此时难免再次陷入 暴力解法的怪圈。</p>
<p>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p>
<p>那么问题来了， 滑动窗口的起始位置如何移动呢？</p>
<p>这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p>
<p>最后找到 4，3 是最短距离。</p>
<p>其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>
<p>在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p>
<p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210312160441942.png" alt="leetcode_209"></p>
<p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> {</span><br><span class="line">    	<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min_length</span> <span class="operator">=</span> Interge.MAX_VALUE;</span><br><span class="line">    	<span class="keyword">while</span>(fastIndex&lt;nums.length) {</span><br><span class="line">            sum += nums[fastIndex];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s){</span><br><span class="line">                sum -= nums[slowIndex++];</span><br><span class="line">               </span><br><span class="line">            }</span><br><span class="line">            min_length = min_length &lt; fastIndex - slowIndex+<span class="number">1</span> ? min_length:fastIndex - slowIndex+<span class="number">1</span>;</span><br><span class="line">    		fastIndex++;</span><br><span class="line">    	}</span><br><span class="line">        <span class="type">return</span> <span class="variable">min_length</span> <span class="operator">=</span>= MAX_VALUE?<span class="number">0</span>:min_length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><ul>
<li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串(opens new window)</a></li>
</ul>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>用队列实现栈_栈01</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9701/</url>
    <content><![CDATA[<html><head></head><body><h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">力扣题目链接(opens new window)</a></p>
<p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<p>注意:</p>
<ul>
<li>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>（这里要强调是单向队列）</p>
<p>有的同学可能疑惑这种题目有什么实际工程意义，<strong>其实很多算法题目主要是对知识点的考察和教学意义远大于其工程实践的意义，所以面试题也是这样！</strong></p>
<p>刚刚做过<a href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html">栈与队列：我用栈来实现队列怎么样？ (opens new window)</a>的同学可能依然想着用一个输入队列，一个输出队列，就可以模拟栈的功能，仔细想一下还真不行！</p>
<p><strong>队列模拟栈，其实一个队列就够了</strong>，那么我们先说一说两个队列来实现栈的思路。</p>
<p><strong>队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。</strong></p>
<p>所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。</p>
<p>但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用又来备份的！</p>
<p>如下面动画所示，<strong>用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用</strong>，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。</p>
<p>模拟的队列执行语句如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);        </span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 注意弹出的操作       </span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">3</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">4</span>);       </span><br><span class="line">queue.<span class="built_in">pop</span>();  <span class="comment">// 注意弹出的操作    </span></span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">empty</span>();    </span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://code-thinking.cdn.bcebos.com/gifs/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="225.用队列实现栈"></p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue1; <span class="comment">// 和栈中保持一样元素的队列</span></span><br><span class="line">    Queue&lt;Integer&gt; queue2; <span class="comment">// 辅助队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">    	queue1.push(x);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que1.isEmpty()) {</span><br><span class="line">            temp = que1.poll();</span><br><span class="line">            <span class="keyword">if</span>(!que1.isEmpty()) {</span><br><span class="line">                que2.offer(temp);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!que2.isEmpty()) {</span><br><span class="line">            que1.offer(que2.poll());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que1.isEmpty()) {</span><br><span class="line">            temp = que1.peek();</span><br><span class="line">            <span class="keyword">if</span>(!que1.isEmpty()) {</span><br><span class="line">                que2.offer(temp);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!que2.isEmpty()) {</span><br><span class="line">            que1.offer(que2.poll());</span><br><span class="line">        }</span><br><span class="line">        que1.offer(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty() &amp;&amp; queue2.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>用栈实现队列_栈02</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9702/</url>
    <content><![CDATA[<html><head></head><body><h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣题目链接(opens new window)</a></p>
<p>使用栈实现队列的下列操作：</p>
<p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p>
<p>示例:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> <span class="built_in">MyQueue</span>();</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">peek</span>();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">empty</span>(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></tbody></table></figure>

<p>说明:</p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道模拟题，不涉及到具体算法，考察的就是对栈和队列的掌握程度。</p>
<p>使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈<strong>一个输入栈，一个输出栈</strong>，这里要注意输入栈和输出栈的关系。</p>
<p>下面动画模拟以下队列的执行过程如下：</p>
<p>执行语句：<br>queue.push(1);<br>queue.push(2);<br>queue.pop(); <strong>注意此时的输出栈的操作</strong><br>queue.push(3);<br>queue.push(4);<br>queue.pop();<br>queue.pop();<strong>注意此时的输出栈的操作</strong><br>queue.pop();<br>queue.empty();</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2"></p>
<p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p>
<p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p>
<p>在代码实现的时候，会发现pop() 和 peek()两个函数功能类似，代码实现上也是类似的，可以思考一下如何把代码抽象一下。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>可以看出peek()的实现，直接复用了pop()。</p>
<p>再多说一些代码开发上的习惯问题，在工业级别代码开发中，最忌讳的就是 实现一个类似的函数，直接把代码粘过来改一改就完事了。</p>
<p>这样的项目代码会越来越乱，<strong>一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！（踩过坑的人自然懂）</strong></p>
<p>工作中如果发现某一个功能自己要经常用，同事们可能也会用到，自己就花点时间把这个功能抽象成一个好用的函数或者工具类，不仅自己方便，也方面了同事们。</p>
<p>同事们就会逐渐认可你的工作态度和工作能力，自己的口碑都是这么一点一点积累起来的！在同事圈里口碑起来了之后，你就发现自己走上了一个正循环，以后的升职加薪才少不了你！哈哈哈</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> {</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">    	stackIn.push(val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">    	<span class="keyword">if</span>(!stackOut.isEmpty()) {</span><br><span class="line">    		stackOut.pop();</span><br><span class="line">    	} <span class="keyword">else</span> {</span><br><span class="line">    		<span class="keyword">while</span>(!stackIn.isEmpty()) {</span><br><span class="line">    			stackOut.push(stackIn.pop());</span><br><span class="line">    		}</span><br><span class="line">    		stackOut.pop();</span><br><span class="line">    	}</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">    	<span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">    	<span class="keyword">if</span>(!stackOut.isEmpty()) <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    	<span class="keyword">while</span>(!stackIn.isEmpty()) {</span><br><span class="line">    			stackOut.push(stackIn.pop());</span><br><span class="line">    		}</span><br><span class="line">    	<span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号_栈03</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9703/</url>
    <content><![CDATA[<html><head></head><body><h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">力扣题目链接(opens new window)</a></p>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p>示例 1:</p>
<ul>
<li>输入: “()”</li>
<li>输出: true</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: “()[]{}”</li>
<li>输出: true</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: “(]”</li>
<li>输出: false</li>
</ul>
<p>示例 4:</p>
<ul>
<li>输入: “([)]”</li>
<li>输出: false</li>
</ul>
<p>示例 5:</p>
<ul>
<li>输入: “{[]}”</li>
<li>输出: true</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p><strong>括号匹配是使用栈解决的经典问题。</strong></p>
<p>题意其实就像我们在写代码的过程中，要求括号的顺序是一样的，有左括号，相应的位置必须要有右括号。</p>
<p>如果还记得编译原理的话，编译器在 词法分析的过程中处理括号、花括号等这个符号的逻辑，也是使用了栈这种数据结构。</p>
<p>再举个例子，linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">cd a/b/c/../../</span><br></pre></td></tr></tbody></table></figure>

<p>1</p>
<p>这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用（其实可以出一道相应的面试题了）</p>
<p>所以栈在计算机领域中应用是非常广泛的。</p>
<p>有的同学经常会想学的这些数据结构有什么用，也开发不了什么软件，大多数同学说的软件应该都是可视化的软件例如APP、网站之类的，那都是非常上层的应用了，底层很多功能的实现都是基础的数据结构和算法。</p>
<p><strong>所以数据结构与算法的应用往往隐藏在我们看不到的地方！</strong></p>
<p>这里我就不过多展开了，先来看题。</p>
<h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><p>由于栈结构的特殊性，非常适合做对称匹配类的题目。</p>
<p>首先要弄清楚，字符串里的括号不匹配有几种情况。</p>
<p><strong>一些同学，在面试中看到这种题目上来就开始写代码，然后就越写越乱。</strong></p>
<p>建议要写代码之前要分析好有哪几种不匹配的情况，如果不动手之前分析好，写出的代码也会有很多问题。</p>
<p>先来分析一下 这里有三种不匹配的情况，</p>
<ol>
<li>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。 <img src="https://img-blog.csdnimg.cn/2020080915505387.png" alt="括号匹配1"></li>
<li>第二种情况，括号没有多余，但是 括号的类型没有匹配上。 <img src="https://img-blog.csdnimg.cn/20200809155107397.png" alt="括号匹配2"></li>
<li>第三种情况，字符串里右方向的括号多余了，所以不匹配。 <img src="https://img-blog.csdnimg.cn/20200809155115779.png" alt="括号匹配3"></li>
</ol>
<p>我们的代码只要覆盖了这三种不匹配的情况，就不会出问题，可以看出 动手之前分析好题目的重要性。</p>
<p>动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号"></p>
<p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</p>
<p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</p>
<p>第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false</p>
<p>那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。</p>
<p>分析完之后，代码其实就比较好写了，</p>
<p>但还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> {</span><br><span class="line">    	 Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    	 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) {</span><br><span class="line">    	 	<span class="keyword">if</span>(s.charAt(i) == <span class="string">'{'</span>) {</span><br><span class="line">    	 		stack.add(<span class="string">'}'</span>);</span><br><span class="line">    	 	} <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'['</span>) {</span><br><span class="line">    	 		stack.add(<span class="string">']'</span>);</span><br><span class="line">    	 	} <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>) {</span><br><span class="line">    	 		stack.add(<span class="string">')'</span>);</span><br><span class="line">    	 	} <span class="keyword">else</span> <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;s.charAt(i) != stack.peek()) {</span><br><span class="line">    	 		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">            	stack.pop();</span><br><span class="line">            }</span><br><span class="line">    	 }</span><br><span class="line">    	 <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    	 </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰表达式求值_栈05</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9705/</url>
    <content><![CDATA[<html><head></head><body><h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">力扣题目链接(opens new window)</a></p>
<p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：</p>
<p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：</p>
<ul>
<li>输入: [“2”, “1”, “+”, “3”, “ * “]</li>
<li>输出: 9</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入: [“4”, “13”, “5”, “/“, “+”]</li>
<li>输出: 6</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</li>
</ul>
<p>示例 3：</p>
<ul>
<li><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “ * “, “/“, “ * “, “17”, “+”, “5”, “+”]</p>
</li>
<li><p>输出: 22</p>
</li>
<li><p>解释:该算式转化为常见的中缀算术表达式为：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">((10 * (6 / ((9 + 3) * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5     </span><br><span class="line">= ((10 * 0) + 17) + 5     </span><br><span class="line">= (0 + 17) + 5    </span><br><span class="line">= 17 + 5    </span><br><span class="line">= 22    </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</p>
<p>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</p>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在上一篇文章中<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047.删除字符串中的所有相邻重复项 (opens new window)</a>提到了 递归就是用栈来实现的。</p>
<p>所以<strong>栈与递归之间在某种程度上是可以转换的！</strong> 这一点我们在后续讲解二叉树的时候，会更详细的讲解到。</p>
<p>那么来看一下本题，<strong>其实逆波兰表达式相当于是二叉树中的后序遍历</strong>。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。</p>
<p>但我们没有必要从二叉树的角度去解决这个问题，只要知道逆波兰表达式是用后续遍历的方式把二叉树序列化了，就可以了。</p>
<p>在进一步看，本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么<strong>这岂不就是一个相邻字符串消除的过程，和<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047.删除字符串中的所有相邻重复项 (opens new window)</a>中的对对碰游戏是不是就非常像了。</strong></p>
<p>如动画所示： <img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p>
<p>相信看完动画大家应该知道，这和<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047. 删除字符串中的所有相邻重复项 (opens new window)</a>是差不错的，只不过本题不要相邻元素做消除了，而是做运算！</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> {</span><br><span class="line">    	Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    	<span class="keyword">for</span>(String s:tokens) {</span><br><span class="line">    		<span class="keyword">if</span>(s.equals(<span class="string">"+"</span>)) {</span><br><span class="line">    			deque.add(deque.pop()+deque.pop());</span><br><span class="line">    		} <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">"-"</span>)) {</span><br><span class="line">                deque.add(-(deque.pop()-deque.pop()));</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">"*"</span>)) {</span><br><span class="line">                deque.add(deque.pop()*deque.pop());</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">"/"</span>)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">                deque.add(B/A);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                deque.add(Integer.valueOf(s));</span><br><span class="line">            }</span><br><span class="line">    	}</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>我们习惯看到的表达式都是中缀表达式，因为符合我们的习惯，但是中缀表达式对于计算机来说就不是很友好了。</p>
<p>例如：4 + 13 / 5，这就是中缀表达式，计算机从左到右去扫描的话，扫到13，还要判断13后面是什么运算法，还要比较一下优先级，然后13还和后面的5做运算，做完运算之后，还要向前回退到 4 的位置，继续做加法，你说麻不麻烦！</p>
<p>那么将中缀表达式，转化为后缀表达式之后：[“4”, “13”, “5”, “/“, “+”] ，就不一样了，计算机可以利用栈里顺序处理，不需要考虑优先级了。也不用回退了， <strong>所以后缀表达式对计算机来说是非常友好的。</strong></p>
<p>可以说本题不仅仅是一道好题，也展现出计算机的思考方式。</p>
<p>在1970年代和1980年代，惠普在其所有台式和手持式计算器中都使用了RPN（后缀表达式），直到2020年代仍在某些模型中使用了RPN。</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>删除字符串中的所有相邻重复项_栈04</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9704/</url>
    <content><![CDATA[<html><head></head><body><h1 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h1><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">力扣题目链接(opens new window)</a></p>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<ul>
<li>输入：”abbaca”</li>
<li>输出：”ca”</li>
<li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S 仅由小写英文字母组成。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>这道题目就像是我们玩过的游戏对对碰，如果相同的元素放在挨在一起就要消除。</p>
<p>可能我们在玩游戏的时候感觉理所当然应该消除，但程序又怎么知道该如果消除呢，特别是消除之后又有新的元素可能挨在一起。</p>
<p>此时游戏的后端逻辑就可以用一个栈来实现（我没有实际考察对对碰或者爱消除游戏的代码实现，仅从原理上进行推断）。</p>
<p>游戏开发可能使用栈结构，编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，例如：</p>
<p><img src="https://img-blog.csdnimg.cn/20210309093252776.png" alt="1047.删除字符串中的所有相邻重复项"></p>
<p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是<code>Segmentation fault</code>（当然不是所有的<code>Segmentation fault</code> 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。</p>
<p>而且<strong>在企业项目开发中，尽量不要使用递归！</strong>在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong></p>
<p>好了，题外话over，我们进入正题。</p>
<h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>本题要删除相邻相同元素，其实也是匹配问题，相同左元素相当于左括号，相同右元素就是相当于右括号，匹配上了就删除。</p>
<p>那么再来看一下本题：可以把字符串顺序放到一个栈中，然后如果相同的话 栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。</p>
<p>如动画所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047.删除字符串中的所有相邻重复项"></p>
<p>从栈中弹出剩余元素，此时是字符串ac，因为从栈里弹出的元素是倒序的，所以在对字符串进行反转一下，就得到了最终的结果。</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String S)</span> {</span><br><span class="line">        <span class="comment">//ArrayDeque会比LinkedList在除了删除元素这一点外会快一点</span></span><br><span class="line">        <span class="comment">//参考：https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist</span></span><br><span class="line">        ArrayDeque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:arr) {</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; c == deque.peek()) {</span><br><span class="line">                deque.pop();</span><br><span class="line">            }</span><br><span class="line">            deque.add(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()) {</span><br><span class="line">            str = deque.pop() + str;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串_字符串01</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9707/</url>
    <content><![CDATA[<html><head></head><body></body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值_队列06</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9706/</url>
    <content><![CDATA[<html><head></head><body><h1 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">力扣题目链接(opens new window)</a></p>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>进阶：</p>
<p>你能在线性时间复杂度内解决此题吗？</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt="img"></p>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 10^5</li>
<li>-10^4 &lt;= nums[i] &lt;= 10^4</li>
<li>1 &lt;= k &lt;= nums.length</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是使用单调队列的经典题目。</p>
<p>难点是如何求一个区间里的最大值呢？ （这好像是废话），暴力一下不就得了。</p>
<p>暴力方法，遍历一遍的过程中每次从窗口中在找到最大的数值，这样很明显是$O(n × k)$的算法。</p>
<p>有的同学可能会想用一个大顶堆（优先级队列）来存放这个窗口里的k个数字，这样就可以知道最大的最大值是多少了， <strong>但是问题是这个窗口是移动的，而大顶堆每次只能弹出最大值，我们无法移除其他数值，这样就造成大顶堆维护的不是滑动窗口里面的数值了。所以不能用大顶堆。</strong></p>
<p>此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p>
<p>这个队列应该长这个样子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。</p>
<p>这么个队列香不香，要是有现成的这种数据结构是不是更香了！</p>
<p><strong>可惜了，没有！ 我们需要自己实现这么个队列。</strong></p>
<p>然后在分析一下，队列里的元素一定是要排序的，而且要最大值放在出队口，要不然怎么知道最大值呢。</p>
<p>但如果把窗口里的元素都放进队列里，窗口移动的时候，队列需要弹出元素。</p>
<p>那么问题来了，已经排序之后的队列 怎么能把窗口要移除的元素（这个元素可不一定是最大值）弹出呢。</p>
<p>大家此时应该陷入深思…..</p>
<p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。</strong></p>
<p>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来一个单调队列</strong></p>
<p><strong>不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。</strong></p>
<p>来看一下单调队列如何维护队列里的元素。</p>
<p>动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif" alt="239.滑动窗口最大值"></p>
<p>对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。</p>
<p>此时大家应该怀疑单调队列里维护着{5, 4} 怎么配合窗口经行滑动呢？</p>
<p>设计单调队列的时候，pop，和push操作要保持如下规则：</p>
<ol>
<li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li>
<li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li>
</ol>
<p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p>
<p>为了更直观的感受到单调队列的工作过程，以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2"></p>
<p>那么我们用什么数据结构来实现这个单调队列呢？</p>
<p>使用deque最为合适，在文章<a href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">栈与队列：来看看栈和队列不为人知的一面 (opens new window)</a>中，我们就提到了常用的queue在没有指定容器的情况下，deque就是默认底层容器。</p>
<p>基于刚刚说过的单调队列pop和push的规则，代码不难实现，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> { <span class="comment">//单调队列（从大到小）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) {</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) {</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>这样我们就用deque实现了一个单调队列，接下来解决滑动窗口最大值的问题就很简单了，直接看代码吧。</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Class MyQueue {</span><br><span class="line">	Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span>(!que.isEmpty() &amp;&amp; val == que.peek()) {</span><br><span class="line">            que.poll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty() &amp;&amp; val &gt; que.getLast()) {</span><br><span class="line">            que.removeLast();</span><br><span class="line">        }</span><br><span class="line">        que.add(val);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="comment">// 初始化队列</span></span><br><span class="line">        <span class="type">Myqueue</span> <span class="variable">myque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myqueue</span>();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) {</span><br><span class="line">            myque.add(nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        res[count++] = myque.peek();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.length;i++) {</span><br><span class="line">            myque.poll(nums[i-k]);</span><br><span class="line">            myque.add(nums[i]);</span><br><span class="line">            res[count++] = myque.peek();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>理论基础_贪心01</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8301/</url>
    <content><![CDATA[<html><head></head><body><h1 id="关于贪心算法，你该了解这些！"><a href="#关于贪心算法，你该了解这些！" class="headerlink" title="关于贪心算法，你该了解这些！"></a>关于贪心算法，你该了解这些！</h1><p>题目分类大纲如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png" alt="贪心算法大纲"></p>
<h2 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="#什么是贪心"></a><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%AA%E5%BF%83">#</a>什么是贪心</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p>
<p>这么说有点抽象，来举一个例子：</p>
<p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p>
<p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p>
<p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p>
<p>再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。</p>
<h2 id="贪心的套路（什么时候用贪心）"><a href="#贪心的套路（什么时候用贪心）" class="headerlink" title="#贪心的套路（什么时候用贪心）"></a><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E8%B4%AA%E5%BF%83%E7%9A%84%E5%A5%97%E8%B7%AF-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E8%B4%AA%E5%BF%83">#</a>贪心的套路（什么时候用贪心）</h2><p>很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。</p>
<p><strong>说实话贪心算法并没有固定的套路</strong>。</p>
<p>所以唯一的难点就是如何通过局部最优，推出整体最优。</p>
<p>那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？</p>
<p><strong>不好意思，也没有！</strong> 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p>
<p>有同学问了如何验证可不可以用贪心算法呢？</p>
<p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p>
<p>可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。</p>
<p>一般数学证明有如下两种方法：</p>
<ul>
<li>数学归纳法</li>
<li>反证法</li>
</ul>
<p>看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。</p>
<p><strong>面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了</strong>。</p>
<p>举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。</p>
<p>虽然这个例子很极端，但可以表达这么个意思：<strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p>
<p><strong>例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！</strong></p>
<p>所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，<strong>因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！</strong></p>
<p><strong>那么刷题的时候什么时候真的需要数学推导呢？</strong></p>
<p>例如这道题目：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">链表：环找到了，那入口呢？ (opens new window)</a>，这道题不用数学推导一下，就找不出环的起始位置，想试一下就不知道怎么试，这种题目确实需要数学简单推导一下。</p>
<h2 id="贪心一般解题步骤"><a href="#贪心一般解题步骤" class="headerlink" title="#贪心一般解题步骤"></a><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E8%B4%AA%E5%BF%83%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4">#</a>贪心一般解题步骤</h2><p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<p>其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>本篇给出了什么是贪心以及大家关心的贪心算法固定套路。</p>
<p><strong>不好意思了，贪心没有套路，说白了就是常识性推导加上举反例</strong>。</p>
<p>最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。</p>
<p>本篇没有配图，其实可以找一些动漫周边或者搞笑的图配一配（符合大多数公众号文章的作风），但这不是我的风格，所以本篇文字描述足以！</p>
<h1 id="重点"><a href="#重点" class="headerlink" title="重点:"></a>重点:</h1><p>常识性推导加上举反例.</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>分发饼干_贪心02</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8302/</url>
    <content><![CDATA[<html><head></head><body><h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h1><p><a href="https://leetcode.cn/problems/assign-cookies/">力扣题目链接(opens new window)</a></p>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>示例 1:</p>
<ul>
<li>输入: g = [1,2,3], s = [1,1]</li>
<li>输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: g = [1,2], s = [1,2,3]</li>
<li>输出: 2</li>
<li>解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= g.length &lt;= 3 * 10^4</li>
<li>0 &lt;= s.length &lt;= 3 * 10^4</li>
<li>1 &lt;= g[i], s[j] &lt;= 2^31 - 1</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p>
<p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p>
<p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p>
<p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123161809624.png" alt="455.分发饼干"></p>
<p>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g,<span class="type">int</span>[] s)</span> {</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=g.length - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i++) {</span><br><span class="line">        <span class="keyword">if</span>(s[index] &gt;= g[i]) index--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s.length - <span class="number">1</span> - index;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>摆动序列_贪心03</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8303/</url>
    <content><![CDATA[<html><head></head><body><h1 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h1><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">力扣题目链接(opens new window)</a></p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>示例 1:</p>
<ul>
<li>输入: [1,7,4,9,2,5]</li>
<li>输出: 6</li>
<li>解释: 整个序列均为摆动序列。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: [1,17,5,10,13,15,10,5,16,8]</li>
<li>输出: 7</li>
<li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: [1,2,3,4,5,6,7,8,9]</li>
<li>输出: 2</li>
</ul>
<h2 id="思路1（贪心解法）"><a href="#思路1（贪心解法）" class="headerlink" title="思路1（贪心解法）"></a>思路1（贪心解法）</h2><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>相信这么一说吓退不少同学，这要求最大摆动序列又可以修改数组，这得如何修改呢？</p>
<p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p>
<p>用示例二来举例，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124174327597.png" alt="376.摆动序列"></p>
<p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p>
<p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p>
<p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p>
<p>（为方便表述，以下说的峰值都是指局部峰值）</p>
<p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p>
<p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong>。</p>
<p>本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。</p>
<p>例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</p>
<p>所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124174357612.png" alt="376.摆动序列1"></p>
<p>针对以上情形，result初始为1（默认最右面有一个峰值），此时curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">	<span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">return</span> nums.length;</span><br><span class="line">	}</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">prediff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">curdiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length - <span class="number">1</span>;i++) {</span><br><span class="line">		curdiff = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">		<span class="keyword">if</span>(curdiff &gt; <span class="number">0</span> &amp;&amp; prediff &lt;=<span class="number">0</span> || curdiff &lt; <span class="number">0</span> &amp;&amp; prediff &gt;= <span class="number">0</span>) {</span><br><span class="line">			count++;</span><br><span class="line">           prediff = curdiff;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏_贪心04</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8304/</url>
    <content><![CDATA[<html><head></head><body><h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h1><p><a href="https://leetcode.cn/problems/jump-game/">力扣题目链接(opens new window)</a></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p>示例 1:</p>
<ul>
<li>输入: [2,3,1,1,4]</li>
<li>输出: true</li>
<li>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: [3,2,1,0,4]</li>
<li>输出: false</li>
<li>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？</p>
<p>其实跳几步无所谓，关键在于可跳的覆盖范围！</p>
<p>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p>
<p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p>
<p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p>
<p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p>
<p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p>
<p>局部最优推出全局最优，找不出反例，试试贪心！</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p>
<p>i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。</p>
<p>而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。</p>
<p>如果cover大于等于了终点下标，直接return true就可以了。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">	<span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;nums.length;i++) {</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + i &gt; cover) cover = nums[i] + i;</span><br><span class="line">        <span class="keyword">if</span>(cover &gt;= nums.length -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏||_贪心05</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8305/</url>
    <content><![CDATA[<html><head></head><body><h1 id="45-跳跃游戏II"><a href="#45-跳跃游戏II" class="headerlink" title="45.跳跃游戏II"></a>45.跳跃游戏II</h1><p><a href="https://leetcode.cn/problems/jump-game-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例:</p>
<ul>
<li>输入: [2,3,1,1,4]</li>
<li>输出: 2</li>
<li>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</li>
</ul>
<p>说明: 假设你总是可以到达数组的最后一个位置。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>本题相对于<a href="https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html">55.跳跃游戏 (opens new window)</a>还是难了不少。</p>
<p>但思路是相似的，还是要看最大覆盖范围。</p>
<p>本题要计算最小步数，那么就要想清楚什么时候步数才一定要加一呢？</p>
<p>贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。</p>
<p>思路虽然是这样，但在写代码的时候还不能真的就能跳多远跳远，那样就不知道下一步最远能跳到哪里了。</p>
<p><strong>所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！</strong></p>
<p><strong>这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖</strong>。</p>
<p>如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201201232309103.png" alt="45.跳跃游戏II"></p>
<p><strong>图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）</strong></p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="#方法一"></a><a href="https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html#%E6%96%B9%E6%B3%95%E4%B8%80">#</a>方法一</h2><p>从图中可以看出来，就是移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。</p>
<p>这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p>
<ul>
<li>如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。</li>
<li>如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。</li>
</ul>
<h1 id="Java01代码如下："><a href="#Java01代码如下：" class="headerlink" title="Java01代码如下："></a>Java01代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">curCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">NextCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++) {</span><br><span class="line">        NextCover = Math.max(nums[i]+i,NextCover);</span><br><span class="line">        <span class="keyword">if</span>(NextCover &gt;= nums.length - <span class="number">1</span>) {</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(curCover == i) {</span><br><span class="line">            <span class="keyword">if</span>(curCover != nums.length -<span class="number">1</span>) {</span><br><span class="line">                count++;</span><br><span class="line">                curCover = NextCover;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>依然是贪心，思路和方法一差不多，代码可以简洁一些。</p>
<p><strong>针对于方法一的特殊情况，可以统一处理</strong>，即：移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。</p>
<p>想要达到这样的效果，只要让移动下标，最大只能移动到nums.size - 2的地方就可以了。</p>
<p>因为当移动下标指向nums.size - 2时：</p>
<ul>
<li>如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图： <img src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2"></li>
<li>如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。如图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201201232338693.png" alt="45.跳跃游戏II1"></p>
<h1 id="Java02代码如下："><a href="#Java02代码如下：" class="headerlink" title="Java02代码如下："></a>Java02代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">curCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">NextCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++) {</span><br><span class="line">        NextCover = Math.max(NextCover,nums[i] + i);</span><br><span class="line">        <span class="keyword">if</span>(curCover == i) {</span><br><span class="line">            count++;</span><br><span class="line">            curCover = NextCover;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>加油站_贪心06</title>
    <url>/2022/08/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8306/</url>
    <content><![CDATA[<html><head></head><body><h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h1><p><a href="https://leetcode.cn/problems/gas-station/">力扣题目链接(opens new window)</a></p>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明:</p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p>示例 1: 输入:</p>
<ul>
<li>gas = [1,2,3,4,5]</li>
<li>cost = [3,4,5,1,2]</li>
</ul>
<p>输出: 3 解释:</p>
<ul>
<li>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</li>
<li>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</li>
<li>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</li>
<li>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</li>
<li>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</li>
<li>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</li>
<li>因此，3 可为起始索引。</li>
</ul>
<p>示例 2: 输入:</p>
<ul>
<li>gas = [2,3,4]</li>
<li>cost = [3,4,3]</li>
<li>输出: -1</li>
<li>解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油。开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油。开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油。你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。</li>
</ul>
<h2 id="暴力方法"><a href="#暴力方法" class="headerlink" title="#暴力方法"></a><a href="https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html#%E6%9A%B4%E5%8A%9B%E6%96%B9%E6%B3%95">#</a>暴力方法</h2><p>暴力的方法很明显就是$O(n^2)$的，遍历每一个加油站为起点的情况，模拟一圈。</p>
<p>如果跑了一圈，中途没有断油，而且最后油量大于等于0，说明这个起点是ok的。</p>
<p>暴力的方法思路比较简单，但代码写起来也不是很容易，关键是要模拟跑一圈的过程。</p>
<p><strong>for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！</strong></p>
<p>C++代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cost.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> rest = gas[i] - cost[i]; <span class="comment">// 记录剩余油量</span></span><br><span class="line">            <span class="type">int</span> index = (i + <span class="number">1</span>) % cost.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (rest &gt; <span class="number">0</span> &amp;&amp; index != i) { <span class="comment">// 模拟以i为起点行驶一圈</span></span><br><span class="line">                rest += gas[index] - cost[index];</span><br><span class="line">                index = (index + <span class="number">1</span>) % cost.<span class="built_in">size</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果以i为起点跑一圈，剩余油量&gt;=0，返回该起始位置</span></span><br><span class="line">            <span class="keyword">if</span> (rest &gt;= <span class="number">0</span> &amp;&amp; index == i) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1</li>
</ul>
<h2 id="贪心算法（方法二）"><a href="#贪心算法（方法二）" class="headerlink" title="贪心算法（方法二）"></a>贪心算法（方法二）</h2><p>可以换一个思路，首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p>
<p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p>
<p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p>
<p>如图： <img src="https://img-blog.csdnimg.cn/20201213162821958.png" alt="134.加油站"></p>
<p>那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现更大的负数？</p>
<p>如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。</p>
<p>而且j之前出现了多少负数，j后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）。</p>
<p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p>
<p>局部最优可以推出全局最优，找不出反例，试试贪心！</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> {</span><br><span class="line">	<span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">TotalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;gas.length;i++) {</span><br><span class="line">		curSum += gas[i] - cost[i];</span><br><span class="line">		TotalSum += gas[i] - cost[i];</span><br><span class="line">		<span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) {</span><br><span class="line">			curSum = <span class="number">0</span>;</span><br><span class="line">			start = (i + <span class="number">1</span>)%gas.length;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(TotalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> start;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>分发糖果_贪心07</title>
    <url>/2022/08/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8307/</url>
    <content><![CDATA[<html><head></head><body><h1 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h1><p><a href="https://leetcode.cn/problems/candy/">力扣题目链接(opens new window)</a></p>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li>
</ul>
<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p>示例 1:</p>
<ul>
<li>输入: [1,0,2]</li>
<li>输出: 5</li>
<li>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: [1,2,2]</li>
<li>输出: 4</li>
<li>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p>
<p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p>
<p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p>
<p>局部最优可以推出全局最优。</p>
<p>如果ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个，所以贪心：candyVec[i] = candyVec[i - 1] + 1</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从前向后</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201117114916878.png" alt="135.分发糖果"></p>
<p>再确定左孩子大于右孩子的情况（从后向前遍历）</p>
<p>遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？</p>
<p>因为如果从前向后遍历，根据 ratings[i + 1] 来确定 ratings[i] 对应的糖果，那么每次都不能利用上前一次的比较结果了。</p>
<p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p>
<p>如果 ratings[i] &gt; ratings[i + 1]，此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。</p>
<p>那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<p>局部最优可以推出全局最优。</p>
<p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201117115658791.png" alt="135.分发糖果1"></p>
<p>所以该过程代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从后向前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) {</span><br><span class="line">        candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p>
<p>那么本题我采用了两次贪心的策略：</p>
<ul>
<li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li>
<li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li>
</ul>
<p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> {</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">    Arrays.fill(res,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先从左往右边遍历 右边比左边大 就有改动</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;ratings.length;i++) {</span><br><span class="line">        <span class="keyword">if</span>(ratings[i] &gt; ratings[i-<span class="number">1</span>]) {</span><br><span class="line">            res[i] = res[i] + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从右向左遍历 如果左边大于右边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ratings.length - <span class="number">1</span>;j&gt;<span class="number">0</span>;j--) {</span><br><span class="line">        <span class="keyword">if</span>(ratings[j-<span class="number">1</span>] &gt; ratings[j]) {</span><br><span class="line">            <span class="keyword">if</span>(res[j-<span class="number">1</span>] &gt; res[j] + <span class="number">1</span>) {</span><br><span class="line">                </span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                res[j-<span class="number">1</span>] = res[j] + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(res).sum();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>用最少数量的箭引爆气球_贪心08</title>
    <url>/2022/08/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8308/</url>
    <content><![CDATA[<html><head></head><body><h1 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h1><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接(opens new window)</a></p>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>示例 1：</p>
<ul>
<li>输入：points = [[10,16],[2,8],[1,6],[7,12]]</li>
<li>输出：2</li>
<li>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：points = [[1,2],[3,4],[5,6],[7,8]]</li>
<li>输出：4</li>
</ul>
<p>示例 3：</p>
<ul>
<li>输入：points = [[1,2],[2,3],[3,4],[4,5]]</li>
<li>输出：2</li>
</ul>
<p>示例 4：</p>
<ul>
<li>输入：points = [[1,2]]</li>
<li>输出：1</li>
</ul>
<p>示例 5：</p>
<ul>
<li>输入：points = [[2,3],[2,3]]</li>
<li>输出：1</li>
</ul>
<p>提示：</p>
<ul>
<li>0 &lt;= points.length &lt;= 10^4</li>
<li>points[i].length == 2</li>
<li>-2^31 &lt;= xstart &lt; xend &lt;= 2^31 - 1</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>如何使用最少的弓箭呢？</p>
<p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p>
<p>尝试一下举反例，发现没有这种情况。</p>
<p>那么就试一试贪心吧！局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。</p>
<p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p>
<p>如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。</p>
<p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remote气球，只要记录一下箭的数量就可以了。</p>
<p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p>
<p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p>
<p>那么按照气球起始位置排序，还是按照气球终止位置排序呢？</p>
<p>其实都可以！只不过对应的遍历顺序不同，我就按照气球的起始位置排序了。</p>
<p>既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p>
<p>从前向后遍历遇到重叠的气球了怎么办？</p>
<p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p>
<p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）</p>
<p><img src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="452.用最少数量的箭引爆气球"></p>
<p>可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> {</span><br><span class="line">	Arrays.sort(points,(a,b) -&gt; {</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">    });</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMin</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.length;i++) {</span><br><span class="line">        <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; rightMin) {</span><br><span class="line">           	count++;</span><br><span class="line">            rightMin = points[i][<span class="number">1</span>];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            rightMin = Math.min(rightMin,points[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>无重叠区间_贪心09</title>
    <url>/2022/08/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8309/</url>
    <content><![CDATA[<html><head></head><body><h1 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h1><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">力扣题目链接(opens new window)</a></p>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
<p>示例 1:</p>
<ul>
<li>输入: [ [1,2], [2,3], [3,4], [1,3] ]</li>
<li>输出: 1</li>
<li>解释: 移除 [1,3] 后，剩下的区间没有重叠。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: [ [1,2], [1,2], [1,2] ]</li>
<li>输出: 2</li>
<li>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: [ [1,2], [2,3] ]</li>
<li>输出: 0</li>
<li>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p><strong>相信很多同学看到这道题目都冥冥之中感觉要排序，但是究竟是按照右边界排序，还是按照左边界排序呢？</strong></p>
<p>这其实是一个难点！</p>
<p>按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的。</p>
<p>按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。</p>
<p>如果按照左边界排序，还从左向右遍历的话，其实也可以，逻辑会有所不同。</p>
<p>一些同学做这道题目可能真的去模拟去重复区间的行为，这是比较麻烦的，还要去删除区间。</p>
<p>题目只是要求移除区间的个数，没有必要去真实的模拟删除区间！</p>
<p><strong>我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p>
<p>此时问题就是要求非交叉区间的最大个数。</p>
<p>右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。</p>
<p>局部最优推出全局最优，试试贪心！</p>
<p>这里记录非交叉区间的个数还是有技巧的，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201221201553618.png" alt="435.无重叠区间"></p>
<p>区间，1，2，3，4，5，6都按照右边界排好序。</p>
<p>每次取非交叉区间的时候，都是可右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间1结束的位置。</p>
<p>接下来就是找大于区间1结束位置的区间，是从区间4开始。<strong>那有同学问了为什么不从区间5开始？别忘已经是按照右边界排序的了</strong>。</p>
<p>区间4结束之后，在找到区间6，所以一共记录非交叉区间的个数是三个。</p>
<p>总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题我认为难度级别可以算是hard级别的！</p>
<p>总结如下难点：</p>
<ul>
<li>难点一：一看题就有感觉需要排序，但究竟怎么排序，按左边界排还是右边界排。</li>
<li>难点二：排完序之后如何遍历，如果没有分析好遍历顺序，那么排序就没有意义了。</li>
<li>难点三：直接求重复的区间是复杂的，转而求最大非重复区间个数。</li>
<li>难点四：求最大非重复区间个数时，需要一个分割点来做标记。</li>
</ul>
<p><strong>这四个难点都不好想，但任何一个没想到位，这道题就解不了</strong>。</p>
<p>一些录友可能看网上的题解代码很简单，照葫芦画瓢稀里糊涂的就过了，但是其题解可能并没有把问题难点讲清楚，然后自己再没有钻研的话，那么一道贪心经典区间问题就这么浪费掉了。</p>
<p>贪心就是这样，代码有时候很简单（不是指代码短，而是逻辑简单），但想法是真的难！</p>
<p>这和动态规划还不一样，动规的代码有个递推公式，可能就看不懂了，而贪心往往是直白的代码，但想法读不懂，哈哈。</p>
<p><strong>所以我把本题的难点也一一列出，帮大家不仅代码看的懂，想法也理解的透彻！</strong></p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">    Arrays.sort(intervals,(a,b) -&gt; {</span><br><span class="line">       <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]; </span><br><span class="line">    });</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;i &lt; intervals.length; i++) {</span><br><span class="line">        <span class="comment">// 没有重叠</span></span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= rightMax) {</span><br><span class="line">            count++;</span><br><span class="line">            rightMax = intervals[i][<span class="number">1</span>];</span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>合并区间_贪心10</title>
    <url>/2022/08/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8310/</url>
    <content><![CDATA[<html><head></head><body><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h1><p><a href="https://leetcode.cn/problems/merge-intervals/">力扣题目链接(opens new window)</a></p>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<ul>
<li>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</li>
<li>输出: [[1,6],[8,10],[15,18]]</li>
<li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: intervals = [[1,4],[4,5]]</li>
<li>输出: [[1,5]]</li>
<li>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</li>
<li>注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>大家应该都感觉到了，此题一定要排序，那么按照左边界排序，还是右边界排序呢？</p>
<p>都可以！</p>
<p>那么我按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。</p>
<p>局部最优可以推出全局最优，找不出反例，试试贪心。</p>
<p>那有同学问了，本来不就应该合并最大右边界么，这和贪心有啥关系？</p>
<p>有时候贪心就是常识！哈哈</p>
<p>按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt; intervals[i - 1][1]</code> 即intervals[i]左边界 &lt; intervals[i - 1]右边界，则一定有重复，因为intervals[i]的左边界一定是大于等于intervals[i - 1]的左边界。</p>
<p>即：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，那么一定有重复！</p>
<p>这么说有点抽象，看图：（<strong>注意图中区间都是按照左边界排序之后了</strong>）</p>
<p><img src="https://img-blog.csdnimg.cn/20201223200632791.png" alt="56.合并区间"></p>
<p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p>
<p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    Arrays.sort(intervals,(a,b) -&gt; {</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">    })</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++) {</span><br><span class="line">        <span class="comment">// 不能合并时</span></span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; right) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {left,right});</span><br><span class="line">            left = intervals[i][<span class="number">0</span>];</span><br><span class="line">            right = intervals[i][<span class="number">1</span>];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            right = Math.max(right,intervals[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {left,right});</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>单调递增的数字_贪心11</title>
    <url>/2022/08/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8311/</url>
    <content><![CDATA[<html><head></head><body><h1 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h1><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接(opens new window)</a></p>
<p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p>
<p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）</p>
<p>示例 1:</p>
<ul>
<li>输入: N = 10</li>
<li>输出: 9</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: N = 1234</li>
<li>输出: 1234</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: N = 332</li>
<li>输出: 299</li>
</ul>
<p>说明: N 是在 [0, 10^9] 范围内的一个整数。</p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="#暴力解法"></a><a href="https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">#</a>暴力解法</h2><p>题意很简单，那么首先想的就是暴力解法了，来我替大家暴力一波，结果自然是超时！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkNum</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">        <span class="type">int</span> max = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (num) {</span><br><span class="line">            <span class="type">int</span> t = num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (max &gt;= t) max = t;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkNum</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>时间复杂度：$O(n × m)$ m为n的数字长度</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="#贪心算法"></a><a href="https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">#</a>贪心算法</h2><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。</p>
<p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p>
<p>这一点如果想清楚了，这道题就好办了。</p>
<p><strong>局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。</p>
<p><strong>全局最优：得到小于等于N的最大单调递增的整数</strong>。</p>
<p><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。</p>
<p>此时是从前向后遍历还是从后向前遍历呢？</p>
<p>从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p>
<p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p>
<p><strong>所以从前后向遍历会改变已经遍历过的结果！</strong></p>
<p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p>
<p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> N)</span> {</span><br><span class="line">	String[] strings = (N + <span class="string">""</span>).split(<span class="string">""</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> strings.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strings.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--) {</span><br><span class="line">		<span class="keyword">if</span>(Integer.valueOf(strings[i-<span class="number">1</span>]) &gt; Integer.valueOf(strings[i])) {</span><br><span class="line">            strings[i-<span class="number">1</span>] = String.valueOf(Integer.valueOf(strings[i-<span class="number">1</span>]) - <span class="number">1</span>);</span><br><span class="line">            start = i;</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;strings.length;i++) {</span><br><span class="line">       	strings[i] = <span class="string">"9"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(String.join(<span class="string">""</span>,strings));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机含手续费_贪心12</title>
    <url>/2022/08/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8312/</url>
    <content><![CDATA[<html><head></head><body><h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8</p>
<p>解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p>
<p>注意:</p>
<ul>
<li>0 &lt; prices.length &lt;= 50000.</li>
<li>0 &lt; prices[i] &lt; 50000.</li>
<li>0 &lt;= fee &lt; 50000.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>本题相对于<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html">贪心算法：122.买卖股票的最佳时机II (opens new window)</a>，多添加了一个条件就是手续费。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="#贪心算法"></a><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">#</a>贪心算法</h2><p>在<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html">贪心算法：122.买卖股票的最佳时机II (opens new window)</a>中使用贪心策略不用关心具体什么时候买卖，只要收集每天的正利润，最后稳稳的就是最大利润了。</p>
<p>而本题有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。</p>
<p>如果使用贪心策略，就是最低值买，最高值（如果算上手续费还盈利）就卖。</p>
<p>此时无非就是要找到两个点，买入日期，和卖出日期。</p>
<ul>
<li>买入日期：其实很好想，遇到更低点就记录一下。</li>
<li>卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。</li>
</ul>
<p>所以我们在做收获利润操作的时候其实有三种情况：</p>
<ul>
<li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。</li>
<li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li>
<li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li>
</ul>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices,<span class="type">int</span> fee)</span> {</span><br><span class="line">	<span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> prices[<span class="number">0</span>] + fee;</span><br><span class="line">	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> p : prices) {</span><br><span class="line">		<span class="keyword">if</span>(p + fee &lt; buy) {</span><br><span class="line">			buy = p + fee;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(p &gt; buy) {</span><br><span class="line">			sum += p - buy;</span><br><span class="line">			buy = p;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>删除_链表01</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A801/</url>
    <content><![CDATA[<html><head></head><body><h1 id="删除-链表01"><a href="#删除-链表01" class="headerlink" title="删除_链表01"></a>删除_链表01</h1><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接(opens new window)</a></p>
<p>题意：删除链表中等于给定值 val 的所有节点。</p>
<p>示例 1：<br>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]</p>
<p>示例 2：<br>输入：head = [], val = 1<br>输出：[]</p>
<p>示例 3：<br>输入：head = [7,7,7,7], val = 7<br>输出：[]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了方便大家理解，我特意录制了视频：<a href="https://www.bilibili.com/video/BV18B4y1s7R9">手把手带你学会操作链表，移除链表元素 (opens new window)</a>，结合视频在看本题解，事半功倍。</p>
<p>这里以链表 1 4 2 4 来举例，移除元素4。</p>
<p><img src="https://img-blog.csdnimg.cn/20210316095351161.png" alt="203_链表删除元素1"></p>
<p>如果使用C，C++编程语言的话，不要忘了还要从内存中删除这两个移除的节点， 清理节点内存之后如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210316095418280.png" alt="203_链表删除元素2"></p>
<p><strong>当然如果使用java ，python的话就不用手动管理内存了。</strong></p>
<p>还要说明一下，就算使用C++来做leetcode，如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p>
<p>这种情况下的移除操作，就是让节点next指针直接指向下下一个节点就可以了，</p>
<p>那么因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？</p>
<p>这里就涉及如下链表操作的两种方式：</p>
<ul>
<li><strong>直接使用原来的链表来进行删除操作。</strong></li>
<li><strong>设置一个虚拟头结点在进行删除操作。</strong></li>
</ul>
<p>来看第一种操作：直接使用原来的链表来进行移除。</p>
<p><img src="https://img-blog.csdnimg.cn/2021031609544922.png" alt="203_链表删除元素3"></p>
<p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p>
<p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</p>
<p><img src="https://img-blog.csdnimg.cn/20210316095512470.png" alt="203_链表删除元素4"></p>
<p>依然别忘将原头结点从内存中删掉。 <img src="https://img-blog.csdnimg.cn/20210316095543775.png" alt="203_链表删除元素5"></p>
<p>这样移除了一个头结点，是不是发现，在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p>
<p>那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p>
<p>其实<strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p>
<p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。</p>
<p><img src="https://img-blog.csdnimg.cn/20210316095619221.png" alt="203_链表删除元素6"></p>
<p>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。</p>
<p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p>
<p>来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。</p>
<p>最后呢在题目中，return 头结点的时候，别忘了 <code>return dummyNode-&gt;next;</code>， 这才是新的头结点</p>
<p>java:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加虚节点方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 因为删除可能涉及到头节点，所以设置dummy节点，统一操作</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) {</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pre = cur;</span><br><span class="line">        }</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>设计链表_链表02</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A802/</url>
    <content><![CDATA[<html><head></head><body><h1 id="设计链表-链表02"><a href="#设计链表-链表02" class="headerlink" title="设计链表_链表02"></a>设计链表_链表02</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接(opens new window)</a></p>
<p>题意：</p>
<p>在链表类中实现这些功能：</p>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200814200558953.png" alt="707示例"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了方便大家理解，我特意录制了视频：<a href="https://www.bilibili.com/video/BV1FU4y1X7WD">帮你把链表操作学个通透！LeetCode：707.设计链表 (opens new window)</a>，结合视频在看本题解，事半功倍。</p>
<p>如果对链表的基础知识还不太懂，可以看这篇文章：<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于链表，你该了解这些！(opens new window)</a></p>
<p>如果对链表的虚拟头结点不清楚，可以看这篇文章：<a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">链表：听说用虚拟头节点会方便很多？(opens new window)</a></p>
<p>删除链表节点： <img src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"></p>
<p>添加链表节点： <img src="https://img-blog.csdnimg.cn/20200806195134331.png" alt="链表-添加节点"></p>
<p>这道题目设计链表的五个接口：</p>
<ul>
<li>获取链表第index个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第index个节点前面插入一个节点</li>
<li>删除链表的第index个节点</li>
</ul>
<p>可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目</p>
<p><strong>链表操作的两种方式：</strong></p>
<ol>
<li>直接使用原来的链表来进行操作。</li>
<li>设置一个虚拟头结点在进行操作。</li>
</ol>
<p>下面采用的设置一个虚拟头结点（这样更方便一些，大家看代码就会感受出来）。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(){}</span><br><span class="line">    ListNode(<span class="type">int</span> val) {</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> {</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> {</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) {</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表最前面插入一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表的最后插入一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) {</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) {</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) {</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        }</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转链表_链表03</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A803/</url>
    <content><![CDATA[<html><head></head><body><h1 id="翻转链表-链表03"><a href="#翻转链表-链表03" class="headerlink" title="翻转链表_链表03"></a>翻转链表_链表03</h1><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接(opens new window)</a></p>
<p>题意：反转一个单链表。</p>
<p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。</p>
<p>其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:</p>
<p><img src="https://img-blog.csdnimg.cn/20210218090901207.png" alt="206_反转链表"></p>
<p>之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改变next指针的方向。</p>
<p>那么接下来看一看是如何反转的呢？</p>
<p>我们拿有示例中的链表来举例，如动画所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="img"></p>
<p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p>
<p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p>
<p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p>
<p>接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。</p>
<p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) {</span><br><span class="line">            temp = cur.next;<span class="comment">// 保存下一个节点</span></span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>两两交换链表中的节点_链表04</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A804/</url>
    <content><![CDATA[<html><head></head><body><h1 id="两两交换链表中的节点-链表04"><a href="#两两交换链表中的节点-链表04" class="headerlink" title="两两交换链表中的节点_链表04"></a>两两交换链表中的节点_链表04</h1><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接(opens new window)</a></p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="24.两两交换链表中的节点-题意"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目正常模拟就可以了。</p>
<p>建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p>
<p>对虚拟头结点的操作，还不熟悉的话，可以看这篇<a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">链表：听说用虚拟头节点会方便很多？ (opens new window)</a>。</p>
<p>接下来就是交换相邻两个元素了，<strong>此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序</strong></p>
<p>初始时，cur指向虚拟头结点，然后进行如下三步：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png" alt="24.两两交换链表中的节点1"></p>
<p>操作之后，链表如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png" alt="24.两两交换链表中的节点2"></p>
<p>看这个可能就更直观一些了：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png" alt="24.两两交换链表中的节点3"></p>
<p>java代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">	<span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> {</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">dummpy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">		dummpy.next = head;</span><br><span class="line">		pre.next = head;</span><br><span class="line">		<span class="keyword">while</span>(pre.next!=<span class="literal">null</span> &amp;&amp; pre.next.next!=<span class="literal">null</span>) {</span><br><span class="line">			<span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">			pre.next = head.next;</span><br><span class="line">			pre.next.next = head;</span><br><span class="line">			head.next = tmp;</span><br><span class="line">			pre = head;</span><br><span class="line">			head = tmp;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> dummpy.next;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表相交_链表06</title>
    <url>/2022/07/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A806/</url>
    <content><![CDATA[<html><head></head><body><h1 id="链表相交-链表06"><a href="#链表相交-链表06" class="headerlink" title="链表相交_链表06"></a>链表相交_链表06</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣题目链接(opens new window)</a></p>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png" alt="img"></p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p>示例 1：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221723.png" alt="img"></p>
<p>示例 2：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221749.png" alt="img"></p>
<p>示例 3：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221812.png" alt="img"><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221812.png" alt="img"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单来说，就是求两个链表交点节点的<strong>指针</strong>。 这里同学们要注意，交点不是数值相等，而是指针相等。</p>
<p>为了方便举例，假设节点元素数值相等，则节点指针相等。</p>
<p>看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_1.png" alt="面试题02.07.链表相交_1"></p>
<p>我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="面试题02.07.链表相交_2"></p>
<p>此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。</p>
<p>否则循环退出返回空指针。</p>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public class Solution {</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {</span><br><span class="line">    	int lenA = 0;</span><br><span class="line">    	ListNode curA = headA;</span><br><span class="line">    	int lenB = 0;</span><br><span class="line">    	ListNode curB = headB;</span><br><span class="line">    	while(curA != null) {</span><br><span class="line">    		lenA++;</span><br><span class="line">    		curA = curA.next;</span><br><span class="line">    	}</span><br><span class="line">    	while(curB != null) {</span><br><span class="line">    		lenB++;</span><br><span class="line">    		curB = curB.next;</span><br><span class="line">    	}</span><br><span class="line">    	int gap = Math.abs(lenA-lenB);</span><br><span class="line">    	if(lenA &gt; lenB) {</span><br><span class="line">    		while(gap-- &gt; 0) {</span><br><span class="line">    			headA = headA.next;</span><br><span class="line">    		}</span><br><span class="line">    	} else {</span><br><span class="line">    		while(gap-- &gt; 0) {</span><br><span class="line">    			headB = headB.next;</span><br><span class="line">    		}</span><br><span class="line">    	}</span><br><span class="line">    	while(headA != null) {</span><br><span class="line">    		if(headA == headB) {</span><br><span class="line">    			return headA;</span><br><span class="line">    		}</span><br><span class="line">    		headA = headA.next;</span><br><span class="line">    		headB = headB.next;</span><br><span class="line">    	}</span><br><span class="line">    }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第N个节点_链表05</title>
    <url>/2022/07/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A805/</url>
    <content><![CDATA[<html><head></head><body><h1 id="代码随想录-链表05"><a href="#代码随想录-链表05" class="headerlink" title="代码随想录_链表05"></a>代码随想录_链表05</h1><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接(opens new window)</a></p>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>进阶：你能尝试使用一趟扫描实现吗？</p>
<p>示例 1：</p>
<p><img src="https://s2.loli.net/2022/07/21/hLWKP3FJsnirElH.png" alt="19.删除链表的倒数第N个节点"></p>
<p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：</p>
<p>输入：head = [1], n = 1 输出：[] 示例 3：</p>
<p>输入：head = [1,2], n = 1 输出：[1]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p>
<p>思路是这样的，但要注意一些细节。</p>
<p>分为如下几步：</p>
<ul>
<li>首先这里我推荐大家使用虚拟头结点，这样方便处理删除实际头结点的逻辑，如果虚拟头结点不清楚，可以看这篇： <a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">链表：听说用虚拟头节点会方便很多？(opens new window)</a></li>
<li>定义fast指针和slow指针，初始值为虚拟头结点，如图：</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/21/yDqCI5BFOieLGjM.png" alt="img"></p>
<ul>
<li>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： <img src="https://s2.loli.net/2022/07/21/wvWEyq9OSzJNFks.png" alt="img"></li>
<li>fast和slow同时移动，直到fast指向末尾，如题： <img src="https://s2.loli.net/2022/07/21/gCJIHN9oaDP8WOX.png" alt="img"></li>
<li>删除slow指向的下一个节点，如图： <img src="https://s2.loli.net/2022/07/21/mZF7AtdsHQPrcgK.png" alt="img"></li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">    		<span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">    		<span class="type">ListNode</span> <span class="variable">fastIndex</span> <span class="operator">=</span> dummy;</span><br><span class="line">        	<span class="type">ListNode</span> <span class="variable">slowIndex</span> <span class="operator">=</span> dummy;</span><br><span class="line">        	<span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) {</span><br><span class="line">                fastIndex = fastIndex.next;</span><br><span class="line">            }</span><br><span class="line">        	<span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        	<span class="keyword">while</span>(fastIndex !=<span class="literal">null</span>) {</span><br><span class="line">                pre = slowIndex;</span><br><span class="line">                fastIndex = fastIndex.next;</span><br><span class="line">                slowIndex = slowIndex.next;</span><br><span class="line">            }</span><br><span class="line">        	pre.next = slow.next;</span><br><span class="line">        	<span class="keyword">return</span> dummy.next;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表_链表07</title>
    <url>/2022/07/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A807/</url>
    <content><![CDATA[<html><head></head><body><h1 id="环形链表-链表07"><a href="#环形链表-链表07" class="headerlink" title="环形链表_链表07"></a>环形链表_链表07</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣题目链接(opens new window)</a></p>
<p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><strong>说明</strong>：不允许修改给定的链表。</p>
<p><img src="https://img-blog.csdnimg.cn/20200816110112704.png" alt="循环链表"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目，不仅考察对链表的操作，而且还需要一些数学运算。</p>
<p>主要考察两知识点：</p>
<ul>
<li>判断链表是否环</li>
<li>如果有环，如何找到这个环的入口</li>
</ul>
<h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="#判断链表是否有环"></a><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF">#</a>判断链表是否有环</h3><p>可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p>
<p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢</p>
<p>首先第一点：<strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</strong></p>
<p>那么来看一下，<strong>为什么fast指针和slow指针一定会相遇呢？</strong></p>
<p>可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。</p>
<p>会发现最终都是这种情况， 如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210318162236720.png" alt="142环形链表1"></p>
<p>fast和slow各自再走一步， fast和slow就相遇了</p>
<p>这是因为fast是走两步，slow是走一步，<strong>其实相对于slow来说，fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo4xglk9yg30fs0b6u0x.gif" alt="141.环形链表"></p>
<h3 id="如果有环，如何找到这个环的入口"><a href="#如果有环，如何找到这个环的入口" class="headerlink" title="#如果有环，如何找到这个环的入口"></a><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E5%A6%82%E6%9E%9C%E6%9C%89%E7%8E%AF-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3">#</a>如果有环，如何找到这个环的入口</h3><p><strong>此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。</strong></p>
<p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210318162938397.png" alt="142环形链表2"></p>
<p>那么相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p>
<p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(x + y) * 2 = x + y + n (y + z)</span><br></pre></td></tr></tbody></table></figure>

<p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p>
<p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p>
<p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p>
<p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p>
<p>这个公式说明什么呢？</p>
<p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p>
<p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p>
<p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>
<p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。</p>
<p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58gauidg30fw0bi4qr.gif" alt="142.环形链表II（求入口）"></p>
<p>那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。</p>
<p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public class Solution {</span><br><span class="line">    public ListNode detectCycle(ListNode head) {</span><br><span class="line">    	ListNode fastIndex = head;</span><br><span class="line">    	ListNode slowIndex = head;</span><br><span class="line">    	while(fastIndex != null &amp;&amp; fastIndex != null) {</span><br><span class="line">    		fastIndex = fastindex.next.next;</span><br><span class="line">    		slowIndex = slowIndex.next;</span><br><span class="line">    		if(fastIndex == slowIndex) {</span><br><span class="line">    			index1 = fastIndex;</span><br><span class="line">    			index2 = head;</span><br><span class="line">    			while(index1 != index2) {</span><br><span class="line">    				index1 = index1.next;</span><br><span class="line">    				index2 = index2.next;</span><br><span class="line">    			}</span><br><span class="line">    			return index1;</span><br><span class="line">    		}</span><br><span class="line">    	}</span><br><span class="line">    	return null;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录_链表理论</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<html><head></head><body><h1 id="代码随想录-链表理论"><a href="#代码随想录-链表理论" class="headerlink" title="代码随想录_链表理论"></a>代码随想录_链表理论</h1><h3 id="关于链表，你该了解这些！"><a href="#关于链表，你该了解这些！" class="headerlink" title="关于链表，你该了解这些！"></a>关于链表，你该了解这些！</h3><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链接的入口节点称为链表的头结点也就是head。</p>
<p>如图所示： <img src="https://img-blog.csdnimg.cn/20200806194529815.png" alt="链表1"></p>
<h1 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h1><p>接下来说一下链表的几种类型:</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>刚刚说的就是单链表。</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>单链表中的指针域只能指向节点的下一个节点。</p>
<p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p>
<p>双链表 既可以向前查询也可以向后查询。</p>
<p>如图所示： <img src="https://img-blog.csdnimg.cn/20200806194559317.png" alt="链表2"></p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表，顾名思义，就是链表首尾相连。</p>
<p>循环链表可以用来解决约瑟夫环问题。</p>
<p><img src="https://img-blog.csdnimg.cn/20200806194629603.png" alt="链表4"></p>
<h2 id="链表的存储方式"><a href="#链表的存储方式" class="headerlink" title="链表的存储方式"></a>链表的存储方式</h2><p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p>
<p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p>
<p>链表是通过指针域的指针链接在内存中各个节点。</p>
<p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806194613920.png" alt="链表3"></p>
<p>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p>
<h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><p>接下来说一说链表的定义。</p>
<p>链表节点的定义，很多同学在面试的时候都写不好。</p>
<p>这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p>
<p>而在面试的时候，一旦要自己手写链表，就写的错漏百出。</p>
<p>这里我给出C/C++的定义链表节点方式，如下所示：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) {}  <span class="comment">// 节点的构造函数</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p>
<p>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p>
<p>通过自己定义构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>使用默认构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p>
<h3 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h3><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除D节点，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"></p>
<p>只要将C节点的next指针 指向E节点就可以了。</p>
<p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p>
<p>是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。</p>
<p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806195134331.png" alt="链表-添加节点"></p>
<p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p>
<p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>再把链表的特性和数组的特性进行一个对比，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806195200276.png" alt="链表-链表与数据性能对比"></p>
<p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<p>相信大家已经对链表足够的了解，后面我会讲解关于链表的高频面试题目，我们下期见！</p>
<p>Java：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>吉他01</title>
    <url>/2022/07/21/%E5%90%89%E4%BB%9601/</url>
    <content><![CDATA[<html><head></head><body><h1 id="吉他01"><a href="#吉他01" class="headerlink" title="吉他01"></a>吉他01</h1><h3 id="音名："><a href="#音名：" class="headerlink" title="音名："></a>音名：</h3><p>C D E F G A B</p>
<h3 id="简谱名："><a href="#简谱名：" class="headerlink" title="简谱名："></a>简谱名：</h3><p>1 2 3 4 5 6 7</p>
<h3 id="唱名："><a href="#唱名：" class="headerlink" title="唱名："></a>唱名：</h3><p>Do Re Mi Fa Sol La Si (Do)</p>
<h3 id="合并来记"><a href="#合并来记" class="headerlink" title="合并来记"></a>合并来记</h3><p>C D E F G A B</p>
<p>1 2 3 4 5 6 7</p>
<p>Do Re Mi Fa Sol La Si (Do)</p>
</body></html>]]></content>
      <categories>
        <category>吉他</category>
      </categories>
      <tags>
        <tag>吉他</tag>
      </tags>
  </entry>
  <entry>
    <title>天猫闲谈</title>
    <url>/2022/07/19/%E5%A4%A9%E7%8C%AB%E9%97%B2%E8%B0%88/</url>
    <content><![CDATA[<html><head></head><body><h1 id="天猫闲谈"><a href="#天猫闲谈" class="headerlink" title="天猫闲谈"></a>天猫闲谈</h1><h2 id="遇到的问题和解决方案"><a href="#遇到的问题和解决方案" class="headerlink" title="遇到的问题和解决方案"></a>遇到的问题和解决方案</h2><h3 id="SSL报错01"><a href="#SSL报错01" class="headerlink" title="SSL报错01"></a>SSL报错01</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  File "C:\ProgramData\Anaconda3\lib\site-packages\requests\adapters.py", line 512, in send</span><br><span class="line">    raise SSLError(e, request=request)</span><br><span class="line">requests.exceptions.SSLError: [SSL: TLSV1_ALERT_INTERNAL_ERROR] tlsv1 alert internal error (_ssl.c:833)</span><br></pre></td></tr></tbody></table></figure>

<p>使用了anaconda，貌似win10 anaconda python中SSL是无法正常使用的</p>
<h3 id="SSL报错02"><a href="#SSL报错02" class="headerlink" title="SSL报错02"></a>SSL报错02</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">    raise SSLError(e, request=request)</span><br><span class="line">requests.exceptions.SSLError: HTTPSConnectionPool(host='detail.tmall.com', port=443): Max retries exceeded with url: /item.htm?spm=a220m.1000858.1000725.6.279262bdaFcN4o&amp;id=644251278102&amp;skuId=4811506167531&amp;areaId=430500&amp;user_id=3695246029&amp;cat_id=2&amp;is_b=1&amp;rn=fbac5ad264b425e565a06fe73f8dddc5 (Caused by SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:1129)')))</span><br></pre></td></tr></tbody></table></figure>

<p>把代理和vpn都关掉就刑了</p>
<h3 id="遇到-u0026开头的数据"><a href="#遇到-u0026开头的数据" class="headerlink" title="遇到\u0026开头的数据"></a>遇到\u0026开头的数据</h3><p>在线网站解码uincode</p>
<p>[网站链接](<a href="https://www.bt.cn/tools/unicode.html">Unicode编码解码 (bt.cn)</a>)</p>
<p><img src="https://img1.imgtp.com/2022/07/20/cpv9DczW.png" alt="image-20220719210902845"></p>
<p>代码解码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">str1 = '\u003d676464506778\u0026ns\u003d1\u0026abbucket\u003d20'</span><br><span class="line">str1 = str1.encode('utf8').decode('unicode_escape')</span><br><span class="line">print(str1)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="JSON形式数据无法格式化"><a href="#JSON形式数据无法格式化" class="headerlink" title="JSON形式数据无法格式化"></a>JSON形式数据无法格式化</h3><p>[网站推荐](<a href="https://www.sojson.com/">JSON在线 | JSON解析格式化—SO JSON在线工具</a>)</p>
<h2 id="主页数据获取"><a href="#主页数据获取" class="headerlink" title="主页数据获取"></a>主页数据获取</h2><p>代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">from lxml import etree</span><br><span class="line">headers = {}</span><br><span class="line">user_agent_list = [</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1",</span><br><span class="line">        "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1",</span><br><span class="line">        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"</span><br><span class="line">    ]</span><br><span class="line"># 思路 先通过re正则表达式截取字符串 再转成json 提取后的detail_url 需要unicode解码 随后请求二级页面 保存到数据库</span><br><span class="line">headers['User-Agent'] = random.choice(user_agent_list)</span><br><span class="line">headers['cookie'] = 'lid=tb9609426962; enc=BH1kwxit6G8cG+yyNm8RGSjGG7Ul6TPPC9cupRd7pcLOTHzbtGjUWvt+y1/lnpq20MnX/L2ib6fxGQgPVPErnDcEfbiBCMvSLjTaVe7Ke+Q=; xlly_s=1; t=1dc717b7817ec57908076132934639cf; tracknick=tb9609426962; lgc=tb9609426962; _tb_token_=e75e6f118fe1f; cookie2=1733e90542b3f845c3ae6495f5805686; dnk=tb9609426962; uc1=cookie21=U+GCWk/7pun3Y5w91g==&amp;existShop=false&amp;cookie14=UoexOtxinA35mw==&amp;cookie15=W5iHLLyFOGW7aA==&amp;cookie16=Vq8l+KCLySLZMFWHxqs8fwqnEw==&amp;pas=0; uc3=id2=UUphw2zWTYMnUcGdIA==&amp;lg2=U+GCWk/75gdr5Q==&amp;nk2=F5RMHyzSuEkCcKo1&amp;vt3=F8dCv4MTXkH24gx6sAo=; uc4=id4=0@U2grGNOhoAYQJI7x06Q9pDUuuKKF/Kxv&amp;nk4=0@FY4HWrWzC/MqtVcYArH9YSEDnCASDHo=; _l_g_=Ug==; unb=2209950509527; cookie1=BYBYyEkdr9rg6r9BkSz4NbO8O9IxtK9O+uxD9+ms0+g=; login=true; cookie17=UUphw2zWTYMnUcGdIA==; _nk_=tb9609426962; sgcookie=E100hATU0w94N3lFcvzLxXKWpFR/t6l5etXuPZwTQZw4C5dK7IMPctrGWC/zr3BN9BMQ8hG+G5eX+4MwnfuJ9a//JxrxaolzbVqljAcBsKt/s8c=; cancelledSubSites=empty; sg=27d; csg=06c4cb83; cna=dxpdG1ujxikCAW416kuUQRzQ; _med=dw:1280&amp;dh:720&amp;pw:1920&amp;ph:1080&amp;ist:0; _m_h5_tk=b13d35cfa8eba44fe9e718d2ab0a8db6_1658233336473; _m_h5_tk_enc=ca8261f26c330ffca5b111d34d3154c2; x5sec=7b22746d616c6c7365617263683b32223a223865636565636234376335353662326338396537313536376232646232393135434e336532705947454c6a42394d4341694b7a754a426f504d6a49774f546b314d4455774f5455794e7a73784d4f5057684b62352f2f2f2f2f77453d227d; res=scroll:990*7119-client:497*561-offset:497*7119-screen:1280*720; pnm_cku822=098#E1hvIvvUvbZvjQCkvvvvvjiWRLLUsjl8n2s9zjrCPmPwsjtPRFLWsjinPFcwQj0evpvhvvmv9u9Cvv9vvUCCx++HVO9CvvwUvUVvwZjWKvhv8vvvvvCvpvvvvvvC9hCvmvZvvUUvphvUpQvv99CvpvkkvvmmvhCvm8UUvpCWCviPvvawafmxfX9Ojomxfa3lD1DlpqmxfwoOd5lPlnoOD40Owm0QD7zheTtYvtxr1WoKHkx/1WBlYCe4axRxfwLvd3ODN+LvaNpM+9vCvvOvCvvvphvRvpvhMMGvv29Cvvpvvvvv; tfstk=cSOGBdwdZdWs2wLyuC1siTHnulDRZ1iNbIR9TV1ISNQJVCOFiweUUjus-MoSb-1..; l=eBSVJC2cL0chGFjsBOfwourza77OSIRAguPzaNbMiOCPOc5H5XMfW6vz5eYMC3GVh6vDR3Wrj_IwBeYBqIY75O9StBALurkmn; isg=BOPj1cl9hRwO7kkrfnvS78pIcieN2HcaWtHIxxVAP8K5VAN2nagHasGGTiTadM8S'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># headers = {</span><br><span class="line">#         'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',</span><br><span class="line">#         'accept-language': 'zh-CN,zh;q=0.9',</span><br><span class="line">#         'cache-control': 'no-cache',</span><br><span class="line"># }</span><br><span class="line">for n in range(1,30):</span><br><span class="line">    url = 'https://list.tmall.com/search_product.htm?spm=a220m.1000858.0.0.752962bd7xoYBT&amp;s=60&amp;q=%C5%AE%CA%BF%B0%FC&amp;sort=s&amp;style=g&amp;from=mallfp..pc_1_searchbutton&amp;type=pc#J_Filter'</span><br><span class="line">    resp = requests.get(url=url, headers=headers).text</span><br><span class="line">    # js_format = re.findall('"itemlist":(.*?),"bottomsearch":',resp)</span><br><span class="line">    # print(js_format)</span><br><span class="line">    html = etree.HTML(resp)</span><br><span class="line">    div_list = html.xpath('//div[@class="page"]/div/div[@id="content"]/div/div[@id="J_ItemList"]/div')</span><br><span class="line">    print(len(div_list))</span><br><span class="line">    for i,v in enumerate(div_list):</span><br><span class="line">        price = v.xpath('./div/p[@class="productPrice"]/em/text()')</span><br><span class="line">        sell_num = v.xpath('./div/p[@class="productStatus"]/span/em/text()')</span><br><span class="line">        shop_name = v.xpath('./div/div[@class="productShop"]/a/text()')</span><br><span class="line">        count_num = v.xpath('./div/p[@class="productStatus"]/span/a/text()')</span><br><span class="line">        print(price,sell_num,shop_name,count_num)</span><br><span class="line">    # print(resp)</span><br><span class="line">    print("end!!!")</span><br><span class="line">    break</span><br></pre></td></tr></tbody></table></figure>

<p>运行截图：</p>
<p><img src="https://img1.imgtp.com/2022/07/20/SagBQra1.png" alt="image-20220719213614328"></p>
<h2 id="二级页面"><a href="#二级页面" class="headerlink" title="二级页面"></a>二级页面</h2><p>代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">import random</span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">headers = {}</span><br><span class="line">user_agent_list = [</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1",</span><br><span class="line">        "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1",</span><br><span class="line">        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"</span><br><span class="line">    ]</span><br><span class="line"># 思路 先通过re正则表达式截取字符串 再转成json 提取后的detail_url 需要unicode解码 随后请求二级页面 保存到数据库</span><br><span class="line">headers['User-Agent'] = random.choice(user_agent_list)</span><br><span class="line">headers['cookie'] = 'lid=tb9609426962; enc=BH1kwxit6G8cG+yyNm8RGSjGG7Ul6TPPC9cupRd7pcLOTHzbtGjUWvt+y1/lnpq20MnX/L2ib6fxGQgPVPErnDcEfbiBCMvSLjTaVe7Ke+Q=; xlly_s=1; t=1dc717b7817ec57908076132934639cf; tracknick=tb9609426962; lgc=tb9609426962; _tb_token_=e75e6f118fe1f; cookie2=1733e90542b3f845c3ae6495f5805686; dnk=tb9609426962; uc1=cookie21=U+GCWk/7pun3Y5w91g==&amp;existShop=false&amp;cookie14=UoexOtxinA35mw==&amp;cookie15=W5iHLLyFOGW7aA==&amp;cookie16=Vq8l+KCLySLZMFWHxqs8fwqnEw==&amp;pas=0; uc3=id2=UUphw2zWTYMnUcGdIA==&amp;lg2=U+GCWk/75gdr5Q==&amp;nk2=F5RMHyzSuEkCcKo1&amp;vt3=F8dCv4MTXkH24gx6sAo=; uc4=id4=0@U2grGNOhoAYQJI7x06Q9pDUuuKKF/Kxv&amp;nk4=0@FY4HWrWzC/MqtVcYArH9YSEDnCASDHo=; _l_g_=Ug==; unb=2209950509527; cookie1=BYBYyEkdr9rg6r9BkSz4NbO8O9IxtK9O+uxD9+ms0+g=; login=true; cookie17=UUphw2zWTYMnUcGdIA==; _nk_=tb9609426962; sgcookie=E100hATU0w94N3lFcvzLxXKWpFR/t6l5etXuPZwTQZw4C5dK7IMPctrGWC/zr3BN9BMQ8hG+G5eX+4MwnfuJ9a//JxrxaolzbVqljAcBsKt/s8c=; cancelledSubSites=empty; sg=27d; csg=06c4cb83; cna=dxpdG1ujxikCAW416kuUQRzQ; pnm_cku822=098#E1hvUpvUvbZvUpCkvvvvvjiWRLLUQjn8RLSvgjthPmPp6jnmPFLpljlhRF59QjtjR8OCvvpvvhHhRvhvCvvvphvvvpvVvUCvpvvvKvhv8vvvphvvvvvvvvCmpQvvv4vvvhxHvvvC4vvvBZZvvvHZvvCHBpvvvxoUvpvjvpC2p+Lve49Cvv9vvhj2ZnnXsQ9CvhQmp+fVjakK5uyTWDKt5BwsRfwrfuVHR4VzWkZnD70Oj8TZfvDr1EAK5dUf8KBlDf8rejOd+87JViIwaHFXSfpAhC3qVUcn+3mO5jIU29hvCPMMvvv=; _m_h5_tk=b13d35cfa8eba44fe9e718d2ab0a8db6_1658233336473; _m_h5_tk_enc=ca8261f26c330ffca5b111d34d3154c2; isg=BCEhGC7I5yaGiEvRiK1wxZRWMO07zpXAVP9KXYPxaSi06kC8yR5TkOhrTB7sIi34; l=eBSVJC2cL0chG4RGBO5Zlurza77t6BOb8sPzaNbMiInca1rfTHWe_NCHUyYk7dtjgt5FrexPUcfRbdh6JSaLRFkDBeYCKXIpBbvy8e1..; tfstk=cwAfB72iPoqXNDn54tgrQGNAvU5GCBD5yxsyl02dXzRLKfg5f51meWSCAc9gV17OP'</span><br><span class="line"></span><br><span class="line">url = 'https://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.6.279262bdaFcN4o&amp;id=644251278102&amp;skuId=4811506167531&amp;areaId=430500&amp;user_id=3695246029&amp;cat_id=2&amp;is_b=1&amp;rn=fbac5ad264b425e565a06fe73f8dddc5'</span><br><span class="line">resp = requests.get(url=url, headers=headers).text</span><br><span class="line"># print(resp)</span><br><span class="line">try:</span><br><span class="line">    place = re.findall(r'&lt;li title=.*?&gt;质地:&amp;nbsp;(.*?)&lt;/li&gt;',resp)</span><br><span class="line">    place = ''.join(place)</span><br><span class="line">except Exception as e:</span><br><span class="line">    place = ''</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    popular = re.findall(r'&lt;li title=.*?&gt;流行元素:&amp;nbsp;(.*?)&lt;/li&gt;',resp)</span><br><span class="line">    popular = ''.join(popular)</span><br><span class="line">except Exception as e:</span><br><span class="line">    popular = ''</span><br><span class="line">    print(e)</span><br><span class="line"># try:</span><br><span class="line">#     color = re.findall(r'&lt;li title=.*?&gt;颜色分类:&amp;nbsp;(.*?)&lt;/li&gt;',resp)</span><br><span class="line">#     color = ''.join(color)</span><br><span class="line"># except Exception as e:</span><br><span class="line">#     color = ''</span><br><span class="line">#     print(e)</span><br><span class="line">try:</span><br><span class="line">    up_time = re.findall(r'&lt;li title=.*?&gt;上市时间:&amp;nbsp;(.*?)&lt;/li&gt;',resp)</span><br><span class="line">    up_time  = ''.join(up_time )</span><br><span class="line">except Exception as e:</span><br><span class="line">    up_time  = ''</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    style = re.findall(r"&lt;li title=.*?&gt;款式:&amp;nbsp;(.*?)&lt;/li&gt;",resp)</span><br><span class="line">    style = ''.join(style)</span><br><span class="line">except Exception as e:</span><br><span class="line">    style = ''</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    size = re.findall(r"&lt;li title=.*?&gt;大小:&amp;nbsp;(.*?)&lt;/li&gt;",resp)</span><br><span class="line">    size = ''.join(size)</span><br><span class="line">except Exception as e:</span><br><span class="line">    size = ''</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    popular_name = re.findall(r"&lt;li title=.*?&gt;流行款式名称:&amp;nbsp;(.*?)&lt;/li&gt;",resp)</span><br><span class="line">    popular_name = ''.join(popular_name)</span><br><span class="line">except Exception as e:</span><br><span class="line">    popular_name = ''</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    sell_way = re.findall(r"&lt;li title=.*?&gt;销售渠道类型:&amp;nbsp;(.*?)&lt;/li&gt;",resp)</span><br><span class="line">    sell_way = ''.join(sell_way)</span><br><span class="line">except Exception as e:</span><br><span class="line">    sell_way = ''</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    brand = re.findall(r'title="&amp;nbsp;.*?&gt;品牌:&amp;nbsp;(.*?)&lt;/li&gt;',resp)</span><br><span class="line">    brand = ''.join(brand)</span><br><span class="line">except Exception as e:</span><br><span class="line">    brand = ''</span><br><span class="line">    print(e)</span><br><span class="line">print(place,popular,style,up_time,size,popular_name,sell_way,brand)</span><br></pre></td></tr></tbody></table></figure>

<p>运行截图：</p>
<p><img src="https://img1.imgtp.com/2022/07/20/1AtXFqL3.png" alt="image-20220719213736527"></p>
<h2 id="网页开发者工具源码展示："><a href="#网页开发者工具源码展示：" class="headerlink" title="网页开发者工具源码展示："></a>网页开发者工具源码展示：</h2><p><img src="https://img1.imgtp.com/2022/07/20/XjNIdKxg.png" alt="image-20220719213948250"></p>
<p><img src="https://img1.imgtp.com/2022/07/20/ZscOvUTw.png" alt="image-20220719214014226"></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">import requests</span><br><span class="line">import re,time</span><br><span class="line">from lxml import etree</span><br><span class="line">import mysql.connector</span><br><span class="line">#连接数据库</span><br><span class="line">mydb = mysql.connector.connect(</span><br><span class="line">    host = 'localhost',</span><br><span class="line">    user = 'root',</span><br><span class="line">    password = 'dlq668713',</span><br><span class="line">    database = 'love',</span><br><span class="line">    auth_plugin='mysql_native_password',</span><br><span class="line">)</span><br><span class="line">mycursor = mydb.cursor()</span><br><span class="line">sql = 'INSERT INTO tm_bag (price,sell_num,shop_name,count_num,place, popular, style, up_time, size, popular_name, sell_way, brand) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)'</span><br><span class="line">user_agent_list = [</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1",</span><br><span class="line">        "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1",</span><br><span class="line">        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3",</span><br><span class="line">        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",</span><br><span class="line">        "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 ",</span><br><span class="line">        "(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"</span><br><span class="line">    ]</span><br><span class="line">def get_detail(url):</span><br><span class="line">    headers = {}</span><br><span class="line">    headers['User-Agent'] = random.choice(user_agent_list)</span><br><span class="line">    headers['cookie'] = 'lid=tb9609426962; enc=BH1kwxit6G8cG+yyNm8RGSjGG7Ul6TPPC9cupRd7pcLOTHzbtGjUWvt+y1/lnpq20MnX/L2ib6fxGQgPVPErnDcEfbiBCMvSLjTaVe7Ke+Q=; xlly_s=1; t=1dc717b7817ec57908076132934639cf; tracknick=tb9609426962; lgc=tb9609426962; _tb_token_=e75e6f118fe1f; cookie2=1733e90542b3f845c3ae6495f5805686; dnk=tb9609426962; uc1=cookie21=U+GCWk/7pun3Y5w91g==&amp;existShop=false&amp;cookie14=UoexOtxinA35mw==&amp;cookie15=W5iHLLyFOGW7aA==&amp;cookie16=Vq8l+KCLySLZMFWHxqs8fwqnEw==&amp;pas=0; uc3=id2=UUphw2zWTYMnUcGdIA==&amp;lg2=U+GCWk/75gdr5Q==&amp;nk2=F5RMHyzSuEkCcKo1&amp;vt3=F8dCv4MTXkH24gx6sAo=; uc4=id4=0@U2grGNOhoAYQJI7x06Q9pDUuuKKF/Kxv&amp;nk4=0@FY4HWrWzC/MqtVcYArH9YSEDnCASDHo=; _l_g_=Ug==; unb=2209950509527; cookie1=BYBYyEkdr9rg6r9BkSz4NbO8O9IxtK9O+uxD9+ms0+g=; login=true; cookie17=UUphw2zWTYMnUcGdIA==; _nk_=tb9609426962; sgcookie=E100hATU0w94N3lFcvzLxXKWpFR/t6l5etXuPZwTQZw4C5dK7IMPctrGWC/zr3BN9BMQ8hG+G5eX+4MwnfuJ9a//JxrxaolzbVqljAcBsKt/s8c=; cancelledSubSites=empty; sg=27d; csg=06c4cb83; cna=dxpdG1ujxikCAW416kuUQRzQ; pnm_cku822=098#E1hvUpvUvbZvUpCkvvvvvjiWRLLUQjn8RLSvgjthPmPp6jnmPFLpljlhRF59QjtjR8OCvvpvvhHhRvhvCvvvphvvvpvVvUCvpvvvKvhv8vvvphvvvvvvvvCmpQvvv4vvvhxHvvvC4vvvBZZvvvHZvvCHBpvvvxoUvpvjvpC2p+Lve49Cvv9vvhj2ZnnXsQ9CvhQmp+fVjakK5uyTWDKt5BwsRfwrfuVHR4VzWkZnD70Oj8TZfvDr1EAK5dUf8KBlDf8rejOd+87JViIwaHFXSfpAhC3qVUcn+3mO5jIU29hvCPMMvvv=; _m_h5_tk=b13d35cfa8eba44fe9e718d2ab0a8db6_1658233336473; _m_h5_tk_enc=ca8261f26c330ffca5b111d34d3154c2; isg=BCEhGC7I5yaGiEvRiK1wxZRWMO07zpXAVP9KXYPxaSi06kC8yR5TkOhrTB7sIi34; l=eBSVJC2cL0chG4RGBO5Zlurza77t6BOb8sPzaNbMiInca1rfTHWe_NCHUyYk7dtjgt5FrexPUcfRbdh6JSaLRFkDBeYCKXIpBbvy8e1..; tfstk=cwAfB72iPoqXNDn54tgrQGNAvU5GCBD5yxsyl02dXzRLKfg5f51meWSCAc9gV17OP'</span><br><span class="line">    resp = requests.get(url=url, headers=headers).text</span><br><span class="line">    # print(resp)</span><br><span class="line">    try:</span><br><span class="line">        place = re.findall(r'&lt;li title=.*?&gt;质地:&amp;nbsp;(.*?)&lt;/li&gt;', resp)</span><br><span class="line">        place = ''.join(place)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        place = ''</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        popular = re.findall(r'&lt;li title=.*?&gt;流行元素:&amp;nbsp;(.*?)&lt;/li&gt;', resp)</span><br><span class="line">        popular = ''.join(popular)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        popular = ''</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        up_time = re.findall(r'&lt;li title=.*?&gt;上市时间:&amp;nbsp;(.*?)&lt;/li&gt;', resp)</span><br><span class="line">        up_time = ''.join(up_time)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        up_time = ''</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        style = re.findall(r"&lt;li title=.*?&gt;款式:&amp;nbsp;(.*?)&lt;/li&gt;", resp)</span><br><span class="line">        style = ''.join(style)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        style = ''</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        size = re.findall(r"&lt;li title=.*?&gt;大小:&amp;nbsp;(.*?)&lt;/li&gt;", resp)</span><br><span class="line">        size = ''.join(size)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        size = ''</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        popular_name = re.findall(r"&lt;li title=.*?&gt;流行款式名称:&amp;nbsp;(.*?)&lt;/li&gt;", resp)</span><br><span class="line">        popular_name = ''.join(popular_name)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        popular_name = ''</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        sell_way = re.findall(r"&lt;li title=.*?&gt;适用对象:&amp;nbsp;(.*?)&lt;/li&gt;", resp)</span><br><span class="line">        sell_way = ''.join(sell_way)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        sell_way = ''</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        brand = re.findall(r'title="&amp;nbsp;.*?&gt;品牌:&amp;nbsp;(.*?)&lt;/li&gt;', resp)</span><br><span class="line">        brand = ''.join(brand)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        brand = ''</span><br><span class="line">        print(e)</span><br><span class="line">    return place, popular, style, up_time, size, popular_name, sell_way, brand</span><br><span class="line">def main(n):</span><br><span class="line">    headers = {}</span><br><span class="line">    headers['User-Agent'] = random.choice(user_agent_list)</span><br><span class="line">    headers['cookie'] = r'lid=tb9609426962; enc=BH1kwxit6G8cG+yyNm8RGSjGG7Ul6TPPC9cupRd7pcLOTHzbtGjUWvt+y1/lnpq20MnX/L2ib6fxGQgPVPErnDcEfbiBCMvSLjTaVe7Ke+Q=; xlly_s=1; t=1dc717b7817ec57908076132934639cf; tracknick=tb9609426962; lgc=tb9609426962; _tb_token_=e75e6f118fe1f; cookie2=1733e90542b3f845c3ae6495f5805686; dnk=tb9609426962; uc1=cookie21=U+GCWk/7pun3Y5w91g==&amp;existShop=false&amp;cookie14=UoexOtxinA35mw==&amp;cookie15=W5iHLLyFOGW7aA==&amp;cookie16=Vq8l+KCLySLZMFWHxqs8fwqnEw==&amp;pas=0; uc3=id2=UUphw2zWTYMnUcGdIA==&amp;lg2=U+GCWk/75gdr5Q==&amp;nk2=F5RMHyzSuEkCcKo1&amp;vt3=F8dCv4MTXkH24gx6sAo=; uc4=id4=0@U2grGNOhoAYQJI7x06Q9pDUuuKKF/Kxv&amp;nk4=0@FY4HWrWzC/MqtVcYArH9YSEDnCASDHo=; _l_g_=Ug==; unb=2209950509527; cookie1=BYBYyEkdr9rg6r9BkSz4NbO8O9IxtK9O+uxD9+ms0+g=; login=true; cookie17=UUphw2zWTYMnUcGdIA==; _nk_=tb9609426962; sgcookie=E100hATU0w94N3lFcvzLxXKWpFR/t6l5etXuPZwTQZw4C5dK7IMPctrGWC/zr3BN9BMQ8hG+G5eX+4MwnfuJ9a//JxrxaolzbVqljAcBsKt/s8c=; cancelledSubSites=empty; sg=27d; csg=06c4cb83; cna=dxpdG1ujxikCAW416kuUQRzQ; _med=dw:1280&amp;dh:720&amp;pw:1920&amp;ph:1080&amp;ist:0; _m_h5_tk=b13d35cfa8eba44fe9e718d2ab0a8db6_1658233336473; _m_h5_tk_enc=ca8261f26c330ffca5b111d34d3154c2; res=scroll:990*7119-client:497*561-offset:497*7119-screen:1280*720; pnm_cku822=098#E1hv9QvUvbZvUpCkvvvvvjiWRLLUsjEmRLzZgjYHPmPvgjYWRLLh1jtERsMZlj3EPF9Cvvpvvvvv29hvCPMMvvmUvpvjmvmC9jHCs89Cvv9vvUCCxKeNCf9Cvm9vvvvvphvvvvvvvOCvpv9HvvmmvhCvmhWvvUUvphvUI9vv99CvpvkkmvhvLv2qGvvjn/An3w0AhjHCTWex6fItb9TxfwCl5dUf8z7+kEys+FUp+8c6zEAfwxzXS47BhC3qVUcnDOmOejIUDajxALwpEcqwaNoxdB9vvpvVvvpvvhCvi9hvCvvv9UU=; tfstk=c-iVBV0e_nKqn2gEzuZwCN-KgSaAZD4g8gyToBG54iQc8S4ci2CTEBR_UJBPsrf..; l=eBSVJC2cL0chGz92BO5Zlurza77tBIOb8sPzaNbMiInca69RtF670NCHUYlWSdtjgtfEYetPUcfRbdCq13Upgei9W5lBe82taY96-; isg=BLKy6xf0BBvYPzgk1_DzyOOzA_iUQ7bdA_rZiHyKpmVQD1MJZNN77Mxt_6uzfy51; x5sec=7b22746d616c6c7365617263683b32223a2235646430336337316634366132656461373162303239653737383936393134634349574232355947454b2b42753943457635627636774561447a49794d446b354e5441314d446b314d6a63374d54446a316f536d2b662f2f2f2f3842227d'</span><br><span class="line">    url = 'https://list.tmall.com/search_product.htm?spm=a220m.1000858.0.0.752962bd7xoYBT&amp;s={}&amp;q=%C5%AE%CA%BF%B0%FC&amp;sort=s&amp;style=g&amp;from=mallfp..pc_1_searchbutton&amp;type=pc#J_Filter'.format(n*30)</span><br><span class="line">    # print(url)</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    resp = requests.get(url=url, headers=headers).text</span><br><span class="line">    html = etree.HTML(resp)</span><br><span class="line">    div_list = html.xpath('//div[@class="page"]/div/div[@id="content"]/div/div[@id="J_ItemList"]/div')</span><br><span class="line">    print(len(div_list))</span><br><span class="line">    for i,v in enumerate(div_list):</span><br><span class="line">        print("进来了！！！")</span><br><span class="line">        data = []</span><br><span class="line">        try:</span><br><span class="line">            price = v.xpath('./div/p[@class="productPrice"]/em/text()')</span><br><span class="line">            price = ''.join(price)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            price = ''</span><br><span class="line">            print("no price")</span><br><span class="line">        try:</span><br><span class="line">            sell_num = v.xpath('./div/p[@class="productStatus"]/span/em/text()')</span><br><span class="line">            sell_num = ''.join(sell_num).replace('+','').replace('笔','')</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sell_num = ''</span><br><span class="line">            print("no sell_num")</span><br><span class="line">        try:</span><br><span class="line">            shop_name = v.xpath('./div/div[@class="productShop"]/a/text()')</span><br><span class="line">            shop_name = ''.join(shop_name).replace(r'\n','')</span><br><span class="line">        except Exception as e:</span><br><span class="line">            shop_name = ''</span><br><span class="line">            print("no shop_name")</span><br><span class="line">        try:</span><br><span class="line">            count_num = v.xpath('./div/p[@class="productStatus"]/span/a/text()')</span><br><span class="line">            count_num = ''.join(count_num)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            count_num = ''</span><br><span class="line">            print("no count_num")</span><br><span class="line">        try:</span><br><span class="line">            href = v.xpath('./div/div[@class="productImg-wrap"]/a/@href')</span><br><span class="line">            href = ''.join(href)</span><br><span class="line">            href = r'https:'+href</span><br><span class="line">        except Exception as e:</span><br><span class="line">            href = ''</span><br><span class="line">            print("no href")</span><br><span class="line">        print(href)</span><br><span class="line">        # print(price,sell_num,shop_name,count_num,href)</span><br><span class="line">        try:</span><br><span class="line">            place, popular, style, up_time, size, popular_name, sell_way, brand = get_detail(href)</span><br><span class="line">            if brand == '':</span><br><span class="line">                place, popular, style, up_time, size, popular_name, sell_way, brand = get_detail(href)</span><br><span class="line">            if sell_way == '':</span><br><span class="line">                place, popular, style, up_time, size, popular_name, sell_way, brand = get_detail(href)</span><br><span class="line">            if popular_name == '':</span><br><span class="line">                place, popular, style, up_time, size, popular_name, sell_way, brand = get_detail(href)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print("详情页")</span><br><span class="line">            print(e)</span><br><span class="line">        print(place, popular, style, up_time, size, popular_name, sell_way, brand)</span><br><span class="line">        try:</span><br><span class="line">            data.append(price)</span><br><span class="line">            data.append(sell_num)</span><br><span class="line">            data.append(shop_name)</span><br><span class="line">            data.append(count_num)</span><br><span class="line">            data.append(place)</span><br><span class="line">            data.append(popular)</span><br><span class="line">            data.append(style)</span><br><span class="line">            data.append(up_time)</span><br><span class="line">            data.append(size)</span><br><span class="line">            data.append(popular_name)</span><br><span class="line">            data.append(sell_way)</span><br><span class="line">            data.append(brand)</span><br><span class="line">            data = tuple(data)</span><br><span class="line">            mycursor.execute(sql, data)</span><br><span class="line">            mydb.commit()</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print("添加错误")</span><br><span class="line">            print(e)</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line">    # print(resp)</span><br><span class="line">    print("end!!!")</span><br><span class="line">if __name__ == '__main__':</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    for n in range(1,2):</span><br><span class="line">        try:</span><br><span class="line">            print("正在爬第:"+str(n)+"页")</span><br><span class="line">            main(n)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print("first blood!")</span><br><span class="line">        if(n%14==0):</span><br><span class="line">            time.sleep(60)</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    print("所耗时间：")</span><br><span class="line">    print(t2-t1)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="很尴尬"><a href="#很尴尬" class="headerlink" title="很尴尬"></a>很尴尬</h2><p>详情页的总是有验证码反爬，以后再想想办法吧</p>
<p>目前是这个鬼样子：</p>
<p><img src="https://img1.imgtp.com/2022/07/20/ULq6Bk79.png" alt="image-20220719230132308"></p>
</body></html>]]></content>
      <categories>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序电脑端抓包成功</title>
    <url>/2022/08/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%93%E5%8C%85%E6%88%90%E5%8A%9F/</url>
    <content><![CDATA[<html><head></head><body><h1 id="微信小程序电脑端抓包成功"><a href="#微信小程序电脑端抓包成功" class="headerlink" title="微信小程序电脑端抓包成功"></a>微信小程序电脑端抓包成功</h1><h3 id="1-删除WMPFRuntime下的文件"><a href="#1-删除WMPFRuntime下的文件" class="headerlink" title="1.删除WMPFRuntime下的文件"></a>1.删除WMPFRuntime下的文件</h3><p>通过任务管理器找到该文件，右键打开文件位置，删除文件(记得先关掉vx才能删除)</p>
<p><img src="https://s2.loli.net/2022/08/01/P8SgjxBsalvfIF9.png" alt="image-20220801221221116.png"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C:\Users\hhh\AppData\Roaming\Tencent\WeChat\XPlugin\Plugins\WMPFRuntime</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/08/01/7GxiEdAQc2ODpIb.png" alt="image-20220801221331236.png"></p>
<h2 id="2-重新打开微信进入小程序"><a href="#2-重新打开微信进入小程序" class="headerlink" title="2.重新打开微信进入小程序"></a>2.重新打开微信进入小程序</h2><p>打开小程序后，fiddle就能抓到包了</p>
<p><img src="https://s2.loli.net/2022/08/04/mwxEOZSfNonD5Ga.jpg" alt="image-20220801221626752.png"></p>
<p>小知识点(大佬教的)：小程序登录的原理是通过微信的wxlogin接口获取一个code，然后把code传到后端，后端调用微信的接口将code解成openid(一小程序中用户唯一标识)</p>
<h2 id="3-pycharm中测试"><a href="#3-pycharm中测试" class="headerlink" title="3.pycharm中测试"></a>3.pycharm中测试</h2><p>源代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = 'https://api.shuidichou.com/api/charity/love-home/find-love-help-case-v2'</span><br><span class="line">data = {</span><br><span class="line">    'Host': 'api.shuidichou.com',</span><br><span class="line">    'Connection': 'keep-alive',</span><br><span class="line">    'Content-Length': '102',</span><br><span class="line">    'User-Agent': '',</span><br><span class="line">    'content-type': 'application/x-www-form-urlencoded',</span><br><span class="line">    'Referer': 'https://servicewechat.com/wx6855c0f0e9cbb26e/74/page-frame.html',</span><br><span class="line">    'AuthorizationV2':'',</span><br><span class="line">    'currentPage':2,</span><br><span class="line">    'pageSize':10,</span><br><span class="line">    'thirdType':464</span><br><span class="line">}</span><br><span class="line">res = requests.post(url=url,data=data).json()</span><br><span class="line">print(res)</span><br></pre></td></tr></tbody></table></figure>

<p>效果展示：</p>
<p><img src="https://s2.loli.net/2022/08/01/ZCX6I5KVsPHyY9u.png" alt="image-20220801225401920.png"></p>
</body></html>]]></content>
      <categories>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/06/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<html><head></head><body><p>没有吃饭</p>
</body></html>]]></content>
  </entry>
  <entry>
    <title>微信小程序采集失败原因</title>
    <url>/2022/07/31/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%87%87%E9%9B%86%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<html><head></head><body><h1 id="微信小程序采集失败原因"><a href="#微信小程序采集失败原因" class="headerlink" title="微信小程序采集失败原因"></a>微信小程序采集失败原因</h1><p>现在微信都更新到了7..0以上的版本，使用charles抓包工具已经无法再抓到接口的数据。原因如下：安卓系统 7.0 以下版本，不管微信任意版本，都会信任系统提供的证书<br>安卓系统 7.0 以上版本，微信 7.0 以下版本，微信会信任系统提供的证书<br>安卓系统 7.0 以上版本，微信 7.0 以上版本，微信只信任它自己配置的证书列表</p>
</body></html>]]></content>
      <categories>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作SQL</title>
    <url>/2022/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/</url>
    <content><![CDATA[<html><head></head><body><p>这次编写的内容是数据库SQL的操作实列 以后要是不会直接从这个武器库拿就是</p>
<hr>
<h1 id="实列"><a href="#实列" class="headerlink" title="实列"></a>实列</h1><h3 id="01-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"><a href="#01-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。" class="headerlink" title="01.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"></a>01.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。</h3><p>试列出计算机系所开课程（CS标志）的最高成绩、最低成绩和平均成绩。如果某门课程的成绩不全（即“成绩”中有NULL出现），则该课程不予统计，结果按“课程号”升序排列。正确的SQL语句是</p>
<p><img src="https://img-blog.csdnimg.cn/8c9d734958ed4a8daa3070201f309889.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATG92ZSA2,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 课程号，<span class="built_in">MAX</span>(成绩)，<span class="built_in">MIN</span>(成绩)，<span class="built_in">AVG</span>(成绩) <span class="keyword">FROM</span> 选课</span><br><span class="line"><span class="keyword">WHERE</span> 课程号 <span class="keyword">Like</span> ‘CS<span class="operator">%</span>’ <span class="keyword">GROUP</span> <span class="keyword">BY</span> 课程号 <span class="keyword">HAVING</span> 课程号 <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> 课程号 <span class="keyword">FROM</span> 选课 <span class="keyword">WHERE</span> 成绩 <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 课程号</span><br></pre></td></tr></tbody></table></figure>

<h3 id="02-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"><a href="#02-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。" class="headerlink" title="02.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"></a>02.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。</h3><p>列出最少选修了三门课程的学生姓名。正确的SQL语句是</p>
<p>图片如上所示</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 姓名　<span class="keyword">FROM</span> 学生　<span class="keyword">WHERE</span> 学号 <span class="keyword">IN</span>　</span><br><span class="line">(<span class="keyword">SELECT</span> 学号　<span class="keyword">FROM</span> 选课　<span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号　<span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="03-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"><a href="#03-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。" class="headerlink" title="03.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"></a>03.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。</h3><p>查询缺成绩的学生名及课程号。正确的SQL语句是</p>
<p><img src="https://img-blog.csdnimg.cn/26c14ddd06ce40bb91c54c036c04ce18.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATG92ZSA2,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 姓名，课程号 <span class="keyword">FROM</span> 学生，选课 <span class="keyword">WHERE</span> 学生.学号<span class="operator">=</span>选课.学号 <span class="keyword">AND</span> 成绩 <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="04-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"><a href="#04-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。" class="headerlink" title="04.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"></a>04.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。</h3><p>查询1996年出生的学生姓名及其秋季所修课程的课程号及成绩。正确的SQL语句是</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 姓名，课程号，成绩 <span class="keyword">FROM</span> 学生，选课，课程 <span class="keyword">WHERE</span> 学生.学号<span class="operator">=</span>选课.学号 <span class="keyword">AND</span> 选课.课程号<span class="operator">=</span>课程.课程号 <span class="keyword">AND</span> <span class="keyword">Year</span>(出生日期)<span class="operator">=</span><span class="number">1996</span> <span class="keyword">AND</span> 开课学期<span class="operator">=</span>’秋’</span><br></pre></td></tr></tbody></table></figure>

<h3 id="05-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"><a href="#05-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。" class="headerlink" title="05.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"></a>05.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。</h3><p><img src="https://img-blog.csdnimg.cn/9c2aed7fa5b74fc9b69def057c6812d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATG92ZSA2,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>求既学过“1001”号课，又学过“2002”号课的所有学生的学号。正确的SQL语句是</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 学号　<span class="keyword">FROM</span> 选课　<span class="keyword">WHERE</span> 课号＝‘<span class="number">1001</span>’ <span class="keyword">AND</span></span><br><span class="line">学号 <span class="keyword">IN</span>　(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 学号　<span class="keyword">FROM</span> 选课　<span class="keyword">WHERE</span> 课号＝‘<span class="number">2002</span>’ )</span><br></pre></td></tr></tbody></table></figure>

<p>我的想法是：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 学号 <span class="keyword">FROM</span> 选课 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号 <span class="keyword">HAVING</span> 课号 <span class="operator">=</span><span class="operator">=</span> ‘<span class="number">1001</span>’ <span class="keyword">AND</span> 课号 <span class="operator">=</span><span class="operator">=</span> ‘<span class="number">2002</span>’</span><br></pre></td></tr></tbody></table></figure>

<h3 id="06-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"><a href="#06-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。" class="headerlink" title="06.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"></a>06.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。</h3><p>列出各门课的平均成绩、最高成绩、最低成绩和选课人数。正确的SQL语句是</p>
<p>图片如上所示</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 课号，<span class="built_in">AVG</span>(成绩)，<span class="built_in">MAX</span>(成绩)，<span class="built_in">MIN</span>(成绩)，<span class="built_in">COUNT</span>(学号)　</span><br><span class="line"><span class="keyword">FROM</span> 选课　<span class="keyword">GROUP</span> <span class="keyword">BY</span> 课号</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语02</title>
    <url>/2022/07/06/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD02/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语02"><a href="#英语口语02" class="headerlink" title="英语口语02"></a>英语口语02</h1><h3 id="精算能力"><a href="#精算能力" class="headerlink" title="精算能力"></a>精算能力</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Math can be helpful for balancing your budget,</span><br><span class="line">because...</span><br><span class="line">you will have a good understanding of how to make sure that </span><br><span class="line">your costs are less than the money you have</span><br></pre></td></tr></tbody></table></figure>

<p>balancing your budget 平衡收支</p>
<p>your costs are less than the money you have 收入大于支出</p>
<h3 id="入不敷出"><a href="#入不敷出" class="headerlink" title="入不敷出"></a>入不敷出</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">People who are terrible at math are likely to go into debt</span><br><span class="line">because...</span><br><span class="line">they don't know how much money they have versus how much money they spent.</span><br></pre></td></tr></tbody></table></figure>

<p>go into debt 负债</p>
<h3 id="满足好奇心"><a href="#满足好奇心" class="headerlink" title="满足好奇心"></a>满足好奇心</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Science feeds the natural curiosity,</span><br><span class="line"></span><br><span class="line">for example...</span><br><span class="line"></span><br><span class="line">The curiosity of uncovering why the sun sets in the west,</span><br><span class="line"></span><br><span class="line">why the sky is blue,how fish breathes in water</span><br><span class="line"></span><br><span class="line">and other everyday scenarios</span><br></pre></td></tr></tbody></table></figure>

<p>natural curiosity 好奇心</p>
<p>sun sets in the west 日落西山</p>
<p>everyday scenarios 日常场景</p>
</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>学习口语</title>
    <url>/2022/07/05/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD01/</url>
    <content><![CDATA[<html><head></head><body><h1 id="第一天英语口语"><a href="#第一天英语口语" class="headerlink" title="第一天英语口语"></a>第一天英语口语</h1><p>这些内容是非常好的英语口语资产 能帮助大伙快速起飞</p>
<h3 id="梅花香自苦寒来"><a href="#梅花香自苦寒来" class="headerlink" title="梅花香自苦寒来"></a>梅花香自苦寒来</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">in order to feel alive,</span><br><span class="line">i have to do things that make me feel uncomfortable,</span><br><span class="line">because...</span><br><span class="line">as human beings,</span><br><span class="line">we become who we are through challenges.</span><br></pre></td></tr></tbody></table></figure>

<p>feel alive 有滋有味的活着</p>
<p>do things that make me feel uncomfortable 折磨自己</p>
<p>we become who we are through challenges 高手从磨难中来</p>
<h3 id="培养顿感"><a href="#培养顿感" class="headerlink" title="培养顿感"></a>培养顿感</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">by taking risks,</span><br><span class="line">you will learn to overcome your fears,</span><br><span class="line">for example...</span><br><span class="line">you will likely find that you care less about what people think and about what could go wrong</span><br></pre></td></tr></tbody></table></figure>

<p>overcome your fears 克服恐惧</p>
<p>care less about what people think and about what could go wrong 大心脏</p>
<h3 id="敢拼敢闯"><a href="#敢拼敢闯" class="headerlink" title="敢拼敢闯"></a>敢拼敢闯</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">all successful people have taken risks,failed and picked themselves up,</span><br><span class="line">because they believe that</span><br><span class="line">those who never venture far </span><br><span class="line">will never know might have been if they had tired to do things beyond what they had already mastered.</span><br></pre></td></tr></tbody></table></figure>

<p>taken risks,failed and picked themselves up 屡战屡败</p>
<p>never venture far 不敢越雷池半步</p>
<p>to do things beyond what they had already mastered 勇敢尝试</p>
<h3 id="言传身教"><a href="#言传身教" class="headerlink" title="言传身教"></a>言传身教</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">we want our children to take risks and try things outside their</span><br><span class="line">comfort zones,</span><br><span class="line">but to help them we need to set a good example,</span><br><span class="line">because...</span><br><span class="line">we can't expect our kids to go out and conquer the world</span><br><span class="line">if we are hiding in our room.</span><br></pre></td></tr></tbody></table></figure>

<p>take risks and try things outside their comfort zones 勇敢试错</p>
<p>set a good example 树立榜样</p>
<p>go out and conquer the world 打天下</p>
<p>hiding in the room 龟缩不前</p>
<p><u>这些都是打基础后面会越来越爽,越来越轻松，爽到飞起</u></p>
</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>瑞吉外卖-Day01</title>
    <url>/2022/08/15/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96_day01/</url>
    <content><![CDATA[<html><head></head><body><h1 id="瑞吉外卖-Day01"><a href="#瑞吉外卖-Day01" class="headerlink" title="瑞吉外卖-Day01"></a>瑞吉外卖-Day01</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><h5 id="软件开发整体介绍"><a href="#软件开发整体介绍" class="headerlink" title="软件开发整体介绍"></a>软件开发整体介绍</h5><h5 id="瑞吉外卖项目介绍"><a href="#瑞吉外卖项目介绍" class="headerlink" title="瑞吉外卖项目介绍"></a>瑞吉外卖项目介绍</h5><h5 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h5><h5 id="后台登录功能开发"><a href="#后台登录功能开发" class="headerlink" title="后台登录功能开发"></a>后台登录功能开发</h5><h5 id="后台退出功能开发"><a href="#后台退出功能开发" class="headerlink" title="后台退出功能开发"></a>后台退出功能开发</h5><h2 id="1-软件开发整体介绍"><a href="#1-软件开发整体介绍" class="headerlink" title="1. 软件开发整体介绍"></a>1. 软件开发整体介绍</h2><h5 id="作为一名软件开发工程师-我们需要了解在软件开发过程中的开发流程，-以及软件开发过程中涉及到的"><a href="#作为一名软件开发工程师-我们需要了解在软件开发过程中的开发流程，-以及软件开发过程中涉及到的" class="headerlink" title="作为一名软件开发工程师,我们需要了解在软件开发过程中的开发流程， 以及软件开发过程中涉及到的"></a>作为一名软件开发工程师,我们需要了解在软件开发过程中的开发流程， 以及软件开发过程中涉及到的</h5><h5 id="岗位角色，角色的分工、职责，-并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从"><a href="#岗位角色，角色的分工、职责，-并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从" class="headerlink" title="岗位角色，角色的分工、职责， 并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从"></a>岗位角色，角色的分工、职责， 并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从</h5><h5 id="软件开发流程、角色分工、软件环境-三个方面，来整体上介绍一下软件开发。"><a href="#软件开发流程、角色分工、软件环境-三个方面，来整体上介绍一下软件开发。" class="headerlink" title="软件开发流程、角色分工、软件环境 三个方面，来整体上介绍一下软件开发。"></a>软件开发流程、角色分工、软件环境 三个方面，来整体上介绍一下软件开发。</h5><h2 id="1-1-软件开发流程"><a href="#1-1-软件开发流程" class="headerlink" title="1.1 软件开发流程"></a>1.1 软件开发流程</h2><p><img src="https://s2.loli.net/2022/08/15/XqWAGMn9fDUeoct.png" alt="image-20220815181153178"></p>
<h5 id="1-第-1-阶段-需求分析"><a href="#1-第-1-阶段-需求分析" class="headerlink" title="1). 第 1 阶段: 需求分析"></a>1). 第 1 阶段: 需求分析</h5><h5 id="完成产品原型、需求规格说明书的编写。"><a href="#完成产品原型、需求规格说明书的编写。" class="headerlink" title="完成产品原型、需求规格说明书的编写。"></a>完成产品原型、需求规格说明书的编写。</h5><h5 id="产品原型，一般是通过网页-html-的形式展示当前的页面展示什么样的数据-页面的布局是什么样子"><a href="#产品原型，一般是通过网页-html-的形式展示当前的页面展示什么样的数据-页面的布局是什么样子" class="headerlink" title="产品原型，一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子"></a>产品原型，一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子</h5><h5 id="的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。"><a href="#的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。" class="headerlink" title="的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。"></a>的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。</h5><h5 id="需求规格说明书，-一般来说就是使用-Word-文档来描述当前项目有哪些功能，每一项功能的需求及"><a href="#需求规格说明书，-一般来说就是使用-Word-文档来描述当前项目有哪些功能，每一项功能的需求及" class="headerlink" title="需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及"></a>需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及</h5><h5 id="业务流程是什么样的，都会在文档中描述。"><a href="#业务流程是什么样的，都会在文档中描述。" class="headerlink" title="业务流程是什么样的，都会在文档中描述。"></a>业务流程是什么样的，都会在文档中描述。</h5><h5 id="2-第-2-阶段-设计"><a href="#2-第-2-阶段-设计" class="headerlink" title="2). 第 2 阶段: 设计"></a>2). 第 2 阶段: 设计</h5><h5 id="设计的内容包含-产品设计、UI界面设计、概要设计、详细设计、数据库设计。"><a href="#设计的内容包含-产品设计、UI界面设计、概要设计、详细设计、数据库设计。" class="headerlink" title="设计的内容包含 产品设计、UI界面设计、概要设计、详细设计、数据库设计。"></a>设计的内容包含 产品设计、UI界面设计、概要设计、详细设计、数据库设计。</h5><h5 id="在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到"><a href="#在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到" class="headerlink" title="在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到"></a>在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到</h5><h5 id="哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字"><a href="#哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字" class="headerlink" title="哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字"></a>哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字</h5><h5 id="段，字段类型都会在文档中描述清楚。"><a href="#段，字段类型都会在文档中描述清楚。" class="headerlink" title="段，字段类型都会在文档中描述清楚。"></a>段，字段类型都会在文档中描述清楚。</h5><h5 id="3-第-3-阶段-编码"><a href="#3-第-3-阶段-编码" class="headerlink" title="3). 第 3 阶段: 编码"></a>3). 第 3 阶段: 编码</h5><h5 id="编写项目代码、并完成单元测试。"><a href="#编写项目代码、并完成单元测试。" class="headerlink" title="编写项目代码、并完成单元测试。"></a>编写项目代码、并完成单元测试。</h5><h5 id="作为软件开发工程师，我们主要的工作就是在该阶段，-对分配给我们的模块功能，进行编码实现。编"><a href="#作为软件开发工程师，我们主要的工作就是在该阶段，-对分配给我们的模块功能，进行编码实现。编" class="headerlink" title="作为软件开发工程师，我们主要的工作就是在该阶段， 对分配给我们的模块功能，进行编码实现。编"></a>作为软件开发工程师，我们主要的工作就是在该阶段， 对分配给我们的模块功能，进行编码实现。编</h5><h5 id="码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。"><a href="#码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。" class="headerlink" title="码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。"></a>码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。</h5><h5 id="4-第-4-阶段-测试"><a href="#4-第-4-阶段-测试" class="headerlink" title="4). 第 4 阶段: 测试"></a>4). 第 4 阶段: 测试</h5><h5 id="在该阶段中主要由测试人员-对部署在测试环境的项目进行功能测试-并出具测试报告。"><a href="#在该阶段中主要由测试人员-对部署在测试环境的项目进行功能测试-并出具测试报告。" class="headerlink" title="在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。"></a>在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。</h5><h5 id="5-第-5-阶段-上线运维"><a href="#5-第-5-阶段-上线运维" class="headerlink" title="5). 第 5 阶段: 上线运维"></a>5). 第 5 阶段: 上线运维</h5><h5 id="在项目上线之前，-会由运维人员准备服务器上的软件环境安装、配置，-配置完毕后，-再将我们开发"><a href="#在项目上线之前，-会由运维人员准备服务器上的软件环境安装、配置，-配置完毕后，-再将我们开发" class="headerlink" title="在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发"></a>在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发</h5><h5 id="好的项目，部署在服务器上运行。"><a href="#好的项目，部署在服务器上运行。" class="headerlink" title="好的项目，部署在服务器上运行。"></a>好的项目，部署在服务器上运行。</h5><h5 id="我们作为软件开发工程师，-我们主要的任务是在编码阶段，-但是在一些小的项目组当中，-也会涉及"><a href="#我们作为软件开发工程师，-我们主要的任务是在编码阶段，-但是在一些小的项目组当中，-也会涉及" class="headerlink" title="我们作为软件开发工程师， 我们主要的任务是在编码阶段， 但是在一些小的项目组当中， 也会涉及"></a>我们作为软件开发工程师， 我们主要的任务是在编码阶段， 但是在一些小的项目组当中， 也会涉及</h5><h5 id="到数据库的设计、测试等方面的工作。"><a href="#到数据库的设计、测试等方面的工作。" class="headerlink" title="到数据库的设计、测试等方面的工作。"></a>到数据库的设计、测试等方面的工作。</h5><h3 id="1-2-角色分工"><a href="#1-2-角色分工" class="headerlink" title="1.2 角色分工"></a>1.2 角色分工</h3><p><img src="https://s2.loli.net/2022/08/15/CpOvhBlsnuadbAi.png" alt="image-20220815181218772"></p>
<h5 id="学习了软件开发的流程之后，-我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及"><a href="#学习了软件开发的流程之后，-我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及" class="headerlink" title="学习了软件开发的流程之后， 我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及"></a>学习了软件开发的流程之后， 我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及</h5><h5 id="各个角色的职责分工。"><a href="#各个角色的职责分工。" class="headerlink" title="各个角色的职责分工。"></a>各个角色的职责分工。</h5><h5 id="岗位-x2F-角色-职责-x2F-分工"><a href="#岗位-x2F-角色-职责-x2F-分工" class="headerlink" title="岗位/角色 职责/分工"></a>岗位/角色 职责/分工</h5><h5 id="项目经理-对整个项目负责，任务分配、把控进度"><a href="#项目经理-对整个项目负责，任务分配、把控进度" class="headerlink" title="项目经理 对整个项目负责，任务分配、把控进度"></a>项目经理 对整个项目负责，任务分配、把控进度</h5><h5 id="产品经理-进行需求调研，输出需求调研文档、产品原型等"><a href="#产品经理-进行需求调研，输出需求调研文档、产品原型等" class="headerlink" title="产品经理 进行需求调研，输出需求调研文档、产品原型等"></a>产品经理 进行需求调研，输出需求调研文档、产品原型等</h5><h5 id="UI设计师-根据产品原型输出界面效果图"><a href="#UI设计师-根据产品原型输出界面效果图" class="headerlink" title="UI设计师 根据产品原型输出界面效果图"></a>UI设计师 根据产品原型输出界面效果图</h5><h5 id="架构师-项目整体架构设计、技术选型等"><a href="#架构师-项目整体架构设计、技术选型等" class="headerlink" title="架构师 项目整体架构设计、技术选型等"></a>架构师 项目整体架构设计、技术选型等</h5><h5 id="开发工程师-功能代码实现"><a href="#开发工程师-功能代码实现" class="headerlink" title="开发工程师 功能代码实现"></a>开发工程师 功能代码实现</h5><h5 id="测试工程师-编写测试用例，输出测试报告"><a href="#测试工程师-编写测试用例，输出测试报告" class="headerlink" title="测试工程师 编写测试用例，输出测试报告"></a>测试工程师 编写测试用例，输出测试报告</h5><h5 id="运维工程师-软件环境搭建、项目上线"><a href="#运维工程师-软件环境搭建、项目上线" class="headerlink" title="运维工程师 软件环境搭建、项目上线"></a>运维工程师 软件环境搭建、项目上线</h5><h5 id="上述我们讲解的角色分工-是在一个项目组中比较标准的角色分工-但是在实际的项目中-有一些项"><a href="#上述我们讲解的角色分工-是在一个项目组中比较标准的角色分工-但是在实际的项目中-有一些项" class="headerlink" title="上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工, 但是在实际的项目中, 有一些项"></a>上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工, 但是在实际的项目中, 有一些项</h5><h5 id="目组由于人员配置紧张-可能并没有专门的架构师或测试人员-这个时候可能需要有项目经理或者程"><a href="#目组由于人员配置紧张-可能并没有专门的架构师或测试人员-这个时候可能需要有项目经理或者程" class="headerlink" title="目组由于人员配置紧张, 可能并没有专门的架构师或测试人员, 这个时候可能需要有项目经理或者程"></a>目组由于人员配置紧张, 可能并没有专门的架构师或测试人员, 这个时候可能需要有项目经理或者程</h5><h5 id="序员兼任。"><a href="#序员兼任。" class="headerlink" title="序员兼任。"></a>序员兼任。</h5><h3 id="1-3-软件环境"><a href="#1-3-软件环境" class="headerlink" title="1.3 软件环境"></a>1.3 软件环境</h3><h5 id="在我们日常的软件开发中，会涉及到软件开发中的三套环境，-那么这三套环境分别是-开发环境、测"><a href="#在我们日常的软件开发中，会涉及到软件开发中的三套环境，-那么这三套环境分别是-开发环境、测" class="headerlink" title="在我们日常的软件开发中，会涉及到软件开发中的三套环境， 那么这三套环境分别是: 开发环境、测"></a>在我们日常的软件开发中，会涉及到软件开发中的三套环境， 那么这三套环境分别是: 开发环境、测</h5><h5 id="试环境、生产环境。-接下来，我们分别介绍一下这三套环境的作用和特点。"><a href="#试环境、生产环境。-接下来，我们分别介绍一下这三套环境的作用和特点。" class="headerlink" title="试环境、生产环境。 接下来，我们分别介绍一下这三套环境的作用和特点。"></a>试环境、生产环境。 接下来，我们分别介绍一下这三套环境的作用和特点。</h5><h5 id="1-开发环境-development"><a href="#1-开发环境-development" class="headerlink" title="1). 开发环境(development)"></a>1). 开发环境(development)</h5><h5 id="我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。"><a href="#我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。" class="headerlink" title="我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。"></a>我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。</h5><h5 id="比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地，-也可以安装"><a href="#比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地，-也可以安装" class="headerlink" title="比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地， 也可以安装"></a>比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地， 也可以安装</h5><h5 id="在一台专门的服务器中，-这些应用软件仅仅在软件开发过程中使用，-项目测试、上线时，我们不会使"><a href="#在一台专门的服务器中，-这些应用软件仅仅在软件开发过程中使用，-项目测试、上线时，我们不会使" class="headerlink" title="在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用， 项目测试、上线时，我们不会使"></a>在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用， 项目测试、上线时，我们不会使</h5><h5 id="用这套环境了，这个环境就是开发环境。"><a href="#用这套环境了，这个环境就是开发环境。" class="headerlink" title="用这套环境了，这个环境就是开发环境。"></a>用这套环境了，这个环境就是开发环境。</h5><h5 id="2-测试环境-testing"><a href="#2-测试环境-testing" class="headerlink" title="2). 测试环境(testing)"></a>2). 测试环境(testing)</h5><h5 id="当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务"><a href="#当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务" class="headerlink" title="当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务"></a>当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务</h5><h5 id="器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境，-也就是测试"><a href="#器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境，-也就是测试" class="headerlink" title="器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境， 也就是测试"></a>器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境， 也就是测试</h5><h5 id="环境，用于项目测试，一般外部用户无法访问。"><a href="#环境，用于项目测试，一般外部用户无法访问。" class="headerlink" title="环境，用于项目测试，一般外部用户无法访问。"></a>环境，用于项目测试，一般外部用户无法访问。</h5><h5 id="3-生产环境-production"><a href="#3-生产环境-production" class="headerlink" title="3). 生产环境(production)"></a>3). 生产环境(production)</h5><h5 id="当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对"><a href="#当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对" class="headerlink" title="当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对"></a>当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对</h5><h5 id="外提供服务，这个线上环境也称之为生产环境。"><a href="#外提供服务，这个线上环境也称之为生产环境。" class="headerlink" title="外提供服务，这个线上环境也称之为生产环境。"></a>外提供服务，这个线上环境也称之为生产环境。</h5><h5 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识:"></a>拓展知识:</h5><h5 id="准生产环境-对于有的公司来说，项目功能开发好-并测试通过以后，并不是直接就上生"><a href="#准生产环境-对于有的公司来说，项目功能开发好-并测试通过以后，并不是直接就上生" class="headerlink" title="准生产环境: 对于有的公司来说，项目功能开发好, 并测试通过以后，并不是直接就上生"></a>准生产环境: 对于有的公司来说，项目功能开发好, 并测试通过以后，并不是直接就上生</h5><h5 id="产环境。为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环"><a href="#产环境。为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环" class="headerlink" title="产环境。为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环"></a>产环境。为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环</h5><h5 id="境中-测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的"><a href="#境中-测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的" class="headerlink" title="境中, 测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的"></a>境中, 测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的</h5><h5 id="克隆体，准生产环境的服务器配置-安装的应用软件-JDK、Tomcat、数据库、中间件-…"><a href="#克隆体，准生产环境的服务器配置-安装的应用软件-JDK、Tomcat、数据库、中间件-…" class="headerlink" title="克隆体，准生产环境的服务器配置, 安装的应用软件(JDK、Tomcat、数据库、中间件 …)"></a>克隆体，准生产环境的服务器配置, 安装的应用软件(JDK、Tomcat、数据库、中间件 …)</h5><h5 id="的版本都一样，这种环境也称为-“仿真环境”。"><a href="#的版本都一样，这种环境也称为-“仿真环境”。" class="headerlink" title="的版本都一样，这种环境也称为 “仿真环境”。"></a>的版本都一样，这种环境也称为 “仿真环境”。</h5><h5 id="ps-由于项目的性质和类型不同，有的项目可能不需要这个环境"><a href="#ps-由于项目的性质和类型不同，有的项目可能不需要这个环境" class="headerlink" title="ps.由于项目的性质和类型不同，有的项目可能不需要这个环境"></a>ps.由于项目的性质和类型不同，有的项目可能不需要这个环境</h5><h2 id="2-瑞吉外卖项目介绍"><a href="#2-瑞吉外卖项目介绍" class="headerlink" title="2. 瑞吉外卖项目介绍"></a>2. 瑞吉外卖项目介绍</h2><h5 id="在开发瑞吉外卖这个项目之前，我们需要全方位的来介绍一下当前我们学习的这个项目。接下来，我们"><a href="#在开发瑞吉外卖这个项目之前，我们需要全方位的来介绍一下当前我们学习的这个项目。接下来，我们" class="headerlink" title="在开发瑞吉外卖这个项目之前，我们需要全方位的来介绍一下当前我们学习的这个项目。接下来，我们"></a>在开发瑞吉外卖这个项目之前，我们需要全方位的来介绍一下当前我们学习的这个项目。接下来，我们</h5><h5 id="将从以下的五个方面，-来介绍瑞吉外卖这个项目。"><a href="#将从以下的五个方面，-来介绍瑞吉外卖这个项目。" class="headerlink" title="将从以下的五个方面， 来介绍瑞吉外卖这个项目。"></a>将从以下的五个方面， 来介绍瑞吉外卖这个项目。</h5><p><img src="https://s2.loli.net/2022/08/15/dcH16aKJ8kYoMCU.png" alt="image-20220815181240435"></p>
<h3 id="2-1-项目介绍"><a href="#2-1-项目介绍" class="headerlink" title="2.1 项目介绍"></a>2.1 项目介绍</h3><h5 id="阶段-功能实现"><a href="#阶段-功能实现" class="headerlink" title="阶段 功能实现"></a>阶段 功能实现</h5><h5 id="第一期-主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问"><a href="#第一期-主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问" class="headerlink" title="第一期 主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问"></a>第一期 主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问</h5><h5 id="第二期-主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便"><a href="#第二期-主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便" class="headerlink" title="第二期 主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便"></a>第二期 主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便</h5><h5 id="第三期-主要针对系统进行优化升级，提高系统的访问性能"><a href="#第三期-主要针对系统进行优化升级，提高系统的访问性能" class="headerlink" title="第三期 主要针对系统进行优化升级，提高系统的访问性能"></a>第三期 主要针对系统进行优化升级，提高系统的访问性能</h5><h5 id="本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括-系统管理后台-和"><a href="#本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括-系统管理后台-和" class="headerlink" title="本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括 系统管理后台 和"></a>本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括 系统管理后台 和</h5><h5 id="移动端应用-两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜"><a href="#移动端应用-两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜" class="headerlink" title="移动端应用 两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜"></a>移动端应用 两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜</h5><h5 id="品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加"><a href="#品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加" class="headerlink" title="品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加"></a>品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加</h5><h5 id="购物车、下单等。"><a href="#购物车、下单等。" class="headerlink" title="购物车、下单等。"></a>购物车、下单等。</h5><h5 id="本项目共分为-3-期进行开发："><a href="#本项目共分为-3-期进行开发：" class="headerlink" title="本项目共分为 3 期进行开发："></a>本项目共分为 3 期进行开发：</h5><p><img src="https://s2.loli.net/2022/08/15/au2QrT9yURLHjg3.png" alt="image-20220815181258405"></p>
<h3 id="2-2-产品原型"><a href="#2-2-产品原型" class="headerlink" title="2.2 产品原型"></a>2.2 产品原型</h3><h5 id="产品原型-，就是一款产品成型之前，由产品经理绘制的一个简单的框架，就是将页面的排版布局展现出"><a href="#产品原型-，就是一款产品成型之前，由产品经理绘制的一个简单的框架，就是将页面的排版布局展现出" class="headerlink" title="产品原型 ，就是一款产品成型之前，由产品经理绘制的一个简单的框架，就是将页面的排版布局展现出"></a>产品原型 ，就是一款产品成型之前，由产品经理绘制的一个简单的框架，就是将页面的排版布局展现出</h5><h5 id="来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的"><a href="#来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的" class="headerlink" title="来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的"></a>来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的</h5><h5 id="功能。"><a href="#功能。" class="headerlink" title="功能。"></a>功能。</h5><h5 id="1-管理端"><a href="#1-管理端" class="headerlink" title="1). 管理端"></a>1). 管理端</h5><h5 id="餐饮企业内部员工使用。-主要功能有"><a href="#餐饮企业内部员工使用。-主要功能有" class="headerlink" title="餐饮企业内部员工使用。 主要功能有:"></a>餐饮企业内部员工使用。 主要功能有:</h5><p><img src="https://s2.loli.net/2022/08/15/1zxQPM3bhgLjBXD.png" alt="image-20220815181455476"></p>
<h5 id="2-用户端"><a href="#2-用户端" class="headerlink" title="2). 用户端"></a>2). 用户端</h5><p><img src="https://s2.loli.net/2022/08/15/2l1JboiyKTruckR.png" alt="image-20220815181545849"></p>
<h5 id="移动端应用主要提供给消费者使用。主要功能有"><a href="#移动端应用主要提供给消费者使用。主要功能有" class="headerlink" title="移动端应用主要提供给消费者使用。主要功能有:"></a>移动端应用主要提供给消费者使用。主要功能有:</h5><h5 id="模块-描述"><a href="#模块-描述" class="headerlink" title="模块 描述"></a>模块 描述</h5><h5 id="登录-x2F-退"><a href="#登录-x2F-退" class="headerlink" title="登录/退"></a>登录/退</h5><h5 id="出"><a href="#出" class="headerlink" title="出"></a>出</h5><h5 id="在移动端-用户也需要登录后使用APP进行点餐"><a href="#在移动端-用户也需要登录后使用APP进行点餐" class="headerlink" title="在移动端, 用户也需要登录后使用APP进行点餐"></a>在移动端, 用户也需要登录后使用APP进行点餐</h5><h5 id="点餐-菜"><a href="#点餐-菜" class="headerlink" title="点餐-菜"></a>点餐-菜</h5><h5 id="单"><a href="#单" class="headerlink" title="单"></a>单</h5><h5 id="在点餐界面需要展示出菜品分类-x2F-套餐分类-并根据当前选择的分类加载其中的菜品"><a href="#在点餐界面需要展示出菜品分类-x2F-套餐分类-并根据当前选择的分类加载其中的菜品" class="headerlink" title="在点餐界面需要展示出菜品分类/套餐分类, 并根据当前选择的分类加载其中的菜品"></a>在点餐界面需要展示出菜品分类/套餐分类, 并根据当前选择的分类加载其中的菜品</h5><h5 id="信息-供用户查询选择"><a href="#信息-供用户查询选择" class="headerlink" title="信息, 供用户查询选择"></a>信息, 供用户查询选择</h5><h5 id="点餐-购"><a href="#点餐-购" class="headerlink" title="点餐-购"></a>点餐-购</h5><h5 id="物车"><a href="#物车" class="headerlink" title="物车"></a>物车</h5><h5 id="用户选中的菜品就会加入用户的购物车-主要包含-查询购物车、加入购物车、删除"><a href="#用户选中的菜品就会加入用户的购物车-主要包含-查询购物车、加入购物车、删除" class="headerlink" title="用户选中的菜品就会加入用户的购物车, 主要包含 查询购物车、加入购物车、删除"></a>用户选中的菜品就会加入用户的购物车, 主要包含 查询购物车、加入购物车、删除</h5><h5 id="购物车、清空购物车等功能"><a href="#购物车、清空购物车等功能" class="headerlink" title="购物车、清空购物车等功能"></a>购物车、清空购物车等功能</h5><h5 id="订单支"><a href="#订单支" class="headerlink" title="订单支"></a>订单支</h5><h5 id="付"><a href="#付" class="headerlink" title="付"></a>付</h5><h5 id="用户选完菜品-x2F-套餐后-可以对购物车菜品进行结算支付-这时就需要进行订单的支"><a href="#用户选完菜品-x2F-套餐后-可以对购物车菜品进行结算支付-这时就需要进行订单的支" class="headerlink" title="用户选完菜品/套餐后, 可以对购物车菜品进行结算支付, 这时就需要进行订单的支"></a>用户选完菜品/套餐后, 可以对购物车菜品进行结算支付, 这时就需要进行订单的支</h5><h5 id="付-1"><a href="#付-1" class="headerlink" title="付"></a>付</h5><h5 id="个人信"><a href="#个人信" class="headerlink" title="个人信"></a>个人信</h5><h5 id="息"><a href="#息" class="headerlink" title="息"></a>息</h5><h5 id="在个人中心页面中会展示当前用户的基本信息-用户可以管理收货地址-也可以查"><a href="#在个人中心页面中会展示当前用户的基本信息-用户可以管理收货地址-也可以查" class="headerlink" title="在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址, 也可以查"></a>在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址, 也可以查</h5><h5 id="询历史订单数据"><a href="#询历史订单数据" class="headerlink" title="询历史订单数据"></a>询历史订单数据</h5><h3 id="2-3-技术选型"><a href="#2-3-技术选型" class="headerlink" title="2.3 技术选型"></a>2.3 技术选型</h3><p><img src="https://s2.loli.net/2022/08/15/NPlZcFJ6IOk37LK.png" alt="image-20220815181605439"></p>
<h5 id="关于本项目的技术选型-我们将会从-用户层、网关层、应用层、数据层-这几个方面进行介绍，而对"><a href="#关于本项目的技术选型-我们将会从-用户层、网关层、应用层、数据层-这几个方面进行介绍，而对" class="headerlink" title="关于本项目的技术选型, 我们将会从 用户层、网关层、应用层、数据层 这几个方面进行介绍，而对"></a>关于本项目的技术选型, 我们将会从 用户层、网关层、应用层、数据层 这几个方面进行介绍，而对</h5><h5 id="于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。"><a href="#于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。" class="headerlink" title="于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。"></a>于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。</h5><h5 id="1-用户层"><a href="#1-用户层" class="headerlink" title="1). 用户层"></a>1). 用户层</h5><h5 id="本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue-js、ElementUI等技术。而在构建移"><a href="#本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue-js、ElementUI等技术。而在构建移" class="headerlink" title="本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI等技术。而在构建移"></a>本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI等技术。而在构建移</h5><h5 id="动端应用时，我们会使用到微信小程序。"><a href="#动端应用时，我们会使用到微信小程序。" class="headerlink" title="动端应用时，我们会使用到微信小程序。"></a>动端应用时，我们会使用到微信小程序。</h5><h5 id="2-网关层"><a href="#2-网关层" class="headerlink" title="2). 网关层"></a>2). 网关层</h5><h5 id="Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个"><a href="#Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个" class="headerlink" title="Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个"></a>Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个</h5><h5 id="比较重要的作用：-反向代理和负载均衡，-在进行项目部署时，要实现Tomcat的负载均衡，就可以通"><a href="#比较重要的作用：-反向代理和负载均衡，-在进行项目部署时，要实现Tomcat的负载均衡，就可以通" class="headerlink" title="比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通"></a>比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通</h5><h5 id="过Nginx来实现。"><a href="#过Nginx来实现。" class="headerlink" title="过Nginx来实现。"></a>过Nginx来实现。</h5><h5 id="3-应用层"><a href="#3-应用层" class="headerlink" title="3). 应用层"></a>3). 应用层</h5><h5 id="SpringBoot：-快速构建Spring项目-采用-“约定优于配置”-的思想-简化Spring项目的配置开"><a href="#SpringBoot：-快速构建Spring项目-采用-“约定优于配置”-的思想-简化Spring项目的配置开" class="headerlink" title="SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开"></a>SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开</h5><h5 id="发。"><a href="#发。" class="headerlink" title="发。"></a>发。</h5><h5 id="Spring-统一管理项目中的各种资源-bean-在web开发的各层中都会用到。"><a href="#Spring-统一管理项目中的各种资源-bean-在web开发的各层中都会用到。" class="headerlink" title="Spring: 统一管理项目中的各种资源(bean), 在web开发的各层中都会用到。"></a>Spring: 统一管理项目中的各种资源(bean), 在web开发的各层中都会用到。</h5><h5 id="SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进"><a href="#SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进" class="headerlink" title="SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进"></a>SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进</h5><h5 id="行整合，可以无缝集成。"><a href="#行整合，可以无缝集成。" class="headerlink" title="行整合，可以无缝集成。"></a>行整合，可以无缝集成。</h5><h5 id="SpringSession-主要解决在集群环境下的Session共享问题。"><a href="#SpringSession-主要解决在集群环境下的Session共享问题。" class="headerlink" title="SpringSession: 主要解决在集群环境下的Session共享问题。"></a>SpringSession: 主要解决在集群环境下的Session共享问题。</h5><h5 id="lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的"><a href="#lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的" class="headerlink" title="lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的"></a>lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的</h5><h5 id="javabean，都需要花时间去添加相应的getter-x2F-setter，也许还要去写构造器、equals等方法。"><a href="#javabean，都需要花时间去添加相应的getter-x2F-setter，也许还要去写构造器、equals等方法。" class="headerlink" title="javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法。"></a>javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法。</h5><h5 id="Swagger：-可以自动的帮助开发人员生成接口文档，并对接口进行测试。"><a href="#Swagger：-可以自动的帮助开发人员生成接口文档，并对接口进行测试。" class="headerlink" title="Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。"></a>Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。</h5><h5 id="4-数据层"><a href="#4-数据层" class="headerlink" title="4). 数据层"></a>4). 数据层</h5><h5 id="MySQL：-关系型数据库-本项目的核心业务数据都会采用MySQL进行存储。"><a href="#MySQL：-关系型数据库-本项目的核心业务数据都会采用MySQL进行存储。" class="headerlink" title="MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。"></a>MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。</h5><h5 id="MybatisPlus：-本项目持久层将会使用MybatisPlus来简化开发-基本的单表增删改查直接调用框"><a href="#MybatisPlus：-本项目持久层将会使用MybatisPlus来简化开发-基本的单表增删改查直接调用框" class="headerlink" title="MybatisPlus： 本项目持久层将会使用MybatisPlus来简化开发, 基本的单表增删改查直接调用框"></a>MybatisPlus： 本项目持久层将会使用MybatisPlus来简化开发, 基本的单表增删改查直接调用框</h5><h5 id="架提供的方法即可。"><a href="#架提供的方法即可。" class="headerlink" title="架提供的方法即可。"></a>架提供的方法即可。</h5><h5 id="Redis：-基于key-value格式存储的内存数据库-访问速度快-经常使用它做缓存-降低数据库访问"><a href="#Redis：-基于key-value格式存储的内存数据库-访问速度快-经常使用它做缓存-降低数据库访问" class="headerlink" title="Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存(降低数据库访问"></a>Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存(降低数据库访问</h5><h5 id="压力-提供访问效率-在后面的性能优化中会使用。"><a href="#压力-提供访问效率-在后面的性能优化中会使用。" class="headerlink" title="压力, 提供访问效率), 在后面的性能优化中会使用。"></a>压力, 提供访问效率), 在后面的性能优化中会使用。</h5><h5 id="5-工具"><a href="#5-工具" class="headerlink" title="5). 工具"></a>5). 工具</h5><h5 id="git-版本控制工具-在团队协作中-使用该工具对项目中的代码进行管理。"><a href="#git-版本控制工具-在团队协作中-使用该工具对项目中的代码进行管理。" class="headerlink" title="git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。"></a>git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。</h5><h5 id="maven-项目构建工具。"><a href="#maven-项目构建工具。" class="headerlink" title="maven: 项目构建工具。"></a>maven: 项目构建工具。</h5><h5 id="junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。"><a href="#junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。" class="headerlink" title="junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。"></a>junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。</h5><h3 id="2-4-功能架构"><a href="#2-4-功能架构" class="headerlink" title="2.4 功能架构"></a>2.4 功能架构</h3><p><img src="https://s2.loli.net/2022/08/15/VKvEQTPncJ51hNp.png" alt="image-20220815181648383"></p>
<h5 id="角色-权限操作"><a href="#角色-权限操作" class="headerlink" title="角色 权限操作"></a>角色 权限操作</h5><h5 id="后台系统管理员-登录后台管理系统，拥有后台系统中的所有操作权限"><a href="#后台系统管理员-登录后台管理系统，拥有后台系统中的所有操作权限" class="headerlink" title="后台系统管理员 登录后台管理系统，拥有后台系统中的所有操作权限"></a>后台系统管理员 登录后台管理系统，拥有后台系统中的所有操作权限</h5><h5 id="后台系统普通员工-登录后台管理系统，对菜品、套餐、订单等进行管理-不包含员工管理"><a href="#后台系统普通员工-登录后台管理系统，对菜品、套餐、订单等进行管理-不包含员工管理" class="headerlink" title="后台系统普通员工 登录后台管理系统，对菜品、套餐、订单等进行管理 (不包含员工管理)"></a>后台系统普通员工 登录后台管理系统，对菜品、套餐、订单等进行管理 (不包含员工管理)</h5><h5 id="C端用户-登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等"><a href="#C端用户-登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等" class="headerlink" title="C端用户 登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等"></a>C端用户 登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等</h5><h5 id="1-移动端前台功能"><a href="#1-移动端前台功能" class="headerlink" title="1). 移动端前台功能"></a>1). 移动端前台功能</h5><h5 id="手机号登录-微信登录-收件人地址管理-用户历史订单查询-菜品规格查询-购物车功能"><a href="#手机号登录-微信登录-收件人地址管理-用户历史订单查询-菜品规格查询-购物车功能" class="headerlink" title="手机号登录 , 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能"></a>手机号登录 , 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能</h5><h5 id="下单-分类及菜品浏览。"><a href="#下单-分类及菜品浏览。" class="headerlink" title=", 下单 , 分类及菜品浏览。"></a>, 下单 , 分类及菜品浏览。</h5><h5 id="2-系统管理后台功能"><a href="#2-系统管理后台功能" class="headerlink" title="2). 系统管理后台功能"></a>2). 系统管理后台功能</h5><h5 id="员工登录-x2F-退出-员工信息管理-分类管理-菜品管理-套餐管理-菜品口味管理-订单管"><a href="#员工登录-x2F-退出-员工信息管理-分类管理-菜品管理-套餐管理-菜品口味管理-订单管" class="headerlink" title="员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管"></a>员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管</h5><h5 id="理-。"><a href="#理-。" class="headerlink" title="理 。"></a>理 。</h5><h3 id="2-5-角色"><a href="#2-5-角色" class="headerlink" title="2.5 角色"></a>2.5 角色</h3><h5 id="在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色：-后台系统管理员、后台系统"><a href="#在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色：-后台系统管理员、后台系统" class="headerlink" title="在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色： 后台系统管理员、后台系统"></a>在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色： 后台系统管理员、后台系统</h5><h5 id="普通员工、C端-移动端-用户。"><a href="#普通员工、C端-移动端-用户。" class="headerlink" title="普通员工、C端(移动端)用户。"></a>普通员工、C端(移动端)用户。</h5><p><img src="https://s2.loli.net/2022/08/15/nEwsjVAWSpoCd3x.png" alt="image-20220815181732164"></p>
<h2 id="3-开发环境搭建"><a href="#3-开发环境搭建" class="headerlink" title="3. 开发环境搭建"></a>3. 开发环境搭建</h2><h3 id="3-1-数据库环境搭建"><a href="#3-1-数据库环境搭建" class="headerlink" title="3.1 数据库环境搭建"></a>3.1 数据库环境搭建</h3><h4 id="3-1-1-创建数据库"><a href="#3-1-1-创建数据库" class="headerlink" title="3.1.1 创建数据库"></a>3.1.1 创建数据库</h4><h5 id="可以通过以下两种方式中的任意一种-来创建项目的数据库"><a href="#可以通过以下两种方式中的任意一种-来创建项目的数据库" class="headerlink" title="可以通过以下两种方式中的任意一种, 来创建项目的数据库:"></a>可以通过以下两种方式中的任意一种, 来创建项目的数据库:</h5><h5 id="1-图形界面"><a href="#1-图形界面" class="headerlink" title="1).图形界面"></a>1).图形界面</h5><h5 id="注意-本项目数据库的字符串-选择-utf8mb"><a href="#注意-本项目数据库的字符串-选择-utf8mb" class="headerlink" title="注意: 本项目数据库的字符串, 选择 utf8mb"></a>注意: 本项目数据库的字符串, 选择 utf8mb</h5><h5 id="2-命令行"><a href="#2-命令行" class="headerlink" title="2).命令行"></a>2).命令行</h5><h4 id="3-1-2-数据库表导入"><a href="#3-1-2-数据库表导入" class="headerlink" title="3.1.2 数据库表导入"></a>3.1.2 数据库表导入</h4><h5 id="项目的数据库创建好了之后-可以直接将-资料-x2F-数据模型-x2F-db-reggie-sql-直接导入到数据库中"><a href="#项目的数据库创建好了之后-可以直接将-资料-x2F-数据模型-x2F-db-reggie-sql-直接导入到数据库中" class="headerlink" title="项目的数据库创建好了之后, 可以直接将 资料/数据模型/db_reggie.sql 直接导入到数据库中,"></a>项目的数据库创建好了之后, 可以直接将 资料/数据模型/db_reggie.sql 直接导入到数据库中,</h5><h5 id="也可以通过两种方式实现"><a href="#也可以通过两种方式实现" class="headerlink" title="也可以通过两种方式实现:"></a>也可以通过两种方式实现:</h5><h5 id="1-图形界面-1"><a href="#1-图形界面-1" class="headerlink" title="1).图形界面"></a>1).图形界面</h5><h5 id="2-命令行-1"><a href="#2-命令行-1" class="headerlink" title="2).命令行"></a>2).命令行</h5><h5 id="注意-通过命令导入表结构时，注意sql文件不要放在中文目录中"><a href="#注意-通过命令导入表结构时，注意sql文件不要放在中文目录中" class="headerlink" title="注意: 通过命令导入表结构时，注意sql文件不要放在中文目录中"></a>注意: 通过命令导入表结构时，注意sql文件不要放在中文目录中</h5><h4 id="3-1-3-数据库表介绍"><a href="#3-1-3-数据库表介绍" class="headerlink" title="3.1.3 数据库表介绍"></a>3.1.3 数据库表介绍</h4><h5 id="数据库表导入之后-接下来介绍一下本项目中所涉及到的表结构"><a href="#数据库表导入之后-接下来介绍一下本项目中所涉及到的表结构" class="headerlink" title="数据库表导入之后, 接下来介绍一下本项目中所涉及到的表结构:"></a>数据库表导入之后, 接下来介绍一下本项目中所涉及到的表结构:</h5><h5 id="序号-表名-说明"><a href="#序号-表名-说明" class="headerlink" title="序号 表名 说明"></a>序号 表名 说明</h5><h5 id="1-employee-员工表"><a href="#1-employee-员工表" class="headerlink" title="1 employee 员工表"></a>1 employee 员工表</h5><h5 id="2-category-菜品和套餐分类表"><a href="#2-category-菜品和套餐分类表" class="headerlink" title="2 category 菜品和套餐分类表"></a>2 category 菜品和套餐分类表</h5><h5 id="3-dish-菜品表"><a href="#3-dish-菜品表" class="headerlink" title="3 dish 菜品表"></a>3 dish 菜品表</h5><h5 id="4-setmeal-套餐表"><a href="#4-setmeal-套餐表" class="headerlink" title="4 setmeal 套餐表"></a>4 setmeal 套餐表</h5><h5 id="5-setmeal-dish-套餐菜品关系表"><a href="#5-setmeal-dish-套餐菜品关系表" class="headerlink" title="5 setmeal_dish 套餐菜品关系表"></a>5 setmeal_dish 套餐菜品关系表</h5><h5 id="6-dish-flavor-菜品口味关系表"><a href="#6-dish-flavor-菜品口味关系表" class="headerlink" title="6 dish_flavor 菜品口味关系表"></a>6 dish_flavor 菜品口味关系表</h5><h5 id="7-user-用户表（C端）"><a href="#7-user-用户表（C端）" class="headerlink" title="7 user 用户表（C端）"></a>7 user 用户表（C端）</h5><h5 id="8-address-book-地址簿表"><a href="#8-address-book-地址簿表" class="headerlink" title="8 address_book 地址簿表"></a>8 address_book 地址簿表</h5><h5 id="9-shopping-cart-购物车表"><a href="#9-shopping-cart-购物车表" class="headerlink" title="9 shopping_cart 购物车表"></a>9 shopping_cart 购物车表</h5><h5 id="10-orders-订单表"><a href="#10-orders-订单表" class="headerlink" title="10 orders 订单表"></a>10 orders 订单表</h5><h5 id="11-order-detail-订单明细表"><a href="#11-order-detail-订单明细表" class="headerlink" title="11 order_detail 订单明细表"></a>11 order_detail 订单明细表</h5><h5 id="上述的表结构-我们目前先简单的结合页面原型了解一下-大概有那些表-每张表结构中存储什么样"><a href="#上述的表结构-我们目前先简单的结合页面原型了解一下-大概有那些表-每张表结构中存储什么样" class="headerlink" title="上述的表结构, 我们目前先简单的结合页面原型了解一下, 大概有那些表, 每张表结构中存储什么样"></a>上述的表结构, 我们目前先简单的结合页面原型了解一下, 大概有那些表, 每张表结构中存储什么样</h5><h5 id="的数据-有一个印象。对于具体的表结构-以及表结构中的字段-在讲解具体的功能开发时-我们再"><a href="#的数据-有一个印象。对于具体的表结构-以及表结构中的字段-在讲解具体的功能开发时-我们再" class="headerlink" title="的数据, 有一个印象。对于具体的表结构, 以及表结构中的字段, 在讲解具体的功能开发时, 我们再"></a>的数据, 有一个印象。对于具体的表结构, 以及表结构中的字段, 在讲解具体的功能开发时, 我们再</h5><h5 id="详细介绍。"><a href="#详细介绍。" class="headerlink" title="详细介绍。"></a>详细介绍。</h5><h3 id="3-2-Maven项目搭建"><a href="#3-2-Maven项目搭建" class="headerlink" title="3.2 Maven项目搭建"></a>3.2 Maven项目搭建</h3><h4 id="3-2-1-创建maven项目"><a href="#3-2-1-创建maven项目" class="headerlink" title="3.2.1 创建maven项目"></a>3.2.1 创建maven项目</h4><h5 id="1-在idea中创建maven-project-项目名称-reggie-take-out"><a href="#1-在idea中创建maven-project-项目名称-reggie-take-out" class="headerlink" title="1). 在idea中创建maven project, 项目名称 reggie_take_out"></a>1). 在idea中创建maven project, 项目名称 reggie_take_out</h5><p><img src="https://s2.loli.net/2022/08/15/zbgX3lHWFJOPemG.png" alt="image-20220815181857359"></p>
<h5 id="2-检查项目编码"><a href="#2-检查项目编码" class="headerlink" title="2). 检查项目编码"></a>2). 检查项目编码</h5><p><img src="https://s2.loli.net/2022/08/15/KUAHys1IrMVeqpE.png" alt="image-20220815181910429"></p>
<h5 id="3-检查maven配置"><a href="#3-检查maven配置" class="headerlink" title="3). 检查maven配置"></a>3). 检查maven配置</h5><p><img src="https://s2.loli.net/2022/08/15/oj7kn6HOK3ILDlZ.png" alt="image-20220815181925803"></p>
<h5 id="4-检查JDK版本"><a href="#4-检查JDK版本" class="headerlink" title="4). 检查JDK版本"></a>4). 检查JDK版本</h5><p><img src="https://s2.loli.net/2022/08/15/AaCElgjHtBXJe7W.png" alt="image-20220815181937778"></p>
<h5 id="JDK的版本选择1-8"><a href="#JDK的版本选择1-8" class="headerlink" title="JDK的版本选择1.8;"></a>JDK的版本选择1.8;</h5><h4 id="3-2-2-搭建基础环境"><a href="#3-2-2-搭建基础环境" class="headerlink" title="3.2.2 搭建基础环境"></a>3.2.2 搭建基础环境</h4><h5 id="1-在pom-xml中导入依赖"><a href="#1-在pom-xml中导入依赖" class="headerlink" title="1).在pom.xml中导入依赖"></a>1).在pom.xml中导入依赖</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;parent&gt;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.4.5&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.18.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.76&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-在工程的resources目录下创建application-yml文件-并引入配置"><a href="#2-在工程的resources目录下创建application-yml文件-并引入配置" class="headerlink" title="2).在工程的resources目录下创建application.yml文件,并引入配置"></a>2).在工程的resources目录下创建application.yml文件,并引入配置</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;groupId&gt;commons-lang&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-lang&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.23&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.4.5&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">port: 8080</span><br><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">#应用名称 , 可选</span><br><span class="line">name: reggie_take_out</span><br><span class="line">datasource:</span><br><span class="line">druid:</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-创建包-com-itheima-reggie-并编写启动类"><a href="#3-创建包-com-itheima-reggie-并编写启动类" class="headerlink" title="3).创建包 com.itheima.reggie , 并编写启动类"></a>3).创建包 com.itheima.reggie , 并编写启动类</h5><h5 id="Slf4j"><a href="#Slf4j" class="headerlink" title="@Slf4j :"></a>@Slf4j :</h5><h5 id="是lombok中提供的注解-用来通过slf4j记录日志。"><a href="#是lombok中提供的注解-用来通过slf4j记录日志。" class="headerlink" title="是lombok中提供的注解, 用来通过slf4j记录日志。"></a>是lombok中提供的注解, 用来通过slf4j记录日志。</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">url: jdbc:mysql://localhost:3306/reggie?</span><br><span class="line">serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-</span><br><span class="line">8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br><span class="line">username: root</span><br><span class="line">password: root</span><br><span class="line">mybatis-plus:</span><br><span class="line">configuration:</span><br><span class="line">#在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span><br><span class="line">address_book ---&gt; AddressBook</span><br><span class="line">map-underscore-to-camel-case: true</span><br><span class="line">#日志输出</span><br><span class="line">log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">global-config:</span><br><span class="line">db-config:</span><br><span class="line">id-type: ASSIGN_ID</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">@Slf4j</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ReggieApplication {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">log.info("项目启动成功...");</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="当搭建完上述的基础环境之后-就可以通过引导类-启动该项目。"><a href="#当搭建完上述的基础环境之后-就可以通过引导类-启动该项目。" class="headerlink" title="当搭建完上述的基础环境之后, 就可以通过引导类, 启动该项目。"></a>当搭建完上述的基础环境之后, 就可以通过引导类, 启动该项目。</h5><h4 id="3-2-3-前端静态资源导入"><a href="#3-2-3-前端静态资源导入" class="headerlink" title="3.2.3 前端静态资源导入"></a>3.2.3 前端静态资源导入</h4><h5 id="我们作为服务端开发工程师，-我们课程学习的重心应该放在后端的业务代码上，-前端的页面我们只需"><a href="#我们作为服务端开发工程师，-我们课程学习的重心应该放在后端的业务代码上，-前端的页面我们只需" class="headerlink" title="我们作为服务端开发工程师， 我们课程学习的重心应该放在后端的业务代码上， 前端的页面我们只需"></a>我们作为服务端开发工程师， 我们课程学习的重心应该放在后端的业务代码上， 前端的页面我们只需</h5><h5 id="要导入课程资料中的前端资源，-前端页面的代码我们只需要能看懂即可。"><a href="#要导入课程资料中的前端资源，-前端页面的代码我们只需要能看懂即可。" class="headerlink" title="要导入课程资料中的前端资源， 前端页面的代码我们只需要能看懂即可。"></a>要导入课程资料中的前端资源， 前端页面的代码我们只需要能看懂即可。</h5><h5 id="1-导入静态资源"><a href="#1-导入静态资源" class="headerlink" title="1). 导入静态资源"></a>1). 导入静态资源</h5><h5 id="前端资源存放位置为-资料-x2F-前端资源"><a href="#前端资源存放位置为-资料-x2F-前端资源" class="headerlink" title="前端资源存放位置为 资料/前端资源 :"></a>前端资源存放位置为 资料/前端资源 :</h5><h5 id="将上述两个目录中的静态资源文件-导入到项目的resources目录下"><a href="#将上述两个目录中的静态资源文件-导入到项目的resources目录下" class="headerlink" title="将上述两个目录中的静态资源文件, 导入到项目的resources目录下:"></a>将上述两个目录中的静态资源文件, 导入到项目的resources目录下:</h5><p><img src="https://s2.loli.net/2022/08/15/Z368XJPHjKno1UG.png" alt="image-20220815182026354"></p>
<h5 id="2-创建配置类WebMvcConfig，设置静态资源映射"><a href="#2-创建配置类WebMvcConfig，设置静态资源映射" class="headerlink" title="2). 创建配置类WebMvcConfig，设置静态资源映射"></a>2). 创建配置类WebMvcConfig，设置静态资源映射</h5><h5 id="用于在Springboot项目中-默认静态资源的存放目录为-“classpath-x2F-resources-x2F-“"><a href="#用于在Springboot项目中-默认静态资源的存放目录为-“classpath-x2F-resources-x2F-“" class="headerlink" title="用于在Springboot项目中, 默认静态资源的存放目录为 : “classpath:/resources/“,"></a>用于在Springboot项目中, 默认静态资源的存放目录为 : “classpath:/resources/“,</h5><h5 id="“classpath-x2F-static-x2F-“-“classpath-x2F-public-x2F-“-而在我们的项目中静态资源存放在"><a href="#“classpath-x2F-static-x2F-“-“classpath-x2F-public-x2F-“-而在我们的项目中静态资源存放在" class="headerlink" title="“classpath:/static/“, “classpath:/public/“ ; 而在我们的项目中静态资源存放在"></a>“classpath:/static/“, “classpath:/public/“ ; 而在我们的项目中静态资源存放在</h5><h5 id="backend-front-目录中-那么这个时候要想访问到静态资源-就需要设置静态资源映射。"><a href="#backend-front-目录中-那么这个时候要想访问到静态资源-就需要设置静态资源映射。" class="headerlink" title="backend, front 目录中, 那么这个时候要想访问到静态资源, 就需要设置静态资源映射。"></a>backend, front 目录中, 那么这个时候要想访问到静态资源, 就需要设置静态资源映射。</h5><h5 id="3-访问测试"><a href="#3-访问测试" class="headerlink" title="3). 访问测试"></a>3). 访问测试</h5><h5 id="http-localhost-8080-backend-index-html"><a href="#http-localhost-8080-backend-index-html" class="headerlink" title="http://localhost:8080/backend/index.html"></a><a href="http://localhost:8080/backend/index.html">http://localhost:8080/backend/index.html</a></h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line">import</span><br><span class="line">org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line">@Slf4j</span><br><span class="line">@Configuration</span><br><span class="line">public class WebMvcConfig extends WebMvcConfigurationSupport {</span><br><span class="line">/**</span><br><span class="line">* 设置静态资源映射</span><br><span class="line">* @param registry</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">protected void addResourceHandlers(ResourceHandlerRegistry registry) {</span><br><span class="line">log.info("开始进行静态资源映射...");</span><br><span class="line">registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/back</span><br><span class="line">end/");</span><br><span class="line">registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/</span><br><span class="line">");</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-后台系统登录功能"><a href="#4-后台系统登录功能" class="headerlink" title="4. 后台系统登录功能"></a>4. 后台系统登录功能</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><h5 id="1-页面原型展示"><a href="#1-页面原型展示" class="headerlink" title="1). 页面原型展示"></a>1). 页面原型展示</h5><h5 id="2-登录页面成品展示"><a href="#2-登录页面成品展示" class="headerlink" title="2). 登录页面成品展示"></a>2). 登录页面成品展示</h5><p><img src="https://s2.loli.net/2022/08/15/jcg1HmbyWpuaqxr.png" alt="image-20220815182114156"></p>
<h5 id="登录页面存放目录-x2F-resources-x2F-backend-x2F-page-x2F-login-x2F-login-html"><a href="#登录页面存放目录-x2F-resources-x2F-backend-x2F-page-x2F-login-x2F-login-html" class="headerlink" title="登录页面存放目录 /resources/backend/page/login/login.html"></a>登录页面存放目录 /resources/backend/page/login/login.html</h5><h5 id="3-查看登录请求"><a href="#3-查看登录请求" class="headerlink" title="3). 查看登录请求"></a>3). 查看登录请求</h5><p><img src="https://s2.loli.net/2022/08/15/Lvf4xWUthwBJGbO.png" alt="image-20220815182134757"></p>
<h5 id="通过浏览器调试工具（F12），可以发现，点击登录按钮时，页面会发送请求（请求地址为-http-l"><a href="#通过浏览器调试工具（F12），可以发现，点击登录按钮时，页面会发送请求（请求地址为-http-l" class="headerlink" title="通过浏览器调试工具（F12），可以发现，点击登录按钮时，页面会发送请求（请求地址为 http://l"></a>通过浏览器调试工具（F12），可以发现，点击登录按钮时，页面会发送请求（请求地址为 <a href="http://l/">http://l</a></h5><h5 id="ocalhost-8080-x2F-employee-x2F-login-）并提交参数-username和password-请求参数为json格式"><a href="#ocalhost-8080-x2F-employee-x2F-login-）并提交参数-username和password-请求参数为json格式" class="headerlink" title="ocalhost:8080/employee/login ）并提交参数 username和password, 请求参数为json格式"></a>ocalhost:8080/employee/login ）并提交参数 username和password, 请求参数为json格式</h5><h5 id="数据-“username”-”admin”-”password”-”123456”-。"><a href="#数据-“username”-”admin”-”password”-”123456”-。" class="headerlink" title="数据 {“username”:”admin”,”password”:”123456”}。"></a>数据 {“username”:”admin”,”password”:”123456”}。</h5><h5 id="此时报-404-，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处"><a href="#此时报-404-，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处" class="headerlink" title="此时报 404 ，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处"></a>此时报 404 ，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处</h5><h5 id="理登录请求-；"><a href="#理登录请求-；" class="headerlink" title="理登录请求 ；"></a>理登录请求 ；</h5><h5 id="4-数据模型-employee表"><a href="#4-数据模型-employee表" class="headerlink" title="4). 数据模型(employee表)"></a>4). 数据模型(employee表)</h5><p><img src="https://s2.loli.net/2022/08/15/JWnPxeLYiAj1Rwa.png" alt="image-20220815182148542"></p>
<h5 id="5-前端页面分析"><a href="#5-前端页面分析" class="headerlink" title="5). 前端页面分析"></a>5). 前端页面分析</h5><p><img src="https://s2.loli.net/2022/08/15/39NhP5cCOwVf6Ez.png" alt="image-20220815182158908"></p>
<h5 id="当点击-“登录”-按钮-会触发Vue中定义的-handleLogin-方法"><a href="#当点击-“登录”-按钮-会触发Vue中定义的-handleLogin-方法" class="headerlink" title="当点击 “登录” 按钮, 会触发Vue中定义的 handleLogin 方法:"></a>当点击 “登录” 按钮, 会触发Vue中定义的 handleLogin 方法:</h5><h5 id="在上述的前端代码中-大家可以看到-发送登录的异步请求之后-获取到响应结果-在响应结果中至"><a href="#在上述的前端代码中-大家可以看到-发送登录的异步请求之后-获取到响应结果-在响应结果中至" class="headerlink" title="在上述的前端代码中, 大家可以看到, 发送登录的异步请求之后, 获取到响应结果, 在响应结果中至"></a>在上述的前端代码中, 大家可以看到, 发送登录的异步请求之后, 获取到响应结果, 在响应结果中至</h5><h5 id="少包含三个属性-code、data、msg-。"><a href="#少包含三个属性-code、data、msg-。" class="headerlink" title="少包含三个属性: code、data、msg 。"></a>少包含三个属性: code、data、msg 。</h5><h5 id="由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信"><a href="#由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信" class="headerlink" title="由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信"></a>由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信</h5><h5 id="息，存储在客户端的-localStorage-中了。"><a href="#息，存储在客户端的-localStorage-中了。" class="headerlink" title="息，存储在客户端的 localStorage 中了。"></a>息，存储在客户端的 localStorage 中了。</h5><h3 id="4-2-代码开发"><a href="#4-2-代码开发" class="headerlink" title="4.2 代码开发"></a>4.2 代码开发</h3><h4 id="4-2-1-基础准备工作"><a href="#4-2-1-基础准备工作" class="headerlink" title="4.2.1 基础准备工作"></a>4.2.1 基础准备工作</h4><h5 id="在进行登录功能的代码实现之前，-首先在我们的工程下创建包结构："><a href="#在进行登录功能的代码实现之前，-首先在我们的工程下创建包结构：" class="headerlink" title="在进行登录功能的代码实现之前， 首先在我们的工程下创建包结构："></a>在进行登录功能的代码实现之前， 首先在我们的工程下创建包结构：</h5><p><img src="https://s2.loli.net/2022/08/15/l3aZWwX2BOm7qy1.png" alt="image-20220815182230949"></p>
<h5 id="1-创建实体类Employee"><a href="#1-创建实体类Employee" class="headerlink" title="1). 创建实体类Employee"></a>1). 创建实体类Employee</h5><h5 id="该实体类主要用于和员工表-employee-进行映射。-该实体类，-也可以直接从资料-资料-x2F-实体类"><a href="#该实体类主要用于和员工表-employee-进行映射。-该实体类，-也可以直接从资料-资料-x2F-实体类" class="headerlink" title="该实体类主要用于和员工表 employee 进行映射。 该实体类， 也可以直接从资料( 资料/实体类"></a>该实体类主要用于和员工表 employee 进行映射。 该实体类， 也可以直接从资料( 资料/实体类</h5><h5 id="中拷贝工程中。"><a href="#中拷贝工程中。" class="headerlink" title=")中拷贝工程中。"></a>)中拷贝工程中。</h5><h5 id="所属包-com-itheima-reggie-entity"><a href="#所属包-com-itheima-reggie-entity" class="headerlink" title="所属包: com.itheima.reggie.entity"></a>所属包: com.itheima.reggie.entity</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 localStorage.setItem('userInfo',JSON.stringify(res.data))</span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-定义Mapper接口"><a href="#2-定义Mapper接口" class="headerlink" title="2). 定义Mapper接口"></a>2). 定义Mapper接口</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">@Data</span><br><span class="line">public class Employee implements Serializable {</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">private Long id;</span><br><span class="line">private String username;</span><br><span class="line">private String name;</span><br><span class="line">private String password;</span><br><span class="line">private String phone;</span><br><span class="line">private String sex;</span><br><span class="line">private String idNumber; //驼峰命名法 ---&gt; 映射的字段名为 id_number</span><br><span class="line">private Integer status;</span><br><span class="line">private LocalDateTime createTime;</span><br><span class="line">private LocalDateTime updateTime;</span><br><span class="line">@TableField(fill = FieldFill.INSERT)</span><br><span class="line">private Long createUser;</span><br><span class="line">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">private Long updateUser;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="在MybatisPlus中-自定义的Mapper接口-需要继承自-BaseMapper。"><a href="#在MybatisPlus中-自定义的Mapper接口-需要继承自-BaseMapper。" class="headerlink" title="在MybatisPlus中, 自定义的Mapper接口, 需要继承自 BaseMapper。"></a>在MybatisPlus中, 自定义的Mapper接口, 需要继承自 BaseMapper。</h5><h5 id="所属包-com-itheima-reggie-mapper"><a href="#所属包-com-itheima-reggie-mapper" class="headerlink" title="所属包: com.itheima.reggie.mapper"></a>所属包: com.itheima.reggie.mapper</h5><h5 id="3-Service接口"><a href="#3-Service接口" class="headerlink" title="3).Service接口"></a>3).Service接口</h5><h5 id="本项目的Service接口-在定义时需要继承自MybatisPlus提供的Service层接口-IService-这"><a href="#本项目的Service接口-在定义时需要继承自MybatisPlus提供的Service层接口-IService-这" class="headerlink" title="本项目的Service接口, 在定义时需要继承自MybatisPlus提供的Service层接口 IService, 这"></a>本项目的Service接口, 在定义时需要继承自MybatisPlus提供的Service层接口 IService, 这</h5><h5 id="样就可以直接调用-父接口的方法直接执行业务操作-简化业务层代码实现。"><a href="#样就可以直接调用-父接口的方法直接执行业务操作-简化业务层代码实现。" class="headerlink" title="样就可以直接调用 父接口的方法直接执行业务操作, 简化业务层代码实现。"></a>样就可以直接调用 父接口的方法直接执行业务操作, 简化业务层代码实现。</h5><h5 id="所属包-com-itheima-reggie-service"><a href="#所属包-com-itheima-reggie-service" class="headerlink" title="所属包: com.itheima.reggie.service"></a>所属包: com.itheima.reggie.service</h5><h5 id="4-Service实现类"><a href="#4-Service实现类" class="headerlink" title="4). Service实现类"></a>4). Service实现类</h5><h5 id="所属包-com-itheima-reggie-service-impl"><a href="#所属包-com-itheima-reggie-service-impl" class="headerlink" title="所属包: com.itheima.reggie.service.impl"></a>所属包: com.itheima.reggie.service.impl</h5><h5 id="5-Controller基础代码"><a href="#5-Controller基础代码" class="headerlink" title="5). Controller基础代码"></a>5). Controller基础代码</h5><h5 id="所属包-com-itheima-reggie-controller"><a href="#所属包-com-itheima-reggie-controller" class="headerlink" title="所属包: com.itheima.reggie.controller"></a>所属包: com.itheima.reggie.controller</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface EmployeeMapper extends BaseMapper&lt;Employee&gt;{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public interface EmployeeService extends IService&lt;Employee&gt; {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Employee;</span><br><span class="line">import com.itheima.reggie.mapper.EmployeeMapper;</span><br><span class="line">import com.itheima.reggie.service.EmployeeService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">@Service</span><br><span class="line">public class EmployeeServiceImpl extends ServiceImpl&lt;EmployeeMapper,Employee&gt;</span><br><span class="line">implements EmployeeService{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-导入通用结果类R"><a href="#6-导入通用结果类R" class="headerlink" title="6). 导入通用结果类R"></a>6). 导入通用结果类R</h5><h5 id="此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。"><a href="#此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。" class="headerlink" title="此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。"></a>此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。</h5><h5 id="所属包-com-itheima-reggie-common"><a href="#所属包-com-itheima-reggie-common" class="headerlink" title="所属包: com.itheima.reggie.common"></a>所属包: com.itheima.reggie.common</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping("/employee")</span><br><span class="line">public class EmployeeController {</span><br><span class="line">@Autowired</span><br><span class="line">private EmployeeService employeeService;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">/**</span><br><span class="line">* 通用返回结果，服务端响应的数据最终都会封装成此对象</span><br><span class="line">* @param &lt;T&gt;</span><br><span class="line">*/</span><br><span class="line">@Data</span><br><span class="line">public class R&lt;T&gt; {</span><br><span class="line">private Integer code; //编码： 1 成功， 0 和其它数字为失败</span><br><span class="line">private String msg; //错误信息</span><br><span class="line">private T data; //数据</span><br><span class="line">private Map map = new HashMap(); //动态数据</span><br><span class="line">public static &lt;T&gt; R&lt;T&gt; success(T object) {</span><br><span class="line">R&lt;T&gt; r = new R&lt;T&gt;();</span><br><span class="line">r.data = object;</span><br><span class="line">r.code = 1 ;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="A-如果业务执行结果为成功-构建R对象时-只需要调用-success-方法-如果需要返回数据传递"><a href="#A-如果业务执行结果为成功-构建R对象时-只需要调用-success-方法-如果需要返回数据传递" class="headerlink" title="A. 如果业务执行结果为成功, 构建R对象时, 只需要调用 success 方法; 如果需要返回数据传递"></a>A. 如果业务执行结果为成功, 构建R对象时, 只需要调用 success 方法; 如果需要返回数据传递</h5><h5 id="object-参数-如果无需返回-可以直接传递null。"><a href="#object-参数-如果无需返回-可以直接传递null。" class="headerlink" title="object 参数, 如果无需返回, 可以直接传递null。"></a>object 参数, 如果无需返回, 可以直接传递null。</h5><h5 id="B-如果业务执行结果为失败-构建R对象时-只需要调用error-方法-传递错误提示信息即可。"><a href="#B-如果业务执行结果为失败-构建R对象时-只需要调用error-方法-传递错误提示信息即可。" class="headerlink" title="B. 如果业务执行结果为失败, 构建R对象时, 只需要调用error 方法, 传递错误提示信息即可。"></a>B. 如果业务执行结果为失败, 构建R对象时, 只需要调用error 方法, 传递错误提示信息即可。</h5><h4 id="4-2-2-登录逻辑分析"><a href="#4-2-2-登录逻辑分析" class="headerlink" title="4.2.2 登录逻辑分析"></a>4.2.2 登录逻辑分析</h4><p><img src="https://s2.loli.net/2022/08/15/murFP9gxDXwMav2.png" alt="image-20220815182323964"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">return r;</span><br><span class="line">}</span><br><span class="line">public static &lt;T&gt; R&lt;T&gt; error(String msg) {</span><br><span class="line">R r = new R();</span><br><span class="line">r.msg = msg;</span><br><span class="line">r.code = 0 ;</span><br><span class="line">return r;</span><br><span class="line">}</span><br><span class="line">public R&lt;T&gt; add(String key, Object value) {</span><br><span class="line">this.map.put(key, value);</span><br><span class="line">return this;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="处理逻辑如下："><a href="#处理逻辑如下：" class="headerlink" title="处理逻辑如下："></a>处理逻辑如下：</h5><h5 id="①-将页面提交的密码password进行md5加密处理-得到加密后的字符串"><a href="#①-将页面提交的密码password进行md5加密处理-得到加密后的字符串" class="headerlink" title="①. 将页面提交的密码password进行md5加密处理, 得到加密后的字符串"></a>①. 将页面提交的密码password进行md5加密处理, 得到加密后的字符串</h5><h5 id="②-根据页面提交的用户名username查询数据库中员工数据信息"><a href="#②-根据页面提交的用户名username查询数据库中员工数据信息" class="headerlink" title="②. 根据页面提交的用户名username查询数据库中员工数据信息"></a>②. 根据页面提交的用户名username查询数据库中员工数据信息</h5><h5 id="③-如果没有查询到-则返回登录失败结果"><a href="#③-如果没有查询到-则返回登录失败结果" class="headerlink" title="③. 如果没有查询到, 则返回登录失败结果"></a>③. 如果没有查询到, 则返回登录失败结果</h5><h5 id="④-密码比对，如果不一致-则返回登录失败结果"><a href="#④-密码比对，如果不一致-则返回登录失败结果" class="headerlink" title="④. 密码比对，如果不一致, 则返回登录失败结果"></a>④. 密码比对，如果不一致, 则返回登录失败结果</h5><h5 id="⑤-查看员工状态，如果为已禁用状态，则返回员工已禁用结果"><a href="#⑤-查看员工状态，如果为已禁用状态，则返回员工已禁用结果" class="headerlink" title="⑤. 查看员工状态，如果为已禁用状态，则返回员工已禁用结果"></a>⑤. 查看员工状态，如果为已禁用状态，则返回员工已禁用结果</h5><h5 id="⑥-登录成功，将员工id存入Session-并返回登录成功结果"><a href="#⑥-登录成功，将员工id存入Session-并返回登录成功结果" class="headerlink" title="⑥. 登录成功，将员工id存入Session, 并返回登录成功结果"></a>⑥. 登录成功，将员工id存入Session, 并返回登录成功结果</h5><h4 id="4-2-3-代码实现"><a href="#4-2-3-代码实现" class="headerlink" title="4.2.3 代码实现"></a>4.2.3 代码实现</h4><h5 id="技术点说明"><a href="#技术点说明" class="headerlink" title="技术点说明:"></a>技术点说明:</h5><h5 id="A-由于需求分析时-我们看到前端发起的请求为post请求-所以服务端需要使用注解"><a href="#A-由于需求分析时-我们看到前端发起的请求为post请求-所以服务端需要使用注解" class="headerlink" title="A. 由于需求分析时, 我们看到前端发起的请求为post请求, 所以服务端需要使用注解"></a>A. 由于需求分析时, 我们看到前端发起的请求为post请求, 所以服务端需要使用注解</h5><h5 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h5><h5 id="B-由于前端传递的请求参数为json格式的数据-这里使用Employee对象接收-但是将json格式数"><a href="#B-由于前端传递的请求参数为json格式的数据-这里使用Employee对象接收-但是将json格式数" class="headerlink" title="B. 由于前端传递的请求参数为json格式的数据, 这里使用Employee对象接收, 但是将json格式数"></a>B. 由于前端传递的请求参数为json格式的数据, 这里使用Employee对象接收, 但是将json格式数</h5><h5 id="据封装到实体类中-在形参前需要加注解-RequestBody"><a href="#据封装到实体类中-在形参前需要加注解-RequestBody" class="headerlink" title="据封装到实体类中, 在形参前需要加注解@RequestBody"></a>据封装到实体类中, 在形参前需要加注解@RequestBody</h5><h6 id="x2F"><a href="#x2F" class="headerlink" title="/**"></a>/**</h6><h6 id="员工登录"><a href="#员工登录" class="headerlink" title="* 员工登录"></a>* 员工登录</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* @param request</span><br><span class="line">* @param employee</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@PostMapping("/login")</span><br><span class="line">public R&lt;Employee&gt; login(HttpServletRequest request,@RequestBody Employee</span><br><span class="line">employee){</span><br><span class="line">//1、将页面提交的密码password进行md5加密处理</span><br><span class="line">String password = employee.getPassword();</span><br><span class="line">password = DigestUtils.md5DigestAsHex(password.getBytes());</span><br><span class="line">//2、根据页面提交的用户名username查询数据库</span><br><span class="line">LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">queryWrapper.eq(Employee::getUsername,employee.getUsername());</span><br><span class="line">Employee emp = employeeService.getOne(queryWrapper);</span><br><span class="line">//3、如果没有查询到则返回登录失败结果</span><br><span class="line">if(emp == null){</span><br><span class="line">return R.error("登录失败");</span><br><span class="line">}</span><br><span class="line">//4、密码比对，如果不一致则返回登录失败结果</span><br><span class="line">if(!emp.getPassword().equals(password)){</span><br><span class="line">return R.error("登录失败");</span><br><span class="line">}</span><br><span class="line">//5、查看员工状态，如果为已禁用状态，则返回员工已禁用结果</span><br><span class="line">if(emp.getStatus() == 0 ){</span><br><span class="line">return R.error("账号已禁用");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-3-功能测试"><a href="#4-3-功能测试" class="headerlink" title="4.3 功能测试"></a>4.3 功能测试</h3><h5 id="代码实现完毕后-启动项目-访问url-http-localhost-8080-backend-page-login-log"><a href="#代码实现完毕后-启动项目-访问url-http-localhost-8080-backend-page-login-log" class="headerlink" title="代码实现完毕后, 启动项目, 访问url: http://localhost:8080/backend/page/login/log"></a>代码实现完毕后, 启动项目, 访问url: <a href="http://localhost:8080/backend/page/login/log">http://localhost:8080/backend/page/login/log</a></h5><h5 id="in-html-进行登录测试。"><a href="#in-html-进行登录测试。" class="headerlink" title="in.html , 进行登录测试。"></a>in.html , 进行登录测试。</h5><h5 id="在测试过程中，-可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各"><a href="#在测试过程中，-可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各" class="headerlink" title="在测试过程中， 可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各"></a>在测试过程中， 可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各</h5><h5 id="个对象的具体赋值情况。而且需要注意-在测试过程中，需要将所有的情况都覆盖到。"><a href="#个对象的具体赋值情况。而且需要注意-在测试过程中，需要将所有的情况都覆盖到。" class="headerlink" title="个对象的具体赋值情况。而且需要注意, 在测试过程中，需要将所有的情况都覆盖到。"></a>个对象的具体赋值情况。而且需要注意, 在测试过程中，需要将所有的情况都覆盖到。</h5><h5 id="1-问题说明"><a href="#1-问题说明" class="headerlink" title="1). 问题说明"></a>1). 问题说明</h5><h5 id="当我们在进行debug端点调试时-前端可能会出现如下问题-前端页面的控制台报出错误-超时"><a href="#当我们在进行debug端点调试时-前端可能会出现如下问题-前端页面的控制台报出错误-超时" class="headerlink" title="当我们在进行debug端点调试时, 前端可能会出现如下问题: 前端页面的控制台报出错误-超时;"></a>当我们在进行debug端点调试时, 前端可能会出现如下问题: 前端页面的控制台报出错误-超时;</h5><p><img src="https://s2.loli.net/2022/08/15/32pX4FBP61jlDgb.png" alt="image-20220815182406849"></p>
<h5 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2). 解决方案"></a>2). 解决方案</h5><h5 id="前端进行异步请求时-默认超时10000ms-可以将该值调大一些。"><a href="#前端进行异步请求时-默认超时10000ms-可以将该值调大一些。" class="headerlink" title="前端进行异步请求时, 默认超时10000ms , 可以将该值调大一些。"></a>前端进行异步请求时, 默认超时10000ms , 可以将该值调大一些。</h5><p><img src="https://s2.loli.net/2022/08/15/ofyRuihm9N1YSL3.png" alt="image-20220815182418678"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//6、登录成功，将员工id存入Session并返回登录成功结果</span><br><span class="line">request.getSession().setAttribute("employee",emp.getId());</span><br><span class="line">return R.success(emp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。"><a href="#由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。" class="headerlink" title="由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。"></a>由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。</h5><h2 id="5-后台系统退出功能"><a href="#5-后台系统退出功能" class="headerlink" title="5. 后台系统退出功能"></a>5. 后台系统退出功能</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><h5 id="在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面"><a href="#在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面" class="headerlink" title="在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面"></a>在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面</h5><h5 id="backend-x2F-index-html-，此时会在系统的右上角显示当前登录用户的姓名。"><a href="#backend-x2F-index-html-，此时会在系统的右上角显示当前登录用户的姓名。" class="headerlink" title="(backend/index.html)，此时会在系统的右上角显示当前登录用户的姓名。"></a>(backend/index.html)，此时会在系统的右上角显示当前登录用户的姓名。</h5><h5 id="如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。"><a href="#如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。" class="headerlink" title="如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。"></a>如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。</h5><h5 id="1-退出页面展示"><a href="#1-退出页面展示" class="headerlink" title="1). 退出页面展示"></a>1). 退出页面展示</h5><p><img src="https://s2.loli.net/2022/08/15/Zuw7F2hta5y9lxY.png" alt="image-20220815182529818"></p>
<h5 id="2-前端页面分析"><a href="#2-前端页面分析" class="headerlink" title="2).前端页面分析"></a>2).前端页面分析</h5><p><img src="https://s2.loli.net/2022/08/15/3P2g9DMpCwz7WN6.png" alt="image-20220815182542458"></p>
<h5 id="点击-将会调用一个js方法logout-在logout的方法中执行如下逻辑"><a href="#点击-将会调用一个js方法logout-在logout的方法中执行如下逻辑" class="headerlink" title="点击 将会调用一个js方法logout, 在logout的方法中执行如下逻辑:"></a>点击 将会调用一个js方法logout, 在logout的方法中执行如下逻辑:</h5><h5 id="A-发起post请求-调用服务端接口-x2F-employee-x2F-logout-执行退出操作"><a href="#A-发起post请求-调用服务端接口-x2F-employee-x2F-logout-执行退出操作" class="headerlink" title="A. 发起post请求, 调用服务端接口 /employee/logout 执行退出操作 ;"></a>A. 发起post请求, 调用服务端接口 /employee/logout 执行退出操作 ;</h5><h5 id="B-删除客户端-localStorage-中存储的用户登录信息-跳转至登录页面"><a href="#B-删除客户端-localStorage-中存储的用户登录信息-跳转至登录页面" class="headerlink" title="B. 删除客户端 localStorage 中存储的用户登录信息, 跳转至登录页面 ;"></a>B. 删除客户端 localStorage 中存储的用户登录信息, 跳转至登录页面 ;</h5><h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><h5 id="需要在Controller中创建对应的处理方法-接收页面发送的POST请求-x2F-employee-x2F-logout-，具"><a href="#需要在Controller中创建对应的处理方法-接收页面发送的POST请求-x2F-employee-x2F-logout-，具" class="headerlink" title="需要在Controller中创建对应的处理方法, 接收页面发送的POST请求 /employee/logout ，具"></a>需要在Controller中创建对应的处理方法, 接收页面发送的POST请求 /employee/logout ，具</h5><h5 id="体的处理逻辑："><a href="#体的处理逻辑：" class="headerlink" title="体的处理逻辑："></a>体的处理逻辑：</h5><h5 id="A-清理Session中的用户id"><a href="#A-清理Session中的用户id" class="headerlink" title="A. 清理Session中的用户id"></a>A. 清理Session中的用户id</h5><h5 id="B-返回结果"><a href="#B-返回结果" class="headerlink" title="B. 返回结果"></a>B. 返回结果</h5><h3 id="5-3-功能测试"><a href="#5-3-功能测试" class="headerlink" title="5.3 功能测试"></a>5.3 功能测试</h3><h5 id="1-代码实现完毕后-重启服务-访问登录界面-http-localhost-8080-backend-page-lo"><a href="#1-代码实现完毕后-重启服务-访问登录界面-http-localhost-8080-backend-page-lo" class="headerlink" title="1). 代码实现完毕后, 重启服务, 访问登录界面 http://localhost:8080/backend/page/lo"></a>1). 代码实现完毕后, 重启服务, 访问登录界面 <a href="http://localhost:8080/backend/page/lo">http://localhost:8080/backend/page/lo</a></h5><h5 id="gin-x2F-login-html"><a href="#gin-x2F-login-html" class="headerlink" title="gin/login.html ;"></a>gin/login.html ;</h5><h5 id="2-登录完成之后-进入到系统首页-backend-x2F-index-html-点击右上角-按钮-执行退出"><a href="#2-登录完成之后-进入到系统首页-backend-x2F-index-html-点击右上角-按钮-执行退出" class="headerlink" title="2). 登录完成之后, 进入到系统首页 backend/index.html, 点击右上角 按钮 执行退出"></a>2). 登录完成之后, 进入到系统首页 backend/index.html, 点击右上角 按钮 执行退出</h5><h5 id="操作-完成后看看是否可以跳转到登录页面-并检查localStorage。"><a href="#操作-完成后看看是否可以跳转到登录页面-并检查localStorage。" class="headerlink" title="操作, 完成后看看是否可以跳转到登录页面 , 并检查localStorage。"></a>操作, 完成后看看是否可以跳转到登录页面 , 并检查localStorage。</h5><h6 id="x2F-1"><a href="#x2F-1" class="headerlink" title="/**"></a>/**</h6><p><img src="https://s2.loli.net/2022/08/15/nS9RWdL1chFamxC.png" alt="image-20220815182448441"></p>
<h6 id="员工退出"><a href="#员工退出" class="headerlink" title="* 员工退出"></a>* 员工退出</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* @param request</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@PostMapping("/logout")</span><br><span class="line">public R&lt;String&gt; logout(HttpServletRequest request){</span><br><span class="line">//清理Session中保存的当前登录员工的id</span><br><span class="line">request.getSession().removeAttribute("employee");</span><br><span class="line">return R.success("退出成功");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/08/15/yqSvXYUHNwEn827.png" alt="image-20220815182505884"></p>
</body></html>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>瑞吉外卖_day02</title>
    <url>/2022/08/15/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96_day02/</url>
    <content><![CDATA[<html><head></head><body><hr>
<h1 id="瑞吉外卖-Day02"><a href="#瑞吉外卖-Day02" class="headerlink" title="瑞吉外卖-Day02"></a>瑞吉外卖-Day02</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><h5 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h5><h5 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h5><h5 id="员工信息分页查询"><a href="#员工信息分页查询" class="headerlink" title="员工信息分页查询"></a>员工信息分页查询</h5><h5 id="启用-x2F-禁用员工账号"><a href="#启用-x2F-禁用员工账号" class="headerlink" title="启用/禁用员工账号"></a>启用/禁用员工账号</h5><h5 id="编辑员工信息"><a href="#编辑员工信息" class="headerlink" title="编辑员工信息"></a>编辑员工信息</h5><h2 id="1-完善登录功能"><a href="#1-完善登录功能" class="headerlink" title="1. 完善登录功能"></a>1. 完善登录功能</h2><h2 id="1-1-问题分析"><a href="#1-1-问题分析" class="headerlink" title="1.1 问题分析"></a>1.1 问题分析</h2><h5 id="前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个"><a href="#前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个" class="headerlink" title="前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个"></a>前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个</h5><h5 id="这个问题，-以及如何处理。"><a href="#这个问题，-以及如何处理。" class="headerlink" title="这个问题， 以及如何处理。"></a>这个问题， 以及如何处理。</h5><h5 id="1-目前现状"><a href="#1-目前现状" class="headerlink" title="1). 目前现状"></a>1). 目前现状</h5><h5 id="用户如果不登录，直接访问系统首页面，照样可以正常访问。"><a href="#用户如果不登录，直接访问系统首页面，照样可以正常访问。" class="headerlink" title="用户如果不登录，直接访问系统首页面，照样可以正常访问。"></a>用户如果不登录，直接访问系统首页面，照样可以正常访问。</h5><p><img src="https://s2.loli.net/2022/08/17/qPHLyBl1D5wAYtd.png" alt="image-20220815232544699"></p>
<h5 id="2-理想效果"><a href="#2-理想效果" class="headerlink" title="2). 理想效果"></a>2). 理想效果</h5><h5 id="上述这种设计并不合理，我们希望看到的效果应该-是，只有登录成功后才可以访问系统中的页面，如"><a href="#上述这种设计并不合理，我们希望看到的效果应该-是，只有登录成功后才可以访问系统中的页面，如" class="headerlink" title="上述这种设计并不合理，我们希望看到的效果应该 是，只有登录成功后才可以访问系统中的页面，如"></a>上述这种设计并不合理，我们希望看到的效果应该 是，只有登录成功后才可以访问系统中的页面，如</h5><h5 id="果没有登录-访问系统中的任何界面都直接跳转到登录页面。"><a href="#果没有登录-访问系统中的任何界面都直接跳转到登录页面。" class="headerlink" title="果没有登录, 访问系统中的任何界面都直接跳转到登录页面。"></a>果没有登录, 访问系统中的任何界面都直接跳转到登录页面。</h5><p><img src="https://s2.loli.net/2022/08/17/O9eHgxS6WokyG5z.png" alt="image-20220815232809364"></p>
<h5 id="那么，具体应该怎么实现呢？"><a href="#那么，具体应该怎么实现呢？" class="headerlink" title="那么，具体应该怎么实现呢？"></a>那么，具体应该怎么实现呢？</h5><h5 id="可以使用我们之前讲解过的-过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断"><a href="#可以使用我们之前讲解过的-过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断" class="headerlink" title="可以使用我们之前讲解过的 过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断"></a>可以使用我们之前讲解过的 过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断</h5><h5 id="用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。"><a href="#用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。" class="headerlink" title="用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。"></a>用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。</h5><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><img src="https://s2.loli.net/2022/08/17/enC7tQqmYpO1rZM.png" alt="image-20220815232834075"></p>
<h5 id="过滤器具体的处理逻辑如下："><a href="#过滤器具体的处理逻辑如下：" class="headerlink" title="过滤器具体的处理逻辑如下："></a>过滤器具体的处理逻辑如下：</h5><h5 id="A-获取本次请求的URI"><a href="#A-获取本次请求的URI" class="headerlink" title="A. 获取本次请求的URI"></a>A. 获取本次请求的URI</h5><h5 id="B-判断本次请求-是否需要登录-才可以访问"><a href="#B-判断本次请求-是否需要登录-才可以访问" class="headerlink" title="B. 判断本次请求, 是否需要登录, 才可以访问"></a>B. 判断本次请求, 是否需要登录, 才可以访问</h5><h5 id="C-如果不需要，则直接放行"><a href="#C-如果不需要，则直接放行" class="headerlink" title="C. 如果不需要，则直接放行"></a>C. 如果不需要，则直接放行</h5><h5 id="D-判断登录状态，如果已登录，则直接放行"><a href="#D-判断登录状态，如果已登录，则直接放行" class="headerlink" title="D. 判断登录状态，如果已登录，则直接放行"></a>D. 判断登录状态，如果已登录，则直接放行</h5><h5 id="E-如果未登录-则返回未登录结果"><a href="#E-如果未登录-则返回未登录结果" class="headerlink" title="E. 如果未登录, 则返回未登录结果"></a>E. 如果未登录, 则返回未登录结果</h5><h5 id="如果未登录-我们需要给前端返回什么样的结果呢-这个时候-我们可以去看看前端是如何处理的"><a href="#如果未登录-我们需要给前端返回什么样的结果呢-这个时候-我们可以去看看前端是如何处理的" class="headerlink" title="如果未登录,我们需要给前端返回什么样的结果呢? 这个时候, 我们可以去看看前端是如何处理的?"></a>如果未登录,我们需要给前端返回什么样的结果呢? 这个时候, 我们可以去看看前端是如何处理的?</h5><p><img src="https://s2.loli.net/2022/08/17/WtmBjQYwSp8eohu.png" alt="image-20220815232921086"></p>
<h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><h5 id="1-定义登录校验过滤器"><a href="#1-定义登录校验过滤器" class="headerlink" title="1). 定义登录校验过滤器"></a>1). 定义登录校验过滤器</h5><h5 id="自定义一个过滤器-LoginCheckFilter-并实现-Filter-接口-在doFilter方法中完成校验的逻"><a href="#自定义一个过滤器-LoginCheckFilter-并实现-Filter-接口-在doFilter方法中完成校验的逻" class="headerlink" title="自定义一个过滤器 LoginCheckFilter 并实现 Filter 接口, 在doFilter方法中完成校验的逻"></a>自定义一个过滤器 LoginCheckFilter 并实现 Filter 接口, 在doFilter方法中完成校验的逻</h5><h5 id="辑。-那么接下来-我们就根据上述分析的步骤-来完成具体的功能代码实现"><a href="#辑。-那么接下来-我们就根据上述分析的步骤-来完成具体的功能代码实现" class="headerlink" title="辑。 那么接下来, 我们就根据上述分析的步骤, 来完成具体的功能代码实现:"></a>辑。 那么接下来, 我们就根据上述分析的步骤, 来完成具体的功能代码实现:</h5><h5 id="所属包-com-itheima-reggie-filter"><a href="#所属包-com-itheima-reggie-filter" class="headerlink" title="所属包: com.itheima.reggie.filter"></a>所属包: com.itheima.reggie.filter</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.util.AntPathMatcher;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br></pre></td></tr></tbody></table></figure>

<h6 id="x2F"><a href="#x2F" class="headerlink" title="/**"></a>/**</h6><h6 id="检查用户是否已经完成登录"><a href="#检查用户是否已经完成登录" class="headerlink" title="* 检查用户是否已经完成登录"></a>* 检查用户是否已经完成登录</h6><h6 id="x2F-1"><a href="#x2F-1" class="headerlink" title="*/"></a>*/</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")</span><br><span class="line">@Slf4j</span><br><span class="line">public class LoginCheckFilter implements Filter{</span><br><span class="line">//路径匹配器，支持通配符</span><br><span class="line">public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();</span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest servletRequest, ServletResponse</span><br><span class="line">servletResponse, FilterChain filterChain) throws IOException, ServletException {</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line">//1、获取本次请求的URI</span><br><span class="line">String requestURI = request.getRequestURI();// /backend/index.html</span><br><span class="line">log.info("拦截到请求：{}",requestURI);</span><br><span class="line">//定义不需要处理的请求路径</span><br><span class="line">String[] urls = new String[]{</span><br><span class="line">"/employee/login",</span><br><span class="line">"/employee/logout",</span><br><span class="line">"/backend/**",</span><br><span class="line">"/front/**"</span><br><span class="line">};</span><br><span class="line">//2、判断本次请求是否需要处理</span><br><span class="line">boolean check = check(urls, requestURI);</span><br><span class="line">//3、如果不需要处理，则直接放行</span><br><span class="line">if(check){</span><br><span class="line">log.info("本次请求{}不需要处理",requestURI);</span><br><span class="line">filterChain.doFilter(request,response);</span><br><span class="line">return;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="AntPathMatcher-拓展"><a href="#AntPathMatcher-拓展" class="headerlink" title="AntPathMatcher 拓展:"></a>AntPathMatcher 拓展:</h5><h5 id="介绍-Spring中提供的路径匹配器"><a href="#介绍-Spring中提供的路径匹配器" class="headerlink" title="介绍: Spring中提供的路径匹配器 ;"></a>介绍: Spring中提供的路径匹配器 ;</h5><h6 id="x2F-x2F-4、判断登录状态，如果已登录，则直接放行"><a href="#x2F-x2F-4、判断登录状态，如果已登录，则直接放行" class="headerlink" title="//4、判断登录状态，如果已登录，则直接放行"></a>//4、判断登录状态，如果已登录，则直接放行</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(request.getSession().getAttribute(<span class="string">"employee"</span>) != <span class="literal">null</span>){</span><br><span class="line">log.info(<span class="string">"用户已登录，用户id为：</span></span><br><span class="line"><span class="string">{}"</span>,request.getSession().getAttribute(<span class="string">"employee"</span>));</span><br><span class="line">filterChain.doFilter(request,response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">log.info(<span class="string">"用户未登录"</span>);</span><br><span class="line"><span class="comment">//5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据</span></span><br><span class="line">response.getWriter().write(JSON.toJSONString(R.error(<span class="string">"NOTLOGIN"</span>)));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 路径匹配，检查本次请求是否需要放行</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> requestURI</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String[] urls,String requestURI)</span>{</span><br><span class="line"><span class="keyword">for</span> (String url : urls) {</span><br><span class="line"><span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> PATH_MATCHER.match(url, requestURI);</span><br><span class="line"><span class="keyword">if</span>(match){</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-开启组件扫描"><a href="#2-开启组件扫描" class="headerlink" title="2). 开启组件扫描"></a>2). 开启组件扫描</h5><h5 id="需要在引导类上-加上Servlet组件扫描的注解-来扫描过滤器配置的-WebFilter注解，-扫描上"><a href="#需要在引导类上-加上Servlet组件扫描的注解-来扫描过滤器配置的-WebFilter注解，-扫描上" class="headerlink" title="需要在引导类上, 加上Servlet组件扫描的注解, 来扫描过滤器配置的@WebFilter注解， 扫描上"></a>需要在引导类上, 加上Servlet组件扫描的注解, 来扫描过滤器配置的@WebFilter注解， 扫描上</h5><h5 id="之后，-过滤器在运行时就生效了。"><a href="#之后，-过滤器在运行时就生效了。" class="headerlink" title="之后， 过滤器在运行时就生效了。"></a>之后， 过滤器在运行时就生效了。</h5><h5 id="ServletComponentScan-的作用"><a href="#ServletComponentScan-的作用" class="headerlink" title="@ServletComponentScan 的作用:"></a>@ServletComponentScan 的作用:</h5><h5 id="在SpringBoot项目中-在引导类-x2F-配置类上加了该注解后-会自动扫描项目中-当前包及"><a href="#在SpringBoot项目中-在引导类-x2F-配置类上加了该注解后-会自动扫描项目中-当前包及" class="headerlink" title="在SpringBoot项目中, 在引导类/配置类上加了该注解后, 会自动扫描项目中(当前包及"></a>在SpringBoot项目中, 在引导类/配置类上加了该注解后, 会自动扫描项目中(当前包及</h5><h5 id="其子包下-的-WebServlet-WebFilter-WebListener-注解-自动注册Servlet的"><a href="#其子包下-的-WebServlet-WebFilter-WebListener-注解-自动注册Servlet的" class="headerlink" title="其子包下)的@WebServlet , @WebFilter , @WebListener 注解, 自动注册Servlet的"></a>其子包下)的@WebServlet , @WebFilter , @WebListener 注解, 自动注册Servlet的</h5><h5 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件 ;"></a>相关组件 ;</h5><h3 id="1-4-功能测试"><a href="#1-4-功能测试" class="headerlink" title="1.4 功能测试"></a>1.4 功能测试</h3><h5 id="代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后"><a href="#代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后" class="headerlink" title="代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后"></a>代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后</h5><h5 id="看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。"><a href="#看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。" class="headerlink" title="看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。"></a>看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。</h5><p><img src="https://s2.loli.net/2022/08/17/Ggy72Ck3v5uIFxi.png" alt="image-20220815233039881"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@ServletComponentScan</span><br><span class="line">public class ReggieApplication {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">log.info("项目启动成功...");</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="对于前端的代码-也可以进行debug调试。"><a href="#对于前端的代码-也可以进行debug调试。" class="headerlink" title="对于前端的代码, 也可以进行debug调试。"></a>对于前端的代码, 也可以进行debug调试。</h5><h5 id="F12打开浏览器的调试工具-找到我们前面提到的request-js-在request-js的响应拦截器位置打"><a href="#F12打开浏览器的调试工具-找到我们前面提到的request-js-在request-js的响应拦截器位置打" class="headerlink" title="F12打开浏览器的调试工具, 找到我们前面提到的request.js, 在request.js的响应拦截器位置打"></a>F12打开浏览器的调试工具, 找到我们前面提到的request.js, 在request.js的响应拦截器位置打</h5><h5 id="上断点。"><a href="#上断点。" class="headerlink" title="上断点。"></a>上断点。</h5><h2 id="2-新增员工"><a href="#2-新增员工" class="headerlink" title="2. 新增员工"></a>2. 新增员工</h2><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><h5 id="后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击-添加员工-按钮跳转到新增页"><a href="#后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击-添加员工-按钮跳转到新增页" class="headerlink" title="后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击[添加员工]按钮跳转到新增页"></a>后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击[添加员工]按钮跳转到新增页</h5><h5 id="面，如下："><a href="#面，如下：" class="headerlink" title="面，如下："></a>面，如下：</h5><p><img src="https://s2.loli.net/2022/08/17/4qTwDh7dLJRYz8K.png" alt="image-20220815233113163"></p>
<h5 id="当填写完表单信息-点击”保存”按钮后-会提交该表单的数据到服务端-在服务端中需要接受数据"><a href="#当填写完表单信息-点击”保存”按钮后-会提交该表单的数据到服务端-在服务端中需要接受数据" class="headerlink" title="当填写完表单信息, 点击”保存”按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据,"></a>当填写完表单信息, 点击”保存”按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据,</h5><h5 id="然后将数据保存至数据库中。"><a href="#然后将数据保存至数据库中。" class="headerlink" title="然后将数据保存至数据库中。"></a>然后将数据保存至数据库中。</h5><h3 id="2-2-数据模型"><a href="#2-2-数据模型" class="headerlink" title="2.2 数据模型"></a>2.2 数据模型</h3><h5 id="新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。employee表中的status字"><a href="#新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。employee表中的status字" class="headerlink" title="新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。employee表中的status字"></a>新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。employee表中的status字</h5><h5 id="段已经设置了默认值-1-，表示状态正常。"><a href="#段已经设置了默认值-1-，表示状态正常。" class="headerlink" title="段已经设置了默认值 1 ，表示状态正常。"></a>段已经设置了默认值 1 ，表示状态正常。</h5><h5 id="需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必"><a href="#需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必" class="headerlink" title="需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必"></a>需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必</h5><h5 id="须是唯一的。"><a href="#须是唯一的。" class="headerlink" title="须是唯一的。"></a>须是唯一的。</h5><p><img src="https://s2.loli.net/2022/08/17/8J17ijOCNWlGsLm.png" alt="image-20220815233130088"></p>
<p><img src="https://s2.loli.net/2022/08/17/gVrXJCxHmqAwI58.png" alt="image-20220815233200739"></p>
<h3 id="2-3-程序执行流程"><a href="#2-3-程序执行流程" class="headerlink" title="2.3 程序执行流程"></a>2.3 程序执行流程</h3><p><img src="https://s2.loli.net/2022/08/17/1AQzGE2x6Da4UHS.png" alt="image-20220815233226285"></p>
<h5 id="在开发代码之前，我们需要结合着前端页面发起的请求，-梳理一下整个程序的执行过程："><a href="#在开发代码之前，我们需要结合着前端页面发起的请求，-梳理一下整个程序的执行过程：" class="headerlink" title="在开发代码之前，我们需要结合着前端页面发起的请求， 梳理一下整个程序的执行过程："></a>在开发代码之前，我们需要结合着前端页面发起的请求， 梳理一下整个程序的执行过程：</h5><h5 id="A-点击”保存”按钮-页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务"><a href="#A-点击”保存”按钮-页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务" class="headerlink" title="A. 点击”保存”按钮, 页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务"></a>A. 点击”保存”按钮, 页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务</h5><h5 id="端-请求方式POST-请求路径-x2F-employee"><a href="#端-请求方式POST-请求路径-x2F-employee" class="headerlink" title="端, 请求方式POST, 请求路径 /employee"></a>端, 请求方式POST, 请求路径 /employee</h5><h5 id="B-服务端Controller接收页面提交的数据并调用Service将数据进行保存"><a href="#B-服务端Controller接收页面提交的数据并调用Service将数据进行保存" class="headerlink" title="B. 服务端Controller接收页面提交的数据并调用Service将数据进行保存"></a>B. 服务端Controller接收页面提交的数据并调用Service将数据进行保存</h5><h5 id="C-Service调用Mapper操作数据库，保存数据"><a href="#C-Service调用Mapper操作数据库，保存数据" class="headerlink" title="C. Service调用Mapper操作数据库，保存数据"></a>C. Service调用Mapper操作数据库，保存数据</h5><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><h5 id="在EmployeeController中增加save方法-用于保存用户员工信息。"><a href="#在EmployeeController中增加save方法-用于保存用户员工信息。" class="headerlink" title="在EmployeeController中增加save方法, 用于保存用户员工信息。"></a>在EmployeeController中增加save方法, 用于保存用户员工信息。</h5><h5 id="A-在新增员工时，-按钮页面原型中的需求描述，-需要给员工设置初始默认密码-123456-，-并对密"><a href="#A-在新增员工时，-按钮页面原型中的需求描述，-需要给员工设置初始默认密码-123456-，-并对密" class="headerlink" title="A. 在新增员工时， 按钮页面原型中的需求描述， 需要给员工设置初始默认密码 123456 ， 并对密"></a>A. 在新增员工时， 按钮页面原型中的需求描述， 需要给员工设置初始默认密码 123456 ， 并对密</h5><h5 id="码进行MD5加密。"><a href="#码进行MD5加密。" class="headerlink" title="码进行MD5加密。"></a>码进行MD5加密。</h5><h5 id="B-在组装员工信息时-还需要封装创建时间、修改时间，创建人、修改人信息-从session中获取当"><a href="#B-在组装员工信息时-还需要封装创建时间、修改时间，创建人、修改人信息-从session中获取当" class="headerlink" title="B. 在组装员工信息时, 还需要封装创建时间、修改时间，创建人、修改人信息(从session中获取当"></a>B. 在组装员工信息时, 还需要封装创建时间、修改时间，创建人、修改人信息(从session中获取当</h5><h5 id="前登录用户-。"><a href="#前登录用户-。" class="headerlink" title="前登录用户)。"></a>前登录用户)。</h5><h6 id="x2F-2"><a href="#x2F-2" class="headerlink" title="/**"></a>/**</h6><h6 id="新增员工-1"><a href="#新增员工-1" class="headerlink" title="* 新增员工"></a>* 新增员工</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* @param employee</span><br><span class="line">* @return</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-5-功能测试"><a href="#2-5-功能测试" class="headerlink" title="2.5 功能测试"></a>2.5 功能测试</h3><h5 id="代码编写完毕之后，我们需要将工程重启-完毕之后直接访问管理系统首页-点击-“员工管理”-页面"><a href="#代码编写完毕之后，我们需要将工程重启-完毕之后直接访问管理系统首页-点击-“员工管理”-页面" class="headerlink" title="代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 点击 “员工管理” 页面"></a>代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 点击 “员工管理” 页面</h5><h5 id="中的-“添加员工”-按钮-输入员工基本信息-然后点击-“保存”-进行数据保存-保存完毕后-检查"><a href="#中的-“添加员工”-按钮-输入员工基本信息-然后点击-“保存”-进行数据保存-保存完毕后-检查" class="headerlink" title="中的 “添加员工” 按钮, 输入员工基本信息, 然后点击 “保存” 进行数据保存, 保存完毕后, 检查"></a>中的 “添加员工” 按钮, 输入员工基本信息, 然后点击 “保存” 进行数据保存, 保存完毕后, 检查</h5><h5 id="数据库中是否录入员工数据。"><a href="#数据库中是否录入员工数据。" class="headerlink" title="数据库中是否录入员工数据。"></a>数据库中是否录入员工数据。</h5><h5 id="当我们在测试中，添加用户时，-输入了一个已存在的用户名时，前端界面出现错误提示信息："><a href="#当我们在测试中，添加用户时，-输入了一个已存在的用户名时，前端界面出现错误提示信息：" class="headerlink" title="当我们在测试中，添加用户时， 输入了一个已存在的用户名时，前端界面出现错误提示信息："></a>当我们在测试中，添加用户时， 输入了一个已存在的用户名时，前端界面出现错误提示信息：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public R&lt;String&gt; save(HttpServletRequest request,@RequestBody Employee employee){</span><br><span class="line">log.info("新增员工，员工信息：{}",employee.toString());</span><br><span class="line">//设置初始密码 123456 ，需要进行md5加密处理</span><br><span class="line">employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));</span><br><span class="line">employee.setCreateTime(LocalDateTime.now());</span><br><span class="line">employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">//获得当前登录用户的id</span><br><span class="line">Long empId = (Long) request.getSession().getAttribute("employee");</span><br><span class="line">employee.setCreateUser(empId);</span><br><span class="line">employee.setUpdateUser(empId);</span><br><span class="line">employeeService.save(employee);</span><br><span class="line">return R.success("新增员工成功");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/08/17/XCsBb2DSkz8A5WP.png" alt="image-20220815233252657"></p>
<h5 id="而此时，服务端已经报错了，-报错信息如下："><a href="#而此时，服务端已经报错了，-报错信息如下：" class="headerlink" title="而此时，服务端已经报错了， 报错信息如下："></a>而此时，服务端已经报错了， 报错信息如下：</h5><p><img src="https://s2.loli.net/2022/08/17/ADIBryYkwEGFqht.png" alt="image-20220815233320769"></p>
<h5 id="出现上述的错误，-主要就是因为在-employee-表结构中，我们针对于username字段，建立了唯一"><a href="#出现上述的错误，-主要就是因为在-employee-表结构中，我们针对于username字段，建立了唯一" class="headerlink" title="出现上述的错误， 主要就是因为在 employee 表结构中，我们针对于username字段，建立了唯一"></a>出现上述的错误， 主要就是因为在 employee 表结构中，我们针对于username字段，建立了唯一</h5><h5 id="索引，添加重复的username数据时，违背该约束，就会报错。但是此时前端提示的信息并不具体，用"><a href="#索引，添加重复的username数据时，违背该约束，就会报错。但是此时前端提示的信息并不具体，用" class="headerlink" title="索引，添加重复的username数据时，违背该约束，就会报错。但是此时前端提示的信息并不具体，用"></a>索引，添加重复的username数据时，违背该约束，就会报错。但是此时前端提示的信息并不具体，用</h5><h5 id="户并不知道是因为什么原因造成的该异常，我们需要给用户提示详细的错误信息-。"><a href="#户并不知道是因为什么原因造成的该异常，我们需要给用户提示详细的错误信息-。" class="headerlink" title="户并不知道是因为什么原因造成的该异常，我们需要给用户提示详细的错误信息 。"></a>户并不知道是因为什么原因造成的该异常，我们需要给用户提示详细的错误信息 。</h5><h3 id="2-6-全局异常处理"><a href="#2-6-全局异常处理" class="headerlink" title="2.6 全局异常处理"></a>2.6 全局异常处理</h3><h4 id="2-6-1-思路分析"><a href="#2-6-1-思路分析" class="headerlink" title="2.6.1 思路分析"></a>2.6.1 思路分析</h4><h5 id="要想解决上述测试中存在的问题，我们需要对程序中可能出现的异常进行捕获，通常有两种处理方式："><a href="#要想解决上述测试中存在的问题，我们需要对程序中可能出现的异常进行捕获，通常有两种处理方式：" class="headerlink" title="要想解决上述测试中存在的问题，我们需要对程序中可能出现的异常进行捕获，通常有两种处理方式："></a>要想解决上述测试中存在的问题，我们需要对程序中可能出现的异常进行捕获，通常有两种处理方式：</h5><h5 id="A-在Controller方法中加入-try…catch-进行异常捕获"><a href="#A-在Controller方法中加入-try…catch-进行异常捕获" class="headerlink" title="A. 在Controller方法中加入 try…catch 进行异常捕获"></a>A. 在Controller方法中加入 try…catch 进行异常捕获</h5><h5 id="形式如下："><a href="#形式如下：" class="headerlink" title="形式如下："></a>形式如下：</h5><p><img src="https://s2.loli.net/2022/08/17/tx26gePac4BDlYC.png" alt="image-20220815233345903"></p>
<h5 id="如果采用这种方式，虽然可以解决，但是存在弊端，需要我们在保存其他业务数据时，也需要在"><a href="#如果采用这种方式，虽然可以解决，但是存在弊端，需要我们在保存其他业务数据时，也需要在" class="headerlink" title="如果采用这种方式，虽然可以解决，但是存在弊端，需要我们在保存其他业务数据时，也需要在"></a>如果采用这种方式，虽然可以解决，但是存在弊端，需要我们在保存其他业务数据时，也需要在</h5><h5 id="Controller方法中加上try…catch进行处理，代码冗余，不通用。"><a href="#Controller方法中加上try…catch进行处理，代码冗余，不通用。" class="headerlink" title="Controller方法中加上try…catch进行处理，代码冗余，不通用。"></a>Controller方法中加上try…catch进行处理，代码冗余，不通用。</h5><h5 id="B-使用异常处理器进行全局异常捕获"><a href="#B-使用异常处理器进行全局异常捕获" class="headerlink" title="B. 使用异常处理器进行全局异常捕获"></a>B. 使用异常处理器进行全局异常捕获</h5><h5 id="采用这种方式来实现，我们只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有"><a href="#采用这种方式来实现，我们只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有" class="headerlink" title="采用这种方式来实现，我们只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有"></a>采用这种方式来实现，我们只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有</h5><h5 id="异常。"><a href="#异常。" class="headerlink" title="异常。"></a>异常。</h5><h4 id="2-6-2-全局异常处理器"><a href="#2-6-2-全局异常处理器" class="headerlink" title="2.6.2 全局异常处理器"></a>2.6.2 全局异常处理器</h4><h5 id="在项目中自定义一个全局异常处理器，在异常处理器上加上注解-ControllerAdvice-可以通过属"><a href="#在项目中自定义一个全局异常处理器，在异常处理器上加上注解-ControllerAdvice-可以通过属" class="headerlink" title="在项目中自定义一个全局异常处理器，在异常处理器上加上注解 @ControllerAdvice,可以通过属"></a>在项目中自定义一个全局异常处理器，在异常处理器上加上注解 @ControllerAdvice,可以通过属</h5><h5 id="性annotations指定拦截哪一类的Controller方法。-并在异常处理器的方法上加上注解"><a href="#性annotations指定拦截哪一类的Controller方法。-并在异常处理器的方法上加上注解" class="headerlink" title="性annotations指定拦截哪一类的Controller方法。 并在异常处理器的方法上加上注解"></a>性annotations指定拦截哪一类的Controller方法。 并在异常处理器的方法上加上注解</h5><h5 id="ExceptionHandler-来指定拦截的是那一类型的异常。"><a href="#ExceptionHandler-来指定拦截的是那一类型的异常。" class="headerlink" title="@ExceptionHandler 来指定拦截的是那一类型的异常。"></a>@ExceptionHandler 来指定拦截的是那一类型的异常。</h5><h5 id="异常处理方法逻辑"><a href="#异常处理方法逻辑" class="headerlink" title="异常处理方法逻辑:"></a>异常处理方法逻辑:</h5><h5 id="指定捕获的异常类型为-SQLIntegrityConstraintViolationException"><a href="#指定捕获的异常类型为-SQLIntegrityConstraintViolationException" class="headerlink" title="指定捕获的异常类型为 SQLIntegrityConstraintViolationException"></a>指定捕获的异常类型为 SQLIntegrityConstraintViolationException</h5><h5 id="解析异常的提示信息-获取出是那个值违背了唯一约束"><a href="#解析异常的提示信息-获取出是那个值违背了唯一约束" class="headerlink" title="解析异常的提示信息, 获取出是那个值违背了唯一约束"></a>解析异常的提示信息, 获取出是那个值违背了唯一约束</h5><h5 id="组装错误信息并返回"><a href="#组装错误信息并返回" class="headerlink" title="组装错误信息并返回"></a>组装错误信息并返回</h5><p><img src="https://s2.loli.net/2022/08/17/J2GFQsqjkgEVUxW.png" alt="image-20220815233415145"></p>
<h5 id="所属包-com-itheima-reggie-common"><a href="#所属包-com-itheima-reggie-common" class="headerlink" title="所属包: com.itheima.reggie.common"></a>所属包: com.itheima.reggie.common</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import java.sql.SQLIntegrityConstraintViolationException;</span><br><span class="line">/**</span><br><span class="line">* 全局异常处理</span><br><span class="line">*/</span><br><span class="line">@ControllerAdvice(annotations = {RestController.class, Controller.class})</span><br><span class="line">@ResponseBody</span><br><span class="line">@Slf4j</span><br><span class="line">public class GlobalExceptionHandler {</span><br><span class="line">/**</span><br><span class="line">* 异常处理方法</span><br><span class="line">* @return</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>

<h5 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明:"></a>注解说明:</h5><h5 id="上述的全局异常处理器上使用了的两个注解-ControllerAdvice-ResponseBody"><a href="#上述的全局异常处理器上使用了的两个注解-ControllerAdvice-ResponseBody" class="headerlink" title="上述的全局异常处理器上使用了的两个注解 @ControllerAdvice , @ResponseBody"></a>上述的全局异常处理器上使用了的两个注解 @ControllerAdvice , @ResponseBody</h5><h5 id="他们的作用分别为"><a href="#他们的作用分别为" class="headerlink" title=", 他们的作用分别为:"></a>, 他们的作用分别为:</h5><h5 id="ControllerAdvice-指定拦截那些类型的控制器"><a href="#ControllerAdvice-指定拦截那些类型的控制器" class="headerlink" title="@ControllerAdvice : 指定拦截那些类型的控制器;"></a>@ControllerAdvice : 指定拦截那些类型的控制器;</h5><h5 id="ResponseBody-将方法的返回值-R-对象转换为json格式的数据-响应给页面"><a href="#ResponseBody-将方法的返回值-R-对象转换为json格式的数据-响应给页面" class="headerlink" title="@ResponseBody: 将方法的返回值 R 对象转换为json格式的数据, 响应给页面;"></a>@ResponseBody: 将方法的返回值 R 对象转换为json格式的数据, 响应给页面;</h5><h5 id="上述使用的两个注解-也可以合并成为一个注解-RestControllerAdvice"><a href="#上述使用的两个注解-也可以合并成为一个注解-RestControllerAdvice" class="headerlink" title="上述使用的两个注解, 也可以合并成为一个注解 @RestControllerAdvice"></a>上述使用的两个注解, 也可以合并成为一个注解 @RestControllerAdvice</h5><h4 id="2-6-3-测试"><a href="#2-6-3-测试" class="headerlink" title="2.6.3 测试"></a>2.6.3 测试</h4><h5 id="全局异常处理器编写完毕之后，我们需要将项目重启-完毕之后直接访问管理系统首页-点击-“员工"><a href="#全局异常处理器编写完毕之后，我们需要将项目重启-完毕之后直接访问管理系统首页-点击-“员工" class="headerlink" title="全局异常处理器编写完毕之后，我们需要将项目重启, 完毕之后直接访问管理系统首页, 点击 “员工"></a>全局异常处理器编写完毕之后，我们需要将项目重启, 完毕之后直接访问管理系统首页, 点击 “员工</h5><h5 id="管理”-页面中的-“添加员工”-按钮。当我们在测试中，添加用户时，-输入了一个已存在的用户名"><a href="#管理”-页面中的-“添加员工”-按钮。当我们在测试中，添加用户时，-输入了一个已存在的用户名" class="headerlink" title="管理” 页面中的 “添加员工” 按钮。当我们在测试中，添加用户时， 输入了一个已存在的用户名"></a>管理” 页面中的 “添加员工” 按钮。当我们在测试中，添加用户时， 输入了一个已存在的用户名</h5><h5 id="时，前端界面出现如下错误提示信息："><a href="#时，前端界面出现如下错误提示信息：" class="headerlink" title="时，前端界面出现如下错误提示信息："></a>时，前端界面出现如下错误提示信息：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span><br><span class="line">public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException</span><br><span class="line">ex){</span><br><span class="line">log.error(ex.getMessage());</span><br><span class="line">if(ex.getMessage().contains("Duplicate entry")){</span><br><span class="line">String[] split = ex.getMessage().split(" ");</span><br><span class="line">String msg = split[ 2 ] + "已存在";</span><br><span class="line">return R.error(msg);</span><br><span class="line">}</span><br><span class="line">return R.error("未知错误");</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/08/17/fNUnzoHYVE1GOpk.png" alt="image-20220815233447982"></p>
<h2 id="3-员工分页查询"><a href="#3-员工分页查询" class="headerlink" title="3. 员工分页查询"></a>3. 员工分页查询</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p><img src="https://s2.loli.net/2022/08/17/EFCwLpqD4XoW8MK.png" alt="image-20220815233518184"></p>
<h5 id="系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系"><a href="#系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系" class="headerlink" title="系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系"></a>系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系</h5><h5 id="统中都会以分页的方式来展示列表数据。而在我们的分页查询页面中-除了分页条件以外，还有一个查"><a href="#统中都会以分页的方式来展示列表数据。而在我们的分页查询页面中-除了分页条件以外，还有一个查" class="headerlink" title="统中都会以分页的方式来展示列表数据。而在我们的分页查询页面中, 除了分页条件以外，还有一个查"></a>统中都会以分页的方式来展示列表数据。而在我们的分页查询页面中, 除了分页条件以外，还有一个查</h5><h5 id="询条件-“员工姓名”。"><a href="#询条件-“员工姓名”。" class="headerlink" title="询条件 “员工姓名”。"></a>询条件 “员工姓名”。</h5><h5 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h5><h5 id="搜索条件：-员工姓名-模糊查询"><a href="#搜索条件：-员工姓名-模糊查询" class="headerlink" title="搜索条件： 员工姓名(模糊查询)"></a>搜索条件： 员工姓名(模糊查询)</h5><h5 id="分页条件：-每页展示条数-，-页码"><a href="#分页条件：-每页展示条数-，-页码" class="headerlink" title="分页条件： 每页展示条数 ， 页码"></a>分页条件： 每页展示条数 ， 页码</h5><h5 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h5><h5 id="总记录数"><a href="#总记录数" class="headerlink" title="总记录数"></a>总记录数</h5><h5 id="结果列表"><a href="#结果列表" class="headerlink" title="结果列表"></a>结果列表</h5><h3 id="3-2-程序执行流程"><a href="#3-2-程序执行流程" class="headerlink" title="3.2 程序执行流程"></a>3.2 程序执行流程</h3><h4 id="3-2-1-页面流程分析"><a href="#3-2-1-页面流程分析" class="headerlink" title="3.2.1 页面流程分析"></a>3.2.1 页面流程分析</h4><p><img src="https://s2.loli.net/2022/08/17/dLHC9wNcv3UDln8.png" alt="image-20220815233535234"></p>
<h5 id="在开发代码之前，需要梳理一下整个程序的执行过程。"><a href="#在开发代码之前，需要梳理一下整个程序的执行过程。" class="headerlink" title="在开发代码之前，需要梳理一下整个程序的执行过程。"></a>在开发代码之前，需要梳理一下整个程序的执行过程。</h5><h5 id="A-点击菜单，打开员工管理页面时，执行查询："><a href="#A-点击菜单，打开员工管理页面时，执行查询：" class="headerlink" title="A. 点击菜单，打开员工管理页面时，执行查询："></a>A. 点击菜单，打开员工管理页面时，执行查询：</h5><h5 id="B-搜索栏输入员工姓名-回车-执行查询"><a href="#B-搜索栏输入员工姓名-回车-执行查询" class="headerlink" title="B. 搜索栏输入员工姓名,回车,执行查询:"></a>B. 搜索栏输入员工姓名,回车,执行查询:</h5><p><img src="https://s2.loli.net/2022/08/17/eUm4lQFaWyI1T2K.png" alt="image-20220815233551935"></p>
<h5 id="1-页面发送ajax请求，将分页查询参数-page、pageSize、name-提交到服务端"><a href="#1-页面发送ajax请求，将分页查询参数-page、pageSize、name-提交到服务端" class="headerlink" title="1). 页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端"></a>1). 页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端</h5><h5 id="2-服务端Controller接收页面提交的数据-并组装条件调用Service查询数据"><a href="#2-服务端Controller接收页面提交的数据-并组装条件调用Service查询数据" class="headerlink" title="2). 服务端Controller接收页面提交的数据, 并组装条件调用Service查询数据"></a>2). 服务端Controller接收页面提交的数据, 并组装条件调用Service查询数据</h5><h5 id="3-Service调用Mapper操作数据库，查询分页数据"><a href="#3-Service调用Mapper操作数据库，查询分页数据" class="headerlink" title="3). Service调用Mapper操作数据库，查询分页数据"></a>3). Service调用Mapper操作数据库，查询分页数据</h5><h5 id="4-Controller将查询到的分页数据-响应给前端页面"><a href="#4-Controller将查询到的分页数据-响应给前端页面" class="headerlink" title="4). Controller将查询到的分页数据, 响应给前端页面"></a>4). Controller将查询到的分页数据, 响应给前端页面</h5><h5 id="5-页面接收到分页数据-并通过ElementUI的Table组件展示到页面上"><a href="#5-页面接收到分页数据-并通过ElementUI的Table组件展示到页面上" class="headerlink" title="5). 页面接收到分页数据, 并通过ElementUI的Table组件展示到页面上"></a>5). 页面接收到分页数据, 并通过ElementUI的Table组件展示到页面上</h5><h4 id="3-2-2-前端代码介绍"><a href="#3-2-2-前端代码介绍" class="headerlink" title="3.2.2 前端代码介绍"></a>3.2.2 前端代码介绍</h4><h5 id="1-访问员工列表页面-x2F-member-x2F-list-html时-会触发Vuejs中的钩子方法-在页面初始化时调用"><a href="#1-访问员工列表页面-x2F-member-x2F-list-html时-会触发Vuejs中的钩子方法-在页面初始化时调用" class="headerlink" title="1). 访问员工列表页面/member/list.html时, 会触发Vuejs中的钩子方法, 在页面初始化时调用"></a>1). 访问员工列表页面/member/list.html时, 会触发Vuejs中的钩子方法, 在页面初始化时调用</h5><h5 id="created方法"><a href="#created方法" class="headerlink" title="created方法"></a>created方法</h5><p><img src="https://s2.loli.net/2022/08/17/iGaqsPKuDpwvBLe.png" alt="image-20220815233615094"></p>
<h5 id="从上述的前端代码中我们可以看到-执行完分页查询-我们需要给前端返回的信息中需要包含两项"><a href="#从上述的前端代码中我们可以看到-执行完分页查询-我们需要给前端返回的信息中需要包含两项" class="headerlink" title="从上述的前端代码中我们可以看到, 执行完分页查询, 我们需要给前端返回的信息中需要包含两项 :"></a>从上述的前端代码中我们可以看到, 执行完分页查询, 我们需要给前端返回的信息中需要包含两项 :</h5><h5 id="records-中封装结果列表-total中封装总记录数-。"><a href="#records-中封装结果列表-total中封装总记录数-。" class="headerlink" title="records 中封装结果列表, total中封装总记录数 。"></a>records 中封装结果列表, total中封装总记录数 。</h5><h5 id="而在组装请求参数时-page、pageSize-都是前端分页插件渲染时的参数；"><a href="#而在组装请求参数时-page、pageSize-都是前端分页插件渲染时的参数；" class="headerlink" title="而在组装请求参数时 , page、pageSize 都是前端分页插件渲染时的参数；"></a>而在组装请求参数时 , page、pageSize 都是前端分页插件渲染时的参数；</h5><p><img src="https://s2.loli.net/2022/08/17/AoMKQIE5jNdwZr8.png" alt="image-20220815233808670"></p>
<h5 id="2-在getMemberList方法中-通过axios发起异步请求"><a href="#2-在getMemberList方法中-通过axios发起异步请求" class="headerlink" title="2). 在getMemberList方法中, 通过axios发起异步请求"></a>2). 在getMemberList方法中, 通过axios发起异步请求</h5><p><img src="https://s2.loli.net/2022/08/17/lc2MXQDJ5C948IS.png" alt="image-20220815233825803"></p>
<h5 id="axios发起的异步请求会被声明在-request-js-中的request拦截器拦截-在其中对get请求进行"><a href="#axios发起的异步请求会被声明在-request-js-中的request拦截器拦截-在其中对get请求进行" class="headerlink" title="axios发起的异步请求会被声明在 request.js 中的request拦截器拦截, 在其中对get请求进行"></a>axios发起的异步请求会被声明在 request.js 中的request拦截器拦截, 在其中对get请求进行</h5><h5 id="进一步的封装处理"><a href="#进一步的封装处理" class="headerlink" title="进一步的封装处理"></a>进一步的封装处理</h5><p><img src="https://s2.loli.net/2022/08/17/7eRLSJZWBFVGYt9.png" alt="image-20220815233844295"></p>
<h5 id="最终发送给服务端的请求为-GET请求-请求链接-x2F-employee-x2F-page"><a href="#最终发送给服务端的请求为-GET请求-请求链接-x2F-employee-x2F-page" class="headerlink" title="最终发送给服务端的请求为 : GET请求 , 请求链接 /employee/page?"></a>最终发送给服务端的请求为 : GET请求 , 请求链接 /employee/page?</h5><h5 id="page-x3D-1-amp-pageSize-x3D-10-amp-name-x3D-xxx"><a href="#page-x3D-1-amp-pageSize-x3D-10-amp-name-x3D-xxx" class="headerlink" title="page=1&amp;pageSize=10&amp;name=xxx"></a>page=1&amp;pageSize=10&amp;name=xxx</h5><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><h4 id="3-3-1-分页插件配置"><a href="#3-3-1-分页插件配置" class="headerlink" title="3.3.1 分页插件配置"></a>3.3.1 分页插件配置</h4><h5 id="当前我们要实现的分页查询功能，而在MybatisPlus要实现分页功能，就需要用到MybatisPlus中提"><a href="#当前我们要实现的分页查询功能，而在MybatisPlus要实现分页功能，就需要用到MybatisPlus中提" class="headerlink" title="当前我们要实现的分页查询功能，而在MybatisPlus要实现分页功能，就需要用到MybatisPlus中提"></a>当前我们要实现的分页查询功能，而在MybatisPlus要实现分页功能，就需要用到MybatisPlus中提</h5><h5 id="供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象。"><a href="#供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象。" class="headerlink" title="供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象。"></a>供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象。</h5><h5 id="所属包-com-itheima-reggie-config"><a href="#所属包-com-itheima-reggie-config" class="headerlink" title="所属包: com.itheima.reggie.config"></a>所属包: com.itheima.reggie.config</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line">import</span><br><span class="line">com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/**</span><br><span class="line">* 配置MP的分页插件</span><br><span class="line">*/</span><br><span class="line">@Configuration</span><br><span class="line">public class MybatisPlusConfig {</span><br><span class="line">@Bean</span><br></pre></td></tr></tbody></table></figure>

<h5 id="请求-说明"><a href="#请求-说明" class="headerlink" title="请求 说明"></a>请求 说明</h5><h5 id="请求方式-GET"><a href="#请求方式-GET" class="headerlink" title="请求方式 GET"></a>请求方式 GET</h5><h5 id="请求路径-x2F-employee-x2F-page"><a href="#请求路径-x2F-employee-x2F-page" class="headerlink" title="请求路径 /employee/page"></a>请求路径 /employee/page</h5><h5 id="请求参数-page-pageSize-name"><a href="#请求参数-page-pageSize-name" class="headerlink" title="请求参数 page , pageSize , name"></a>请求参数 page , pageSize , name</h5><h4 id="3-3-2-分页查询实现"><a href="#3-3-2-分页查询实现" class="headerlink" title="3.3.2 分页查询实现"></a>3.3.2 分页查询实现</h4><h5 id="在上面我们已经分析了，页面在进行分页查询时，-具体的请求信息如下"><a href="#在上面我们已经分析了，页面在进行分页查询时，-具体的请求信息如下" class="headerlink" title="在上面我们已经分析了，页面在进行分页查询时， 具体的请求信息如下:"></a>在上面我们已经分析了，页面在进行分页查询时， 具体的请求信息如下:</h5><p><img src="https://s2.loli.net/2022/08/17/CiYJg9nBPF5A8Qf.png" alt="image-20220815233948995"></p>
<h5 id="那么查询完毕后我们需要给前端返回什么样的结果呢"><a href="#那么查询完毕后我们需要给前端返回什么样的结果呢" class="headerlink" title="那么查询完毕后我们需要给前端返回什么样的结果呢?"></a>那么查询完毕后我们需要给前端返回什么样的结果呢?</h5><h5 id="在上述我们也分析了-查询返回的结果数据data中应该封装两项信息-分别为-records-封装分页"><a href="#在上述我们也分析了-查询返回的结果数据data中应该封装两项信息-分别为-records-封装分页" class="headerlink" title="在上述我们也分析了, 查询返回的结果数据data中应该封装两项信息, 分别为: records 封装分页"></a>在上述我们也分析了, 查询返回的结果数据data中应该封装两项信息, 分别为: records 封装分页</h5><h5 id="列表数据-total-中封装符合条件的总记录数。-那么这个时候-在定义controller方法的返回值"><a href="#列表数据-total-中封装符合条件的总记录数。-那么这个时候-在定义controller方法的返回值" class="headerlink" title="列表数据, total 中封装符合条件的总记录数。 那么这个时候, 在定义controller方法的返回值"></a>列表数据, total 中封装符合条件的总记录数。 那么这个时候, 在定义controller方法的返回值</h5><h5 id="类型R时-我们可以直接将-MybatisPlus-分页查询的结果-Page-直接封装返回-因为Page中的属"><a href="#类型R时-我们可以直接将-MybatisPlus-分页查询的结果-Page-直接封装返回-因为Page中的属" class="headerlink" title="类型R时, 我们可以直接将 MybatisPlus 分页查询的结果 Page 直接封装返回, 因为Page中的属"></a>类型R时, 我们可以直接将 MybatisPlus 分页查询的结果 Page 直接封装返回, 因为Page中的属</h5><h5 id="性如下"><a href="#性如下" class="headerlink" title="性如下:"></a>性如下:</h5><p><img src="https://s2.loli.net/2022/08/17/rVh7n3QlO9uNRD4.png" alt="image-20220815234002918"></p>
<h5 id="那么接下来就依据于这些已知的需求和条件完成分页查询的代码实现。-具体的逻辑如下"><a href="#那么接下来就依据于这些已知的需求和条件完成分页查询的代码实现。-具体的逻辑如下" class="headerlink" title="那么接下来就依据于这些已知的需求和条件完成分页查询的代码实现。 具体的逻辑如下:"></a>那么接下来就依据于这些已知的需求和条件完成分页查询的代码实现。 具体的逻辑如下:</h5><h5 id="A-构造分页条件"><a href="#A-构造分页条件" class="headerlink" title="A. 构造分页条件"></a>A. 构造分页条件</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public MybatisPlusInterceptor mybatisPlusInterceptor(){</span><br><span class="line">MybatisPlusInterceptor mybatisPlusInterceptor = new</span><br><span class="line">MybatisPlusInterceptor();</span><br><span class="line">mybatisPlusInterceptor.addInnerInterceptor(new</span><br><span class="line">PaginationInnerInterceptor());</span><br><span class="line">return mybatisPlusInterceptor;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="B-构建搜索条件-name进行模糊匹配"><a href="#B-构建搜索条件-name进行模糊匹配" class="headerlink" title="B. 构建搜索条件 - name进行模糊匹配"></a>B. 构建搜索条件 - name进行模糊匹配</h5><h5 id="C-构建排序条件-更新时间倒序排序"><a href="#C-构建排序条件-更新时间倒序排序" class="headerlink" title="C. 构建排序条件 - 更新时间倒序排序"></a>C. 构建排序条件 - 更新时间倒序排序</h5><h5 id="D-执行查询"><a href="#D-执行查询" class="headerlink" title="D. 执行查询"></a>D. 执行查询</h5><h5 id="E-组装结果并返回"><a href="#E-组装结果并返回" class="headerlink" title="E. 组装结果并返回"></a>E. 组装结果并返回</h5><h5 id="具体的代码实现如下"><a href="#具体的代码实现如下" class="headerlink" title="具体的代码实现如下:"></a>具体的代码实现如下:</h5><h3 id="3-4-功能测试"><a href="#3-4-功能测试" class="headerlink" title="3.4 功能测试"></a>3.4 功能测试</h3><h6 id="x2F-3"><a href="#x2F-3" class="headerlink" title="/**"></a>/**</h6><h6 id="员工信息分页查询-1"><a href="#员工信息分页查询-1" class="headerlink" title="* 员工信息分页查询"></a>* 员工信息分页查询</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* @param page 当前查询页码</span><br><span class="line">* @param pageSize 每页展示记录数</span><br><span class="line">* @param name 员工姓名 - 可选参数</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@GetMapping("/page")</span><br><span class="line">public R&lt;Page&gt; page(int page,int pageSize,String name){</span><br><span class="line">log.info("page = {},pageSize = {},name = {}" ,page,pageSize,name);</span><br><span class="line">//构造分页构造器</span><br><span class="line">Page pageInfo = new Page(page,pageSize);</span><br><span class="line">//构造条件构造器</span><br><span class="line">LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">//添加过滤条件</span><br><span class="line">queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);</span><br><span class="line">//添加排序条件</span><br><span class="line">queryWrapper.orderByDesc(Employee::getUpdateTime);</span><br><span class="line">//执行查询</span><br><span class="line">employeeService.page(pageInfo,queryWrapper);</span><br><span class="line">return R.success(pageInfo);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码编写完毕之后，我们需要将工程重启-完毕之后直接访问管理系统首页-默认就会打开员工管理"><a href="#代码编写完毕之后，我们需要将工程重启-完毕之后直接访问管理系统首页-默认就会打开员工管理" class="headerlink" title="代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 默认就会打开员工管理"></a>代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 默认就会打开员工管理</h5><h5 id="的列表页面-我们可以查看列表数据是否可以正常展示-也可以通过分页插件来测试分页功能-及员"><a href="#的列表页面-我们可以查看列表数据是否可以正常展示-也可以通过分页插件来测试分页功能-及员" class="headerlink" title="的列表页面, 我们可以查看列表数据是否可以正常展示, 也可以通过分页插件来测试分页功能, 及员"></a>的列表页面, 我们可以查看列表数据是否可以正常展示, 也可以通过分页插件来测试分页功能, 及员</h5><h5 id="工姓名的模糊查询功能。"><a href="#工姓名的模糊查询功能。" class="headerlink" title="工姓名的模糊查询功能。"></a>工姓名的模糊查询功能。</h5><h5 id="在进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节。-并借助于debug的形"><a href="#在进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节。-并借助于debug的形" class="headerlink" title="在进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节。 并借助于debug的形"></a>在进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节。 并借助于debug的形</h5><h5 id="式，-根据服务端参数接收及逻辑执行情况。"><a href="#式，-根据服务端参数接收及逻辑执行情况。" class="headerlink" title="式， 根据服务端参数接收及逻辑执行情况。"></a>式， 根据服务端参数接收及逻辑执行情况。</h5><p><img src="C:%5CUsers%5C13772%5CDesktop%5Cimg%5Cimage-20220815234032416.png" alt="image-20220815234032416"></p>
<h5 id="测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（-1-或者-0-），但是页面上"><a href="#测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（-1-或者-0-），但是页面上" class="headerlink" title="测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（ 1 或者 0 ），但是页面上"></a>测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（ 1 或者 0 ），但是页面上</h5><h5 id="显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理。"><a href="#显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理。" class="headerlink" title="显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理。"></a>显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理。</h5><p><img src="C:%5CUsers%5C13772%5CDesktop%5Cimg%5Cimage-20220815234056527.png" alt="image-20220815234056527"></p>
<h2 id="4-启用-x2F-禁用员工账号"><a href="#4-启用-x2F-禁用员工账号" class="headerlink" title="4. 启用/禁用员工账号"></a>4. 启用/禁用员工账号</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><h5 id="在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启"><a href="#在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启" class="headerlink" title="在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启"></a>在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启</h5><h5 id="用后的员工可以正常登录。如果某个员工账号状态为正常，则按钮显示为-“禁用”，如果员工账号状态"><a href="#用后的员工可以正常登录。如果某个员工账号状态为正常，则按钮显示为-“禁用”，如果员工账号状态" class="headerlink" title="用后的员工可以正常登录。如果某个员工账号状态为正常，则按钮显示为 “禁用”，如果员工账号状态"></a>用后的员工可以正常登录。如果某个员工账号状态为正常，则按钮显示为 “禁用”，如果员工账号状态</h5><h5 id="为已禁用，则按钮显示为”启用”。"><a href="#为已禁用，则按钮显示为”启用”。" class="headerlink" title="为已禁用，则按钮显示为”启用”。"></a>为已禁用，则按钮显示为”启用”。</h5><h5 id="需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录"><a href="#需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录" class="headerlink" title="需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录"></a>需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录</h5><h5 id="系统后启用、禁用按钮不显示。"><a href="#系统后启用、禁用按钮不显示。" class="headerlink" title="系统后启用、禁用按钮不显示。"></a>系统后启用、禁用按钮不显示。</h5><h5 id="A-admin-管理员登录"><a href="#A-admin-管理员登录" class="headerlink" title="A. admin 管理员登录"></a>A. admin 管理员登录</h5><p><img src="https://s2.loli.net/2022/08/17/6JZSnT9AHdgsNOy.png" alt="image-20220815234111929"></p>
<h5 id="B-普通用户登录"><a href="#B-普通用户登录" class="headerlink" title="B. 普通用户登录"></a>B. 普通用户登录</h5><p><img src="https://s2.loli.net/2022/08/17/SBKp8aHbWicVLnw.png" alt="image-20220815234128776"></p>
<h3 id="4-2-程序执行流程"><a href="#4-2-程序执行流程" class="headerlink" title="4.2 程序执行流程"></a>4.2 程序执行流程</h3><h4 id="4-2-1-页面按钮动态展示"><a href="#4-2-1-页面按钮动态展示" class="headerlink" title="4.2.1 页面按钮动态展示"></a>4.2.1 页面按钮动态展示</h4><h5 id="在上述的需求中-我们提到需要实现的效果是-只有管理员（admin用户）可以对其他普通用户进行"><a href="#在上述的需求中-我们提到需要实现的效果是-只有管理员（admin用户）可以对其他普通用户进行" class="headerlink" title="在上述的需求中,我们提到需要实现的效果是 : 只有管理员（admin用户）可以对其他普通用户进行"></a>在上述的需求中,我们提到需要实现的效果是 : 只有管理员（admin用户）可以对其他普通用户进行</h5><h5 id="启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示-页面中是怎么做到只有管理员"><a href="#启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示-页面中是怎么做到只有管理员" class="headerlink" title="启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示 , 页面中是怎么做到只有管理员"></a>启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示 , 页面中是怎么做到只有管理员</h5><h5 id="admin能够看到启用、禁用按钮的？"><a href="#admin能够看到启用、禁用按钮的？" class="headerlink" title="admin能够看到启用、禁用按钮的？"></a>admin能够看到启用、禁用按钮的？</h5><h5 id="1-在列表页面-list-html-加载时-触发钩子函数created-在钩子函数中-会从"><a href="#1-在列表页面-list-html-加载时-触发钩子函数created-在钩子函数中-会从" class="headerlink" title="1). 在列表页面(list.html)加载时, 触发钩子函数created, 在钩子函数中, 会从"></a>1). 在列表页面(list.html)加载时, 触发钩子函数created, 在钩子函数中, 会从</h5><h5 id="localStorage中获取到用户登录信息-然后获取到用户名"><a href="#localStorage中获取到用户登录信息-然后获取到用户名" class="headerlink" title="localStorage中获取到用户登录信息, 然后获取到用户名"></a>localStorage中获取到用户登录信息, 然后获取到用户名</h5><p><img src="https://s2.loli.net/2022/08/17/uElWDtqYfvXVOm3.png" alt="image-20220815234226735"></p>
<h5 id="2-在页面中-通过Vue指令v-if进行判断-如果登录用户为admin将展示-启用-x2F-禁用-按钮-否则"><a href="#2-在页面中-通过Vue指令v-if进行判断-如果登录用户为admin将展示-启用-x2F-禁用-按钮-否则" class="headerlink" title="2). 在页面中, 通过Vue指令v-if进行判断,如果登录用户为admin将展示 启用/禁用 按钮, 否则"></a>2). 在页面中, 通过Vue指令v-if进行判断,如果登录用户为admin将展示 启用/禁用 按钮, 否则</h5><h5 id="不展示"><a href="#不展示" class="headerlink" title="不展示"></a>不展示</h5><p><img src="https://s2.loli.net/2022/08/17/EO2J3LThpbkFHnv.png" alt="image-20220815234240648"></p>
<h4 id="4-2-2-执行流程分析"><a href="#4-2-2-执行流程分析" class="headerlink" title="4.2.2 执行流程分析"></a>4.2.2 执行流程分析</h4><h5 id="1-当管理员admin点击-“启用”-或-“禁用”-按钮时-调用方法statusHandle"><a href="#1-当管理员admin点击-“启用”-或-“禁用”-按钮时-调用方法statusHandle" class="headerlink" title="1). 当管理员admin点击 “启用” 或 “禁用” 按钮时, 调用方法statusHandle"></a>1). 当管理员admin点击 “启用” 或 “禁用” 按钮时, 调用方法statusHandle</h5><h5 id="scope-row-获取到的是这一行的数据信息"><a href="#scope-row-获取到的是这一行的数据信息" class="headerlink" title="scope.row : 获取到的是这一行的数据信息 ;"></a>scope.row : 获取到的是这一行的数据信息 ;</h5><p><img src="https://s2.loli.net/2022/08/17/G91eDxmJXVQRKYd.png" alt="image-20220815234305791"></p>
<h5 id="2-statusHandle方法中进行二次确认-然后发起ajax请求-传递id、status参数"><a href="#2-statusHandle方法中进行二次确认-然后发起ajax请求-传递id、status参数" class="headerlink" title="2). statusHandle方法中进行二次确认, 然后发起ajax请求, 传递id、status参数"></a>2). statusHandle方法中进行二次确认, 然后发起ajax请求, 传递id、status参数</h5><p><img src="https://s2.loli.net/2022/08/17/oSs8UhMKyR4zNnm.png" alt="image-20220815234325194"></p>
<h5 id="最终发起异步请求-请求服务端-请求信息如下："><a href="#最终发起异步请求-请求服务端-请求信息如下：" class="headerlink" title="最终发起异步请求, 请求服务端, 请求信息如下："></a>最终发起异步请求, 请求服务端, 请求信息如下：</h5><h5 id="请求-说明-1"><a href="#请求-说明-1" class="headerlink" title="请求 说明"></a>请求 说明</h5><h5 id="请求方式-PUT"><a href="#请求方式-PUT" class="headerlink" title="请求方式 PUT"></a>请求方式 PUT</h5><h5 id="请求路径-x2F-employee"><a href="#请求路径-x2F-employee" class="headerlink" title="请求路径 /employee"></a>请求路径 /employee</h5><h5 id="请求参数-“id”-xxx-”status”-xxx"><a href="#请求参数-“id”-xxx-”status”-xxx" class="headerlink" title="请求参数 {“id”:xxx,”status”:xxx}"></a>请求参数 {“id”:xxx,”status”:xxx}</h5><h5 id="…params-三点是ES6中出现的扩展运算符。作用是遍历当前使用的对象能够访问到的所"><a href="#…params-三点是ES6中出现的扩展运算符。作用是遍历当前使用的对象能够访问到的所" class="headerlink" title="{…params} : 三点是ES6中出现的扩展运算符。作用是遍历当前使用的对象能够访问到的所"></a>{…params} : 三点是ES6中出现的扩展运算符。作用是遍历当前使用的对象能够访问到的所</h5><h5 id="有属性，并将属性放入当前对象中。"><a href="#有属性，并将属性放入当前对象中。" class="headerlink" title="有属性，并将属性放入当前对象中。"></a>有属性，并将属性放入当前对象中。</h5><p><img src="https://s2.loli.net/2022/08/17/OoC9SQ1hXcjKPfY.png" alt="image-20220815234341542"></p>
<h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><h5 id="在开发代码之前，需要梳理一下整个程序的执行过程："><a href="#在开发代码之前，需要梳理一下整个程序的执行过程：" class="headerlink" title="在开发代码之前，需要梳理一下整个程序的执行过程："></a>在开发代码之前，需要梳理一下整个程序的执行过程：</h5><h5 id="1-页面发送ajax请求，将参数-id、status-提交到服务端"><a href="#1-页面发送ajax请求，将参数-id、status-提交到服务端" class="headerlink" title="1). 页面发送ajax请求，将参数(id、status)提交到服务端"></a>1). 页面发送ajax请求，将参数(id、status)提交到服务端</h5><h5 id="2-服务端Controller接收页面提交的数据并调用Service更新数据"><a href="#2-服务端Controller接收页面提交的数据并调用Service更新数据" class="headerlink" title="2). 服务端Controller接收页面提交的数据并调用Service更新数据"></a>2). 服务端Controller接收页面提交的数据并调用Service更新数据</h5><h5 id="3-Service调用Mapper操作数据库"><a href="#3-Service调用Mapper操作数据库" class="headerlink" title="3). Service调用Mapper操作数据库"></a>3). Service调用Mapper操作数据库</h5><h5 id="启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作。在"><a href="#启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作。在" class="headerlink" title="启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作。在"></a>启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作。在</h5><h5 id="Controller中创建update方法，此方法是一个通用的修改员工信息的方法。"><a href="#Controller中创建update方法，此方法是一个通用的修改员工信息的方法。" class="headerlink" title="Controller中创建update方法，此方法是一个通用的修改员工信息的方法。"></a>Controller中创建update方法，此方法是一个通用的修改员工信息的方法。</h5><h6 id="x2F-4"><a href="#x2F-4" class="headerlink" title="/**"></a>/**</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* 根据id修改员工信息</span><br><span class="line">* @param employee</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@PutMapping</span><br><span class="line">public R&lt;String&gt; update(HttpServletRequest request,@RequestBody Employee</span><br><span class="line">employee){</span><br><span class="line">log.info(employee.toString());</span><br><span class="line">Long empId = (Long)request.getSession().getAttribute("employee");</span><br><span class="line">employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">employee.setUpdateUser(empId);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-4-功能测试"><a href="#4-4-功能测试" class="headerlink" title="4.4 功能测试"></a>4.4 功能测试</h3><p><img src="https://s2.loli.net/2022/08/17/lKisW87UQ2b1ctI.png" alt="image-20220815234401305"></p>
<h5 id="代码编写完毕之后，我们需要将工程重启。-然后访问前端页面，-进行-“启用”-或-“禁用”-的测试。"><a href="#代码编写完毕之后，我们需要将工程重启。-然后访问前端页面，-进行-“启用”-或-“禁用”-的测试。" class="headerlink" title="代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 进行 “启用” 或 “禁用” 的测试。"></a>代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 进行 “启用” 或 “禁用” 的测试。</h5><h5 id="测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。但是从控制台输出的日"><a href="#测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。但是从控制台输出的日" class="headerlink" title="测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。但是从控制台输出的日"></a>测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。但是从控制台输出的日</h5><h5 id="志，-可以看出确实没有更新成功。"><a href="#志，-可以看出确实没有更新成功。" class="headerlink" title="志， 可以看出确实没有更新成功。"></a>志， 可以看出确实没有更新成功。</h5><h5 id="而在我们的数据库表结构中，-并不存在该ID，-数据库中-风清扬-对应的ID为"><a href="#而在我们的数据库表结构中，-并不存在该ID，-数据库中-风清扬-对应的ID为" class="headerlink" title="而在我们的数据库表结构中， 并不存在该ID， 数据库中 风清扬 对应的ID为"></a>而在我们的数据库表结构中， 并不存在该ID， 数据库中 风清扬 对应的ID为</h5><h5 id="1420038345634918401"><a href="#1420038345634918401" class="headerlink" title="1420038345634918401"></a>1420038345634918401</h5><p><img src="https://s2.loli.net/2022/08/17/jDQIOu5BqVbhgRz.png" alt="image-20220815234414142"></p>
<h3 id="4-5-代码修复"><a href="#4-5-代码修复" class="headerlink" title="4.5 代码修复"></a>4.5 代码修复</h3><h4 id="4-5-1-原因分析"><a href="#4-5-1-原因分析" class="headerlink" title="4.5.1 原因分析"></a>4.5.1 原因分析</h4><p><img src="https://s2.loli.net/2022/08/17/yhDfg9TXEYl7HZb.png" alt="image-20220815234436477">通过观察控制台输出的SQL发现页面传递过来的员工id的值和数据库中的id值不一致，这是怎么回事</p>
<h5 id="呢？"><a href="#呢？" class="headerlink" title="呢？"></a>呢？</h5><h5 id="在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一"><a href="#在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一" class="headerlink" title="在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一"></a>在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一</h5><h5 id="个Long类型的数据，而且是一个长度为-19-位的长整型数据，-该数据返回给前端是没有问题的。"><a href="#个Long类型的数据，而且是一个长度为-19-位的长整型数据，-该数据返回给前端是没有问题的。" class="headerlink" title="个Long类型的数据，而且是一个长度为 19 位的长整型数据， 该数据返回给前端是没有问题的。"></a>个Long类型的数据，而且是一个长度为 19 位的长整型数据， 该数据返回给前端是没有问题的。</h5><p><img src="https://s2.loli.net/2022/08/17/Gf8JBT2g4jzO6NR.png" alt="image-20220815234532569"></p>
<h5 id="那么具体的问题出现在哪儿呢？"><a href="#那么具体的问题出现在哪儿呢？" class="headerlink" title="那么具体的问题出现在哪儿呢？"></a>那么具体的问题出现在哪儿呢？</h5><h5 id="问题实际上，-就出现在前端JS中，-js在对长度较长的长整型数据进行处理时，-会损失精度，-从而"><a href="#问题实际上，-就出现在前端JS中，-js在对长度较长的长整型数据进行处理时，-会损失精度，-从而" class="headerlink" title="问题实际上， 就出现在前端JS中， js在对长度较长的长整型数据进行处理时， 会损失精度， 从而"></a>问题实际上， 就出现在前端JS中， js在对长度较长的长整型数据进行处理时， 会损失精度， 从而</h5><h5 id="导致提交的id和数据库中的id不一致。-这里，我们也可以做一个简单的测试，代码如下："><a href="#导致提交的id和数据库中的id不一致。-这里，我们也可以做一个简单的测试，代码如下：" class="headerlink" title="导致提交的id和数据库中的id不一致。 这里，我们也可以做一个简单的测试，代码如下："></a>导致提交的id和数据库中的id不一致。 这里，我们也可以做一个简单的测试，代码如下：</h5><h4 id="4-5-2-解决方案"><a href="#4-5-2-解决方案" class="headerlink" title="4.5.2 解决方案"></a>4.5.2 解决方案</h4><h5 id="要想解决这个问题，也很简单，我们只需要让js处理的ID数据类型为字符串类型即可-这样就不会损"><a href="#要想解决这个问题，也很简单，我们只需要让js处理的ID数据类型为字符串类型即可-这样就不会损" class="headerlink" title="要想解决这个问题，也很简单，我们只需要让js处理的ID数据类型为字符串类型即可, 这样就不会损"></a>要想解决这个问题，也很简单，我们只需要让js处理的ID数据类型为字符串类型即可, 这样就不会损</h5><h5 id="失精度了。同样，-大家也可以做一个测试："><a href="#失精度了。同样，-大家也可以做一个测试：" class="headerlink" title="失精度了。同样， 大家也可以做一个测试："></a>失精度了。同样， 大家也可以做一个测试：</h5><h5 id="那么在我们的业务中-我们只需要让分页查询返回的json格式数据库中-long类型的属性-不直接"><a href="#那么在我们的业务中-我们只需要让分页查询返回的json格式数据库中-long类型的属性-不直接" class="headerlink" title="那么在我们的业务中, 我们只需要让分页查询返回的json格式数据库中, long类型的属性, 不直接"></a>那么在我们的业务中, 我们只需要让分页查询返回的json格式数据库中, long类型的属性, 不直接</h5><h5 id="转换为数字类型-转换为字符串类型就可以解决这个问题了-最终返回的结果为"><a href="#转换为数字类型-转换为字符串类型就可以解决这个问题了-最终返回的结果为" class="headerlink" title="转换为数字类型, 转换为字符串类型就可以解决这个问题了 , 最终返回的结果为 :"></a>转换为数字类型, 转换为字符串类型就可以解决这个问题了 , 最终返回的结果为 :</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset="UTF-8"&gt;</span><br><span class="line">&lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert( 1420038345634918401 );</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset="UTF-8"&gt;</span><br><span class="line">&lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert("1420038345634918401");</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/08/17/F17KStGp6Wavrnw.png" alt="image-20220815234552741"></p>
<h4 id="4-5-3-代码修复"><a href="#4-5-3-代码修复" class="headerlink" title="4.5.3 代码修复"></a>4.5.3 代码修复</h4><h5 id="由于在SpringMVC中-将Controller方法返回值转换为json对象-是通过jackson来实现的-涉"><a href="#由于在SpringMVC中-将Controller方法返回值转换为json对象-是通过jackson来实现的-涉" class="headerlink" title="由于在SpringMVC中, 将Controller方法返回值转换为json对象, 是通过jackson来实现的, 涉"></a>由于在SpringMVC中, 将Controller方法返回值转换为json对象, 是通过jackson来实现的, 涉</h5><h5 id="及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter-所以我们要解"><a href="#及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter-所以我们要解" class="headerlink" title="及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter, 所以我们要解"></a>及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter, 所以我们要解</h5><h5 id="决这个问题-就需要对该消息转换器的功能进行拓展。"><a href="#决这个问题-就需要对该消息转换器的功能进行拓展。" class="headerlink" title="决这个问题, 就需要对该消息转换器的功能进行拓展。"></a>决这个问题, 就需要对该消息转换器的功能进行拓展。</h5><h5 id="具体实现步骤："><a href="#具体实现步骤：" class="headerlink" title="具体实现步骤："></a>具体实现步骤：</h5><h5 id="1-提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资"><a href="#1-提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资" class="headerlink" title="1). 提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资"></a>1). 提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资</h5><h5 id="料中已经提供，直接复制到项目中使用）"><a href="#料中已经提供，直接复制到项目中使用）" class="headerlink" title="料中已经提供，直接复制到项目中使用）"></a>料中已经提供，直接复制到项目中使用）</h5><h5 id="2-在WebMvcConfig配置类中扩展Spring-mvc的消息转换器，在此消息转换器中使用提供的对象"><a href="#2-在WebMvcConfig配置类中扩展Spring-mvc的消息转换器，在此消息转换器中使用提供的对象" class="headerlink" title="2). 在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象"></a>2). 在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象</h5><h5 id="转换器进行Java对象到json数据的转换"><a href="#转换器进行Java对象到json数据的转换" class="headerlink" title="转换器进行Java对象到json数据的转换"></a>转换器进行Java对象到json数据的转换</h5><h5 id="1-引入JacksonObjectMapper"><a href="#1-引入JacksonObjectMapper" class="headerlink" title="1). 引入JacksonObjectMapper"></a>1). 引入JacksonObjectMapper</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import com.fasterxml.jackson.databind.DeserializationFeature;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import com.fasterxml.jackson.databind.module.SimpleModule;</span><br><span class="line">import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.LocalDateTime;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import java.time.LocalTime;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">import static</span><br><span class="line">com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;</span><br><span class="line">/**</span><br><span class="line">* 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span><br><span class="line">* 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span><br><span class="line">* 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span><br><span class="line">*/</span><br><span class="line">public class JacksonObjectMapper extends ObjectMapper {</span><br><span class="line">public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";</span><br><span class="line">public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";</span><br><span class="line">public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";</span><br><span class="line">public JacksonObjectMapper() {</span><br><span class="line">super();</span><br><span class="line">//收到未知属性时不报异常</span><br><span class="line">this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);</span><br><span class="line">//反序列化时，属性不存在的兼容处理</span><br><span class="line">this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_U</span><br><span class="line">NKNOWN_PROPERTIES);</span><br><span class="line">SimpleModule simpleModule = new SimpleModule()</span><br><span class="line">.addDeserializer(LocalDateTime.class, new</span><br><span class="line">LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">.addDeserializer(LocalDate.class, new</span><br><span class="line">LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">.addDeserializer(LocalTime.class, new</span><br><span class="line">LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))</span><br><span class="line">.addSerializer(BigInteger.class, ToStringSerializer.instance)</span><br><span class="line">.addSerializer(Long.class, ToStringSerializer.instance)</span><br><span class="line">.addSerializer(LocalDateTime.class, new</span><br><span class="line">LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br></pre></td></tr></tbody></table></figure>

<h5 id="该自定义的对象转换器-主要指定了-在进行json数据序列化及反序列化时-LocalDateTime、"><a href="#该自定义的对象转换器-主要指定了-在进行json数据序列化及反序列化时-LocalDateTime、" class="headerlink" title="该自定义的对象转换器, 主要指定了, 在进行json数据序列化及反序列化时, LocalDateTime、"></a>该自定义的对象转换器, 主要指定了, 在进行json数据序列化及反序列化时, LocalDateTime、</h5><h5 id="LocalDate、LocalTime的处理方式-以及BigInteger及Long类型数据，直接转换为字符串。"><a href="#LocalDate、LocalTime的处理方式-以及BigInteger及Long类型数据，直接转换为字符串。" class="headerlink" title="LocalDate、LocalTime的处理方式, 以及BigInteger及Long类型数据，直接转换为字符串。"></a>LocalDate、LocalTime的处理方式, 以及BigInteger及Long类型数据，直接转换为字符串。</h5><h5 id="2-在WebMvcConfig中重写方法extendMessageConverters"><a href="#2-在WebMvcConfig中重写方法extendMessageConverters" class="headerlink" title="2). 在WebMvcConfig中重写方法extendMessageConverters"></a>2). 在WebMvcConfig中重写方法extendMessageConverters</h5><h2 id="编-信息"><a href="#编-信息" class="headerlink" title="编 信息"></a>编 信息</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">.addSerializer(LocalDate.class, new</span><br><span class="line">LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">.addSerializer(LocalTime.class, new</span><br><span class="line">LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));</span><br><span class="line">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span><br><span class="line">this.registerModule(simpleModule);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="x2F-5"><a href="#x2F-5" class="headerlink" title="/**"></a>/**</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* 扩展mvc框架的消息转换器</span><br><span class="line">* @param converters</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span><br><span class="line">{</span><br><span class="line">log.info("扩展消息转换器...");</span><br><span class="line">//创建消息转换器对象</span><br><span class="line">MappingJackson2HttpMessageConverter messageConverter = new</span><br><span class="line">MappingJackson2HttpMessageConverter();</span><br><span class="line">//设置对象转换器，底层使用Jackson将Java对象转为json</span><br><span class="line">messageConverter.setObjectMapper(new JacksonObjectMapper());</span><br><span class="line">//将上面的消息转换器对象追加到mvc框架的转换器集合中</span><br><span class="line">converters.add( 0 ,messageConverter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-编辑员工信息"><a href="#5-编辑员工信息" class="headerlink" title="5. 编辑员工信息"></a>5. 编辑员工信息</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><h5 id="在员工管理列表页面点击-“编辑”-按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最"><a href="#在员工管理列表页面点击-“编辑”-按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最" class="headerlink" title="在员工管理列表页面点击 “编辑” 按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最"></a>在员工管理列表页面点击 “编辑” 按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最</h5><h5 id="后点击-“保存”-按钮完成编辑操作。"><a href="#后点击-“保存”-按钮完成编辑操作。" class="headerlink" title="后点击 “保存” 按钮完成编辑操作。"></a>后点击 “保存” 按钮完成编辑操作。</h5><p><img src="https://s2.loli.net/2022/08/17/wrhgbj1B7l2Cqfo.png" alt="image-20220815234614613"></p>
<h5 id="那么从上述的分析中，我们可以看出当前实现的编辑功能-我们需要实现两个方法"><a href="#那么从上述的分析中，我们可以看出当前实现的编辑功能-我们需要实现两个方法" class="headerlink" title="那么从上述的分析中，我们可以看出当前实现的编辑功能,我们需要实现两个方法:"></a>那么从上述的分析中，我们可以看出当前实现的编辑功能,我们需要实现两个方法:</h5><h5 id="A-根据ID查询-用于页面数据回显"><a href="#A-根据ID查询-用于页面数据回显" class="headerlink" title="A. 根据ID查询, 用于页面数据回显"></a>A. 根据ID查询, 用于页面数据回显</h5><h5 id="B-保存修改"><a href="#B-保存修改" class="headerlink" title="B. 保存修改"></a>B. 保存修改</h5><h3 id="5-2-程序执行流程"><a href="#5-2-程序执行流程" class="headerlink" title="5.2 程序执行流程"></a>5.2 程序执行流程</h3><p><img src="https://s2.loli.net/2022/08/17/B1seUWwA8LiMuDK.png" alt="image-20220815234626520"></p>
<h5 id="在开发代码之前需要梳理一下操作过程和对应的程序的执行流程："><a href="#在开发代码之前需要梳理一下操作过程和对应的程序的执行流程：" class="headerlink" title="在开发代码之前需要梳理一下操作过程和对应的程序的执行流程："></a>在开发代码之前需要梳理一下操作过程和对应的程序的执行流程：</h5><h5 id="1-点击编辑按钮时，页面跳转到add-html，并在url中携带参数-员工id"><a href="#1-点击编辑按钮时，页面跳转到add-html，并在url中携带参数-员工id" class="headerlink" title="1). 点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]"></a>1). 点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]</h5><h5 id="2-在add-html页面获取url中的参数-员工id"><a href="#2-在add-html页面获取url中的参数-员工id" class="headerlink" title="2). 在add.html页面获取url中的参数[员工id]"></a>2). 在add.html页面获取url中的参数[员工id]</h5><h5 id="3-发送ajax请求，请求服务端，同时提交员工id参数"><a href="#3-发送ajax请求，请求服务端，同时提交员工id参数" class="headerlink" title="3). 发送ajax请求，请求服务端，同时提交员工id参数"></a>3). 发送ajax请求，请求服务端，同时提交员工id参数</h5><h5 id="4-服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面"><a href="#4-服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面" class="headerlink" title="4). 服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面"></a>4). 服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面</h5><p><img src="https://s2.loli.net/2022/08/17/4BEsH5GPozImJFi.png" alt="image-20220815234644822"></p>
<h5 id="5-页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显"><a href="#5-页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显" class="headerlink" title="5). 页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显"></a>5). 页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显</h5><h5 id="6-点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端"><a href="#6-点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端" class="headerlink" title="6). 点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端"></a>6). 点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端</h5><h5 id="7-服务端接收员工信息，并进行处理，完成后给页面响应"><a href="#7-服务端接收员工信息，并进行处理，完成后给页面响应" class="headerlink" title="7). 服务端接收员工信息，并进行处理，完成后给页面响应"></a>7). 服务端接收员工信息，并进行处理，完成后给页面响应</h5><h5 id="8-页面接收到服务端响应信息后进行相应处理"><a href="#8-页面接收到服务端响应信息后进行相应处理" class="headerlink" title="8). 页面接收到服务端响应信息后进行相应处理"></a>8). 页面接收到服务端响应信息后进行相应处理</h5><p><img src="C:%5CUsers%5C13772%5CDesktop%5Cimg%5Cimage-20220815234708686.png" alt="image-20220815234708686"></p>
<h5 id="注意：add-html页面为公共页面，新增员工和编辑员工都是在此页面操作"><a href="#注意：add-html页面为公共页面，新增员工和编辑员工都是在此页面操作" class="headerlink" title="注意：add.html页面为公共页面，新增员工和编辑员工都是在此页面操作"></a>注意：add.html页面为公共页面，新增员工和编辑员工都是在此页面操作</h5><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><h4 id="5-3-1-根据ID查询"><a href="#5-3-1-根据ID查询" class="headerlink" title="5.3.1 根据ID查询"></a>5.3.1 根据ID查询</h4><h5 id="经过上述的分析-我们看到-在根据ID查询员工信息时-请求信息如下"><a href="#经过上述的分析-我们看到-在根据ID查询员工信息时-请求信息如下" class="headerlink" title="经过上述的分析,我们看到,在根据ID查询员工信息时,请求信息如下:"></a>经过上述的分析,我们看到,在根据ID查询员工信息时,请求信息如下:</h5><h5 id="请求-说明-2"><a href="#请求-说明-2" class="headerlink" title="请求 说明"></a>请求 说明</h5><h5 id="请求方式-GET-1"><a href="#请求方式-GET-1" class="headerlink" title="请求方式 GET"></a>请求方式 GET</h5><h5 id="请求路径-x2F-employee-x2F-id"><a href="#请求路径-x2F-employee-x2F-id" class="headerlink" title="请求路径 /employee/{id}"></a>请求路径 /employee/{id}</h5><h5 id="请求-说明-3"><a href="#请求-说明-3" class="headerlink" title="请求 说明"></a>请求 说明</h5><h5 id="请求方式-PUT-1"><a href="#请求方式-PUT-1" class="headerlink" title="请求方式 PUT"></a>请求方式 PUT</h5><h5 id="请求路径-x2F-employee-1"><a href="#请求路径-x2F-employee-1" class="headerlink" title="请求路径 /employee"></a>请求路径 /employee</h5><h5 id="请求参数-……-json格式数据"><a href="#请求参数-……-json格式数据" class="headerlink" title="请求参数 {…….} json格式数据"></a>请求参数 {…….} json格式数据</h5><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h5><h5 id="在EmployeeController中增加方法-根据ID查询员工信息。"><a href="#在EmployeeController中增加方法-根据ID查询员工信息。" class="headerlink" title="在EmployeeController中增加方法, 根据ID查询员工信息。"></a>在EmployeeController中增加方法, 根据ID查询员工信息。</h5><h4 id="5-3-2-修改员工"><a href="#5-3-2-修改员工" class="headerlink" title="5.3.2 修改员工"></a>5.3.2 修改员工</h4><h5 id="经过上述的分析-我们看到-在修改员工信息时-请求信息如下"><a href="#经过上述的分析-我们看到-在修改员工信息时-请求信息如下" class="headerlink" title="经过上述的分析,我们看到,在修改员工信息时,请求信息如下:"></a>经过上述的分析,我们看到,在修改员工信息时,请求信息如下:</h5><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现:"></a>代码实现:</h5><h6 id="x2F-6"><a href="#x2F-6" class="headerlink" title="/**"></a>/**</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* 根据id查询员工信息</span><br><span class="line">* @param id</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@GetMapping("/{id}")</span><br><span class="line">public R&lt;Employee&gt; getById(@PathVariable Long id){</span><br><span class="line">log.info("根据id查询员工信息...");</span><br><span class="line">Employee employee = employeeService.getById(id);</span><br><span class="line">if(employee != null){</span><br><span class="line">return R.success(employee);</span><br><span class="line">}</span><br><span class="line">return R.error("没有查询到对应员工信息");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="在EmployeeController中增加方法-根据ID更新员工信息。"><a href="#在EmployeeController中增加方法-根据ID更新员工信息。" class="headerlink" title="在EmployeeController中增加方法, 根据ID更新员工信息。"></a>在EmployeeController中增加方法, 根据ID更新员工信息。</h5><h3 id="5-4-功能测试"><a href="#5-4-功能测试" class="headerlink" title="5.4 功能测试"></a>5.4 功能测试</h3><h5 id="代码编写完毕之后，我们需要将工程重启。-然后访问前端页面，-按照前面分析的操作流程进行测试，"><a href="#代码编写完毕之后，我们需要将工程重启。-然后访问前端页面，-按照前面分析的操作流程进行测试，" class="headerlink" title="代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 按照前面分析的操作流程进行测试，"></a>代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 按照前面分析的操作流程进行测试，</h5><h5 id="查看数据是否正常修改即可。"><a href="#查看数据是否正常修改即可。" class="headerlink" title="查看数据是否正常修改即可。"></a>查看数据是否正常修改即可。</h5><h6 id="x2F-7"><a href="#x2F-7" class="headerlink" title="/**"></a>/**</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">* 根据id修改员工信息</span><br><span class="line">* <span class="meta">@param</span> employee</span><br><span class="line">* <span class="meta">@return</span></span><br><span class="line">*/</span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(HttpServletRequest request,<span class="meta">@RequestBody</span> Employee</span></span><br><span class="line"><span class="params">employee)</span>{</span><br><span class="line">log.info(employee.toString());</span><br><span class="line"><span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long)request.getSession().getAttribute(<span class="string">"employee"</span>);</span><br><span class="line">employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">employee.setUpdateUser(empId);</span><br><span class="line">employeeService.updateById(employee);</span><br><span class="line"><span class="keyword">return</span> R.success(<span class="string">"员工信息修改成功"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语03</title>
    <url>/2022/07/12/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD03/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语03"><a href="#英语口语03" class="headerlink" title="英语口语03"></a>英语口语03</h1><h3 id="精力充沛"><a href="#精力充沛" class="headerlink" title="精力充沛"></a>精力充沛</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">i will try to get into the routine of getting up early in the morning and go to bed</span><br><span class="line">early at night,</span><br><span class="line">so that...</span><br><span class="line">i will have a better sleeping pattern which enables me to be more energetic throughtout the day</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三省吾身"><a href="#三省吾身" class="headerlink" title="三省吾身"></a>三省吾身</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">i think it's important to refresh my mind about the current situation,</span><br><span class="line">by vasualizing long,middle,short term goals everyday </span><br><span class="line">because...</span><br><span class="line">sometimes it's easy to lose the big picture when we are immersing yourself in detailed executions.</span><br><span class="line">But it's also easy to miss out the detailed executions when we are grasping the big picture</span><br></pre></td></tr></tbody></table></figure>

<h3 id="熬夜伤身"><a href="#熬夜伤身" class="headerlink" title="熬夜伤身"></a>熬夜伤身</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">being a night owl could hurt our health</span><br><span class="line">because...</span><br><span class="line">staying up late will disrupts your sleep-wake cycle...</span><br><span class="line">which can affect your mental functioning and energy levels the next day.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*不要找借口，不要找理由，把这些宝贵资产全部拿下*</strong></em></p>
<p><em><strong>*足够的时间，足够的方法论支撑，不可能拿不下的。*</strong></em></p>
<p><em><strong>*今天的辛苦就是明天的幸福，道理就是这么简单。*</strong></em></p>
</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语04</title>
    <url>/2022/07/13/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD04/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语04"><a href="#英语口语04" class="headerlink" title="英语口语04"></a>英语口语04</h1><h3 id="心中有蓝图"><a href="#心中有蓝图" class="headerlink" title="心中有蓝图"></a>心中有蓝图</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">you should have a version for the future,</span><br><span class="line">something you want to do or accomplish,</span><br><span class="line">because...</span><br><span class="line">when you map out your goals,</span><br><span class="line">you will focus on things that can help you achieve what you want in life.</span><br></pre></td></tr></tbody></table></figure>

<h3 id="打开适应度"><a href="#打开适应度" class="headerlink" title="打开适应度"></a>打开适应度</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">if you just do what you are pretty good at already,</span><br><span class="line">you will not triggle adaptability.</span><br><span class="line">because...</span><br><span class="line">mastery is not just about putting in 10000 hours,</span><br><span class="line">just doing something over and over again does't make you </span><br><span class="line">better at something,</span><br><span class="line">it's about 100 hours of deliberate practice.</span><br></pre></td></tr></tbody></table></figure>

<h3 id="苦练成才"><a href="#苦练成才" class="headerlink" title="苦练成才"></a>苦练成才</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">to reach your peak performance level,</span><br><span class="line">you need to challenge yourself,</span><br><span class="line">because...</span><br><span class="line">you can't expect to evolve and reach new heights if </span><br><span class="line">you only stick to your normal habits and lifestyle.</span><br></pre></td></tr></tbody></table></figure>

<p><strong>世界上最甜蜜的事，就是极致内化之后的自动脑补。</strong></p>
<p><strong>不必消耗脑流量，直接下意识输出。</strong></p>
<p><strong>就像弹钢琴一样。</strong></p>
<p><strong>练至精熟之境，你不必在意手指，</strong></p>
<p><strong>手指自动会落在适合的琴键上，并一瞬间打开最精确的力度和准度。</strong></p>
<p><strong>这种境界，你不去体会，必遗憾终身。</strong></p>
</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语06</title>
    <url>/2022/07/15/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD06/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语06"><a href="#英语口语06" class="headerlink" title="英语口语06"></a>英语口语06</h1><h3 id="朝九晚五"><a href="#朝九晚五" class="headerlink" title="朝九晚五"></a>朝九晚五</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">the dark side of 9-5 job is that</span><br><span class="line">you're exchanging your time for money,</span><br><span class="line">like...</span><br><span class="line">you spent an hour at your job,you get paied for that hour,</span><br><span class="line">for example,</span><br><span class="line">you could work your ass off,like...80 hours a week and make a certain</span><br><span class="line">amount of money...</span><br><span class="line">the problem is...</span><br><span class="line">next week you want to make that same amount,</span><br><span class="line">you still have to spend 80 hours a week.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：概念落地+例证说明，潇洒利落，层次分明。*</strong></em></p>
<p><em><strong>*如果你不赞同这个观点，你也可以拿他当一个返利，比如，啊，有些人说朝九晚五不行，他们的逻辑是….但我认为…*</strong></em></p>
<p><em><strong>*口语中，拿自己不赞同的观点开刷，是非常聪明的打法。*</strong></em></p>
<h3 id="大负翁"><a href="#大负翁" class="headerlink" title="大负翁"></a>大负翁</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Many bussiness owners end up in debt,</span><br><span class="line">because...</span><br><span class="line">they are struggling to keep the personal finances afloat</span><br><span class="line">while running a business which is not yet making money.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：短小精悍，犀利非常。*</strong></em></p>
<p><em><strong>*特别是后面逻辑链中的长句，宛若美酒，越品越香。*</strong></em></p>
<p><em><strong>*while代表伴随动作，同时发生。*</strong></em></p>
<p><em><strong>*which引导从句，修饰business.*</strong></em></p>
<h3 id="利滚利"><a href="#利滚利" class="headerlink" title="利滚利"></a>利滚利</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Debt feels free when you are swipping your card,</span><br><span class="line">but it is a illusion,</span><br><span class="line">because...</span><br><span class="line">the higher the interest rate, the more you'll end up paying for the debt,</span><br><span class="line">Also,the longer it takes you to pay off the debt,the more interest you'll pay.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：这个框架非常好，攻击力强悍霸道。*</strong></em></p>
<p><em><strong>*后面自带两个比较级，组成长句，更是威力非凡。*</strong></em></p>
<p><em><strong>*请注意此语流中的用词，细细体会。*</strong></em></p>
</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语05</title>
    <url>/2022/07/14/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD05/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语05"><a href="#英语口语05" class="headerlink" title="英语口语05"></a>英语口语05</h1><h3 id="行动是良药"><a href="#行动是良药" class="headerlink" title="行动是良药"></a>行动是良药</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">negative emotions are a call to action,</span><br><span class="line">i mean...</span><br><span class="line">if you feel crappy,</span><br><span class="line">it's because that your brain is telling you that </span><br><span class="line">there's a problem that's unaddressed,</span><br><span class="line">and you're supposed to do something.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：第一句话种复数接a call to action，是没问题的，母语者语流*</strong></em></p>
<h3 id="种瓜得瓜"><a href="#种瓜得瓜" class="headerlink" title="种瓜得瓜"></a>种瓜得瓜</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">happiness requires struggles,</span><br><span class="line">because...</span><br><span class="line">Joy doesn't sprout out of the ground,</span><br><span class="line">if you want something,you have to work for it,</span><br><span class="line">what you reap what you sow</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：母语者语流种蕴含着天然的合理节奏，比中英翻译要合理得多。*</strong></em></p>
<p><em><strong>*大白话就是说的时候节奏很自然，语流清晰而地道。*</strong></em></p>
<h3 id="机会成本"><a href="#机会成本" class="headerlink" title="机会成本"></a>机会成本</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Everything comes with a inherent sacrifice(有利有弊)</span><br><span class="line">what we gain is also what we lose,</span><br><span class="line">like...</span><br><span class="line">the person you marry is the person you fight with,</span><br><span class="line">the house you buy is the house you repair,</span><br><span class="line">the dream job you take is the job you stress over</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：例证时的排比，宛若长江三叠浪，节奏中力度十足，掷地有声。*</strong></em></p>
<p><em><strong>*我们现阶段要达到的境界，就是在中文表达中，或日常所见所闻，慢慢感受到从“中文俗语”到“英文语流”的无缝连接。*</strong></em></p>
<p><em><strong>*这样一来，中英文的互换，就变得极其轻松。*</strong></em></p>
<p><em><strong>*流利度也慢慢得到体现。*</strong></em></p>
</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语07</title>
    <url>/2022/07/16/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD07/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语07"><a href="#英语口语07" class="headerlink" title="英语口语07"></a>英语口语07</h1><h3 id="固定收入"><a href="#固定收入" class="headerlink" title="固定收入"></a>固定收入</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Most full-time employees have a fixed salaries,</span><br><span class="line">so...</span><br><span class="line">they can properly budget their money based on their expenses,</span><br><span class="line">because...</span><br><span class="line">they have a clear idea about how much to expect in their bank </span><br><span class="line">account every month.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*fixed salaries*</strong></em> <em><strong>*固定收入*</strong></em></p>
<p><em><strong>*budget*</strong></em> <em><strong>*their*</strong></em> <em><strong>*money based on*</strong></em> <em><strong>*their*</strong></em> <em><strong>*expenses*</strong></em> <em><strong>*收支平衡*</strong></em></p>
<p><em><strong>*how much to expect in*</strong></em> <em><strong>*their*</strong></em> <em><strong>*bank account*</strong></em> <em><strong>*收入预期*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*观点+逻辑链，是最有效率的打击方法之一。*</strong></em></p>
<p><em><strong>*逻辑中的推导（so…）, 因果（because）, 必须在平时内化语流中，刻意留意，才能在实战中屡屡打出暴击效果。*</strong></em></p>
<h3 id="固定日程"><a href="#固定日程" class="headerlink" title="固定日程"></a>固定日程</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Full-time employees work a fixed schedule,</span><br><span class="line">for a lot of people,it is crucial to have a specific and consistent work time each day,</span><br><span class="line">because...</span><br><span class="line">it allows them to plan around their schedules,</span><br><span class="line">rather than waiting for a rotating schedule from a part-time job.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*fixed schedule*</strong></em> <em><strong>*固定日程*</strong></em></p>
<p><em><strong>*a specific and consistent work time each day*</strong></em> <em><strong>*具体且不变的时间安排*</strong></em> </p>
<p><em><strong>*plan around*</strong></em> <em><strong>*their*</strong></em> <em><strong>*work schedule*</strong></em><em><strong>*s 围绕工作安排来计划各种事务*</strong></em></p>
<p><em><strong>*a rotating schedule*</strong></em> <em><strong>*多变的日程计划*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*切入点，把人物带进来。*</strong></em></p>
<p><em><strong>*张三，李四，大部分人，小部分人，*</strong></em></p>
<p><em><strong>*只要把人物带进来，并站在他们的角度上，就有话可说。*</strong></em></p>
<p><em><strong>*同学们参考罗翔老师的说话技巧。*</strong></em></p>
<p><em><strong>*It*</strong></em><em><strong>*’*</strong></em><em><strong>*s crucial…+because it allows…, 是实战价值非常强悍的框架。*</strong></em></p>
<p><em><strong>*最后rather than+名词或从句，也是出战率非常高的句式。*</strong></em></p>
<h3 id="懈怠"><a href="#懈怠" class="headerlink" title="懈怠"></a>懈怠</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">if we don't like we work,</span><br><span class="line">it's easy for us to be drawn to the things that we want to do</span><br><span class="line">like...</span><br><span class="line">scrolling TikTok,or reading music blogs,</span><br><span class="line">rather than the things we have to do,</span><br><span class="line">this tension possibly causes fatigue.</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语08</title>
    <url>/2022/07/18/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD08/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语08"><a href="#英语口语08" class="headerlink" title="英语口语08"></a>英语口语08</h1><h3 id="处世态度不同"><a href="#处世态度不同" class="headerlink" title="处世态度不同"></a>处世态度不同</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">There has always been a diffrence in attitude betwen the younger and</span><br><span class="line">older generations.</span><br><span class="line">because...</span><br><span class="line">Everyone wants to live and behave in his own way,no one wants to</span><br><span class="line">compromise with his or her values and views,</span><br><span class="line">and over time,</span><br><span class="line">the attitude has agumented the gernerations gap.</span><br><span class="line">and it is wider day-by-day</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：这种直接洞察人性的答案，其实是具备很大威力的。*</strong></em></p>
<p><em><strong>*因为如果你的答题经验足够丰富，你就可以知道一个本质：*</strong></em></p>
<p><em><strong>*几乎所有分析类问题的回答，其实都可以用人性来解决其中一个或几个维度。*</strong></em></p>
<p><em><strong>*注意over time后面的句式，核心词可以替换成很多东西，*</strong></em></p>
<p><em><strong>*非常有用。*</strong></em></p>
<h3 id="价值观不同"><a href="#价值观不同" class="headerlink" title="价值观不同"></a>价值观不同</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">all generations have their own set of values and views,</span><br><span class="line">because...</span><br><span class="line">Every generation have a certain time under certain circumstances</span><br><span class="line">and conditions.</span><br><span class="line">in the mean time...</span><br><span class="line">Every generation wants to uphold the principles they believe in</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：*</strong></em><em><strong>*人生在世，不可能让所有人都喜欢你。*</strong></em></p>
<p><em><strong>*因为每个人的生活处境，对世界的认知，以及思维习惯都不一样*</strong></em></p>
<p><em><strong>*通过一代人的角度来分析事物，配以人性的辅助，*</strong></em></p>
<p><em><strong>*寥寥数语，却具备深度洞察力，以及理性的包容，*</strong></em></p>
<p><em><strong>*令人闻之激赏。*</strong></em></p>
<p><em><strong>*高能动词“have”“live”“want”三星连携，一气呵成。*</strong></em></p>
<h3 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">school is very important because it is where you establish the building blocks</span><br><span class="line">of your knowledge.</span><br><span class="line">for example...</span><br><span class="line">you will begin to learn basic subjects that you will be able to </span><br><span class="line">apply in real life.</span><br><span class="line">and you will learn important social skills as you interact with other </span><br><span class="line">students.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*establish the building blocks*</strong></em> <em><strong>*of your knowledge*</strong></em> <em><strong>*建立体系*</strong></em></p>
<p><em><strong>*basic subjects that you will be able to apply in real life*</strong></em> <em><strong>*实用的知识*</strong></em></p>
<p><em><strong>*social skills as you interact with other students*</strong></em> <em><strong>*人际交往的技巧*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*知识体系的建立，必须从小接受良好的教育。*</strong></em></p>
<p><em><strong>*而一个认知力很厉害的人，往往就是通过教育，建立了自己的认知体系。*</strong></em></p>
<p><em><strong>*此语流一个观点+例证，鲜明清晰，让人听得不累。*</strong></em></p>
<p><em><strong>*有时候也没必要一定要太复杂，一个好玩的例子，其实已经是功力的展现。*</strong></em></p>
<p><em><strong>*词伙“*</strong></em><em><strong>*establish the building blocks*</strong></em> <em><strong>*of your knowledge*</strong></em><em><strong>*”具象化非常漂亮，而其后两个长句，*</strong></em></p>
<p><em><strong>*一个that从句，一个as从句，低调而华丽。*</strong></em></p>
</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语10</title>
    <url>/2022/07/21/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD10/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语10"><a href="#英语口语10" class="headerlink" title="英语口语10"></a>英语口语10</h1><h3 id="光阴似箭"><a href="#光阴似箭" class="headerlink" title="光阴似箭"></a>光阴似箭</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">time is the most valuable things on earth,</span><br><span class="line">we can't afford to let it go by without maximizing it,</span><br><span class="line">because...</span><br><span class="line">it is one of the few things that can't be measured in terms of money</span><br><span class="line">time never come back,when it's gone,it's gone</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*we can’t afford to let it go by without maximizing*</strong></em> <em><strong>*it*</strong></em></p>
<p><em><strong>*有效利用*</strong></em></p>
<p><em><strong>*Time*</strong></em> <em><strong>*never comes back, when it’s gone, it’s gone*</strong></em></p>
<p><em><strong>*时光一去不复返*</strong></em></p>
<p><em><strong>*it*</strong></em> <em><strong>*is one of the few things that can’t be measured in terms of money*</strong></em></p>
<p><em><strong>*无法用金钱衡量*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*大家想一想，和时间一样，不能用金钱衡量的还有那些，*</strong></em></p>
<p><em><strong>*并且这些东西如何融入这个框架中。*</strong></em></p>
<p><em><strong>*体会一下举一反三的快感。*</strong></em></p>
<h3 id="恶习"><a href="#恶习" class="headerlink" title="恶习"></a>恶习</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Most people have developed a 'productivity_busting habit' over years,</span><br><span class="line">for example...</span><br><span class="line">they check their emails compulsively throughout the day or</span><br><span class="line">get interrupted whenever the phone buzzes,</span><br><span class="line">the worst part is when the habit is formed,it is hard to break.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*productivity-busting habits*</strong></em> <em><strong>*损害效率的习惯*</strong></em></p>
<p><em><strong>*check their emails compulsively throughout the day*</strong></em> <em><strong>*信息强迫症*</strong></em></p>
<p><em><strong>*get interrupted whenever their phone buzzes*</strong></em> <em><strong>*无时不刻要回复信息*</strong></em></p>
<p><em><strong>*when the habit is formed, it’s hard to break*</strong></em> <em><strong>*根深蒂固*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*尽量避免对你效率产生危害的习惯。*</strong></em></p>
<p><em><strong>*一旦这种习惯被剔除，你的有效时间会大大增加。*</strong></em></p>
<p><em><strong>*这个语流中的两个例子，请大家代入情景去思考和记忆。*</strong></em></p>
<p><em><strong>*你的邮箱，你的手机，你的聊天工具……*</strong></em></p>
<h3 id="逃避情绪自耗"><a href="#逃避情绪自耗" class="headerlink" title="逃避情绪自耗"></a>逃避情绪自耗</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">staying busy is a way to avoid painful feels,</span><br><span class="line">because...</span><br><span class="line">if you are super busy,</span><br><span class="line">you are unable to focus on what's bothering you or</span><br><span class="line">what's causing you to feel longly and insecure.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*painful feelings*</strong></em> </p>
<p><em><strong>*伤心事*</strong></em></p>
<p><em><strong>*feel lonely and insecure*</strong></em> </p>
<p><em><strong>*孤独和惶恐*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*重点：代入感*</strong></em></p>
<p><em><strong>*能不能将语流变成你生活中的一个个场景？*</strong></em></p>
<p><em><strong>*比如这个语流，我们可以代入我们伤心或茫然的时刻。*</strong></em></p>
<p><em><strong>*这就是高度内化（mental representation）的第二阶段。*</strong></em></p>
<h3 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">University education will not only give the students a opportunity to</span><br><span class="line">gain in-depth knowledge</span><br><span class="line">but also to develop skills such as communication,</span><br><span class="line">presentation and problem-solving,</span><br><span class="line">while enhancing the ability to work as part of a team</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*在这个简简单单的语流中，大学吸收知识的四个关键点，每一个点都踩到了。*</strong></em></p>
<p><em><strong>*而这一切，全是在电光石火之中，瞬间输出。*</strong></em></p>
<p><em><strong>*速度，力度，精度俱全。*</strong></em></p>
<p><em><strong>*这个语流并不是说句式有多漂亮，但胜在简单有效。*</strong></em></p>
<p><em><strong>*框架中，*</strong></em></p>
<p><em><strong>*Not only+but also+while组成行云流水的长句。*</strong></em> </p>
<p><em><strong>*————————————————————*</strong></em></p>
<p><em><strong>*今天把大脑放空，先别记着去记忆了。*</strong></em></p>
<p><em><strong>*试着在不看中文对接的情况学，把学到的每个语流回忆起来，并试着把它跟你的生活联系在一起。*</strong></em></p>
<p><em><strong>*不要有压力，想到多少就是多少。*</strong></em></p>
<p><em><strong>*语言内化，其实就是一个游戏。*</strong></em></p>
<p> <em><strong>*_________________*</strong></em></p>
<p><em><strong>*what do you think about time management?*</strong></em></p>
<p><em><strong>*I*</strong></em> <em><strong>*know nothing about time management*</strong></em><em><strong>*…*</strong></em></p>
<p><em><strong>*the only thing i know for sure is that*</strong></em></p>
<p><em><strong>*time is one of the few things that can’t be measured*</strong></em><em><strong>*/*</strong></em> <em><strong>*in terms of*</strong></em> </p>
<p><em><strong>*money…*</strong></em></p>
<p><em><strong>*it never comes back,*</strong></em> <em><strong>*you know,*</strong></em> <em><strong>*when it’s gone, it’s gone*</strong></em></p>
<p><em><strong>*So…*</strong></em> </p>
<p><em><strong>*I can’t afford to let it go by*</strong></em><em><strong>*/*</strong></em> <em><strong>*without maximizing*</strong></em><em><strong>*/*</strong></em> <em><strong>*the time*</strong></em> <em><strong>*I*</strong></em> <em><strong>*have*</strong></em> </p>
<p><em><strong>*so yeah*</strong></em></p>
<p><em><strong>*i will do everything i can in my power to maximize it…*</strong></em></p>
<p><em><strong>*for example…*</strong></em></p>
<p><em><strong>*i will try to get into the routine of getting up early in the morning*</strong></em></p>
<p><em><strong>*and go*</strong></em><em><strong>*ing*</strong></em> <em><strong>*to bed early at night…*</strong></em></p>
<p><em><strong>*so that*</strong></em> <em><strong>*i will have a better sleeping pattern*</strong></em> </p>
<p><em><strong>*which enables m*</strong></em><em><strong>*e to*</strong></em> <em><strong>*have*</strong></em> <em><strong>*m*</strong></em><em><strong>*ore time*</strong></em> </p>
<p><em><strong>*To*</strong></em> <em><strong>*focus on the important things in my life,*</strong></em></p>
<p><em><strong>*and…*</strong></em></p>
<p><em><strong>*Because*</strong></em> <em><strong>*our brains tend to be most alert*</strong></em><em><strong>*/*</strong></em> <em><strong>*in the morning*</strong></em><em><strong>*, right?*</strong></em></p>
<p><em><strong>*So*</strong></em><em><strong>*…*</strong></em> </p>
<p><em><strong>*to*</strong></em> <em><strong>*increase*</strong></em> <em><strong>*my*</strong></em> <em><strong>*productivity at wor*</strong></em><em><strong>*k*</strong></em> <em><strong>*for this day,*</strong></em></p>
<p><em><strong>*i will try to*</strong></em> <em><strong>*get into the state of flow of deep work early in the day*</strong></em></p>
<p><em><strong>*while the rest of the world*</strong></em><em><strong>*/*</strong></em> </p>
<p><em><strong>*is asleep*</strong></em><em><strong>*.*</strong></em></p>
</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语11</title>
    <url>/2022/07/22/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD11/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语11"><a href="#英语口语11" class="headerlink" title="英语口语11"></a>英语口语11</h1><h3 id="一件令你悲伤的事"><a href="#一件令你悲伤的事" class="headerlink" title="一件令你悲伤的事:"></a>一件令你悲伤的事:</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">i lost my dog after a year of long battle,</span><br><span class="line">a year before i had been told that her liver was died and she had only 6 months,</span><br><span class="line">After my dog died, i didn't know what to deal with myself</span><br><span class="line">and i couldn't get myself together,</span><br><span class="line">i have this massive a pit of depression inside of me,</span><br><span class="line">...</span><br><span class="line">one day,i woke up,i was sitting there in my bed</span><br><span class="line">and i didn't know what i was supposed to do next,</span><br><span class="line">it was like my brain had spilt in half,</span><br><span class="line">anyway, it took me three years to get over it</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注*</strong></em><em><strong>*：*</strong></em></p>
<p><em><strong>*两点。*</strong></em></p>
<p><em><strong>*一，*</strong></em><em><strong>*情绪是很多话题的导火线，熟悉运用各种情绪的叙事，可以很快打开话题。*</strong></em></p>
<p><em><strong>*比如悲伤的话题，可以衍生至：一件你不愿想起的事，一件你很难忘记的事，说说你的的宠物，*</strong></em></p>
<p><em><strong>*二，*</strong></em><em><strong>*一件令你成长的事，一件令你感悟的事……*</strong></em></p>
<p><em><strong>*这个语流我用了中英文对照，但不是翻译，而是意译，让大家体会一下叙述性语流的特点。*</strong></em></p>
<h3 id="积极主动"><a href="#积极主动" class="headerlink" title="积极主动"></a>积极主动</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">being proactive,</span><br><span class="line">it means you take actions that be intented to cause changes</span><br><span class="line">rather than reacting to changes,</span><br><span class="line">like...</span><br><span class="line">if you want to sellproducts,</span><br><span class="line">instead of focusing on how people these days don't appreciate good products,</span><br><span class="line">you focus on how can you improve your product so that your customers can't live without it.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*make actions that are intended to cause changes*</strong></em> <em><strong>*主动改变现状的行动*</strong></em></p>
<p><em><strong>*rather than just reacting to change*</strong></em> <em><strong>*被动接受变化*</strong></em></p>
<p><em><strong>*can’t live without it*</strong></em> <em><strong>*割舍不下*</strong></em></p>
<p><em><strong>*注：场景化的运用，非常重要。*</strong></em></p>
<p><em><strong>*proactive是一个实战性非常高的概念，而且天然具备极多的可扩展性。*</strong></em></p>
<h3 id="方法灵活"><a href="#方法灵活" class="headerlink" title="方法灵活"></a>方法灵活</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Strategic thinkers take the time to plan out the best solution to a problem,</span><br><span class="line">so...</span><br><span class="line">rather than relying on a standard problem-solving method,</span><br><span class="line">they will try to take different approach to a problem,</span><br><span class="line">and deal with it in a more creative manner</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*这是一个对我人生极其重要的语流。*</strong></em></p>
<p><em><strong>*对我的影响至深。*</strong></em></p>
<p><em><strong>*方法总比苦难多，至理名言。*</strong></em></p>
<p><em><strong>*句式方面，rather than提前，后面接主句，非常地道的语流展现手法。*</strong></em></p>
<p><em><strong>*后半部分的三个高质量词伙的运用，也非常方便串联式记忆。*</strong></em></p>
</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机的三大原则</title>
    <url>/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<html><head></head><body><h2 id="计算机的三大原则"><a href="#计算机的三大原则" class="headerlink" title="计算机的三大原则"></a>计算机的三大原则</h2><p>既然是三大原则，那肯定就是有三条了，也就是如下：<br>​</p>
<ol>
<li>计算机本质上就是在执行“输入-运算-输出”</li>
<li>指令和数据的结合就是程序</li>
<li>计算机只认识数字</li>
</ol>
<p>怎样样，这三条有没有让你长知识的感觉？尤其是这个第三条，计算机只认识数字，这个蛮重要的，基于此，有句话，大家一定要熟记于心了：<br>​</p>
<blockquote>
<p>数据都是以二进制的形式存在于内存中的<br>​</p>
</blockquote>
<h3 id="输入-运算-输出"><a href="#输入-运算-输出" class="headerlink" title="输入-运算-输出"></a>输入-运算-输出</h3><p>首先我们来非常直观看下，我们现在用的计算机是不是基本都是这样的：<br>​</p>
<blockquote>
<p>键盘上输入相关信息，然后点击一些程序的相关按钮进行相关计算，然后在屏幕上显示出一些结果</p>
</blockquote>
<p>对于笔记本电脑，一般就是一体的，我们可以看看台式机，不是那种一体机，就是那种一个主机，然后一个显示器，接着还需要一把键盘和一个鼠标，那这个配置就更加清晰了，画个图，是不是就是这样的：<br>​</p>
<p><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-080815.png" alt="image.png"><br>​</p>
<p>看看是不是这样的，其实说到底是不是就是这么一个流程：<br>​</p>
<blockquote>
<p>输入 - 运算 -输出</p>
</blockquote>
<p>这个是我们很直观的可以从表面看到的这么一个流程，比如我们打开电脑上的计算器：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-080816.png" alt="image.png"><br>这个时候我们如果想计算1+1等于，<strong>我们需要进行输入</strong>，可以使用鼠标直接点击上面的数字，也可以使用键盘进行输入，比如我们使用键盘输入1+1：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-080818.png" alt="image.png"><br>这个时候我们按下键盘上的回车键之后，我们其实就完成了输入的过程，而且<strong>交由电脑去做运算</strong>，这里的运算底层实际上就是交给CPU了，然后运算结束就会把<strong>结果显示在屏幕上，这就是一个输出</strong>：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-080819.png" alt="image.png"><br>​</p>
<p>以上就是完成了一个输入到运算再到输出的过程，当然，这是一个非常简单的例子，但是<strong>很多看似复杂的其实本质都是这三个步骤~</strong><br>​</p>
<p>再往底层的去说一点，我们的<strong>电脑其实是由大量的集成电路组成的</strong>，这个集成电路的英文简称就叫做IC，这个玩意差不多就长这个样子：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-080820.png" alt="image.png"><br>​</p>
<p>一般这些IC上有很多的引脚，这个引脚我想我不用解释你也知道是哪个吧，这些<strong>引脚也都有各自的用处，有的可以进行输入，有的可以进行输出</strong>，而运算往往就是交由IC内部来操作的~<br>​</p>
<p>当然，这个说的可能让你觉得有点底层了，没干系，了解一下就行，其实我主要的还是想告诉你，或者跟你强调，计算机啊，看似复杂，其实它做的绝对大部分事情归根结底就是三步：<br>​</p>
<blockquote>
<p><strong>输入-运算-输出</strong></p>
</blockquote>
<p>比如再举一个例子，大家可以用电脑浏览网页或者看电影，比如你想看某个电影，是不是也是通过搜索（这个就是一个输入），然后经过联网请求（这个就是一个运算）最终把结果给你展现出来，你就可以点击到资源进行观看了（这就是一个输出）~<br>​</p>
<p>其实你可以仔细想想，是不是<strong>电脑做的很多事情都离不开输入-运算-输出</strong>这三个步骤呢？<br>​</p>
<h3 id="指令和数据的结合"><a href="#指令和数据的结合" class="headerlink" title="指令和数据的结合"></a>指令和数据的结合</h3><p>以上就是计算机的第一个原则了，接着我们说说第二个原则，那就是<strong>指令和数据的集合就是程序~</strong><br>​</p>
<p>不知道此前你是否思考过，<strong>什么是程序呢？</strong>简单一句话，就是指令和数据的集合，其实说白了，指令也算是一种数据，只不过比较特殊而已~<br>​</p>
<blockquote>
<p>对于指令，它不参与运算，而是控制运算，也就是说指令是一种命令，控制着计算机进行怎样的输入，运算和输出~</p>
</blockquote>
<p>而输入，运算和输出操作的则是数据了~ 怎么样，这一点还是可以理解的吧~、<br>​</p>
<p>比如我们写的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(s == s1);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>每一行代码其实都可以看做是对计算机的一个指令</strong>，然后把这些指令都给列出来就成了我们说的程序了~<br>​</p>
<p>当然，这个只是很简单的去说，其实你像这些个指令都会进行组合，比如几个指令组合在一起，完成一个特定的功能，比如这样：<br>​</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getAll</span><span class="params">(Object o)</span>{</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>然后给起一个名字，比如函数或者方法，咋样，get到了吧~<br>​</p>
<p>接着我们再来看数据，那数据其实也可以分为两种，想想咱之前说的第一个原则，计算机干的很多事情其实都是输入-运算-输出，那这三个步骤需要操作的其实就是数据啊，所以数据一般分为两种：<br>​</p>
<p>1、输入数据<br>2、输出数据<br>​</p>
<p>但是无论是哪一种数据，我们在写代码的时候总不能就叫做数据吧，<strong>像这种输入数据和输出数据，我们也会给它们起一个特定的名称，比如变量</strong>，就好比以下代码：<br>​</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">66</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>我们定义了一个int类型的变量a，那说到这里，你是不是觉得有点意思了，是不是觉得有些知识被打通了呢？<br>​</p>
<p>所以，到了这里，请你记住：</p>
<blockquote>
<p>无论多么复杂的程序，其实都是指令和数据的集合</p>
</blockquote>
<h3 id="计算机只认识数字"><a href="#计算机只认识数字" class="headerlink" title="计算机只认识数字"></a>计算机只认识数字</h3><p>紧接着，我们来看看计算机三大原则中的最后一个，也就是<strong>计算机其实只认识数字~</strong><br>​</p>
<p>我们表面来看，计算机是一个非常神奇的东西，可以做很多事情，觉得很多东西都是以我们自己现在的知识无法理解的，但是真的当你去细心研究学习的时候，你就会发现，<strong>看似复杂神奇的计算机，其实有些东西的确很简单</strong>~<br>​</p>
<p>说到底，计算机再神奇，也是需要我们来进行操作，也就是说，计算机是在为我们工作，是在按照我们的指令去执行一些事情，说白了，计算机终归只是一种工具而已~<br>​</p>
<p>有句话我需要再给大家强调一下，那就是：<br>​</p>
<blockquote>
<p><strong>数据都是以二进制的形式存储在内存中的</strong></p>
</blockquote>
<p>这句话你现在可以不理解，但是你一定要记住，这个其实和我们现在要说的计算机的第三个原则“计算机只认识数字”本质上是一样的~<br>​</p>
<p>大家是够好奇过这个问题，计算机，也就是电脑，说到底还是电子产品，各种电子元器件组成的，然后通电~<br>​</p>
<p>但是神奇就神奇在这里，我们可以干很多事情，可以使用word编写文档，可以使用视频软件观看电影等等，<strong>你说计算机只认识数字，那这些文字，视频，包括颜色什么的是怎么回事呢？</strong><br>​</p>
<p>都用数字代表吗？<br>​</p>
<p>的确如此，在计算机中，其实还真的是用数字表示所有信息，像正常数字，我们说用数字表示，那没啥问题，<strong>我们可能感到疑惑的就是像颜色这些还能用数字表示？</strong><br>​</p>
<p>当然可以，大家一定见过这个：<br>​</p>
<p><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-080822.png" alt="image.png"><br>就是RGB，比如红色我们就可以用“255,0,0”来表示，那对于计算机来说，它不像我们人，说红色我们都知道是什么颜色，但是计算机不行，你得告诉它数字~<br>​</p>
<p>同样的，像文字也是需要用数字表示，计算机才能看得懂，那对于文字该怎么用数字表示呢？这个其实就需要<strong>字符编码</strong>了~<br>​</p>
<p>那这些该怎么去理解呢？其实你只要仔细思考就会发现，既然计算机只认识数字，那只要把其他需要展现的信息做一个与数字一一对应的映射表不就行了？<br>​</p>
<p>get到了吧？比如咱们可以用“255,0,0”来表示红色，这就是一个颜色和数字的对应啊，这个RGB其实不就是一个映射表嘛？<br>​</p>
<p>同样的，所谓的字符编码也是如此，也就是说，文字也可以进行编码，用数字表示，然后一一对应，这样计算机就可以进行识别了，后续你就会接触到一个叫做<strong>ASCII码</strong>的东西，这也是一张映射表，它<strong>可以将文字转换成计算机认识的数字~</strong><br>​</p>
<p>那关于这点如果你想理解的更加透彻，去看看“计算机其实很笨，只认识0和1”你就会明白了~<br>​</p>
<p>所以到了这里，你就要有这么一个认识：<br>​</p>
<blockquote>
<p><strong>尽管计算机很神奇，但是它处理的任何信息，实际上处理的都是数字</strong></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>内功</category>
      </categories>
      <tags>
        <tag>内功</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算和进制转换，原码，反码</title>
    <url>/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E5%86%85%E5%8A%9F%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<html><head></head><body></body></html>]]></content>
      <categories>
        <category>内功</category>
      </categories>
      <tags>
        <tag>内功</tag>
      </tags>
  </entry>
  <entry>
    <title>内存那点事儿</title>
    <url>/2022/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<html><head></head><body><h1 id="内存那点事儿"><a href="#内存那点事儿" class="headerlink" title="内存那点事儿"></a>内存那点事儿</h1><h3 id="DDR3-DDR4"><a href="#DDR3-DDR4" class="headerlink" title="DDR3?DDR4?"></a>DDR3?DDR4?</h3><p>这个大家熟悉吧，<strong>我们要是换内存条的话一定要看看我们的电脑支持是哪一种</strong>，不然就是白花钱啊，我之前就买错过一次，源于自己的太自信~</p>
<p>我们已经知道了啥是内存，也知道了我们这里的内存也是主存，RAM，它们都是一个品种，一样的，这个RAM是一般的随机存取存储器，除此之外还有<strong>DRAM</strong>，这又是啥嘞，RAM是随机存取存储器，这个DRAM是<strong>动态随机存取存储器</strong>，对应的还有<strong>SRAM叫做静态存取存储器</strong>。</p>
<p>DRAM结构简单，单位体积内容量高成本低，但是访问速度慢，耗电大，相应的SRAM结构复杂，成本高等。<strong>无论DRAM还是SRAM都属于内存</strong>，也就是断电会丢失数据，综合来说DRAM的性价比比较高，扩展性也很好，所以就成了现在广为流行的电脑主存，</p>
<p>然后你还要知道<strong>SDRAM</strong>，这是啥嘞，DRAM是动态随机存取存储器，SDRAM是<strong>同步动态随机存取存储器</strong>，也就是比DRAM更牛，升级版，然后还有<strong>DDR SDRAM</strong>，不用说，这肯定是SDRAM的升级版，这个叫<strong>双倍数据率同步动态随机存取存储器</strong>，哈哈，这名字可以的，继续，还有DDR3 SDRAM，知道这个是啥不，对的，<strong>第三代双倍数据率同步动态随机存取存储器</strong>，哈哈，还有DDR4 SDRAM，知道了吧，那么我们电脑中的DDR3和DDR4知道怎么回事了吧。</p>
<h3 id="内存的原本模样（物理机制）"><a href="#内存的原本模样（物理机制）" class="headerlink" title="内存的原本模样（物理机制）"></a>内存的原本模样（物理机制）</h3><p>我们之前已经说过了<strong>内存就是主存，也叫做随机存取存储器，缩写是RAM</strong>，然后还说了什么DRAM,SRAM然后还有DDR SDRAM等等，这些其实都是内存，只不过是各自的形式不同，但是实实在在的一个电路板，就我们能拿在手里的内存条，他们的物理机制其实都差不多，都有什么电源，地址信号，数据信号和控制信号等等，下面我们来看一张图你就清楚了</p>
<p><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-084033.png" alt="image.png"></p>
<h4 id="啥是内存IC"><a href="#啥是内存IC" class="headerlink" title="啥是内存IC"></a>啥是内存IC</h4><p><strong>这个内存IC其实就是内存中用来真正保存数据的地方，也就是内存提供的容量所在</strong>，因此，可以说<strong>内存的实质就是内存IC</strong>，先知道这些，我们继续往下说，这个内存IC后面还会说的。</p>
<p>刚开始看这个图一定是懵的，那么我们先来看一个问题，就是<strong>这个图代表的内存能够存储多少数据呢？</strong>接下来我们就以这个图开始说，最后如果你能明白这个内存能存储多少数据，目的就达到了。</p>
<p>上图的各个标志已经有说明了，VCC和GND是链接电源的地方，通上电之后这玩意就带电了，我们之前应该知道，数据都是以二进制的形式存放在内存中的，也就是0和1，这个是通识，那么这个0和1是怎么表示的呢？</p>
<p>看这个图，当VCC和GND通上电以后，就可以给其他引脚传递1或者0的信号，这里的引脚就是A0-A9，这是<strong>地址信号引脚</strong>，D0-D7这是数据信号引脚，1或者0是根据电压来表示的。</p>
<p>通常嘞，+5V的直流电压表示1,0V就是0，也就是说啊，通上电以后嘞，这里的数据信号引脚D0-D7这八个引脚可能是+5V或者是0V，也就是可以表示0或者1，一个引脚相当于一位，这位上可以是0或者1，然后这<strong>八个引脚都可以表示对应的0或者1，这样就可以形成一个八位的用0和1表示的数据，这其实就是二进制啊。</strong></p>
<p>D0-D7可以表示具体的数据，这也是存放在内存中的数据的底层表现形式，同样的，上面的地址信号引脚也是一样的道理，每个引脚可以表示1或者0，这样地址信号引脚和数据信号引脚确定以后，地址信号引脚组成的0和1的这个数据就叫做我们熟知的内存地址，根据它我们就可以找到数据信号引脚代表的数据了。</p>
<p><strong>上面说的可能有点小难懂，不理解的多读几遍，对照着图哦</strong></p>
<h4 id="内存IC的容量怎么看"><a href="#内存IC的容量怎么看" class="headerlink" title="内存IC的容量怎么看"></a>内存IC的容量怎么看</h4><p>那么这个<strong>内存可以存储多少个数据嘞</strong>，我们知道数据信号引脚来表示具体的数据，需要通过地址信号表示的二进制数据来找到它，也就是说每个地址信号代表的的数据是对应着一个数据信号引脚表示的真实数据的，所以嘞，<strong>地址信号引脚可以表示多少个数据不就代表这个内存可以存放多少数据嘛</strong>，这里的地址信号引脚有A0-A9，也就是10个，因此它可以表示0000000000—-1111111111之间的数据，有多少嘞，一共有1024个。</p>
<p>所以啊，这个内存可以存储1024个1字节的数据，对了，<strong>数据信号引脚八个代表一个字节的数据，也就是一个引脚代表1位，也就是1bit，8bit就是一个字节，也即是1byte，然后1024byte又等于1KB，所以，这个内存IC最终的容量就是1KB</strong></p>
<p>你可能会说，这也太小了点了吧，确实小，<strong>作为程序员的我们，电脑中使用的内存最低也得8GB吧</strong>，这得多少个内存IC啊，这里你可能会有点迷糊，我详细的说下。</p>
<p><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-084034.png" alt="image.png"></p>
<h4 id="再来说内存IC"><a href="#再来说内存IC" class="headerlink" title="再来说内存IC"></a>再来说内存IC</h4><p>知道这个吧，我们把这个叫做<strong>内存IC，IC是集成电路的意思</strong>，这个内存IC其实有两种，你只需要知道其中一种叫做<strong>内存颗粒或者内存芯片</strong>的就行，我们这里说的内存IC更为准确来说其实就是内存颗粒，是镶嵌在内存条上的，看个图就知道了</p>
<p><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-084036.png" alt="image.png"><br>这个是内存条，上面那<strong>黑的一块一块的其实就是内存颗粒</strong>，也就是我们上面说的内存IC，那么你可能会说，上面那个内存IC的容量才1KB，我们平常用的话最低也得8GB，这也镶不下啊，如果都是容量1KB的内存IC，当然镶不下，因此容量更大的内存条则需要容量更大的内存IC，这个口蹄疫通过内存IC上的引脚数量来实现，不过这个也更加复杂有难度，当然，<strong>容量越大，内存条也越贵啊</strong>，就是这么个道理。</p>
<h3 id="程序员眼中的内存"><a href="#程序员眼中的内存" class="headerlink" title="程序员眼中的内存"></a>程序员眼中的内存</h3><p>上面我们把内存稍微深入的说了一遍，相信你看下来一定有不少收获吧，当然，我不排除你没有看懂，如果真的没有看懂，可以多看几遍，当然，也许你是个大神，发现我哪里说错了，如果是这样，还劳烦指教一下哦~</p>
<blockquote>
<p>那么我们作为一个程序员，每天就是写写代码，我们需要知道什么内存IC，什么这信号那引脚的吗？</p>
</blockquote>
<p>其实吧，我觉不是很有必要，但是知道总比不知道强，不过下面的这些你可一定要知道啊。</p>
<h4 id="如何形象的去理解内存"><a href="#如何形象的去理解内存" class="headerlink" title="如何形象的去理解内存"></a>如何形象的去理解内存</h4><p>在之前的文章中曾经介绍过内存，那时候说我们<strong>可以把内存看成一个个的小格子</strong>，就像这样</p>
<p><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-084037.png" alt="null"><br>这样的一个个的小格子，里面<strong>主要存放数据和一些指令</strong>，然后每个格子还有对应的编号，这个编号就叫做内存地址，想想，这里的编号是不是就是上面说的内存IC中的地址信号引脚组成的数据，然后每个格子中存放的数据和指令就是通过内存IC中的数据信号引脚来表示的。然后你还可以想象成，每个格子可以存放1字节的数据，也就是内存IC中的那八个信号引脚，对应起来了吧，那么一个容量为1KB的内存（只含有一个内存颗粒，容量就为1KB），这样的格子就有1024个，画成图就是这样的</p>
<p><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-084039.png" alt="null"><br>然后我们还知道在java中是有数据类型的，数据类型的作用简单说就是<strong>决定数据在内存中暂用多少内存空间</strong>，这里也就是要占用多少个小格子，我们知道在java中int代表整型占4个字节，这里一个格子可以保存1字节的数据，那么int就需要占用4个小格子。对于作为程序员的我们，就应该这样来理解内存，这样更加形象，有助于我们更好的编程。</p>
<h4 id="这些硬核真的硬？"><a href="#这些硬核真的硬？" class="headerlink" title="这些硬核真的硬？"></a>这些硬核真的硬？</h4><p>看到这里，你想一下，了解了上述知识，当你写下一个</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>你是不是会想，<strong>int向内存申请四个小格子</strong>，每个格子有对应的内存地址，然后10转换成二进制数据存放在这些小格子里，实际上是内存IC中的数据信号引脚按照转换后的二进制，也就是0和1来决定每个引脚是+5V直流电压还是0V电压，当然，内存地址即使地址信号引脚啦……</p>
</body></html>]]></content>
      <categories>
        <category>内功</category>
      </categories>
      <tags>
        <tag>内功</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础_电脑开机</title>
    <url>/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<html><head></head><body><h2 id="电脑开机原因分析"><a href="#电脑开机原因分析" class="headerlink" title="电脑开机原因分析"></a>电脑开机原因分析</h2><p><strong>为什么这个按钮一按，电脑就开机了呢？</strong>不不不，不要跟我说是因为通电～<br>​</p>
<p>后面我进行了不断的学习，我发现，别看一个简单的操作“按一下按钮”，其实背后有着非常多且繁杂的步骤，首先，我们直观感觉，电脑这玩意肯定需要通电，不然屏幕怎么亮啊，但是，你们有没有思考过这样的一个问题：<br>​</p>
<blockquote>
<p>电脑的那些个功能是需要程序支撑的，没有程序很多东西都是无法展现的，也就是需要有某个东西去执行这些程序，而这个东西其实也是一种程序，也就是说必须先有某个程序执行起来，然后电脑才能开机启动，可是嘞，电脑不开机启动，这个程序又是怎么启动的呢？</p>
</blockquote>
<p>想过没有，这是一个很神奇的事情，很矛盾啊，<strong>需要先运行程序才能启动，但是不启动怎么运行呢？</strong><br>​</p>
<p>别着急，我知道看到这些，你依然不是很清楚，很迷糊，没事，接着来看，你一定听说过这样的话：<br>​</p>
<blockquote>
<p>电脑是需要操作系统的，而操作系统也是一种软件，也就是一种程序</p>
</blockquote>
<p>也就是说，我们电脑开机后，需要操作系统去把各个需要的东西给整出来，以便我们可以使用电脑，比如我们电脑开机后，你需要登录qq软件，那你启动qq这个软件其实你看不到的就是操作系统在给你执行一系列的操作，没有操作系统，你和这个qq软件就是个摆设，简单来说，<strong>操作系统帮你把qq这个软件程序执行了起来</strong>～<br>​</p>
<p>那么问题来了，同样身为软件程序的操作系统又是谁给执行起来了的呢？<br>​</p>
<hr>
<p>回到之前咱们说的，直观来看，<strong>电脑这玩意就是个用电的家伙，全身上下基本上都是各种各样的电子元件组成的</strong>，我们“啪”的一下按下开机键：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-083615.png" alt="image.png"><br>OK，我们看到相关的一些指示灯亮起来的，电脑正在启动，此时你会直观看到电脑桌面有一些画面出现，类似这个界面上过网吧的应该都见过吧：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-083616.png" alt="image.png"></p>
<p>反正就类似这样的界面（<strong>上图是网上随便找的，不要抬杠哦</strong>），我那个时候看到这个，也不知道是有问题还是没有问题，习惯性的啪啪啪的狂按键盘上的空格键和enter键，一般等一会就等到开机成功的界面了，一般是这样的：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-083618.png" alt="image.png"></p>
<p>咋样，看到这里有没有很熟悉的感觉？基本到了这里，不一会电脑就可以使用了～<br>​</p>
<p>但是这其中，电脑已经执行了很多我们看不见的步骤了，首先要说的就是这个满屏看不懂代码的界面：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-083619.png" alt="image.png"><br>这是什么？有一个单词大家应该不陌生，那就是BIOS：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-083620.png" alt="image.png"><br>这是什么，我想应该是有一部人不熟悉这个的，其实不必深究，我简单直白的说下：</p>
<blockquote>
<p>这玩意是个缩写，也就是Basic Input/Output System，翻译一下就是基本输入输出系统，不用怀疑，这玩意也是一个程序，只不过它被提前写进了一个内存中，这个内存怎么理解，电脑中咱们安装的内存条都知道吧，那玩意就是我们常说的内存，这里的内存跟这个差不多，只不过容量比较小，只保存了BIOS这段程序！</p>
</blockquote>
<p><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-083621.png" alt="image.png"><br>（图片来源于网络，侵删）<br>​</p>
<p>再看上面这张图，一个电路板中镶嵌的这块黑黑的电子元器件，它就是一种内存，里面存储了BIOS程序，所以上面写着“BIOS”～<br>​</p>
<p>那这个简单了解之后，我们就可以接着往下进行了～⚠️注意啦，先来一句重磅级的描述：<br>​</p>
<blockquote>
<p>你按下开机键之后，电脑就通电了，通电的时候会第一时间发生一件事情，就是这个BIOS程序会被自动加载～</p>
</blockquote>
<p>啥意思嘞，说的直白点，就是你只要按下开机键，电脑通上电，这个BIOS程序就会自动执行，这就是人家的神奇之处嘞，那到了这里，你是不是就觉得稍微明白点什么嘞呢？<br>​</p>
<blockquote>
<p>程序必须先运行计算机才能启动，但是只有计算机启动以后程序才能运行？</p>
</blockquote>
<p>似乎知道怎么回事嘞吧？破解这个迷惑行为的关键就是这个BIOS，也就是只要电脑一通电，这个家伙就会自动执行，当然这个自动执行其实内部牵涉的还是比较复杂的，其中也执行了一些很多其他繁杂的步骤，但是你只需要记住：</p>
<blockquote>
<p>电脑一通电，这个BIOS就启动执行了</p>
</blockquote>
<p>那么这个BIOS启动之后都干啥了呢？那可重要了，因为后续的一切操作都是建立在这个BIOS启动之后，首先这个BIOS启动后的一个重要操作就是进行<strong>“硬件自检”</strong>，俗称POST，其实也就是Power-On Self-Test的缩写，咱就记住“硬件自检”就行！</p>
<p>那<strong>啥又是硬件自检</strong>，这个其实也好理解，硬件的检查呗，就是看看组成电脑的各个电子元器件有没有什么问题，主要就是电脑内部的那些个电路板子，比如所谓的主板啊，硬盘啥的，如果某个出现问题，那就会给出相应的提示了，当然，电脑也就不能正常开机了～<br>​</p>
<p>紧接着，在<strong>进行完“硬件自检”之后，BISO会去选择一个存储设备中的程序进行执行</strong>，这个其实是大家比较熟悉的，这个步骤其实就是去选择启动操作系统了，我们知道，如果你的电脑是windows10，那你正常开机之后进入的局势windows10的界面了～<br>​</p>
<p>想必大家多多少少了解过系统重装吧，我们知道，对于我们电脑，我们的windows10系统一般就是安装在我们的C盘中，所以<strong>一般电脑中的C盘又被称作是系统盘</strong>，如果我们要重装系统的话，有一个用U盘重装的方式，是不是需要先把U盘制作成启动盘，然后把需要安装的操作系统放进去，然后我们将U盘插入电脑，这个时候就需要进入电脑中的BIOS选择将这个U盘作为首选启动项～<br>​</p>
<p>也就是BIOS完成硬件自检之后就会去选择一个存储设备中的程序进行执行，那对BIOS来说，自然有一个可以设置这个启动顺序的地方，比如这样的界面：<br><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-083622.png" alt="image.png"><br>就是BIOS硬件自检完成，从哪个存储设备开始启动，上述顺序我们可以调整成我们想要的顺序，比如将我们的U盘作为第一启动项进行系统重装！<br>​</p>
<p><strong>一般都是默认系统盘作为第一启动项</strong>，这样就会直接进入我们的系统了，还有就是<strong>这个BIOS界面其实是隐藏默认执行的</strong>，也就是你说你开机之后你是看不到这个BIOS界面，它是在后台默认执行的，我们可以通过在开机界面按住电脑上的特定组合按键（不同的电脑有所不同）打开此界面～<br>​</p>
<p>BIOS会按照启动顺序来启动排在第一位的存储设备，那既然是作为存储设备，肯定是要被读取的，也就是读取存储设备中的数据，我们这里要记住的就是，存储设备当中有一个扇区的概念，这个不需要知道到底什么是扇区，我们就可以直白的理解，<strong>这个排在第一位的存储设备会被读取～</strong><br>​</p>
<p>当然，读取之后会进行一些检验，也就你检查检查这个设备能否被启动，如果能就启动，不能的话就依次看看排在第二位的存储设备～<br>​</p>
<p>那说的再详细一点，就是这个排在第一位的存储设备被读取其中的数据，这些数据的最前的说面，说的官方点，稍微专业一点就是看看<strong>这个数据的最前面的512个字节</strong>，如果这512个自己的最后两个字节是0x55和0xAA就表明可以启动，否则就不行～<br>​</p>
<blockquote>
<p>那这512个字节叫做“主引导记录”，这算是一个专业名次了，英文是Master boot record，缩写为MBR～</p>
</blockquote>
<p>那读去这512个字节的目的就是要<strong>找到操作系统这个顶级程序在哪个位置</strong>，那这512个字节具体有如下组成：<br>​</p>
<p>（1） 第1-446字节：调用操作系统的机器码。<br>（2） 第447-510字节：分区表（Partition table）。<br>（3） 第511-512字节：主引导记录签名（0x55和0xAA）。<br>​</p>
<p>是不是觉得越来越看不懂了，不要害怕，我们不需要把上面这些东西都给深入挖掘搞懂，上述的你只需要关注一个分区表即可，这是啥，说的直白点，就是你电脑中的c盘啊，d盘啊等等，这就是分区～<br>​</p>
<p>然后最终的目的就是在这些分区中找到操作系统在哪里，一旦找到操作系统在哪个分区里面，那这个分区就会被读取，这么一个过程可以叫做<strong>“卷引导记录”</strong>，英文是Volume boot record，缩写为VBR～<br>​</p>
<p>对于“卷引导记录”也是一个专业名次了，它的主要作用就是告诉电脑，操作系统在哪里～<br>​</p>
<p>OK，找到操作系统的位置以后，就会加载操作系统，这个时候你就会看到如下画面了：</p>
<p><img src="http://blogimg-1252559003.cos.ap-shanghai.myqcloud.com/blog/2021-11-13-083624.png" alt="image.png"><br>​</p>
</body></html>]]></content>
      <categories>
        <category>内功</category>
      </categories>
      <tags>
        <tag>内功</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语09</title>
    <url>/2022/07/20/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD09/</url>
    <content><![CDATA[<html><head></head><body><h1 id="英语口语09"><a href="#英语口语09" class="headerlink" title="英语口语09"></a>英语口语09</h1><h3 id="钱财安身"><a href="#钱财安身" class="headerlink" title="钱财安身"></a>钱财安身</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Money can buy the security and safety for yourself and your loved ones,</span><br><span class="line">because...</span><br><span class="line">Human beings needs money to pay for all the things that make your life</span><br><span class="line">possible.</span><br><span class="line">such as...</span><br><span class="line">shelter,food,healthcare,and a good education</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*security and safety*</strong></em> 安全感</p>
<p><em><strong>*all the things that make your life possible*</strong></em> <em><strong>*刚需*</strong></em></p>
<p><em><strong>*shelter, food, healthcare, and a good education*</strong></em> <em><strong>*基本需求*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*例证有两种打法，最简单的一种就是名词摆放，直接将名词列举出来。*</strong></em></p>
<p><em><strong>*比如别人问你，你为什么喜欢你的工作，*</strong></em></p>
<p><em><strong>*你可以直接把工作的福利摆出来，*</strong></em></p>
<p><em><strong>*这是最简单直接的打法，在无话可说的时候，非常实用。*</strong></em></p>
<p><em><strong>*在这个语流中，如果仔细观察，三个词伙，其实是不断的递进和具象化，将一个概念不断地落地。*</strong></em></p>
<h3 id="贫穷的陷阱"><a href="#贫穷的陷阱" class="headerlink" title="贫穷的陷阱"></a>贫穷的陷阱</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">most people have a hard time differentiating 'wants' and 'needs',</span><br><span class="line">i mean...</span><br><span class="line">they use a word 'needs' for almost everything they purchase,</span><br><span class="line">causing them have to actually believe that they 'have to' spend money.</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*have a hard time differentiating “wants” and “needs”*</strong></em> </p>
<p><em><strong>*分不清刚需和欲望*</strong></em></p>
<p><em><strong>*use the word ‘need’ for almost everything they purchase*</strong></em></p>
<p><em><strong>*购物癖*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*三个非常重要的句式，核心词替换都非常方便*</strong></em></p>
<p><em><strong>*Have hard time doing sth*</strong></em></p>
<p><em><strong>*Use the word*</strong></em> <em><strong>*“*</strong></em><em><strong>*A*</strong></em> <em><strong>*”*</strong></em> <em><strong>*for sth*</strong></em></p>
<p><em><strong>*Causing+从句，引导一个原因*</strong></em></p>
<p><em><strong>*在背诵的时候，可以从这三个句式开始。*</strong></em></p>
<p><em><strong>*值得注意的是，这个语流中，有文字游戏的意味，这种技法非常高明。*</strong></em></p>
<h3 id="财务能力"><a href="#财务能力" class="headerlink" title="财务能力"></a>财务能力</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Poor financial education have a long-lasting impact on individuals and</span><br><span class="line">their families.</span><br><span class="line">the financial education can make a difference.</span><br><span class="line">because...</span><br><span class="line">it can equal you with the knowledge,skills,confidence to </span><br><span class="line">take charge of your life.</span><br><span class="line">and build a more secure future for yourself and your families.</span><br></pre></td></tr></tbody></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">people lose money in stock market because they think the investing is</span><br><span class="line">the ticket to getting rich quickly.</span><br><span class="line">for example...</span><br><span class="line">they see wealthy day traders show off money and fancy cars...</span><br><span class="line">and they think it's money.</span><br><span class="line">but the 99% of time they lose money following them,</span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>*The*</strong></em> <em><strong>*ticket to getting rich quickly*</strong></em> <em><strong>*一夜暴富*</strong></em></p>
<p><em><strong>*wealthy day traders*</strong></em> <em><strong>*短线炒家*</strong></em></p>
<p><em><strong>*easy money*</strong></em> <em><strong>*很容易赚的钱*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*贪心，单单整个人性，已经可以解决很多问题。*</strong></em></p>
<p><em><strong>*只要你了解人性，你就永远有话可说。*</strong></em></p>
<p><em><strong>*在这个语流中，关于投资的三个很重要的词伙，凝结在了一起。*</strong></em></p>
<p><em><strong>*当我们在记忆语流时，也就连锁记忆了词伙，一举两得。*</strong></em></p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">演绎以下一分钟三十秒的语流，训练节奏和气息</span><br><span class="line">在不改变词伙的情况下，自己可以改动一些句子和单词，不必拘泥</span><br><span class="line">重在开口练习，不要纠结，放开其他东西。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Describe the important decision you made recently.</span><br><span class="line"></span><br><span class="line">I used to be a shy person who would feel depressed all the time...</span><br><span class="line">I think the main reason is because </span><br><span class="line">I cared too much about what people think.</span><br><span class="line">so i made the decision couple of years ago</span><br><span class="line">decided that... </span><br><span class="line">i wanna be a guy who has more confidence in his judgments </span><br><span class="line">and feels more alive.</span><br><span class="line">and one of my friends told me that </span><br><span class="line">to achieve that goal, </span><br><span class="line">I need do things that are out of my comfort zone...</span><br><span class="line">So that I will learn to overcome my fears,</span><br><span class="line">for example...</span><br><span class="line">I will likely find&nbsp;that I care less about what people think</span><br><span class="line">and about what could go wrong.</span><br><span class="line">and...</span><br><span class="line">in order to&nbsp;feel to feel alive,</span><br><span class="line">I need to&nbsp;do things that make me feel uncomfortable,</span><br><span class="line">because...</span><br><span class="line">as human beings,</span><br><span class="line">we become who we are&nbsp;through challenges.</span><br><span class="line">for example...</span><br><span class="line">all successful people have taken risks, failed and picked themselves up,</span><br><span class="line">because they believe that those who never&nbsp;venture far&nbsp;</span><br><span class="line">will never&nbsp;know what might have been if they had tired&nbsp;to do things beyond what&nbsp;they had already mastered.</span><br><span class="line"></span><br><span class="line">逆推：</span><br><span class="line">Describe a piece of advice you received ...</span><br><span class="line">describe the important lesson you learned in high school...</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础_编译和解释</title>
    <url>/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E7%BC%96%E8%AF%91%E5%92%8C%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<html><head></head><body><h2 id="先来简单了解下"><a href="#先来简单了解下" class="headerlink" title="先来简单了解下"></a>先来简单了解下</h2><p>我们是要说程序的编译和解释，也就是要搞清楚，<strong>编译是个啥，解释又是个啥</strong>，以及它们之间有啥关系和区别，知道这些啥用，基础知识，可以帮助你更好的编程和学习新的技术知识。</p>
<p>正所谓基础不牢，地动山摇啊，来，先来看看编译和解释是个啥：</p>
<blockquote>
<p>编译和解释都属于翻译，翻译的最终目的是把程序源代码变成计算机可以执行的机器语言，也就是二进制的形式.<br>编译的话是把源程序一次性的翻译成机器语言，这样的话计算机执行起来速度就比较快.<br>解释的话是程序在执行的时候，一条条的把源码翻译成机器语言，这样的速度就不如编译了.</p>
</blockquote>
<p>你要是理解能力超强的话，那看上面这些就基本能掌握今天要说的大部分知识了，只不过这其中牵涉到一些细节性的知识点，以及考虑到大部分人的理解能力不是特别的超强，所以我还是有必要继续的详细的解释一下，如果你觉得只看上面明白的有点不知所以，那不妨跟着我继续往下。</p>
<h2 id="说说低级语言和高级语言"><a href="#说说低级语言和高级语言" class="headerlink" title="说说低级语言和高级语言"></a>说说低级语言和高级语言</h2><p>学过编程的你们对这两个概念也许并不陌生，啥是低级语言，就是机器语言，汇编语言这些吧，那你说C语言是不是低级语言，其实吧，人家<strong>C语言</strong>不能算作是低级语言，但是<strong>高级语言</strong>好像又有点算不上，介于两者之间吧。</p>
<p>高级语言就是我们常说的也是大家经常学的这些了，比如Java，Python和C++这些语言。</p>
<blockquote>
<p>低级语言 ： <strong>最基本的低级语言就是机器语言了</strong>，早期的编程就是使用机器语言，这样的难度是很大的，也就是0和1那种形式，对，是二进制的形式，二进制就是0和1组成的，不同的组合代表不同的含义或者指令，时代在进步，技术在发展，后来发展了一种把0和1组成的这种机器代码指令用一些助记符号来表示，这就形成了汇编，汇编依然是低级语言，它是需要翻译成机器代码才可以执行</p>
</blockquote>
<p>其实可以<strong>将汇编代码翻译成不同平台上的机器代码，这叫做交叉汇编技术</strong>，不知道讲到这大家理解的怎么样，如果觉得读的酣畅淋漓，很爽的那种，那可以继续往下看，但凡是有点不明不白，那可以稍微停下来，重读一遍，不明白的地方尽量多读几遍，还好理解，既然花时间看这篇文章，还是希望大家有所收获，不能是看完了，啥也没有了。</p>
<p>再来看看高级语言。</p>
<blockquote>
<p>上面也大致说了，所谓的高级语言也就是我们熟知的那些Java和跑Python等等，为啥说是高级语言，因为这些语言的设计逻辑大多是按照我们人的正常思维角度去设计的，所以看起来门槛比较低，大部分高级语言都有自己的解释器，这个解释器就是把源码翻译成目标平台代码去执行。</p>
</blockquote>
<p>状态还ok？我们接着往下。</p>
<h2 id="翻译和执行（主要针对Java）"><a href="#翻译和执行（主要针对Java）" class="headerlink" title="翻译和执行（主要针对Java）"></a>翻译和执行（主要针对Java）</h2><p>这里我想带大家了解两个概念，<strong>一个是翻译，一个是执行</strong>，就是简单看看这俩货是个啥，这有助于你对编译和解释的理解。</p>
<p><strong>翻译的目的是生成另外一套格式的代码</strong>，是将A变成B ，生成的这个B可以直接被计算机执行 ，那就是翻译一步到位，生成目标机器代码，可直接运行 ，这个就叫做编译。</p>
<p>当然 ，生成的B也有可能是个半成品，不能被计算机直接执行，是一种中间代码 需要再次翻译成目标机器代码 ，<strong>这个再次翻译的过程称为解释</strong> ，前者从A生成B的过程，也就是生成中间代码的过程也是编译 所以编译可以直接一步到位 ，也可以编译成一个中间代码，再进行解释成计算机可以直接执行的目标代码。</p>
<p><strong>因此，翻译包括两种，一是编译，二是解释。</strong></p>
<p>上面了解了什么是翻译，那执行嘞，对于代码而言，执行的最终目的就是代码要在计算机中运行起来，要想运行起来，那就得经过前面的翻译过程，需要得到目标机器代码，才可以执行。</p>
<p>翻译由上面知道分为编译和解释，那么也即是会有编译执行和解释执行了。</p>
<h3 id="编译执行和解释执行"><a href="#编译执行和解释执行" class="headerlink" title="编译执行和解释执行"></a>编译执行和解释执行</h3><p><strong>编译执行就是把源程序一步到位翻译成目标机器代码，然后直接运行。</strong></p>
<p>解释执行是把生成的中间代码，就是不是源程序了，然后把中间代码一条一条的翻译成目标机器代码，**翻译一条执行一条，边翻译边执行 **，Java就是这样的。</p>
<p>这其实就是在告诉你什么是编译，什么是解释。编译强调的是一次性做好准备工作，就是先把源码全部翻译成机器代码，想要运行的可以直接读取进行执行，但是解释则不同，强调的是用的话再翻译，也就是逐条翻译，翻译一点执行一点，边翻译边执行的这种。</p>
<h3 id="单独看看解释"><a href="#单独看看解释" class="headerlink" title="单独看看解释"></a>单独看看解释</h3><p>其实我觉得<strong>编译比解释好理解点</strong>，比较纯粹，也就是把源程序一次性翻译成目标机器代码，直接给你全部一次性搞成你想要的，运行的话直接读取就行了，但是解释就稍显麻烦。</p>
<p>如果你是学Java的很可能对编译和解释就停留在上面的认知了，其实对于Java来说，上述理解很正确，编译和解释理解的也很到位，但是脱离Java放到其他高级语言之中，对于编译的理解没啥问题，但是对于解释的理解就有点偏差，这是因为在Java中，会编译生成中间码，也就是字节码，然后字节码依靠虚拟机解释成平台的目标机器码。</p>
<p>因为并不是其他语言也像java那样会生成中间码，先编译字节码，再解释成目标机器码，所以对于Java这门高级编程语言来说，既不能说是编译型语言也不能说是解释型语言，而是两者都包含。</p>
<p>谈到大家熟知的另外一门语言Python，它的翻译模式就跟Java很像，也是先编译成中间码，然后再交由解释器去解释执行，<strong>但是像PHP这门语言就不同，它就是一门解释型语言。</strong></p>
<p><strong>对于PHP来说，就是把源程序直接进行逐条翻译成目标机器码然后执行 中间没有编译啥的</strong>，直接就是解释一条执行一条的这种，说的专业点也就是PHP将代码解释为opcode之后再交由Zend引擎执行。</p>
<p><strong>像C和C++，就是编译型的语言，它会首先把源程序一次性编译成目标机器代码，然后再执行。</strong></p>
<h3 id="重要理解点，两者区别"><a href="#重要理解点，两者区别" class="headerlink" title="重要理解点，两者区别"></a>重要理解点，两者区别</h3><p>这里说<strong>一个编译和解释两者的一个区别</strong>，因为个人觉得知道这点，对理解编译和解释之间的不同是有很大帮助的。</p>
<p>我们看编译，经过上述的阐述，你应该知道了，编译讲究的是把源程序一次性翻译成目标机器代码，然后交由计算机去执行，这里面<strong>很重要的一点就是，程序代码经过编译之后会生成另外一种可存储的代码</strong>，计算机执行是去读取这些生成的代码，一般就是目标机器代码。</p>
<p>我们看<strong>Java的编译过程</strong>，它是生成中间码，也就是字节码，这个字节码你是可以看到的吧，就是javac命令之后的字节码文件，<strong>这是可见的可存储的另外一套代码，生成的是可存储的，这是编译的一个特征。</strong></p>
<p>再反观解释，解释一般就是翻译和执行一起进行，逐条翻译，然后边翻译边执行，这个过程是不生成可存储的目标代码的。</p>
<blockquote>
<p>对于编译来说，它的翻译和执行是分来的，先翻译成一份代码，然后再执行，但是对于解释则不同，它的翻译和执行是不分开的，翻译和执行同步进行的。</p>
</blockquote>
<h2 id="知道什么是编译和解释了吗"><a href="#知道什么是编译和解释了吗" class="headerlink" title="知道什么是编译和解释了吗"></a>知道什么是编译和解释了吗</h2><p>到了这里，不知道你搞清楚编译和解释了吗？如果还是有点模糊，看看我下面的总结。</p>
</body></html>]]></content>
      <categories>
        <category>内功</category>
      </categories>
      <tags>
        <tag>内功</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算和进制转换，原码，反码</title>
    <url>/2022/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80_%E8%A1%A5%E7%A0%81%E5%8F%8D%E7%A0%81%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<html><head></head><body><h1 id="位运算和进制转换，原码，反码"><a href="#位运算和进制转换，原码，反码" class="headerlink" title="位运算和进制转换，原码，反码"></a>位运算和进制转换，原码，反码</h1><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 <<"></a>左移 &lt;&lt;</h3><p>举个栗子，5 &lt;&lt; 2 将5左移2 结果为20 为啥？注意是对二进制进行的操作，来看：</p>
<p>首先会将5转为二进制表示形式(Java中，整数默认就是int类型,也就是32位):</p>
<p><img src="https://img-blog.csdnimg.cn/20200112012237518.png#id=NbSo8&amp;originHeight=131&amp;originWidth=804&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="null"><br>怎么去理解，首先在Java中，整数默认就是int类型，也就是占4个字节32位，你就可以想成这样</p>
<p>0000 0000 0000 0000 0000 0000 0000 0000</p>
<p>这就是32位，但是每位上都是0，这是一个标准，用于后面的比较，比如5的二进制是</p>
<p>0000 0000 0000 0000 0000 0000 0000 0101</p>
<p>然后把它与标准的进行对比，也就是这样：</p>
<p><img src="https://img-blog.csdnimg.cn/20200112012316883.png#id=ORtNo&amp;originHeight=106&amp;originWidth=506&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="null"><br>这时候的区别就在后四位，然后将5左移（&lt;&lt;）2，也就是5的二进制以标准为参考整体左移2位，也就是这样：</p>
<p><img src="https://img-blog.csdnimg.cn/20200112012351962.png#id=HU0Wl&amp;originHeight=108&amp;originWidth=533&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="null"></p>
<p>这样一来，就<strong>产生了错位</strong>，看图：<br><img src="http://book.ithuangqing.vip/uploads/dxsn/images/m_5a08b7657ba56c493c7e4a0b364ecaff_r.png" alt="null"><br>不过这时候看着总是有点别扭，应该都是四位四位的在一块吧，所以从低位开始，四位一组，就成了这样<br>0000 0000 0000 0000 0000 0000 0001 0100</p>
<p>换算成十进制就是20了 这就是5 &lt;&lt; 2得到结果的由来。</p>
<h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 >>"></a>右移 &gt;&gt;</h3><p>还是先将5转为2进制表示形式：<br>0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：<br>0000 0000 0000 0000 0000 0000 0000 0001</p>
<p>看图：</p>
<p><img src="http://book.ithuangqing.vip/uploads/dxsn/images/m_4b2813b65b2e67c22aef0ddd28da7df6_r.png" alt="null"></p>
<p>仔细看图分析分析😃</p>
<h3 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移 >>>"></a>无符号右移 &gt;&gt;&gt;</h3><p>先记住这句话：*<strong>正数右移，高位补0，负数右移，高位补1，负数无符号右移，高位补0 正数无符号右移 ，高位补0 正数换算成二进制后的最高位为0，负数的二进制最高位为1*</strong></p>
<p>接下来依然是看例子，在此之前我看过好多别人写的，发现好多都喜欢用5举例子你知道为啥吗😂</p>
<p>5换算成二进制是： 0000 0000 0000 0000 0000 0000 0000 0101</p>
<p>5右移3位后结果为0，0的二进制为： 0000 0000 0000 0000 0000 0000 0000 0000 // (这里高位补0)</p>
<p>-5换算成二进制是： 1111 1111 1111 1111 1111 1111 1111 1011</p>
<p>-5右移3位后结果为-1，-1的二进制为： 1111 1111 1111 1111 1111 1111 1111 1111 // (高位补1)</p>
<p>-5无符号右移3位后的结果 536870911 换算成二进制： 0001 1111 1111 1111 1111 1111 1111 1111 // (高位补0)</p>
<p>这里需要注意了：*<strong>以上说的都是右移的情况，如果是左移，无论是正数还是负数，低位都是用0补*</strong></p>
<p>时间关系，就不赘述了。</p>
<h3 id="位与-amp"><a href="#位与-amp" class="headerlink" title="位与 &amp;"></a>位与 &amp;</h3><p>其实<strong>核心都是二进制</strong>，所以掌握好进制转换是关键，看看位与 &amp;是怎么计算的：</p>
<p><img src="http://book.ithuangqing.vip/uploads/dxsn/images/m_209fd4dda96bf3f11a59ddd0e45c7cb6_r.png" alt="null"></p>
<p>这里要看两个操作数的二进制的各个位的对应情况，总结起来也就是：</p>
<blockquote>
<p>有0则0，否则为1</p>
</blockquote>
<p>什么意思呢？我们举一个例子来看看<br>我们猜这个结果是什么，答案是<br><img src="http://book.ithuangqing.vip/uploads/dxsn/images/m_a78c757bf12600532653c7f031b0bb92_r.png" alt="null"><br>注意这里可不是6除以3，它是这样计算的，首先6和3都要转成二进制，6的二进制是110，3的二进制是11也就是011，那么这样运算</p>
<p><img src="https://img-blog.csdnimg.cn/20200112013619903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70#height=116&amp;id=D7BgP&amp;originHeight=472&amp;originWidth=1315&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none&amp;width=321.8517150878906" alt="null"><br>我相信看图就能明白的，而二进制的010就是2啦，这就是位与的操作，对于或和亦或其实同样道理，我们继续来看~</p>
<h3 id="位或"><a href="#位或" class="headerlink" title="位或 |"></a>位或 |</h3><p><strong>规则就是：有1则1</strong></p>
<p>看例子：</p>
<p><img src="http://book.ithuangqing.vip/uploads/dxsn/images/m_bec650431125bd562820182f72a6b26d_r.png" alt="null"></p>
<h3 id="位异或"><a href="#位异或" class="headerlink" title="位异或 ^"></a>位异或 ^</h3><p><strong>规则是：相同则0，不同则1</strong></p>
<p>看例子：</p>
<p><img src="http://book.ithuangqing.vip/uploads/dxsn/images/m_656f33f383c53cb6deea4440692f6349_r.png" alt="null"></p>
<h3 id="有点难懂的位非"><a href="#有点难懂的位非" class="headerlink" title="有点难懂的位非 ~"></a>有点难懂的位非 ~</h3><p>这是网站随便找的一个例子，你看看，求~5，得-6，为啥？</p>
<p><img src="https://img-blog.csdnimg.cn/20200112014009625.png#id=DFVgM&amp;originHeight=177&amp;originWidth=692&amp;originalType=binary&amp;ratio=1&amp;status=done&amp;style=none" alt="null"><br><strong>它这里的规则是：操作数的第n位为1，那么结果的第n位为0，反之。</strong></p>
<p>不知道你懂吗？有这么一个解释：</p>
<blockquote>
<p>6的二进制数为： 0000 0000 0000 0000 0000 0000 0000 0110 然后6的二进制反码为： 1111 1111 1111 1111 1111 1111 1111 1001 将反码+1得到-6的补码二进制数：1111 1111 1111 1111 1111 1111 1111 1010</p>
</blockquote>
<p>所以这里就牵涉到原码，反码和补码了，另外还有个重点的点就是：</p>
<blockquote>
<p>负数在计算机中是以补码的形式存在的</p>
</blockquote>
<p>好了，我们赶紧来看看什么是原码，反码和补码吧！</p>
<h2 id="最后攻克原码，反码和补码"><a href="#最后攻克原码，反码和补码" class="headerlink" title="最后攻克原码，反码和补码"></a>最后攻克原码，反码和补码</h2><p>这是<strong>非常重要的概念，需要熟练掌握</strong>，要记得。开始之前，先上一个重要的结论：</p>
<blockquote>
<p>数据在计算机中的存储是二进制的形式，二进制简单来说就是0和1组合的，无论原码，反码还是补码，都是二进制的形式</p>
</blockquote>
<p>其次我们<strong>要注意的点</strong>就是正数和负数的原码，反码和补码，是有区别的。</p>
<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>什么是原码嘞？</p>
<p>对于正数来说，我们把它的绝对值转换成的二进制数叫做正数的原码，对于负数来说我们把它的绝对值转换成的二进制数，然后最高位补1，称为原码。看看，还是有区别的。<br>​</p>
<blockquote>
<p>发现关键所在了吧，原码是绝对值转换成的二进制数，那正负数自然存在本质差别了</p>
</blockquote>
<p>比如 ：</p>
<p>00000000 00000000 00000000 00000101 是 5的 原码。<br>10000000 00000000 00000000 00000101 是 -5的 原码。</p>
<p>这里有个点就是<strong>最高位是0代表正数，是1代表负数</strong>。</p>
<h3 id="正数和负数在计算机中怎么表示的"><a href="#正数和负数在计算机中怎么表示的" class="headerlink" title="正数和负数在计算机中怎么表示的"></a>正数和负数在计算机中怎么表示的</h3><p>接下来就是<strong>在计算机中的表示</strong>：</p>
<p><strong>对于正数：原码，反码和补码都是一样的</strong>，所以在计算机中怎么说都一样，反正就是本身转换成二进制的结果，可以说原码，也可以说补码，因为都是一样的</p>
<p><strong>对于负数：原码，反码和补码是不一样的</strong>，在计算机中*<strong>负数是以补码的形式存在的*</strong></p>
<p>所以说，重点聚焦在负数上，看它的反码和补码是怎么表示的</p>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>那反码是啥嘞？</p>
<p>*<strong>负数的反码为对该数的原码除符号位外各位取反[每一位取反(除符号位)]。*</strong><br>*<strong>​*</strong></p>
<blockquote>
<p>*<strong>要理解什么是符号位*</strong></p>
</blockquote>
<p>这里有个符号位，啥？还记得刚刚说的吗？</p>
<blockquote>
<p>最高位是0代表正数，是1代表负数。</p>
</blockquote>
<p>也就是最左边的那一位，叫做符号位！二进制数从右往左看，依次由低变高，所以最左边的就是最高位，通常也叫做符号位！</p>
<p>取反操作指：<strong>原为1，得0；原为0，得1。（1变0; 0变1）</strong></p>
<p>比如：</p>
<p>正数00000000 00000000 00000000 00000101 的反码还是<br>00000000 00000000 00000000 00000101</p>
<p>负数10000000 00000000 00000000 00000101 的反码则是<br>11111111 11111111 11111111 11111010</p>
<p>另外啊反码是相互的，因此也可称：<br>10000000 00000000 00000000 00000101 和 11111111 11111111 11111111 11111010互为反码。</p>
<p><strong>不过这里有个问题，那就是+0和-0</strong>，什么意思呢？</p>
<p>原码和反码在表示数的时候的有点尴尬啊，比如表示零的时候，同样都是0，但是原码就有两种表示法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[-0]原=10000000</span><br><span class="line"></span><br><span class="line">[+0]原=00000000</span><br></pre></td></tr></tbody></table></figure>

<p>反码也有两种表示法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[+0]反=00000000</span><br><span class="line"></span><br><span class="line">[- 0]反=11111111</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这就有点难受啊，不都是0吗，于是乎，就出了补码</strong></p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>那啥又是补码嘞？</p>
<p>*<strong>负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1*</strong></p>
<p>比如：10000000 00000000 00000000 00000101 的反码是：11111111 11111111 11111111 11111010</p>
<p>那么，补码为：<br>11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011</p>
<p>这里有两点需要注意：<br>1、从补码求原码的方法跟原码求补码是一样的 ，也可以通过完全逆运算来做，先减一，再取反。<br>2、补码却规定0没有正负之分</p>
<p>第二个啥意思呢，也就是说对于0的表示，补码只有一种[-0]补=00000000。感觉这样就正常多了。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p><strong>原码表示法规定</strong>：用符号位（最左边）和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示，数值部分用二进制形式表示。</p>
<p><strong>反码表示法规定：</strong>正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。</p>
<p><strong>补码表示法规定：</strong>正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1~</p>
<p>正零和负零的补码相同，[+0]补=[-0]补=0000 0000B</p>
</body></html>]]></content>
      <categories>
        <category>内功</category>
      </categories>
      <tags>
        <tag>内功</tag>
      </tags>
  </entry>
  <entry>
    <title>论文_传感器的点01</title>
    <url>/2022/09/07/%E8%AE%BA%E6%96%87_%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<html><head></head><body><h1 id="论文-传感器的点01"><a href="#论文-传感器的点01" class="headerlink" title="论文_传感器的点01"></a>论文_传感器的点01</h1><h2 id="数据的来源："><a href="#数据的来源：" class="headerlink" title="数据的来源："></a>数据的来源：</h2><p>一般都是实测的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Some data from sensors are used in real time for maneuvering and related actions and some sensors are placed in sensitive area like propeller blade to collect the data for future purpose such as system diagnosis.</span><br></pre></td></tr></tbody></table></figure>

<p>数据的问题:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Considering the raw data may contains noisy, discontinuous and redundant information,</span><br></pre></td></tr></tbody></table></figure>

<h3 id="how-to-eliminate-the-noisy"><a href="#how-to-eliminate-the-noisy" class="headerlink" title="how to eliminate the noisy?"></a>how to eliminate the noisy?</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景:"></a>场景:</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">room. Because of external noise like cables and the coupling of electric and magnetic fields, the measured temperature is full of spikes.</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Solution01"><a href="#Solution01" class="headerlink" title="Solution01"></a>Solution01</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A natural way to eliminate them is to use median filtering technique,After three iterations of median filtering, the spikes are successfully removed and the series of temperature data becomes smooth,</span><br></pre></td></tr></tbody></table></figure>

<p><img src="D:%5C%E6%A1%8C%E9%9D%A2%5Cimg%5Cimage-20220907180553202.png" alt="image-20220907180553202"></p>
<h4 id="Solution02"><a href="#Solution02" class="headerlink" title="Solution02"></a>Solution02</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Another necessary data cleaning process is resampling. Because both the data modules in Table I with sampling frequency of 1.65Hz and 1Hz respectively are involved for ship motion prediction,</span><br></pre></td></tr></tbody></table></figure>

<h3 id="how-to-deal-with-discontinuity"><a href="#how-to-deal-with-discontinuity" class="headerlink" title="how to deal with discontinuity?"></a>how to deal with discontinuity?</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">In addition, raw data may contain jumping phenomenon due to data definition. The bottom panel of Fig. 2 is an example for heading recording. Because the definition of heading is within [0∘, 360∘], it is inevitable to occur jumping phenomenon when the heading changes near the border.</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Solution01-1"><a href="#Solution01-1" class="headerlink" title="Solution01"></a>Solution01</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">To remove this type of discontinuity, the heading angle is defined unbounded and a variable for the number of laps is introduced:</span><br></pre></td></tr></tbody></table></figure>

<p><img src="D:%5C%E6%A1%8C%E9%9D%A2%5Cimg%5Cimage-20220907181406138.png" alt="image-20220907181406138"></p>
<p><a href="https://sci-hub.wf/https://ieeexplore.ieee.org/abstract/document/7485648/">参考文献01</a></p>
</body></html>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习银行破产预测</title>
    <url>/2022/09/03/%E8%AE%BA%E6%96%87_%E6%9D%A5/</url>
    <content><![CDATA[<html><head></head><body></body></html>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>论文_文章常规打法</title>
    <url>/2022/09/03/%E8%AE%BA%E6%96%87_%E6%96%87%E7%AB%A0%E7%9A%84%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<html><head></head><body><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>写关于能够影响主题(现实中能够解决的问题)的参数，基于参数建立模型，并且比较模型，模型预测的准确性</p>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>手段，主题</p>
<h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2></body></html>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习银行破产预测</title>
    <url>/2022/09/01/%E8%AE%BA%E6%96%87_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%93%B6%E8%A1%8C%E7%A0%B4%E4%BA%A7%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<html><head></head><body><h2 id="机器学习银行破产预测"><a href="#机器学习银行破产预测" class="headerlink" title="机器学习银行破产预测"></a>机器学习银行破产预测</h2><h2 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h2><p>这篇文章不是出自本作者手中，文章来源于一位学长的允许下发布的。</p>
<h1 id="2022-第七届“数维杯”大学生数"><a href="#2022-第七届“数维杯”大学生数" class="headerlink" title="2022 第七届“数维杯”大学生数"></a>2022 第七届“数维杯”大学生数</h1><h1 id="学建模竞赛论文"><a href="#学建模竞赛论文" class="headerlink" title="学建模竞赛论文"></a>学建模竞赛论文</h1><p>题 目 银行效率分析及其破产成因研究</p>
<p>摘 要<br>在互联网金融的强大背景下，金融危机中的预测问题一直是当今社会的研究热点。<br>通过机器学习或人工智能技术实现对金融数据的分析和挖掘，在实际的应用中能够为银<br>行或企业予以提前预警，以减少经济上的损失。<br>针对任务 1 ，本文使用Z-score模型对 64 项指标进行了数据分析。首先，我们对附<br>件 1 中数据进行预处理，根据指标缺失率及指标含义剔除缺失值，通过 3 σ原则筛选异<br>常值。然后，根据Z-score模型和筛选出的指标计算各个银行的Z值；最后，通过引入阈<br>值实现对银行破产情况的预测。实验结果表明，2017-2021年的分界线分别为-1.0、-3.9、<br>-7.7、-2.1、-3.5，当阈值高于分界线时，银行正常运营，反之即为破产。<br>针对任务 2 ，本文使用随机森林算法选出 5 项贡献度最高的指标数据及其对权重进行<br>分析。实验结果表明，通过对 2017 年的特征值贡献度进行排序，最终选取X 29 , X 46 , X 61 , X 45 ,<br>X 44 指标，其他年份的所选指标见附件。<br>针对任务 3 ，本文将Z-score模型与随机森林模型的召回率、准确率、精确率和F测<br>度进行对比分析。实验结果表明，随机森林具有很高的平均召回率，其值高达99.89%，<br>因此本问基于随机森林算法作为倒闭风险预测模型。<br>针对任务 4 ，本文基于K-means聚类方法和蒙特卡洛方法对该问进行深度剖析。实<br>验结果表明，在聚类方法和蒙特卡洛方法下的代表性银行数据通过倒闭风险预测模型的<br>预测精度分别为54.76%、95.35%。由此可见，采用蒙特卡洛方法下选取的结果更加准<br>确，数据更具有代表性。<br>针对任务 5 ，本问首先从每年数据中选取 1000 个样本点，通过对每个指标的聚类中<br>心点进行线性拟合，以获取银行的整体偏移趋势；其次根据拟合方程计算出次年各个指<br>标的聚类中心作为次年预测结果，根据与次年真实情况的相似度最大值，确定为次年最<br>接近的银行编号，即为同一家银行。根据将每一家银行各指标线性拟合得到银行个体的<br>偏移趋势，建立有关整体偏移趋势和个体偏移趋势的函数，由 2021 年的各项指标来预<br>测 2022 年的各项指标数据，最后代入随机森林模型中求得最后的预测结果。</p>
<p>关键词:风险预测；Z-score模型；随机森林；K-means聚类；蒙特卡洛方法</p>
<h2 id="目-录"><a href="#目-录" class="headerlink" title="目 录"></a>目 录</h2><ul>
<li>一、问题重述<ul>
<li>1.1 引言</li>
<li>1.2 要解决的具体问题</li>
<li>1.3 文献综述</li>
<li>1.4 我们的工作</li>
</ul>
</li>
<li>二、问题分析<ul>
<li>2.1 问题一的分析</li>
<li>2.2 问题二的分析</li>
<li>2.3 问题三的分析</li>
<li>2.4 问题四的分析</li>
<li>2.5 问题五的分析</li>
</ul>
</li>
<li>三、模型假设</li>
<li>四、名词解释与符号说明</li>
<li>五、模型的建立与求解<ul>
<li>5.1 数据的预处理<ul>
<li>5.1.1 缺失值处理</li>
<li>5.1.2 异常值处理</li>
</ul>
</li>
<li>5.2 基于Z-score模型的银行风险预测<ul>
<li>5.2.1 Z-score模型的建立</li>
<li>5.2.2 模型求解</li>
</ul>
</li>
<li>5.3 基于随机森林模型的指标权重分析<ul>
<li>5.3.1 随机森林算法简介</li>
<li>5.3.2 随机森林模型的构建</li>
<li>5.3.3 指标筛选结果及分析</li>
</ul>
</li>
<li>5.4 Z-score模型与随机森林模型的对比<ul>
<li>5.4.1 两种模型结果的对比分析</li>
<li>5.4.2 倒闭风险预测模型构建</li>
</ul>
</li>
<li>5.5 随机森林模型的验证及预测<ul>
<li>5.5.1 聚类方法</li>
<li>5.5.2 蒙特卡洛方法</li>
<li>5.5.3 结果对比分析</li>
</ul>
</li>
<li>5.6 基于余弦相似度的银行同属模型构建及其预测<ul>
<li>5.6.1 余弦相似度模型的构建</li>
<li>5.6.2 同属银行倒闭风险趋势模型的构建</li>
</ul>
</li>
</ul>
</li>
<li>六、模型的评价<ul>
<li>6.1 模型的优点</li>
<li>6.2 模型的缺点</li>
</ul>
</li>
<li>参考文献</li>
</ul>
<h2 id="一、问题重述"><a href="#一、问题重述" class="headerlink" title="一、问题重述"></a>一、问题重述</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><h5 id="如今，金融行业在国民经济发展的过程中占据主导地位。金融的风险"><a href="#如今，金融行业在国民经济发展的过程中占据主导地位。金融的风险" class="headerlink" title="如今，金融行业在国民经济发展的过程中占据主导地位。金融的风险"></a>如今，金融行业在国民经济发展的过程中占据主导地位。金融的风险</h5><h5 id="防控问题一直以来是社会的研究热点。据中国银保监会统计，截至-2022-年"><a href="#防控问题一直以来是社会的研究热点。据中国银保监会统计，截至-2022-年" class="headerlink" title="防控问题一直以来是社会的研究热点。据中国银保监会统计，截至 2022 年"></a>防控问题一直以来是社会的研究热点。据中国银保监会统计，截至 2022 年</h5><h5 id="2-月，我国的大型商业银行的总资产为-1370052-亿元，总负债为-1250629-亿"><a href="#2-月，我国的大型商业银行的总资产为-1370052-亿元，总负债为-1250629-亿" class="headerlink" title="2 月，我国的大型商业银行的总资产为 1370052 亿元，总负债为 1250629 亿"></a>2 月，我国的大型商业银行的总资产为 1370052 亿元，总负债为 1250629 亿</h5><h5 id="元，均占银行业金融机构的39-7-。虽然我国银行业的大型商业银行占据主"><a href="#元，均占银行业金融机构的39-7-。虽然我国银行业的大型商业银行占据主" class="headerlink" title="元，均占银行业金融机构的39.7%。虽然我国银行业的大型商业银行占据主"></a>元，均占银行业金融机构的39.7%。虽然我国银行业的大型商业银行占据主</h5><h5 id="导地位，但中小银行的总负债仍然占比较高。随着中小商业银行市场占额"><a href="#导地位，但中小银行的总负债仍然占比较高。随着中小商业银行市场占额" class="headerlink" title="导地位，但中小银行的总负债仍然占比较高。随着中小商业银行市场占额"></a>导地位，但中小银行的总负债仍然占比较高。随着中小商业银行市场占额</h5><h5 id="的扩增和互联网金融等多因素的影响，各大金融机构竞争不断，部分银行"><a href="#的扩增和互联网金融等多因素的影响，各大金融机构竞争不断，部分银行" class="headerlink" title="的扩增和互联网金融等多因素的影响，各大金融机构竞争不断，部分银行"></a>的扩增和互联网金融等多因素的影响，各大金融机构竞争不断，部分银行</h5><h5 id="也因此出现了资金周转困难甚至破产的局面。国际、国内的中小商业银行"><a href="#也因此出现了资金周转困难甚至破产的局面。国际、国内的中小商业银行" class="headerlink" title="也因此出现了资金周转困难甚至破产的局面。国际、国内的中小商业银行"></a>也因此出现了资金周转困难甚至破产的局面。国际、国内的中小商业银行</h5><h5 id="具有高负债、高风险和高回报的特征，难以躲避潜在的经营风险。因此，本"><a href="#具有高负债、高风险和高回报的特征，难以躲避潜在的经营风险。因此，本" class="headerlink" title="具有高负债、高风险和高回报的特征，难以躲避潜在的经营风险。因此，本"></a>具有高负债、高风险和高回报的特征，难以躲避潜在的经营风险。因此，本</h5><h5 id="文旨在深度分析银行倒闭的原因，并提出能够精准预测银行破产风险的预"><a href="#文旨在深度分析银行倒闭的原因，并提出能够精准预测银行破产风险的预" class="headerlink" title="文旨在深度分析银行倒闭的原因，并提出能够精准预测银行破产风险的预"></a>文旨在深度分析银行倒闭的原因，并提出能够精准预测银行破产风险的预</h5><h5 id="警体系。"><a href="#警体系。" class="headerlink" title="警体系。"></a>警体系。</h5><h3 id="1-2-要解决的具体问题"><a href="#1-2-要解决的具体问题" class="headerlink" title="1.2 要解决的具体问题"></a>1.2 要解决的具体问题</h3><h5 id="1-从附件中的-64-项数据中整理出适合的投入产出数据，并对各银行的效"><a href="#1-从附件中的-64-项数据中整理出适合的投入产出数据，并对各银行的效" class="headerlink" title="1. 从附件中的 64 项数据中整理出适合的投入产出数据，并对各银行的效"></a>1. 从附件中的 64 项数据中整理出适合的投入产出数据，并对各银行的效</h5><h5 id="率展开对应评价，同时提供银行倒闭效率的分界线；"><a href="#率展开对应评价，同时提供银行倒闭效率的分界线；" class="headerlink" title="率展开对应评价，同时提供银行倒闭效率的分界线；"></a>率展开对应评价，同时提供银行倒闭效率的分界线；</h5><h5 id="2-利用附件中的-64-项指标对银行倒闭的原因进行挖掘，并提供最为重要"><a href="#2-利用附件中的-64-项指标对银行倒闭的原因进行挖掘，并提供最为重要" class="headerlink" title="2. 利用附件中的 64 项指标对银行倒闭的原因进行挖掘，并提供最为重要"></a>2. 利用附件中的 64 项指标对银行倒闭的原因进行挖掘，并提供最为重要</h5><h5 id="的-5-项指标数据及其对应的权重"><a href="#的-5-项指标数据及其对应的权重" class="headerlink" title="的 5 项指标数据及其对应的权重"></a>的 5 项指标数据及其对应的权重</h5><h5 id="3-对任务（-1-）和任务（-2-）中的银行倒闭分析结果展开比对分析，同时提"><a href="#3-对任务（-1-）和任务（-2-）中的银行倒闭分析结果展开比对分析，同时提" class="headerlink" title="3. 对任务（ 1 ）和任务（ 2 ）中的银行倒闭分析结果展开比对分析，同时提"></a>3. 对任务（ 1 ）和任务（ 2 ）中的银行倒闭分析结果展开比对分析，同时提</h5><h5 id="出一个精确的倒闭风险预测模型；"><a href="#出一个精确的倒闭风险预测模型；" class="headerlink" title="出一个精确的倒闭风险预测模型；"></a>出一个精确的倒闭风险预测模型；</h5><h5 id="4-从-2021-年银行数据中筛选出最具代表意义的-20-家现存银行和-20-家倒"><a href="#4-从-2021-年银行数据中筛选出最具代表意义的-20-家现存银行和-20-家倒" class="headerlink" title="4. 从 2021 年银行数据中筛选出最具代表意义的 20 家现存银行和 20 家倒"></a>4. 从 2021 年银行数据中筛选出最具代表意义的 20 家现存银行和 20 家倒</h5><h5 id="闭银行，并利用这些银行数据对其它银行倒闭风险进行预测。"><a href="#闭银行，并利用这些银行数据对其它银行倒闭风险进行预测。" class="headerlink" title="闭银行，并利用这些银行数据对其它银行倒闭风险进行预测。"></a>闭银行，并利用这些银行数据对其它银行倒闭风险进行预测。</h5><h5 id="5-通过相关理论分析出-2017-年至-2021-年的银行数据中哪些数据可能来"><a href="#5-通过相关理论分析出-2017-年至-2021-年的银行数据中哪些数据可能来" class="headerlink" title="5. 通过相关理论分析出 2017 年至 2021 年的银行数据中哪些数据可能来"></a>5. 通过相关理论分析出 2017 年至 2021 年的银行数据中哪些数据可能来</h5><h5 id="自同一家银行，并结合同一家银行的时间序列数据预测哪些银行呈现"><a href="#自同一家银行，并结合同一家银行的时间序列数据预测哪些银行呈现" class="headerlink" title="自同一家银行，并结合同一家银行的时间序列数据预测哪些银行呈现"></a>自同一家银行，并结合同一家银行的时间序列数据预测哪些银行呈现</h5><h5 id="出了倒闭的趋势。"><a href="#出了倒闭的趋势。" class="headerlink" title="出了倒闭的趋势。"></a>出了倒闭的趋势。</h5><h3 id="1-3-文献综述"><a href="#1-3-文献综述" class="headerlink" title="1.3 文献综述"></a>1.3 文献综述</h3><p>早期用来判定企业是否破产的模型是由Altman教授在 1968 年提出来<br>的[1]，其主要用来观察美国的破产和非破产的生产企业指标。该模型基于<br>梳理统计思想，从 22 个财务比率中筛选并建立了“五指标”Z-score模型。</p>
<p>Sharda等人[2]通过采用人工神经网络分析了信托机构的信用风险，从而有<br>效地帮助企业进行财务预警。随着机器学习的快速发展，基于机器学习的风<br>险预测模型相继被提出。例如霍远等人[3]通过聚类分析法对上市公司的财<br>务状况进行了分析。Chih-Fong Tsai[4]等人比较了主成分分析、因子分析等<br>常见的五种破产预测方法，并采用多层感知机作为预测模型。陈荣达等人<br>[5]将启发式算法与支持向量机相结合，既保留了原始数据的特征信息，又</p>
<p>提高了模型的泛化能力和训练效率。Santoni等人[6]对比分析了Z-score、分<br>类评定模型和随机森林等三种破产预测方法。实验结果表明，基于随机森<br>林具有较高的分类预测结果，其值高达99.85%。因此，本文使用随机森林<br>的方法构建银行破产预测模型，旨在帮助企业有效进行破产预警，以减少<br>企业的损失。</p>
<h3 id="1-4-我们的工作"><a href="#1-4-我们的工作" class="headerlink" title="1.4 我们的工作"></a>1.4 我们的工作</h3><h5 id="1-筛选整理对于银行倒闭结果最为显著的指标，建立模型将银行财务风"><a href="#1-筛选整理对于银行倒闭结果最为显著的指标，建立模型将银行财务风" class="headerlink" title="1. 筛选整理对于银行倒闭结果最为显著的指标，建立模型将银行财务风"></a>1. 筛选整理对于银行倒闭结果最为显著的指标，建立模型将银行财务风</h5><h5 id="险情况量化表示，通过合适的阈值来分类。"><a href="#险情况量化表示，通过合适的阈值来分类。" class="headerlink" title="险情况量化表示，通过合适的阈值来分类。"></a>险情况量化表示，通过合适的阈值来分类。</h5><h5 id="2-通过两种模型来筛选指标并且预测结果，比较两种模型的预测准确性。"><a href="#2-通过两种模型来筛选指标并且预测结果，比较两种模型的预测准确性。" class="headerlink" title="2. 通过两种模型来筛选指标并且预测结果，比较两种模型的预测准确性。"></a>2. 通过两种模型来筛选指标并且预测结果，比较两种模型的预测准确性。</h5><h5 id="3-从银行样本中选择最显著的样本，建立模型预测剩余银行的倒闭情况。"><a href="#3-从银行样本中选择最显著的样本，建立模型预测剩余银行的倒闭情况。" class="headerlink" title="3. 从银行样本中选择最显著的样本，建立模型预测剩余银行的倒闭情况。"></a>3. 从银行样本中选择最显著的样本，建立模型预测剩余银行的倒闭情况。</h5><h5 id="4-分析五年内哪些样本的数据来自同一家银行，并建立模型预测银行的"><a href="#4-分析五年内哪些样本的数据来自同一家银行，并建立模型预测银行的" class="headerlink" title="4. 分析五年内哪些样本的数据来自同一家银行，并建立模型预测银行的"></a>4. 分析五年内哪些样本的数据来自同一家银行，并建立模型预测银行的</h5><h5 id="财务情况发展趋势"><a href="#财务情况发展趋势" class="headerlink" title="财务情况发展趋势"></a>财务情况发展趋势</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">图 1-1:本文论文框架</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><h3 id="2-1-问题一的分析"><a href="#2-1-问题一的分析" class="headerlink" title="2.1 问题一的分析"></a>2.1 问题一的分析</h3><h5 id="要求对-64-项指标数据整理出适合的投入产出数据，显然-64-项指标过"><a href="#要求对-64-项指标数据整理出适合的投入产出数据，显然-64-项指标过" class="headerlink" title="要求对 64 项指标数据整理出适合的投入产出数据，显然 64 项指标过"></a>要求对 64 项指标数据整理出适合的投入产出数据，显然 64 项指标过</h5><h5 id="多并且其中很多指标相关性很强，那么解决任务-1-就是找出对于银行的财"><a href="#多并且其中很多指标相关性很强，那么解决任务-1-就是找出对于银行的财" class="headerlink" title="多并且其中很多指标相关性很强，那么解决任务 1 就是找出对于银行的财"></a>多并且其中很多指标相关性很强，那么解决任务 1 就是找出对于银行的财</h5><h5 id="务情况的评价最有力的指标，并且通过这些指标，可以将对银行财务情况"><a href="#务情况的评价最有力的指标，并且通过这些指标，可以将对银行财务情况" class="headerlink" title="务情况的评价最有力的指标，并且通过这些指标，可以将对银行财务情况"></a>务情况的评价最有力的指标，并且通过这些指标，可以将对银行财务情况</h5><p>的评价量化为一个评价分数。在诸多研究中表明Z-score模型对于预测银行<br>倒闭效果良好，并且可以根据银行的财务情况得分判断分类银行的财务情<br>况。因此我们建立一个Z-score模型来评价银行是否倒闭。根据附件给出的<br>数据可以发现存在一定数量的缺失值和异常值，所以首先对数据进行预处<br>理，下一步建立Z-SCORE模型分别对2017-2021年给出的银行样本进行预<br>测，得到关于银行财务情况的评价得分，最后与银行倒闭的真实情况对比，<br>给出可以最准确反映倒闭情况的临界阈值。</p>
<h3 id="2-2-问题二的分析"><a href="#2-2-问题二的分析" class="headerlink" title="2.2 问题二的分析"></a>2.2 问题二的分析</h3><h5 id="任务-2-要求我们利用附件中的-64-项指标对银行倒闭的原因进行挖掘，"><a href="#任务-2-要求我们利用附件中的-64-项指标对银行倒闭的原因进行挖掘，" class="headerlink" title="任务 2 要求我们利用附件中的 64 项指标对银行倒闭的原因进行挖掘，"></a>任务 2 要求我们利用附件中的 64 项指标对银行倒闭的原因进行挖掘，</h5><h5 id="并提供最为重要的-5-项指标数据及其对应的权重。本问将预处理之后的-62"><a href="#并提供最为重要的-5-项指标数据及其对应的权重。本问将预处理之后的-62" class="headerlink" title="并提供最为重要的 5 项指标数据及其对应的权重。本问将预处理之后的 62"></a>并提供最为重要的 5 项指标数据及其对应的权重。本问将预处理之后的 62</h5><h5 id="个指标（剔除X21和X37）作为研究对象，并构建随机森林模型。模型的"><a href="#个指标（剔除X21和X37）作为研究对象，并构建随机森林模型。模型的" class="headerlink" title="个指标（剔除X21和X37）作为研究对象，并构建随机森林模型。模型的"></a>个指标（剔除X21和X37）作为研究对象，并构建随机森林模型。模型的</h5><h5 id="的输入为-62-个特征指标数据，输出则为银行是否倒闭的判定结果。首先划"><a href="#的输入为-62-个特征指标数据，输出则为银行是否倒闭的判定结果。首先划" class="headerlink" title="的输入为 62 个特征指标数据，输出则为银行是否倒闭的判定结果。首先划"></a>的输入为 62 个特征指标数据，输出则为银行是否倒闭的判定结果。首先划</h5><h5 id="分训练集和测试集；然后在训练集中随机有放回地抽取样本数据（重复-200"><a href="#分训练集和测试集；然后在训练集中随机有放回地抽取样本数据（重复-200" class="headerlink" title="分训练集和测试集；然后在训练集中随机有放回地抽取样本数据（重复 200"></a>分训练集和测试集；然后在训练集中随机有放回地抽取样本数据（重复 200</h5><h5 id="次），并通过特征选取构造决策树；其次调节模型参数生成随机森林；最终"><a href="#次），并通过特征选取构造决策树；其次调节模型参数生成随机森林；最终" class="headerlink" title="次），并通过特征选取构造决策树；其次调节模型参数生成随机森林；最终"></a>次），并通过特征选取构造决策树；其次调节模型参数生成随机森林；最终</h5><h5 id="对特征值的贡献度进行排序并选择最为重要的-5-项指标。"><a href="#对特征值的贡献度进行排序并选择最为重要的-5-项指标。" class="headerlink" title="对特征值的贡献度进行排序并选择最为重要的 5 项指标。"></a>对特征值的贡献度进行排序并选择最为重要的 5 项指标。</h5><h3 id="2-3-问题三的分析"><a href="#2-3-问题三的分析" class="headerlink" title="2.3 问题三的分析"></a>2.3 问题三的分析</h3><h5 id="任务-3-要求我们对任务（-1-）和任务（-2-）中的银行倒闭分析结果展开"><a href="#任务-3-要求我们对任务（-1-）和任务（-2-）中的银行倒闭分析结果展开" class="headerlink" title="任务 3 要求我们对任务（ 1 ）和任务（ 2 ）中的银行倒闭分析结果展开"></a>任务 3 要求我们对任务（ 1 ）和任务（ 2 ）中的银行倒闭分析结果展开</h5><p>比对分析，并提出一个精确的倒闭风险预测模型。本问将Z-score模型与随<br>机森林模型的结果展开对比。分析指标包括混淆矩阵中的比率，即召回率、<br>准确率、精确率和F测度，同时采用混淆阵列示每种方法的输出结果，以此<br>判断模型的性能。由于随机森林具有较强的泛化能力，因此本问基于随机<br>森林算法构建倒闭风险预测模型。</p>
<h3 id="2-4-问题四的分析"><a href="#2-4-问题四的分析" class="headerlink" title="2.4 问题四的分析"></a>2.4 问题四的分析</h3><h5 id="任务-4-要求从-2021-年银行中选取出最具有代表性的-20-家破产和-20-个"><a href="#任务-4-要求从-2021-年银行中选取出最具有代表性的-20-家破产和-20-个" class="headerlink" title="任务 4 要求从 2021 年银行中选取出最具有代表性的 20 家破产和 20 个"></a>任务 4 要求从 2021 年银行中选取出最具有代表性的 20 家破产和 20 个</h5><p>未破产的样本，本文基于K-means聚类方法和蒙特卡洛方法对该问进行深<br>度剖析。由任务三可知，随机森林模型对于预测风险的效果更佳，因此将采<br>用聚类方法和蒙特卡洛方法生成的代表性银行数据分别输入到随机森林模<br>型中，并根据已训练模型对其余数据进行精准预测。本问对两种方法进行<br>了对比分析，最终给出最佳方案。</p>
<h3 id="2-5-问题五的分析"><a href="#2-5-问题五的分析" class="headerlink" title="2.5 问题五的分析"></a>2.5 问题五的分析</h3><h5 id="任务-5-要求我们通过相关理论分析出-2017-年至-2021-年的银行数据中"><a href="#任务-5-要求我们通过相关理论分析出-2017-年至-2021-年的银行数据中" class="headerlink" title="任务 5 要求我们通过相关理论分析出 2017 年至 2021 年的银行数据中"></a>任务 5 要求我们通过相关理论分析出 2017 年至 2021 年的银行数据中</h5><h5 id="哪些数据可能来自同一家银行，并结合同一家银行的时间序列数据预测哪"><a href="#哪些数据可能来自同一家银行，并结合同一家银行的时间序列数据预测哪" class="headerlink" title="哪些数据可能来自同一家银行，并结合同一家银行的时间序列数据预测哪"></a>哪些数据可能来自同一家银行，并结合同一家银行的时间序列数据预测哪</h5><h5 id="些银行呈现出了倒闭的趋势。以每一年的前-1000-个银行样本为例，根据任"><a href="#些银行呈现出了倒闭的趋势。以每一年的前-1000-个银行样本为例，根据任" class="headerlink" title="些银行呈现出了倒闭的趋势。以每一年的前 1000 个银行样本为例，根据任"></a>些银行呈现出了倒闭的趋势。以每一年的前 1000 个银行样本为例，根据任</h5><h5 id="务四得到的各个银行每个指标的聚类中心，在2017-2021年线性拟合各项指"><a href="#务四得到的各个银行每个指标的聚类中心，在2017-2021年线性拟合各项指" class="headerlink" title="务四得到的各个银行每个指标的聚类中心，在2017-2021年线性拟合各项指"></a>务四得到的各个银行每个指标的聚类中心，在2017-2021年线性拟合各项指</h5><h5 id="标的聚类中心，以获取每项指标的整体偏移趋势；其次根据拟合方程计算出"><a href="#标的聚类中心，以获取每项指标的整体偏移趋势；其次根据拟合方程计算出" class="headerlink" title="标的聚类中心，以获取每项指标的整体偏移趋势；其次根据拟合方程计算出"></a>标的聚类中心，以获取每项指标的整体偏移趋势；其次根据拟合方程计算出</h5><h5 id="我们选取银行样本次年各个指标的预测数据，并与次年真实值进行余弦相"><a href="#我们选取银行样本次年各个指标的预测数据，并与次年真实值进行余弦相" class="headerlink" title="我们选取银行样本次年各个指标的预测数据，并与次年真实值进行余弦相"></a>我们选取银行样本次年各个指标的预测数据，并与次年真实值进行余弦相</h5><h5 id="似度的计算，余弦相似度最高的次年样本认为与我们所选样本属于同一家"><a href="#似度的计算，余弦相似度最高的次年样本认为与我们所选样本属于同一家" class="headerlink" title="似度的计算，余弦相似度最高的次年样本认为与我们所选样本属于同一家"></a>似度的计算，余弦相似度最高的次年样本认为与我们所选样本属于同一家</h5><h5 id="银行。以此方法可以得到每一年所选样本在次年中发展趋势最相似的样本。"><a href="#银行。以此方法可以得到每一年所选样本在次年中发展趋势最相似的样本。" class="headerlink" title="银行。以此方法可以得到每一年所选样本在次年中发展趋势最相似的样本。"></a>银行。以此方法可以得到每一年所选样本在次年中发展趋势最相似的样本。</h5><h5 id="整理出来自同一家银行的指标数据，根据五年的指标数据可以线性拟合得"><a href="#整理出来自同一家银行的指标数据，根据五年的指标数据可以线性拟合得" class="headerlink" title="整理出来自同一家银行的指标数据，根据五年的指标数据可以线性拟合得"></a>整理出来自同一家银行的指标数据，根据五年的指标数据可以线性拟合得</h5><h5 id="到同一家公司指标数据的个体偏移趋势，将整体偏移趋势和个体偏移趋势"><a href="#到同一家公司指标数据的个体偏移趋势，将整体偏移趋势和个体偏移趋势" class="headerlink" title="到同一家公司指标数据的个体偏移趋势，将整体偏移趋势和个体偏移趋势"></a>到同一家公司指标数据的个体偏移趋势，将整体偏移趋势和个体偏移趋势</h5><h5 id="的斜率的均值作为-2021-年至次年的偏移趋势，根据这一偏移趋势，通过拟"><a href="#的斜率的均值作为-2021-年至次年的偏移趋势，根据这一偏移趋势，通过拟" class="headerlink" title="的斜率的均值作为 2021 年至次年的偏移趋势，根据这一偏移趋势，通过拟"></a>的斜率的均值作为 2021 年至次年的偏移趋势，根据这一偏移趋势，通过拟</h5><h5 id="合方程得到次年的指标预测数据，将各项指标数据代入随机森林模型中求"><a href="#合方程得到次年的指标预测数据，将各项指标数据代入随机森林模型中求" class="headerlink" title="合方程得到次年的指标预测数据，将各项指标数据代入随机森林模型中求"></a>合方程得到次年的指标预测数据，将各项指标数据代入随机森林模型中求</h5><h5 id="得最后的倒闭与否结果。"><a href="#得最后的倒闭与否结果。" class="headerlink" title="得最后的倒闭与否结果。"></a>得最后的倒闭与否结果。</h5><h2 id="三、模型假设"><a href="#三、模型假设" class="headerlink" title="三、模型假设"></a>三、模型假设</h2><h5 id="1-假设题目所给的数据真实可靠且合理；"><a href="#1-假设题目所给的数据真实可靠且合理；" class="headerlink" title="1. 假设题目所给的数据真实可靠且合理；"></a>1. 假设题目所给的数据真实可靠且合理；</h5><h5 id="2-不考虑不可抗力因素（如自然灾害、新冠肺炎等）的影响；"><a href="#2-不考虑不可抗力因素（如自然灾害、新冠肺炎等）的影响；" class="headerlink" title="2. 不考虑不可抗力因素（如自然灾害、新冠肺炎等）的影响；"></a>2. 不考虑不可抗力因素（如自然灾害、新冠肺炎等）的影响；</h5><h5 id="3-假设银行破产因素只受附件中所给指标的影响；"><a href="#3-假设银行破产因素只受附件中所给指标的影响；" class="headerlink" title="3. 假设银行破产因素只受附件中所给指标的影响；"></a>3. 假设银行破产因素只受附件中所给指标的影响；</h5><h5 id="4-假设程序中浮点数运算的位数不会对结果产生较大影响。"><a href="#4-假设程序中浮点数运算的位数不会对结果产生较大影响。" class="headerlink" title="4. 假设程序中浮点数运算的位数不会对结果产生较大影响。"></a>4. 假设程序中浮点数运算的位数不会对结果产生较大影响。</h5><h5 id="5-用以计算整体偏移趋势的样本中不包含倒闭样本，认为倒闭的银行次"><a href="#5-用以计算整体偏移趋势的样本中不包含倒闭样本，认为倒闭的银行次" class="headerlink" title="5. 用以计算整体偏移趋势的样本中不包含倒闭样本，认为倒闭的银行次"></a>5. 用以计算整体偏移趋势的样本中不包含倒闭样本，认为倒闭的银行次</h5><h5 id="年不再运营"><a href="#年不再运营" class="headerlink" title="年不再运营"></a>年不再运营</h5><h2 id="四、名词解释与符号说明"><a href="#四、名词解释与符号说明" class="headerlink" title="四、名词解释与符号说明"></a>四、名词解释与符号说明</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">序号 符号 符号说明</span><br><span class="line">1 Ai Z-SCORE模型中第i项影响指标）</span><br><span class="line">2 Xi 附件 1 中 64 项指标中的第i项指标</span><br><span class="line">3 Ki 第i年份的Z-SCORE阈值</span><br><span class="line">4 Hij 第i年份第j项指标的聚类中心点</span><br><span class="line">5 Ti 第i个指标2017-2021年的整体偏移</span><br><span class="line">趋势</span><br><span class="line">6 Si 第i个银行自身的个体偏移趋势</span><br><span class="line">7 Ui 第i个银行的真实偏移趋势</span><br></pre></td></tr></tbody></table></figure>
<h2 id="五、模型的建立与求解"><a href="#五、模型的建立与求解" class="headerlink" title="五、模型的建立与求解"></a>五、模型的建立与求解</h2><h3 id="5-1-数据的预处理"><a href="#5-1-数据的预处理" class="headerlink" title="5.1 数据的预处理"></a>5.1 数据的预处理</h3><h4 id="5-1-1-缺失值处理"><a href="#5-1-1-缺失值处理" class="headerlink" title="5.1.1 缺失值处理"></a>5.1.1 缺失值处理</h4><h5 id="首先，我们对附件-1-中的缺失数据进行统计，并对缺失率进行排列，其"><a href="#首先，我们对附件-1-中的缺失数据进行统计，并对缺失率进行排列，其" class="headerlink" title="首先，我们对附件 1 中的缺失数据进行统计，并对缺失率进行排列，其"></a>首先，我们对附件 1 中的缺失数据进行统计，并对缺失率进行排列，其</h5><h5 id="中选取缺失率最高的前五项进行绘图，结果如图5-2"><a href="#中选取缺失率最高的前五项进行绘图，结果如图5-2" class="headerlink" title="中选取缺失率最高的前五项进行绘图，结果如图5-2:"></a>中选取缺失率最高的前五项进行绘图，结果如图5-2:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">图 5-2:缺失率与指标关系图</span><br></pre></td></tr></tbody></table></figure>

<h5 id="由上图可以看出，附件-1-中每个年份中的X21和X37数据缺失最为严"><a href="#由上图可以看出，附件-1-中每个年份中的X21和X37数据缺失最为严" class="headerlink" title="由上图可以看出，附件 1 中每个年份中的X21和X37数据缺失最为严"></a>由上图可以看出，附件 1 中每个年份中的X21和X37数据缺失最为严</h5><p>重，其中X21指标表示销售(n)/销售(n-1)，意义表明为销售数量的对比，其<br>值越接近 1 ，则销售数量越多。X37指标表示(流动资产-存货)/长期负债，意<br>义表明为银行负债承受能力。两者指标对银行倒闭风险相关程度不大，为保<br>证模型训练效果的一致性，因此我们剔除附件 1 中所有年份的X21和X<br>指标。其他指标的缺失率不足5%，因此也可直接剔除缺失数据，不影响数<br>据整体信息量。</p>
<h4 id="5-1-2-异常值处理"><a href="#5-1-2-异常值处理" class="headerlink" title="5.1.2 异常值处理"></a>5.1.2 异常值处理</h4><p>根据3sigma准则，对银行样本的指标数据进行异常值的剔除，一旦产生<br>异常值我们认为该样本的数据将会对模型的准确性和整体性产生影响，所<br>以直接剔除产生异常值的样本。最后 2017 年的样本中剔除了 13 项， 2018<br>年的样本剔除了 5 项， 2019 年的样本剔除了 7 项， 2020 年的数据无剔除，<br>2021 年的数据剔除了 3 项。</p>
<h3 id="5-2-基于Z-score模型的银行风险预测"><a href="#5-2-基于Z-score模型的银行风险预测" class="headerlink" title="5.2 基于Z-score模型的银行风险预测"></a>5.2 基于Z-score模型的银行风险预测</h3><h4 id="5-2-1-Z-score模型的建立"><a href="#5-2-1-Z-score模型的建立" class="headerlink" title="5.2.1 Z-score模型的建立"></a>5.2.1 Z-score模型的建立</h4><p>Z-score模型是以多变量的统计方法为基础，以破产企业为样本，通过<br>大量试验后对企业运营情况、破产与否进行分析的模型。在大量的分析基<br>础上，从上市公司的财务报告中计算出一组反映反映公司财务情况的指标，<br>然后根据这些指标对于财务危机的作用大小给出权重，最后加权得到一个<br>公司的财务风险评价指数Z。<br>Z-score模型主要用来解决多变量预警问题，已被广泛应用于财务预警<br>领域中。关预警的计算公式如式( 1 )所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Z= 1. 2 A 1 + 1. 4 A 2 + 3. 3 A 3 + 0. 6 A 4 + 0. 999 A 5 (1)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，A 1 能够反映出银行资金的流动能力及其规模的大小，同时也能<br>较好地体现出银行在短时期内的偿付能力。若企业拥有较多的运营资金，则<br>说明其具有较强的偿付能力，破产几率就越小，反之，则将会面临破产的问<br>题。A 2 指标是衡量一段时间内的累积盈利能力，反映出银行在营期间的利<br>润情况。例如，一个相对年轻的公司可能会显示出较低的数值，因为它还</p>
<h5 id="没有时间来建立其累积利润。因此，可以说年轻的公司在这个分析中受到"><a href="#没有时间来建立其累积利润。因此，可以说年轻的公司在这个分析中受到" class="headerlink" title="没有时间来建立其累积利润。因此，可以说年轻的公司在这个分析中受到"></a>没有时间来建立其累积利润。因此，可以说年轻的公司在这个分析中受到</h5><h5 id="了某种程度的歧视，它被归类为破产的几率相对高于另一个较年长的公司，"><a href="#了某种程度的歧视，它被归类为破产的几率相对高于另一个较年长的公司，" class="headerlink" title="了某种程度的歧视，它被归类为破产的几率相对高于另一个较年长的公司，"></a>了某种程度的歧视，它被归类为破产的几率相对高于另一个较年长的公司，</h5><h5 id="当然也包括其他情况。但是，这正是现实世界中的情况。在公司的早期，破"><a href="#当然也包括其他情况。但是，这正是现实世界中的情况。在公司的早期，破" class="headerlink" title="当然也包括其他情况。但是，这正是现实世界中的情况。在公司的早期，破"></a>当然也包括其他情况。但是，这正是现实世界中的情况。在公司的早期，破</h5><h5 id="产的发生率要高得多。A-3-主要体现出银行是否考虑税收与融资方面的影响，"><a href="#产的发生率要高得多。A-3-主要体现出银行是否考虑税收与融资方面的影响，" class="headerlink" title="产的发生率要高得多。A 3 主要体现出银行是否考虑税收与融资方面的影响，"></a>产的发生率要高得多。A 3 主要体现出银行是否考虑税收与融资方面的影响，</h5><h5 id="侧面体现出银行提升资产价值的能力，该比值越大，则银行的利用效率越"><a href="#侧面体现出银行提升资产价值的能力，该比值越大，则银行的利用效率越" class="headerlink" title="侧面体现出银行提升资产价值的能力，该比值越大，则银行的利用效率越"></a>侧面体现出银行提升资产价值的能力，该比值越大，则银行的利用效率越</h5><h5 id="高，因而具有较强的业务水平。A-4-主要体现银行在破产前的市值可下降程"><a href="#高，因而具有较强的业务水平。A-4-主要体现银行在破产前的市值可下降程" class="headerlink" title="高，因而具有较强的业务水平。A 4 主要体现银行在破产前的市值可下降程"></a>高，因而具有较强的业务水平。A 4 主要体现银行在破产前的市值可下降程</h5><h5 id="度，该比值越大，则当银行出现较低的经营问题时，收益也越低。A-5-主要"><a href="#度，该比值越大，则当银行出现较低的经营问题时，收益也越低。A-5-主要" class="headerlink" title="度，该比值越大，则当银行出现较低的经营问题时，收益也越低。A 5 主要"></a>度，该比值越大，则当银行出现较低的经营问题时，收益也越低。A 5 主要</h5><h5 id="体现出银行的收入情况，该比值越大，则说明资产利用效率越高，反之，则"><a href="#体现出银行的收入情况，该比值越大，则说明资产利用效率越高，反之，则" class="headerlink" title="体现出银行的收入情况，该比值越大，则说明资产利用效率越高，反之，则"></a>体现出银行的收入情况，该比值越大，则说明资产利用效率越高，反之，则</h5><h5 id="说明资产利用效率越低。"><a href="#说明资产利用效率越低。" class="headerlink" title="说明资产利用效率越低。"></a>说明资产利用效率越低。</h5><h5 id="根据附件-1-中的-64-项指标之中找出与A-1-A-2-A-3-A-4-A-5-相对应的指标。"><a href="#根据附件-1-中的-64-项指标之中找出与A-1-A-2-A-3-A-4-A-5-相对应的指标。" class="headerlink" title="根据附件 1 中的 64 项指标之中找出与A 1 , A 2 , A 3 , A 4 , A 5 相对应的指标。"></a>根据附件 1 中的 64 项指标之中找出与A 1 , A 2 , A 3 , A 4 , A 5 相对应的指标。</h5><h5 id="其中A-1-A-2-A-3-A-5-分别与X-3-X-6-X-7-X-9-之相对应，X-4-由X-17-·X-25-得到。"><a href="#其中A-1-A-2-A-3-A-5-分别与X-3-X-6-X-7-X-9-之相对应，X-4-由X-17-·X-25-得到。" class="headerlink" title="其中A 1 , A 2 , A 3 , A 5 分别与X 3 , X 6 , X 7 , X 9 之相对应，X 4 由X 17 ·X 25 得到。"></a>其中A 1 , A 2 , A 3 , A 5 分别与X 3 , X 6 , X 7 , X 9 之相对应，X 4 由X 17 ·X 25 得到。</h5><h5 id="因此银行的风险评价指数的计算公式如式-2-所示："><a href="#因此银行的风险评价指数的计算公式如式-2-所示：" class="headerlink" title="因此银行的风险评价指数的计算公式如式( 2 )所示："></a>因此银行的风险评价指数的计算公式如式( 2 )所示：</h5><h5 id="Z-x3D-1-2-X-3-1-4-X-6-3-3-X-7-0-6-X-17-·X-25-0-999-X-9-2"><a href="#Z-x3D-1-2-X-3-1-4-X-6-3-3-X-7-0-6-X-17-·X-25-0-999-X-9-2" class="headerlink" title="Z= 1. 2 X 3 + 1. 4 X 6 + 3. 3 X 7 + 0. 6 X 17 ·X 25 + 0. 999 X 9 (2)"></a>Z= 1. 2 X 3 + 1. 4 X 6 + 3. 3 X 7 + 0. 6 X 17 ·X 25 + 0. 999 X 9 (2)</h5><h4 id="5-2-2-模型求解"><a href="#5-2-2-模型求解" class="headerlink" title="5.2.2 模型求解"></a>5.2.2 模型求解</h4><h5 id="从附件-1-中2017-2021五个年份中各大银行的X-3-X-6-X-7-X-9-X-17-XX-21"><a href="#从附件-1-中2017-2021五个年份中各大银行的X-3-X-6-X-7-X-9-X-17-XX-21" class="headerlink" title="从附件 1 中2017 2021五个年份中各大银行的X 3 , X 6 , X 7 , X 9 , X 17 , XX 21"></a>从附件 1 中2017 2021五个年份中各大银行的X 3 , X 6 , X 7 , X 9 , X 17 , XX 21</h5><p>六个指标数据代入( 2 )进行计算，以此可得各年份中各大银行的Z-score值。<br>为节约篇幅，仅展示 2017 年部分银行的结果数据表。其余见附件。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-1: 2017 年部分银行的Z-SCORE得分</span><br><span class="line">银行序号 Z-SCORE得分 是否倒闭</span><br><span class="line">4 1.78687973696 否</span><br><span class="line">6260 -5.3947893104 是</span><br><span class="line">1324 0.107538178 否</span><br><span class="line">700 3.12884351904 否</span><br><span class="line">98 1.639916158 否</span><br><span class="line">150 -2.166910048832 是</span><br><span class="line">259 2.846472957 否</span><br><span class="line">1141 -2.2365304792 是</span><br><span class="line">4722 1.463034408 否</span><br><span class="line">6319 0.1308990584 否</span><br><span class="line">888 3.2468726324 否</span><br><span class="line">2527 -1.91140947424 是</span><br><span class="line">3422 -0.42500176848 否</span><br><span class="line">6291 0.181738457488 否</span><br><span class="line">2914 -3.333019503872 是</span><br><span class="line">3887 1.783426924 否</span><br><span class="line">226 1.398590248 否</span><br><span class="line">13 -2.235894737664 是</span><br><span class="line">4505 0.572546358 否</span><br><span class="line">781 -1.22306576608 是</span><br></pre></td></tr></tbody></table></figure>
<p>为划分银行银行倒闭效率的分界，我们引入阈值K这一概念，当K &lt;<br>Z−score时，表示该银行经营效率妥善，财务情况良好；当K &gt; Z−score<br>时，表示该银行处于破产区域。因此我们对附件 1 中各年的所有银行Z-score<br>值与K值进行比对，当准确率最高时且处于即将开始快速下降为最佳K值<br>点。以 2017 年数据为例，如图5-3和图5-4所示</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">图 5-3:全局准确率与Z-score关系图</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">图 5-4:局部准确率与Z-score关系图</span><br></pre></td></tr></tbody></table></figure>
<p>由上图可知，当K值取-1.0时，能够较好的划分银行倒闭的概率区域。<br>因此，从 2017 年至 2021 年各年份的分界线如下表所示。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-2:2017-2021年银行K值分界线及准确率</span><br><span class="line">年份 2017 2018 2019 2020 2021</span><br><span class="line">K值分界线 -1.0 -3.9 -7.7 -21 -3.</span><br><span class="line">准确率 0.90915 0.92862 0.92486 0.92233 0.</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-3-基于随机森林模型的指标权重分析"><a href="#5-3-基于随机森林模型的指标权重分析" class="headerlink" title="5.3 基于随机森林模型的指标权重分析"></a>5.3 基于随机森林模型的指标权重分析</h3><h4 id="5-3-1-随机森林算法简介"><a href="#5-3-1-随机森林算法简介" class="headerlink" title="5.3.1 随机森林算法简介"></a>5.3.1 随机森林算法简介</h4><h5 id="随机森林通过改进决策树算法，能够分析较为复杂且样本之间具有相"><a href="#随机森林通过改进决策树算法，能够分析较为复杂且样本之间具有相" class="headerlink" title="随机森林通过改进决策树算法，能够分析较为复杂且样本之间具有相"></a>随机森林通过改进决策树算法，能够分析较为复杂且样本之间具有相</h5><h5 id="关性的数据特征。由于其能够捕获高维数据特征且具有较强的鲁棒性，被"><a href="#关性的数据特征。由于其能够捕获高维数据特征且具有较强的鲁棒性，被" class="headerlink" title="关性的数据特征。由于其能够捕获高维数据特征且具有较强的鲁棒性，被"></a>关性的数据特征。由于其能够捕获高维数据特征且具有较强的鲁棒性，被</h5><h5 id="广泛应用于数据分类、特征选择等领域。该算法的思想如下："><a href="#广泛应用于数据分类、特征选择等领域。该算法的思想如下：" class="headerlink" title="广泛应用于数据分类、特征选择等领域。该算法的思想如下："></a>广泛应用于数据分类、特征选择等领域。该算法的思想如下：</h5><h5 id="1-假设原始数据集A中共有N个数据样本，从中随机地重复选取N个数"><a href="#1-假设原始数据集A中共有N个数据样本，从中随机地重复选取N个数" class="headerlink" title="1. 假设原始数据集A中共有N个数据样本，从中随机地重复选取N个数"></a>1. 假设原始数据集A中共有N个数据样本，从中随机地重复选取N个数</h5><h5 id="据（有放回）组成新数据集B。"><a href="#据（有放回）组成新数据集B。" class="headerlink" title="据（有放回）组成新数据集B。"></a>据（有放回）组成新数据集B。</h5><ol start="2">
<li>假设B中共有X个特征，从中随机抽取x个特征，且x≪X，生成一<br> 个可以不剪枝的分类回归树。</li>
<li>重复执行（ 1 ）和（ 2 ）m次，最终生成的m棵决策树即为随机森林。<br> 在构造随机森林时，对每棵决策树对应的b个OOB（out of bag, OOB）<br>数据进行投票，以得到b个样本投票分数s 1 , s 2 ,… , sb。通过随机改变OOB<br>数据的特征变量xi来获取新的OOB数据样本，并利用随机森林对其进行<br>投票，得到矩阵S：</li>
</ol>
<h5 id="S-x3D"><a href="#S-x3D" class="headerlink" title="S="></a>S=</h5><h5 id="0"><a href="#0" class="headerlink" title="0"></a>0</h5><h5 id="BB"><a href="#BB" class="headerlink" title="BB"></a>BB</h5><h5 id="BB-1"><a href="#BB-1" class="headerlink" title="BB"></a>BB</h5><h5 id="BB-2"><a href="#BB-2" class="headerlink" title="BB"></a>BB</h5><h5 id=""><a href="#" class="headerlink" title="@"></a>@</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">s 11 s 12 ... s 1 b</span><br><span class="line">s 21 s 22 ... s 2 b</span><br><span class="line">... ... ...</span><br><span class="line">sk 1 sk 2 ... skb</span><br></pre></td></tr></tbody></table></figure>
<h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><h5 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h5><h5 id="CC-1"><a href="#CC-1" class="headerlink" title="CC"></a>CC</h5><h5 id="CC-2"><a href="#CC-2" class="headerlink" title="CC"></a>CC</h5><h5 id="A"><a href="#A" class="headerlink" title="A"></a>A</h5><h5 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h5><p>并通过式X计算各个特征向量对分类阶段的贡献大小ci，以衡量各个特征<br>的重要性：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ci=</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Xb</span><br><span class="line">j=</span><br></pre></td></tr></tbody></table></figure>
<p>(sj−sij)<br>b (4)<br>其中，sj和sij为变量修改前后的第i棵树的OOB误差率。随机森林<br>算法的流程图如图5-5所示。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">图 5-5:随机森林流程图</span><br></pre></td></tr></tbody></table></figure>
<h4 id="5-3-2-随机森林模型的构建"><a href="#5-3-2-随机森林模型的构建" class="headerlink" title="5.3.2 随机森林模型的构建"></a>5.3.2 随机森林模型的构建</h4><h5 id="经数据预处理后，得到-62-个特征指标。我们选取-2017-年作为模型演"><a href="#经数据预处理后，得到-62-个特征指标。我们选取-2017-年作为模型演" class="headerlink" title="经数据预处理后，得到 62 个特征指标。我们选取 2017 年作为模型演"></a>经数据预处理后，得到 62 个特征指标。我们选取 2017 年作为模型演</h5><h5 id="示。本文中随机森林模型的伪代码如下："><a href="#示。本文中随机森林模型的伪代码如下：" class="headerlink" title="示。本文中随机森林模型的伪代码如下："></a>示。本文中随机森林模型的伪代码如下：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">算法 1: 随机森林模型构建伪代码</span><br><span class="line">输入 : 上述中的 62 个特征指标数据</span><br><span class="line">输出 : 银行是否倒闭</span><br><span class="line">1 repeat</span><br><span class="line">2 训练集与测试集的划分;</span><br><span class="line">3 for n= 1 to 200 do</span><br><span class="line">4 从训练集数据样本中随机有放回地抽取生成一个样本子集;</span><br><span class="line">5 选取</span><br><span class="line">p</span><br><span class="line">[62] = 8个特征作为特征子集;</span><br><span class="line">6 生成决策树;</span><br><span class="line">7 end</span><br><span class="line">8 调节模型参数;</span><br><span class="line">9 形成随机森林;</span><br><span class="line">10 特征值贡献度排序;</span><br><span class="line">11 特征选择结果;</span><br><span class="line">12 until 模型准确率达到最大;</span><br><span class="line">本文使用sklearn中的RandomForestClassifier函数。按照上述代码进行</span><br></pre></td></tr></tbody></table></figure>

<h5 id="随机森林模型编写，其调节参数如下表所示："><a href="#随机森林模型编写，其调节参数如下表所示：" class="headerlink" title="随机森林模型编写，其调节参数如下表所示："></a>随机森林模型编写，其调节参数如下表所示：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-3:超参数列表</span><br><span class="line">超参数名称 超参数值</span><br><span class="line">n_estimators 8</span><br><span class="line">max_features 8</span><br><span class="line">random_state 90</span><br><span class="line">criterion gini</span><br><span class="line">min_samples_leaf 4</span><br><span class="line">min_samples_split 21</span><br></pre></td></tr></tbody></table></figure>
<h4 id="5-3-3-指标筛选结果及分析"><a href="#5-3-3-指标筛选结果及分析" class="headerlink" title="5.3.3 指标筛选结果及分析"></a>5.3.3 指标筛选结果及分析</h4><h5 id="将-2017-年数据代入上述模型运行，得到特征贡献度排序如下（得分越"><a href="#将-2017-年数据代入上述模型运行，得到特征贡献度排序如下（得分越" class="headerlink" title="将 2017 年数据代入上述模型运行，得到特征贡献度排序如下（得分越"></a>将 2017 年数据代入上述模型运行，得到特征贡献度排序如下（得分越</h5><h5 id="高相关性越强）："><a href="#高相关性越强）：" class="headerlink" title="高相关性越强）："></a>高相关性越强）：</h5><h5 id="’X29’-0-05607-’X46’-0-04940-’X61’-0-04850-’X45’-0-04751"><a href="#’X29’-0-05607-’X46’-0-04940-’X61’-0-04850-’X45’-0-04751" class="headerlink" title="[(’X29’, 0.05607), (’X46’, 0.04940), (’X61’, 0.04850), (’X45’, 0.04751),"></a>[(’X29’, 0.05607), (’X46’, 0.04940), (’X61’, 0.04850), (’X45’, 0.04751),</h5><h5 id="’X44’-0-03391-’X35’-0-03291-’X63’-0-03092-’X11’-0-02669-。如下"><a href="#’X44’-0-03391-’X35’-0-03291-’X63’-0-03092-’X11’-0-02669-。如下" class="headerlink" title="(’X44’, 0.03391), (’X35’, 0.03291), (’X63’, 0.03092), (’X11’, 0.02669)]。如下"></a>(’X44’, 0.03391), (’X35’, 0.03291), (’X63’, 0.03092), (’X11’, 0.02669)]。如下</h5><h5 id="图所示："><a href="#图所示：" class="headerlink" title="图所示："></a>图所示：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">图 5-6:指标贡献图</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">特征指标选择结果：选取排名前 5 的特征：X 29 , X 46 , X 61 , X 45 , X 44</span><br><span class="line">其中，X29为总资产的对数，其表示上市公司的总资产规模。X46为速</span><br></pre></td></tr></tbody></table></figure>

<h5 id="冻比率，其用来衡量某公司或企业的流动资产中能够快速变现并偿还流动"><a href="#冻比率，其用来衡量某公司或企业的流动资产中能够快速变现并偿还流动" class="headerlink" title="冻比率，其用来衡量某公司或企业的流动资产中能够快速变现并偿还流动"></a>冻比率，其用来衡量某公司或企业的流动资产中能够快速变现并偿还流动</h5><h5 id="负债的能力。若该值大于-1-，则说明公司投资的机会成本越多。X61为应收"><a href="#负债的能力。若该值大于-1-，则说明公司投资的机会成本越多。X61为应收" class="headerlink" title="负债的能力。若该值大于 1 ，则说明公司投资的机会成本越多。X61为应收"></a>负债的能力。若该值大于 1 ，则说明公司投资的机会成本越多。X61为应收</h5><h5 id="帐款与销售额的比率，其用来衡量企业中有多少销售是赊销的业务。该值"><a href="#帐款与销售额的比率，其用来衡量企业中有多少销售是赊销的业务。该值" class="headerlink" title="帐款与销售额的比率，其用来衡量企业中有多少销售是赊销的业务。该值"></a>帐款与销售额的比率，其用来衡量企业中有多少销售是赊销的业务。该值</h5><h5 id="越大，则说明该企业可能会遇到短期的资金流动性问题。X45为净利润占"><a href="#越大，则说明该企业可能会遇到短期的资金流动性问题。X45为净利润占" class="headerlink" title="越大，则说明该企业可能会遇到短期的资金流动性问题。X45为净利润占"></a>越大，则说明该企业可能会遇到短期的资金流动性问题。X45为净利润占</h5><h5 id="存货的比值，其用来表明利润的临界值，当存货减少时，对当期净利润影响"><a href="#存货的比值，其用来表明利润的临界值，当存货减少时，对当期净利润影响" class="headerlink" title="存货的比值，其用来表明利润的临界值，当存货减少时，对当期净利润影响"></a>存货的比值，其用来表明利润的临界值，当存货减少时，对当期净利润影响</h5><h5 id="较大，利润容易产生亏损。X44为应收账款的周转天数。该值越大，则说明"><a href="#较大，利润容易产生亏损。X44为应收账款的周转天数。该值越大，则说明" class="headerlink" title="较大，利润容易产生亏损。X44为应收账款的周转天数。该值越大，则说明"></a>较大，利润容易产生亏损。X44为应收账款的周转天数。该值越大，则说明</h5><h5 id="应收账款周转率越小，收账较慢，账龄较长，资产流动性和短期偿债能力较"><a href="#应收账款周转率越小，收账较慢，账龄较长，资产流动性和短期偿债能力较" class="headerlink" title="应收账款周转率越小，收账较慢，账龄较长，资产流动性和短期偿债能力较"></a>应收账款周转率越小，收账较慢，账龄较长，资产流动性和短期偿债能力较</h5><h5 id="弱。"><a href="#弱。" class="headerlink" title="弱。"></a>弱。</h5><h3 id="5-4-Z-score模型与随机森林模型的对比"><a href="#5-4-Z-score模型与随机森林模型的对比" class="headerlink" title="5.4 Z-score模型与随机森林模型的对比"></a>5.4 Z-score模型与随机森林模型的对比</h3><h4 id="5-4-1-两种模型结果的对比分析"><a href="#5-4-1-两种模型结果的对比分析" class="headerlink" title="5.4.1 两种模型结果的对比分析"></a>5.4.1 两种模型结果的对比分析</h4><h5 id="对于分类器的性能评价也出现了两大指标体系，分别是混淆矩阵中的"><a href="#对于分类器的性能评价也出现了两大指标体系，分别是混淆矩阵中的" class="headerlink" title="对于分类器的性能评价也出现了两大指标体系，分别是混淆矩阵中的"></a>对于分类器的性能评价也出现了两大指标体系，分别是混淆矩阵中的</h5><h5 id="比率指标和ROC曲线以及曲线下面积AUC。基于混淆矩阵的思想下，又将"><a href="#比率指标和ROC曲线以及曲线下面积AUC。基于混淆矩阵的思想下，又将" class="headerlink" title="比率指标和ROC曲线以及曲线下面积AUC。基于混淆矩阵的思想下，又将"></a>比率指标和ROC曲线以及曲线下面积AUC。基于混淆矩阵的思想下，又将</h5><h5 id="不同的比率进行分类，即召回率、准确率、精确率和F测度。本文采用混淆"><a href="#不同的比率进行分类，即召回率、准确率、精确率和F测度。本文采用混淆" class="headerlink" title="不同的比率进行分类，即召回率、准确率、精确率和F测度。本文采用混淆"></a>不同的比率进行分类，即召回率、准确率、精确率和F测度。本文采用混淆</h5><h5 id="矩阵列示每种方法的输出结果，以此判断模型的性能。"><a href="#矩阵列示每种方法的输出结果，以此判断模型的性能。" class="headerlink" title="矩阵列示每种方法的输出结果，以此判断模型的性能。"></a>矩阵列示每种方法的输出结果，以此判断模型的性能。</h5><h5 id="混淆矩阵表示如下："><a href="#混淆矩阵表示如下：" class="headerlink" title="混淆矩阵表示如下："></a>混淆矩阵表示如下：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-4:分类结果混淆矩阵</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">真实情况 正例 预测结果反例</span><br><span class="line">正例 TP(真正例) FN(假反例)</span><br><span class="line">反例 FP(假正例) TN(真反例)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Z-score模型的混淆矩阵结果如下：</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-5:Z-score的混淆矩阵结果</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">真实情况 正例 预测结果反例</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2017 正例反例^60229671919</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2018 正例反例^778618534570</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2019 正例反例^841027613219</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2020 正例反例^7831304468</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2021 正例反例^481424835</span><br></pre></td></tr></tbody></table></figure>
<h5 id="随机森林的混淆矩阵结果："><a href="#随机森林的混淆矩阵结果：" class="headerlink" title="随机森林的混淆矩阵结果："></a>随机森林的混淆矩阵结果：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-6:随机森林的混淆矩阵结果</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">真实情况 正例 预测结果反例</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2017 正例反例^18682800</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2018 正例反例^25116200</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2019 正例反例^25629000</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2020 正例反例^234511200</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2021 正例反例^144253818</span><br></pre></td></tr></tbody></table></figure>
<h5 id="1-召回率对比"><a href="#1-召回率对比" class="headerlink" title="1. 召回率对比"></a>1. 召回率对比</h5><h5 id="召回率公式为："><a href="#召回率公式为：" class="headerlink" title="召回率公式为："></a>召回率公式为：</h5><h5 id="召回率-x3D-T-PT-P-F-N-5"><a href="#召回率-x3D-T-PT-P-F-N-5" class="headerlink" title="召回率=T PT P+F N (5)"></a>召回率=T PT P+F N (5)</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-7:两种模型召回率的对比结果</span><br><span class="line">2017 2018 2019 2020 2021 平均召回率</span><br><span class="line">Z-score 96.93% 99.57% 98.45% 99.42% 99.94% 98.86%</span><br><span class="line">随机森林 100.00% 100.00% 100.00% 100.00% 99.45% 99.89%</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>准确率对比<br> 准确率公式为：<br>准确率=T P+F NT P++T NF P+F N (6)</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-8:两种模型准确率的对比结果</span><br><span class="line">2017 2018 2019 2020 2021 平均准确率</span><br><span class="line">Z-score 83.89% 97.45% 95.38% 95.73% 95.05% 93.50%</span><br><span class="line">随机森林 98.52% 97.59% 96.61% 95.44% 95.99% 96.83%</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>精确率对比<br> 精确率公式为：<br>精确率=T PT P+F P (7)</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-9:两种模型精确率的对比结果</span><br><span class="line">2017 2018 2019 2020 2021 平均精确率</span><br><span class="line">Z-score 86.16% 97.68% 96.82% 96.26% 95.10% 94.41%</span><br><span class="line">随机森林 98.52% 97.59% 96.61% 95.44% 96.45% 96.92%</span><br></pre></td></tr></tbody></table></figure>
<ol start="4">
<li>F测度对比<br> F测度公式为：<br>F测度=^2 ×召回率召回率+×准确率准确率 (8)</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-10:两种模型F测度的对比结果</span><br><span class="line">2017 2018 2019 2020 2021 平均精确率</span><br><span class="line">Z-score 86.16% 97.68% 96.82% 96.26% 95.10% 94.41%</span><br><span class="line">随机森林 98.52% 97.59% 96.61% 95.44% 96.45% 96.92%</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-4-2-倒闭风险预测模型构建"><a href="#5-4-2-倒闭风险预测模型构建" class="headerlink" title="5.4.2 倒闭风险预测模型构建"></a>5.4.2 倒闭风险预测模型构建</h4><h5 id="由于本文的中心在于预警银行倒闭风险，因此将未倒闭银行识别成未"><a href="#由于本文的中心在于预警银行倒闭风险，因此将未倒闭银行识别成未" class="headerlink" title="由于本文的中心在于预警银行倒闭风险，因此将未倒闭银行识别成未"></a>由于本文的中心在于预警银行倒闭风险，因此将未倒闭银行识别成未</h5><h5 id="倒闭银行的召回率更为重要，由以上结果可以看出随机森林模型具备更好"><a href="#倒闭银行的召回率更为重要，由以上结果可以看出随机森林模型具备更好" class="headerlink" title="倒闭银行的召回率更为重要，由以上结果可以看出随机森林模型具备更好"></a>倒闭银行的召回率更为重要，由以上结果可以看出随机森林模型具备更好</h5><p>的性能，即随机森林模型在准确率、精准率和F测度都比Z-score模型精度<br>高，总体性能较好的分类器。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-11:两种模型的性能对比汇总</span><br><span class="line">Z-score模型 随机森林模型</span><br><span class="line">平均召回率 98.86% 99.89%</span><br><span class="line">平均准确率 93.50% 96.83%</span><br><span class="line">平均精确率 94.41% 96.92%</span><br><span class="line">平均F测度 96.06% 98.33%</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-5-随机森林模型的验证及预测"><a href="#5-5-随机森林模型的验证及预测" class="headerlink" title="5.5 随机森林模型的验证及预测"></a>5.5 随机森林模型的验证及预测</h3><h5 id="任务四中要求我们选取具有代表性的-20-家未破产银行和-20-家已破产"><a href="#任务四中要求我们选取具有代表性的-20-家未破产银行和-20-家已破产" class="headerlink" title="任务四中要求我们选取具有代表性的 20 家未破产银行和 20 家已破产"></a>任务四中要求我们选取具有代表性的 20 家未破产银行和 20 家已破产</h5><h5 id="银行。为选取具有代表性的数据，我们分别采用聚类方法和蒙特卡洛方法"><a href="#银行。为选取具有代表性的数据，我们分别采用聚类方法和蒙特卡洛方法" class="headerlink" title="银行。为选取具有代表性的数据，我们分别采用聚类方法和蒙特卡洛方法"></a>银行。为选取具有代表性的数据，我们分别采用聚类方法和蒙特卡洛方法</h5><h5 id="进行比对分析。"><a href="#进行比对分析。" class="headerlink" title="进行比对分析。"></a>进行比对分析。</h5><h4 id="5-5-1-聚类方法"><a href="#5-5-1-聚类方法" class="headerlink" title="5.5.1 聚类方法"></a>5.5.1 聚类方法</h4><h5 id="1-聚类流程"><a href="#1-聚类流程" class="headerlink" title="(1)聚类流程"></a>(1)聚类流程</h5><h5 id="第一步，将-2021-年中未破产和已破产银行分为两类；"><a href="#第一步，将-2021-年中未破产和已破产银行分为两类；" class="headerlink" title="第一步，将 2021 年中未破产和已破产银行分为两类；"></a>第一步，将 2021 年中未破产和已破产银行分为两类；</h5><h5 id="第二步，通过聚类算法分别获取未破产银行和已破产银行的聚类中心"><a href="#第二步，通过聚类算法分别获取未破产银行和已破产银行的聚类中心" class="headerlink" title="第二步，通过聚类算法分别获取未破产银行和已破产银行的聚类中心"></a>第二步，通过聚类算法分别获取未破产银行和已破产银行的聚类中心</h5><h5 id="点；"><a href="#点；" class="headerlink" title="点；"></a>点；</h5><h5 id="第三步，通过欧式距离计算未破产银行和已破产银行数据点与聚类中"><a href="#第三步，通过欧式距离计算未破产银行和已破产银行数据点与聚类中" class="headerlink" title="第三步，通过欧式距离计算未破产银行和已破产银行数据点与聚类中"></a>第三步，通过欧式距离计算未破产银行和已破产银行数据点与聚类中</h5><h5 id="心点的距离，欧式距离公式如下；"><a href="#心点的距离，欧式距离公式如下；" class="headerlink" title="心点的距离，欧式距离公式如下；"></a>心点的距离，欧式距离公式如下；</h5><h5 id="D-x3D"><a href="#D-x3D" class="headerlink" title="D="></a>D=</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vu</span><br><span class="line">utXn</span><br><span class="line">k=</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(x 1 k−x 2 k)^2 (9)</span><br></pre></td></tr></tbody></table></figure>
<p>该式表示两个n维向量间的欧氏距离。<br>第四步，分别筛选未破产银行和已破产银行距离总和最小的 20 家银行；<br>第五步，代入到训练好的预测风险模型中来判别剩余银行的倒闭概率。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">算法 2: Kmeans聚类算法伪代码</span><br><span class="line">输入 : 输入数据C，聚类数k。</span><br><span class="line">输出 : 输出结果C 1 , C 2 ,... , CK</span><br><span class="line">1 repeat</span><br><span class="line">2 聚类中心初始化;</span><br><span class="line">3 for n=i to M G do</span><br><span class="line">4 计算每一个数据点与之最近的聚类中心，并将其添加到此</span><br><span class="line">集群中;</span><br><span class="line">5 重新计算聚类中心ck=N^1 Pxt∈Ckxt,Nk为目前第个聚类集</span><br><span class="line">群中所包含的样本数;</span><br><span class="line">6 计算总类间离散度JM SE;</span><br><span class="line">7 if JM SE收敛 then</span><br><span class="line">8 break;</span><br><span class="line">9 end</span><br><span class="line">10 end</span><br><span class="line">11 until 迭代次数达到最大值 MG ;</span><br><span class="line">(2)聚类结果</span><br><span class="line">通过python聚类后，结果如表5-12所示：</span><br><span class="line">表 5-12:聚类方法下部分代表性银行编号表</span><br><span class="line">银行编号</span><br><span class="line">已破产银行 3 12 21 60 65 79 84 89 100 112</span><br><span class="line">未破产银行 283 448 1186 1335 1364 1558 1626 1769 1897 1959</span><br></pre></td></tr></tbody></table></figure>
<p>(3)银行预测<br>将聚类方法下的代表性银行数据代入到已训练好的随机森林模型中进<br>行训练，并对剩余银行数据进行预测。其预测准确度为54.76%。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-13: 2021 年随机森林模型超参数表格</span><br><span class="line">超参数名称 超参数值</span><br><span class="line">n_estimators 28</span><br><span class="line">max_features 8</span><br><span class="line">random_state 90</span><br><span class="line">criterion entropy</span><br><span class="line">min_samples_leaf 1</span><br><span class="line">min_samples_split 16</span><br><span class="line">max_depth 18</span><br></pre></td></tr></tbody></table></figure>
<h4 id="5-5-2-蒙特卡洛方法"><a href="#5-5-2-蒙特卡洛方法" class="headerlink" title="5.5.2 蒙特卡洛方法"></a>5.5.2 蒙特卡洛方法</h4><h5 id="1-蒙特卡洛流程"><a href="#1-蒙特卡洛流程" class="headerlink" title="(1)蒙特卡洛流程"></a>(1)蒙特卡洛流程</h5><h5 id="第一步，由计算机随机获取-2021-年已破产和未破产各-20-家银行数据，"><a href="#第一步，由计算机随机获取-2021-年已破产和未破产各-20-家银行数据，" class="headerlink" title="第一步，由计算机随机获取 2021 年已破产和未破产各 20 家银行数据，"></a>第一步，由计算机随机获取 2021 年已破产和未破产各 20 家银行数据，</h5><h5 id="并将其作为训练样本，其余数据则作为测试样本；"><a href="#并将其作为训练样本，其余数据则作为测试样本；" class="headerlink" title="并将其作为训练样本，其余数据则作为测试样本；"></a>并将其作为训练样本，其余数据则作为测试样本；</h5><h5 id="第二步，训练蒙特卡洛模型，并得出该训练集和测试集下的最终预测"><a href="#第二步，训练蒙特卡洛模型，并得出该训练集和测试集下的最终预测" class="headerlink" title="第二步，训练蒙特卡洛模型，并得出该训练集和测试集下的最终预测"></a>第二步，训练蒙特卡洛模型，并得出该训练集和测试集下的最终预测</h5><h5 id="精度；"><a href="#精度；" class="headerlink" title="精度；"></a>精度；</h5><h5 id="第三步，针对步骤-1-和步骤-2-重复模拟次随机试验；"><a href="#第三步，针对步骤-1-和步骤-2-重复模拟次随机试验；" class="headerlink" title="第三步，针对步骤 1 和步骤 2 重复模拟次随机试验；"></a>第三步，针对步骤 1 和步骤 2 重复模拟次随机试验；</h5><h5 id="第四步，从个输出结果中选取预测精度最高的一组作为最具代表意义"><a href="#第四步，从个输出结果中选取预测精度最高的一组作为最具代表意义" class="headerlink" title="第四步，从个输出结果中选取预测精度最高的一组作为最具代表意义"></a>第四步，从个输出结果中选取预测精度最高的一组作为最具代表意义</h5><h5 id="的-20-家现存银行和-20-家倒闭银行。"><a href="#的-20-家现存银行和-20-家倒闭银行。" class="headerlink" title="的 20 家现存银行和 20 家倒闭银行。"></a>的 20 家现存银行和 20 家倒闭银行。</h5><h5 id="2-蒙特卡洛结果"><a href="#2-蒙特卡洛结果" class="headerlink" title="(2)蒙特卡洛结果"></a>(2)蒙特卡洛结果</h5><h5 id="通过蒙特卡洛方法后，结果如表5-14所示："><a href="#通过蒙特卡洛方法后，结果如表5-14所示：" class="headerlink" title="通过蒙特卡洛方法后，结果如表5-14所示："></a>通过蒙特卡洛方法后，结果如表5-14所示：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-14:蒙特卡洛方法下部分代表性银行编号表</span><br><span class="line">银行编号</span><br><span class="line">已破产银行 133 236 101 134 131 125 118 203 217 186</span><br><span class="line">未破产银行 3685 2260 4006 1894 4459 3919 2687 2119 28 4093</span><br></pre></td></tr></tbody></table></figure>
<p>(3)银行预测<br>将蒙特卡洛方法下的代表性银行数据代入到已训练好的随机森林模型<br>中进行训练，并对剩余银行数据进行预测。其预测准确度为95.35%。</p>
<h4 id="5-5-3-结果对比分析"><a href="#5-5-3-结果对比分析" class="headerlink" title="5.5.3 结果对比分析"></a>5.5.3 结果对比分析</h4><h5 id="从上述分析中，可以看出蒙特卡洛方法下选取的结果更加准确，为判"><a href="#从上述分析中，可以看出蒙特卡洛方法下选取的结果更加准确，为判" class="headerlink" title="从上述分析中，可以看出蒙特卡洛方法下选取的结果更加准确，为判"></a>从上述分析中，可以看出蒙特卡洛方法下选取的结果更加准确，为判</h5><p>断是否具有代表性，我们通过碎石图分析得出K-Mean聚类下选取的银行是<br>不能够准确识别大多数银行的性质性，而蒙特卡洛方法下选取的银行是能<br>够有效的准确识别大多数银行的性质。因此，蒙特卡洛方法下选择的 40 家<br>银行数据是更具有代表性。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">图 5-7:碎石图</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-6-基于余弦相似度的银行同属模型构建及其预测"><a href="#5-6-基于余弦相似度的银行同属模型构建及其预测" class="headerlink" title="5.6 基于余弦相似度的银行同属模型构建及其预测"></a>5.6 基于余弦相似度的银行同属模型构建及其预测</h3><h4 id="5-6-1-余弦相似度模型的构建"><a href="#5-6-1-余弦相似度模型的构建" class="headerlink" title="5.6.1 余弦相似度模型的构建"></a>5.6.1 余弦相似度模型的构建</h4><h5 id="从-2017-年开始，从未倒闭的银行中的银行中选择-1000-个样本。因为已"><a href="#从-2017-年开始，从未倒闭的银行中的银行中选择-1000-个样本。因为已" class="headerlink" title="从 2017 年开始，从未倒闭的银行中的银行中选择 1000 个样本。因为已"></a>从 2017 年开始，从未倒闭的银行中的银行中选择 1000 个样本。因为已</h5><h5 id="经倒闭的银行不会再运营，因此不可能在次年及以后出现该银行的指标数"><a href="#经倒闭的银行不会再运营，因此不可能在次年及以后出现该银行的指标数" class="headerlink" title="经倒闭的银行不会再运营，因此不可能在次年及以后出现该银行的指标数"></a>经倒闭的银行不会再运营，因此不可能在次年及以后出现该银行的指标数</h5><h5 id="据，对于研究指标的整体偏移趋势没有意义。"><a href="#据，对于研究指标的整体偏移趋势没有意义。" class="headerlink" title="据，对于研究指标的整体偏移趋势没有意义。"></a>据，对于研究指标的整体偏移趋势没有意义。</h5><h5 id="在任务四中我们已经通过聚类算法得到2017-2021年各项指标的聚类"><a href="#在任务四中我们已经通过聚类算法得到2017-2021年各项指标的聚类" class="headerlink" title="在任务四中我们已经通过聚类算法得到2017-2021年各项指标的聚类"></a>在任务四中我们已经通过聚类算法得到2017-2021年各项指标的聚类</h5><p>中心点Hij，这样我们可以线性拟合每一项指标五年的聚类中心点数值，可<br>以得到拟合出的直线方程，斜率即为指标的整体偏移趋势Tj，通过每个指<br>标拟合出的直线方程，从 2017 年开始逐年计算每一个银行样本次年的各项<br>指标的预测数据，接下来我们将每一个银行预测的数据与次年的真实指标<br>数据采用式( 10 )进行余弦相似度计算。</p>
<p>假定A= (A 1 , A 2 ,… , An)和B= (B 1 , B 2 ,… , Bn)是两个n维向量，则<br>A与B的夹角θ的余弦值为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cosθ=</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Pn</span><br><span class="line">pPn i=1(AI×Bi)</span><br><span class="line">i=1(AI)^2 ×</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">pPn</span><br><span class="line">i=1(BI)^2</span><br></pre></td></tr></tbody></table></figure>
<h5 id="10"><a href="#10" class="headerlink" title="(10)"></a>(10)</h5><h5 id="x3D-AA-×-·BB-11"><a href="#x3D-AA-×-·BB-11" class="headerlink" title="=|AA|×|·BB| (11)"></a>=|AA|×|·BB| (11)</h5><h5 id="余弦相似度可以表示两个样本的相似度大小，余弦相似度越大则两个"><a href="#余弦相似度可以表示两个样本的相似度大小，余弦相似度越大则两个" class="headerlink" title="余弦相似度可以表示两个样本的相似度大小，余弦相似度越大则两个"></a>余弦相似度可以表示两个样本的相似度大小，余弦相似度越大则两个</h5><h5 id="银行的相似度越高，可以认为是来自同一家银行。当余弦相似度最大时，认"><a href="#银行的相似度越高，可以认为是来自同一家银行。当余弦相似度最大时，认" class="headerlink" title="银行的相似度越高，可以认为是来自同一家银行。当余弦相似度最大时，认"></a>银行的相似度越高，可以认为是来自同一家银行。当余弦相似度最大时，认</h5><h5 id="为次年该编号的银行样本与当前年份的银行样本数据相似度最高，最接近"><a href="#为次年该编号的银行样本与当前年份的银行样本数据相似度最高，最接近" class="headerlink" title="为次年该编号的银行样本与当前年份的银行样本数据相似度最高，最接近"></a>为次年该编号的银行样本与当前年份的银行样本数据相似度最高，最接近</h5><h5 id="整体发展趋势，认为次年该编号银行与当年银行是同一家。"><a href="#整体发展趋势，认为次年该编号银行与当年银行是同一家。" class="headerlink" title="整体发展趋势，认为次年该编号银行与当年银行是同一家。"></a>整体发展趋势，认为次年该编号银行与当年银行是同一家。</h5><h5 id="根据余弦相似度，我们可以得到每一年选取的-1000-个银行按照整体偏"><a href="#根据余弦相似度，我们可以得到每一年选取的-1000-个银行按照整体偏" class="headerlink" title="根据余弦相似度，我们可以得到每一年选取的 1000 个银行按照整体偏"></a>根据余弦相似度，我们可以得到每一年选取的 1000 个银行按照整体偏</h5><h5 id="移趋势对应的次年的银行编号，如下表所示，可整理出来自同一家银行的"><a href="#移趋势对应的次年的银行编号，如下表所示，可整理出来自同一家银行的" class="headerlink" title="移趋势对应的次年的银行编号，如下表所示，可整理出来自同一家银行的"></a>移趋势对应的次年的银行编号，如下表所示，可整理出来自同一家银行的</h5><h5 id="五年的指标数据。"><a href="#五年的指标数据。" class="headerlink" title="五年的指标数据。"></a>五年的指标数据。</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-15:不同年份同属银行表</span><br><span class="line">2017 年公司编号 2018 年公司编号 2019 年公司编号 2020 年公司编号 2021 年公司编号</span><br><span class="line">518 842 732 48 407</span><br><span class="line">181 638 197 447 995</span><br><span class="line">405 194 171 471 746</span><br><span class="line">331 639 650 765 763</span><br><span class="line">920 473 510 445 322</span><br><span class="line">894 645 292 175 38</span><br><span class="line">869 636 127 250 544</span><br><span class="line">361 341 750 655 345</span><br><span class="line">0 8 293 57 736</span><br></pre></td></tr></tbody></table></figure>
<h4 id="5-6-2-同属银行倒闭风险趋势模型的构建"><a href="#5-6-2-同属银行倒闭风险趋势模型的构建" class="headerlink" title="5.6.2 同属银行倒闭风险趋势模型的构建"></a>5.6.2 同属银行倒闭风险趋势模型的构建</h4><h5 id="为预测同一家银行在未来是否呈现倒闭趋势，我们引入真实偏移趋势"><a href="#为预测同一家银行在未来是否呈现倒闭趋势，我们引入真实偏移趋势" class="headerlink" title="为预测同一家银行在未来是否呈现倒闭趋势，我们引入真实偏移趋势"></a>为预测同一家银行在未来是否呈现倒闭趋势，我们引入真实偏移趋势</h5><p>Uj。<br>Uj=f(Tj, Sj) (12)</p>
<p>其中Tj表示整体偏移趋势，Sj表示个体偏移趋势，个体偏移趋势是由同一<br>家银行在五年内本身数据变化引起的，通过最小二乘法拟合同一家银行各</p>
<h5 id="指标随年份变化的直线方程。"><a href="#指标随年份变化的直线方程。" class="headerlink" title="指标随年份变化的直线方程。"></a>指标随年份变化的直线方程。</h5><h5 id="式-12-表示各银行是由个体偏移趋势和整体偏移趋势共同导致而成，"><a href="#式-12-表示各银行是由个体偏移趋势和整体偏移趋势共同导致而成，" class="headerlink" title="式( 12 )表示各银行是由个体偏移趋势和整体偏移趋势共同导致而成，"></a>式( 12 )表示各银行是由个体偏移趋势和整体偏移趋势共同导致而成，</h5><h5 id="为简便运算，我们令"><a href="#为简便运算，我们令" class="headerlink" title="为简便运算，我们令"></a>为简便运算，我们令</h5><p>Uj=Tj+ 2 Sj (13)<br>即整体偏移趋势和个体偏移趋势的比重一致。将表5-15整理后的银行<br>数据代入倒闭风险预测模型中进行预测分析。其结果如表5-16所示(仅展示<br>部分数据，其余数据见附件)。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表 5-16:倒闭银行风险趋向</span><br><span class="line">2017 年 2018 年 2019 年 2020 年 2021 年 是否有倒闭倾向</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">公司编号</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">518 842 732 48 407 0</span><br><span class="line">181 638 197 447 995 0</span><br><span class="line">405 194 171 471 746 0</span><br><span class="line">331 639 650 765 763 0</span><br><span class="line">920 473 510 445 322 0</span><br><span class="line">894 645 292 175 38 0</span><br><span class="line">869 636 127 250 544 0</span><br><span class="line">361 341 750 655 345 0</span><br><span class="line">0 8 293 57 736 0</span><br><span class="line">425 385 521 203 883 1</span><br></pre></td></tr></tbody></table></figure>
<h2 id="六、模型的评价"><a href="#六、模型的评价" class="headerlink" title="六、模型的评价"></a>六、模型的评价</h2><h3 id="6-1-模型的优点"><a href="#6-1-模型的优点" class="headerlink" title="6.1 模型的优点"></a>6.1 模型的优点</h3><ol>
<li>在Z-score模型种引入了能够反映银行破产的临界阈值，以实现对各银<br> 行的倒闭情况进行精准预测；</li>
<li>较好地解决了题目中的问题。随机森林的平均召回率在99%以上，其<br> 准确率也达到96.83%。特征的提取也做到了少而精，结果更容易理解；</li>
<li>采用蒙特卡洛方法中筛选出最具代表意义的 20 家现存银行和 20 家倒<br> 闭银行，在对其余的银行数据进行预测时，具有较高的准确度，其值<br> 高达95.35%；</li>
<li>通过拟合方程找出次年各个指标的聚类中心，并与次年的每个真实指</li>
</ol>
<h5 id="标值计算余弦相似度。相比距离度量，余弦相似度更加注重向量在两"><a href="#标值计算余弦相似度。相比距离度量，余弦相似度更加注重向量在两" class="headerlink" title="标值计算余弦相似度。相比距离度量，余弦相似度更加注重向量在两"></a>标值计算余弦相似度。相比距离度量，余弦相似度更加注重向量在两</h5><h5 id="个方向上的差异，同时修正了数据间可能存在的度量标准不统一的问"><a href="#个方向上的差异，同时修正了数据间可能存在的度量标准不统一的问" class="headerlink" title="个方向上的差异，同时修正了数据间可能存在的度量标准不统一的问"></a>个方向上的差异，同时修正了数据间可能存在的度量标准不统一的问</h5><h5 id="题，具有更强的判决准确性。"><a href="#题，具有更强的判决准确性。" class="headerlink" title="题，具有更强的判决准确性。"></a>题，具有更强的判决准确性。</h5><h3 id="6-2-模型的缺点"><a href="#6-2-模型的缺点" class="headerlink" title="6.2 模型的缺点"></a>6.2 模型的缺点</h3><h5 id="1-由于缺失数据较多且不规律，导致模型误差较大；"><a href="#1-由于缺失数据较多且不规律，导致模型误差较大；" class="headerlink" title="1. 由于缺失数据较多且不规律，导致模型误差较大；"></a>1. 由于缺失数据较多且不规律，导致模型误差较大；</h5><h5 id="2-在计算余弦相似度时，时间复杂度和空间复杂度较高；"><a href="#2-在计算余弦相似度时，时间复杂度和空间复杂度较高；" class="headerlink" title="2. 在计算余弦相似度时，时间复杂度和空间复杂度较高；"></a>2. 在计算余弦相似度时，时间复杂度和空间复杂度较高；</h5><h5 id="3-由于时间有限，在对准确率进行对比分析时，未使用更为精确的深度"><a href="#3-由于时间有限，在对准确率进行对比分析时，未使用更为精确的深度" class="headerlink" title="3. 由于时间有限，在对准确率进行对比分析时，未使用更为精确的深度"></a>3. 由于时间有限，在对准确率进行对比分析时，未使用更为精确的深度</h5><h5 id="学习模型。"><a href="#学习模型。" class="headerlink" title="学习模型。"></a>学习模型。</h5><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1] Altman E I. Financial ratios, discriminant analysis and the prediction of cor-</span><br><span class="line">porate bankruptcy[J]. The journal of finance, 1968, 23(4): 589-609.</span><br><span class="line">[2] Odom M D, Sharda R. A neural network model for bankruptcy predic-</span><br><span class="line">tion[C]//1990 IJCNN International Joint Conference on neural networks.</span><br><span class="line">IEEE, 1990: 163-168.</span><br><span class="line">[3] 霍远, 王惠.关于上市公司财务状况的聚类分析[J].统计与决策, 2007</span><br><span class="line">(17): 156-157.</span><br><span class="line">[4] TsaiCF,WuJW.Usingneuralnetworkensemblesforbankruptcyprediction</span><br><span class="line">and credit scoring[J]. Expert systems with applications, 2008, 34(4): 2639-</span><br><span class="line">2649.</span><br><span class="line">[5] 陈荣达,虞欢欢.基于启发式算法的支持向量机选股模型[J].系统工程,</span><br><span class="line">2014, 32(2): 40-48.</span><br><span class="line">[6] antoni V. La Previsione dell’insolvenza aziendale: confronto della perfor-</span><br><span class="line">mancedeimodelliZscore,LogiteRandomForestsuuncampionediaziende</span><br><span class="line">manifatturiere italiane[J]. 2014.</span><br></pre></td></tr></tbody></table></figure>

<p>附 录</p>
<h5 id="程序一：随机森林分类"><a href="#程序一：随机森林分类" class="headerlink" title="程序一：随机森林分类 :"></a>程序一：随机森林分类 :</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import pylab as pl</span><br><span class="line">from sklearn.preprocessing import OneHotEncoder</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line">from sklearn.model_selection import GridSearchCV</span><br><span class="line">from sklearn import metrics # 分类结果评价函数</span><br><span class="line">pl.rcParams['font.sans-serif'] = ['SimHei'] # 用来画图显示中文字体</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">data = pd.read_excel(r'2021.xlsx')</span><br><span class="line">data_data = data.iloc [: ,0:62]</span><br><span class="line">target = data.iloc[:, 62]</span><br><span class="line">rfc = RandomForestClassifier(n_estimators =100, random_state =90)</span><br><span class="line">score_pre = cross_val_score(rfc , data_data , target , cv=10)</span><br><span class="line">score_pre.mean()</span><br><span class="line">scorel = []</span><br><span class="line">for i in range (0, 200, 10):</span><br><span class="line">rfc = RandomForestClassifier(n_estimators=i,</span><br><span class="line">n_jobs=-1,</span><br><span class="line">random_state =90)</span><br><span class="line">score = cross_val_score(rfc , data_data , target , cv =10). mean()</span><br><span class="line">scorel.append(score)</span><br><span class="line">pl.plot( range (1, 201, 10), scorel)</span><br><span class="line">pl.show()</span><br><span class="line">scorel.remove(scorel [0])</span><br><span class="line">print ( max (scorel), (scorel.index( max (scorel ))*10)+1)</span><br><span class="line">scorel = []</span><br><span class="line">for i in range (15, 35, 1):</span><br><span class="line">rfc = RandomForestClassifier(n_estimators=i,</span><br><span class="line">n_jobs=-1,</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">random_state =90)</span><br><span class="line">score = cross_val_score(rfc , data_data , target , cv =10). mean()</span><br><span class="line">scorel.append(score)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">print** ( **max** (scorel), (scorel.index( **max** (scorel )))+15)</span><br><span class="line"></span><br><span class="line">pl.plot( **range** (15, 35, 1), scorel)</span><br><span class="line">pl.show()</span><br><span class="line"></span><br><span class="line">param_grid = {'max_depth': np.arange(1, 20, 1)}</span><br><span class="line">rfc = RandomForestClassifier(n_estimators =28,</span><br><span class="line">random_state =90)</span><br><span class="line">GS = GridSearchCV(rfc , param_grid , cv=10)</span><br><span class="line">GS.fit(data_data , target)</span><br><span class="line"></span><br><span class="line">param_grid = {'min_samples_leaf': np.arange(1, 11, 1)}</span><br><span class="line">rfc = RandomForestClassifier(n_estimators =28,</span><br><span class="line">random_state =90)</span><br><span class="line">GS = GridSearchCV(rfc , param_grid , cv=10)</span><br><span class="line">GS.fit(data_data , target)</span><br><span class="line">param_grid = {'min_samples_split': np.arange(2, 22, 1)}</span><br><span class="line">rfc = RandomForestClassifier(n_estimators =28,</span><br><span class="line">random_state =90)</span><br><span class="line">GS = GridSearchCV(rfc , param_grid , cv=10)</span><br><span class="line">GS.fit(data_data , target)</span><br><span class="line"></span><br><span class="line">param_grid = {'criterion': ['gini', 'entropy']}</span><br><span class="line">rfc = RandomForestClassifier(n_estimators =28,</span><br><span class="line">random_state =90)</span><br><span class="line">GS = GridSearchCV(rfc , param_grid , cv=10)</span><br><span class="line">GS.fit(data_data , target)</span><br><span class="line"></span><br><span class="line">rfc = RandomForestClassifier(n_estimators =28,</span><br><span class="line">random_state =90,</span><br><span class="line">max_depth =18,</span><br><span class="line">criterion='entropy',</span><br><span class="line">min_samples_leaf =1,</span><br><span class="line">min_samples_split =16)</span><br><span class="line"></span><br><span class="line">xtrain , xtest , ytrain , ytest = train_test_split(data_data , target , test_size =0.3)</span><br><span class="line"></span><br><span class="line">rfc = rfc.fit(xtrain , ytrain)</span><br><span class="line"></span><br><span class="line">importances = rfc.feature_importances_</span><br></pre></td></tr></tbody></table></figure>




<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sum (importances)</span><br><span class="line">predicted = rfc.predict(xtest)</span><br><span class="line">print (metrics.classification_report(ytest , predicted ))</span><br><span class="line">print (metrics.confusion_matrix(ytest , predicted ))</span><br><span class="line">auc = metrics.roc_auc_score(ytest , predicted)</span><br><span class="line">accuracy = metrics.accuracy_score(ytest , predicted) # 求精度</span><br><span class="line">print ("Accuracy: %.2f%%" % (accuracy * 100.0))</span><br></pre></td></tr></tbody></table></figure>
<h5 id="程序二：银行相似性"><a href="#程序二：银行相似性" class="headerlink" title="程序二：银行相似性 :"></a>程序二：银行相似性 :</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">from sklearn.cluster import KMeans</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">from scipy import optimize</span><br><span class="line">import pylab as pl</span><br><span class="line">import random</span><br><span class="line">from sklearn.preprocessing import OneHotEncoder</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line">from sklearn.model_selection import GridSearchCV</span><br><span class="line">from sklearn import metrics # 分类结果评价函数</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">data_2017 = pd.read_excel('2017.xlsx')</span><br><span class="line">data_2018 = pd.read_excel('2018.xlsx')</span><br><span class="line">data_2019 = pd.read_excel('2019.xlsx')</span><br><span class="line">data_2020 = pd.read_excel('2020.xlsx')</span><br><span class="line">data_2021 = pd.read_excel('2021.xlsx')</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">num = 1000</span><br><span class="line">data_2017 = data_2017.iloc [0:num ,0:62]</span><br><span class="line">data_2018 = data_2018.iloc [0:num ,0:62]</span><br><span class="line">data_2019 = data_2019.iloc [0:num ,0:62]</span><br><span class="line">data_2020 = data_2020.iloc [0:num ,0:62]</span><br><span class="line">data_2021 = data_2021.iloc [0:num ,0:62]</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">X = [data_2017 ,data_2018 ,data_2019 ,data_2020 ,data_2021]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**def** cosine_similarity(x,y):</span><br><span class="line">num = x.dot(y.T)</span><br><span class="line">denom = np.linalg.norm(x) * np.linalg.norm(y)</span><br><span class="line">**return** 1 - num / denom</span><br><span class="line"></span><br><span class="line">**def** func(x,k,b):</span><br><span class="line">**return** k*x+b</span><br><span class="line"></span><br><span class="line">centroid_list = []</span><br><span class="line">**for** x **in** X:</span><br><span class="line">n_clusters = 1</span><br><span class="line">cluster = KMeans(n_clusters=n_clusters , random_state =0)</span><br><span class="line">cluster.fit(x)</span><br><span class="line">centroid = cluster.cluster_centers_</span><br><span class="line">centroid_list.append(centroid)</span><br><span class="line"></span><br><span class="line">T_list = []</span><br><span class="line">**for** i **in range** (1, 5):</span><br><span class="line">k = centroid_list[i]-centroid_list[i-1]</span><br><span class="line">a = X[i-1]*k</span><br><span class="line">b = X[i]</span><br><span class="line">df = cosine_similarity(a,b)</span><br><span class="line">K_list = []</span><br><span class="line">**for** j **in range** ( **len** (df)):</span><br><span class="line">min_index = df.stack (). idxmin ()</span><br><span class="line">df = df.drop(min_index [0], axis =0)</span><br><span class="line">df = df.drop(min_index [1], axis =1)</span><br><span class="line">K_list.append ([ min_index [0], min_index [1]])</span><br><span class="line">T_list.append(K_list)</span><br><span class="line"></span><br><span class="line">end_list = []</span><br><span class="line">**for** i **in range** (num):</span><br><span class="line">sort_list = []</span><br><span class="line">sort_list.append(T_list [0][i][0])</span><br><span class="line">sort_list.append(T_list [0][i][1])</span><br><span class="line">**for** j **in range** (num):</span><br><span class="line">**if** T_list [1][j][0] == T_list [0][i][1]:</span><br><span class="line">sort_list.append(T_list [1][j][1])</span><br><span class="line">**for** s **in range** (num):</span><br><span class="line">**if** T_list [2][s][0] == T_list [1][j][1]:</span><br></pre></td></tr></tbody></table></figure>




<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sort_list.append(T_list [2][s][1])</span><br><span class="line">for m in range (num):</span><br><span class="line">if T_list [3][m][0] == T_list [2][s][1]:</span><br><span class="line">sort_list.append(T_list [3][m][1])</span><br><span class="line">end_list.append(sort_list)</span><br><span class="line">df1 = pd.DataFrame(end_list)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">df1.columns = [' 2017 年公司编号', ' 2018 年公司编号', ' 2019 年公司编号', ' 2020 年公司编号', ' 2021 年公司编号', ]</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">df1.to_excel('同家银行编号.xlsx', index=False)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="整体偏移"><a href="#整体偏移" class="headerlink" title="整体偏移"></a>整体偏移</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">data = pd.read_excel('中心点偏移拟合直线 .xlsx')</span><br><span class="line">l_all = 2022 * data['k'] + data['b']</span><br><span class="line">l_all = l_all.tolist ()</span><br></pre></td></tr></tbody></table></figure>
<h1 id="个体偏移"><a href="#个体偏移" class="headerlink" title="个体偏移"></a>个体偏移</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">table = []</span><br><span class="line">for i in range (1000):</span><br><span class="line">dat_2017 = data_2017.iloc[df1.iloc[i, 0], :]. tolist ()</span><br><span class="line">dat_2018 = data_2018.iloc[df1.iloc[i, 1], :]. tolist ()</span><br><span class="line">dat_2019 = data_2019.iloc[df1.iloc[i, 2], :]. tolist ()</span><br><span class="line">dat_2020 = data_2020.iloc[df1.iloc[i, 3], :]. tolist ()</span><br><span class="line">dat_2021 = data_2021.iloc[df1.iloc[i, 4], :]. tolist ()</span><br><span class="line">dict = {</span><br><span class="line">'A': dat_2017 ,</span><br><span class="line">'B': dat_2018 ,</span><br><span class="line">'C': dat_2019 ,</span><br><span class="line">'D': dat_2020 ,</span><br><span class="line">'E': dat_2021</span><br><span class="line">}</span><br><span class="line">data = pd.DataFrame( dict )</span><br><span class="line">l_unit = []</span><br><span class="line">for j in range (62):</span><br><span class="line">popt , pcov = optimize.curve_fit(func , [2017 , 2018, 2019, 2020, 2021] , data.iloc[j, :]. tolist ())</span><br><span class="line">k = 2022 * popt [0] + popt [1]</span><br><span class="line">l_unit.append(k)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">table.append(l_unit)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">df = pd.DataFrame(table)</span><br><span class="line"></span><br><span class="line">rfc = RandomForestClassifier(n_estimators =28,</span><br><span class="line">random_state =90,</span><br><span class="line">max_depth =18,</span><br><span class="line">criterion='entropy',</span><br><span class="line">min_samples_leaf =1,</span><br><span class="line">min_samples_split =16)</span><br><span class="line"></span><br><span class="line">data = pd.read_excel(r'2021.xlsx')</span><br><span class="line"></span><br><span class="line">data_data = data.iloc [: ,0:62]</span><br><span class="line">target = data.iloc[:, 62]</span><br><span class="line"></span><br><span class="line">rfc.fit(data_data , target)</span><br><span class="line">pre_ = rfc.predict(df)</span><br><span class="line">df1['预测值'] = pd.DataFrame(pre_)</span><br><span class="line">df1.to_excel('预测值.xlsx',index=False)</span><br><span class="line">rfc.predict_proba(df)</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_某宝闲谈</title>
    <url>/2022/09/10/python-%20%E6%B7%98%E5%AE%9D/</url>
    <content><![CDATA[<html><head></head><body><h1 id="某宝闲谈"><a href="#某宝闲谈" class="headerlink" title="某宝闲谈"></a>某宝闲谈</h1><h2 id="需要的库"><a href="#需要的库" class="headerlink" title="需要的库:"></a>需要的库:</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">re</span><br><span class="line">time</span><br><span class="line">random</span><br><span class="line">selenium</span><br><span class="line">openpyxl</span><br></pre></td></tr></tbody></table></figure>

<h2 id="爬虫思路"><a href="#爬虫思路" class="headerlink" title="爬虫思路"></a>爬虫思路</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">通过Selenium进入到https://www.taobao.com/ 在搜索框输入关键词 并且回车 然后自己扫描登陆</span><br><span class="line">首先判断有没有出现验证码(通过获取本页内容看是否包含“亲，请拖动下方滑块完成验证”字样没有就返回内容)</span><br><span class="line">有滑块那么就过滑块 过三次，如果三次不行就自己手动吧</span><br><span class="line">随后获取商品的总页数，并且构造每页的链接</span><br><span class="line">再判断一次验证码 模拟真人操作，拖动滚动条</span><br><span class="line">获取所有数据</span><br></pre></td></tr></tbody></table></figure>





<h2 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h2><h3 id="验证是否有滑块"><a href="#验证是否有滑块" class="headerlink" title="验证是否有滑块:"></a>验证是否有滑块:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validation</span>(<span class="params">self</span>):</span><br><span class="line">	content = self.driver.page_source</span><br><span class="line">	<span class="keyword">if</span> <span class="string">"亲，请拖动下方滑块完成验证"</span> <span class="keyword">in</span> content:</span><br><span class="line">		con = self.hua_kuai()</span><br><span class="line">		count = <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> <span class="string">"亲，请拖动下方滑块完成验证"</span> <span class="keyword">in</span> con <span class="keyword">and</span> count &lt;= <span class="number">3</span>:</span><br><span class="line">			con = self.hua_kuai()</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> count == <span class="number">3</span>:</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"已尽力尝试自动滑动验证码，但抱歉没能通过，请手动滑一下吧~\n"</span>)</span><br><span class="line">                <span class="built_in">input</span>(<span class="string">"手动滑动后，请等待页面“加载完成”，扣1并按回车键继续采集："</span>)</span><br><span class="line">                con = self.driver.page_source</span><br><span class="line">     <span class="keyword">return</span> self.driver</span><br></pre></td></tr></tbody></table></figure>

<h3 id="如何过滑块"><a href="#如何过滑块" class="headerlink" title="如何过滑块:"></a>如何过滑块:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hua_kuai</span>(<span class="params">self</span>):</span><br><span class="line">	ele = self.driver.find_element_by_xpath(<span class="string">'//*[@id="nc_1_n1z"]'</span>)</span><br><span class="line">	<span class="comment">#按住滑块不放</span></span><br><span class="line">	ac(self.driver).click_and_hold(ele).perform()</span><br><span class="line">	<span class="comment">#拖动滑块： xxx需要滑动的大小</span></span><br><span class="line">	ac(self.driver).move_by_offset(<span class="number">300</span>,random.randint(-<span class="number">5</span>,<span class="number">5</span>)).perform()</span><br><span class="line">	<span class="comment"># 松开鼠标</span></span><br><span class="line">	ac(self.driver).release().perform()</span><br><span class="line">	<span class="comment"># 加载页面</span></span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">   <span class="comment"># 点击重新滑动按钮</span></span><br><span class="line">   self.driver.find_element_by_xpath(<span class="string">'//*[@id="`nc_1_refresh1`"]'</span>).click()</span><br><span class="line">   <span class="keyword">except</span>:</span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line">   <span class="keyword">return</span> self.driver.page_source</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段:"></a>初始阶段:</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 访问淘宝网址</span></span><br><span class="line">    self.driver.get(<span class="string">'https://www.taobao.com/'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 停一会防止出意外</span></span><br><span class="line">    <span class="comment"># 向搜索框中添加内容，并按下回车进行搜索</span></span><br><span class="line">    self.driver.find_element_by_xpath(<span class="string">"//input[@aria-label='请输入搜索文字']"</span>).send_keys(self.search_content, Keys.ENTER)</span><br><span class="line">    <span class="comment"># 扫码登陆</span></span><br><span class="line">    self.driver.find_element_by_xpath(<span class="string">'//*[@id="login"]/div[1]/i'</span>).click()</span><br><span class="line">    <span class="comment"># 给20秒时间登陆自己的账号，根据自己的速度来</span></span><br><span class="line">    time.sleep(<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 进入循环获取每页数据信息</span></span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>python逆向基础_翼龙货</title>
    <url>/2022/09/11/python%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80_%E7%BF%BC%E9%BE%99%E8%B4%A7/</url>
    <content><![CDATA[<html><head></head><body><h1 id="python逆向基础-翼龙货"><a href="#python逆向基础-翼龙货" class="headerlink" title="python逆向基础_翼龙货"></a>python逆向基础_翼龙货</h1><p><a href="https://cj.eloancn.com/user/login?service=https://cj.eloancn.com/pcgway/app001/v1/02?ret=aHR0cHM6Ly9jai5lbG9hbmNuLmNvbQ==&amp;v=1662874448066">受害对象</a></p>
<p>常用调试流程:</p>
<p>以下是可以参考的调试流程**(面向新手)**:</p>
<ol>
<li><p>如果网页有跳转，必须勾选 preservelog 防止丢包</p>
</li>
<li><p>看一下有没有框架 右键查看框架源代码(弹出式登陆界面)</p>
</li>
<li><p>登陆尽量使用错误密码 防止跳转</p>
</li>
<li><p>查看关键登陆包 分析哪些参数是加密的</p>
</li>
<li><p>使用别的浏览器分析哪些参数是固定的值</p>
</li>
<li><p>初步猜测加密方法</p>
</li>
<li><p>搜索</p>
</li>
<li><ul>
<li>直接搜索参数</li>
<li>pwd=</li>
<li>pwd =</li>
<li>pwd:</li>
<li>pwd :</li>
<li>密码框地方右键 检查 查看 id name type</li>
</ul>
</li>
<li><p>找到加密的地方**(重点)**</p>
</li>
<li><p>调试</p>
</li>
<li><p>找出所有的加密代码</p>
</li>
<li><ul>
<li>从最后一步开始写起，缺啥找啥</li>
<li>如果找的是函数的话 search 要带上 function xxx</li>
<li>如果看到加密的地方有个类，并且之后是用 prototype 把方法加在原生对象上的话，要把<br>所有加在原生对象上的方法都找出来</li>
<li>函数找多了没关系，只要不报错不会影响结果，但是不能找少了</li>
</ul>
</li>
</ol>
<h2 id="发现加密参数"><a href="#发现加密参数" class="headerlink" title="发现加密参数"></a>发现加密参数</h2><p><img src="https://img1.imgtp.com/2022/09/11/6ct5bxKa.png" alt="image-20220911144554874.png"></p>
<h2 id="寻找password"><a href="#寻找password" class="headerlink" title="寻找password"></a>寻找password</h2><p><img src="https://img1.imgtp.com/2022/09/11/d7j1EPM8.png" alt="image-20220911144631513.png"></p>
<h2 id="打上断点"><a href="#打上断点" class="headerlink" title="打上断点"></a>打上断点</h2><p><img src="https://img1.imgtp.com/2022/09/11/rEmmKrEe.png" alt="image-20220911144808475.png"></p>
<h2 id="扣出一级代码"><a href="#扣出一级代码" class="headerlink" title="扣出一级代码:"></a>扣出一级代码:</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">password: r.PUBLIC.encryptByDES(this.checkPwd.password.trim(), r.PUBLIC.DESkey)</span><br></pre></td></tr></tbody></table></figure>

<p>this.checkPwd.password.trim(), r.PUBLIC.DESkey 这两个参数都是固定的，前面的为密码，后面为一个固定值</p>
<h2 id="进入到函数"><a href="#进入到函数" class="headerlink" title="进入到函数"></a>进入到函数</h2><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">encryptByDES</span>: <span class="keyword">function</span>(<span class="params">t, e</span>) {</span><br><span class="line">            <span class="keyword">var</span> a = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(e);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">var</span> s = <span class="title class_">CryptoJS</span>.<span class="property">DES</span>.<span class="title function_">encrypt</span>(<span class="title class_">String</span>(t), a, {</span><br><span class="line">                    <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>,</span><br><span class="line">                    <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">                })</span><br><span class="line">            } <span class="keyword">catch</span> (t) {</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(t)</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> s.<span class="title function_">toString</span>()</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="CryptoJS"><a href="#CryptoJS" class="headerlink" title="CryptoJS"></a>CryptoJS</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">把鼠标放到CryptoJS.DES.encrypt这个上面跳转到一个页面，把里面的js全部拷贝出来</span><br></pre></td></tr></tbody></table></figure>



<h2 id="CryptoJS-mode-ECB"><a href="#CryptoJS-mode-ECB" class="headerlink" title="CryptoJS.mode.ECB"></a>CryptoJS.mode.ECB</h2><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">var</span> a = <span class="title class_">CryptoJS</span>.<span class="property">lib</span>.<span class="property">BlockCipherMode</span>.<span class="title function_">extend</span>();</span><br><span class="line">    a.<span class="property">Encryptor</span> = a.<span class="title function_">extend</span>({</span><br><span class="line">        <span class="attr">processBlock</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) {</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_cipher</span>.<span class="title function_">encryptBlock</span>(a, b)</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    a.<span class="property">Decryptor</span> = a.<span class="title function_">extend</span>({</span><br><span class="line">        <span class="attr">processBlock</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) {</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_cipher</span>.<span class="title function_">decryptBlock</span>(a, b)</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">}();</span><br></pre></td></tr></tbody></table></figure>

<p>整体代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">这就不写了 太多</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Python实现加密方法合集"><a href="#Python实现加密方法合集" class="headerlink" title="Python实现加密方法合集"></a>Python实现加密方法合集</h4><p>其实上面的步骤不一定都要去手动扣JS, 我们的大Python已经为我们造好了轮子,如果可以判断js的加密没有做其他的更改,我们就可以使用造好的轮子直接实现对应的加密。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding：utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> pyDes <span class="keyword">import</span> des, CBC, PAD_PKCS5</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES3</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USE_AES</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    AES</span></span><br><span class="line"><span class="string">    除了MODE_SIV模式key长度为：32, 48, or 64,</span></span><br><span class="line"><span class="string">    其余key长度为16, 24 or 32</span></span><br><span class="line"><span class="string">    详细见AES内部文档</span></span><br><span class="line"><span class="string">    CBC模式传入iv参数</span></span><br><span class="line"><span class="string">    本例使用常用的ECB模式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(key) &gt; <span class="number">32</span>:</span><br><span class="line">            key = key[:<span class="number">32</span>]</span><br><span class="line">        self.key = self.to_16(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_16</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        转为16倍数的bytes数据</span></span><br><span class="line"><span class="string">        :param key:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        key = <span class="built_in">bytes</span>(key, encoding=<span class="string">"utf8"</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(key) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            key += <span class="string">b'\0'</span></span><br><span class="line">        <span class="keyword">return</span> key  <span class="comment"># 返回bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">aes</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> AES.new(self.key, AES.MODE_ECB) <span class="comment"># 初始化加密器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, text</span>):</span><br><span class="line">        aes = self.aes()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(base64.encodebytes(aes.encrypt(self.to_16(text))),</span><br><span class="line">                   encoding=<span class="string">'utf8'</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>)  <span class="comment"># 加密</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodebytes</span>(<span class="params">self, text</span>):</span><br><span class="line">        aes = self.aes()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(aes.decrypt(base64.decodebytes(<span class="built_in">bytes</span>(</span><br><span class="line">            text, encoding=<span class="string">'utf8'</span>))).rstrip(<span class="string">b'\0'</span>).decode(<span class="string">"utf8"</span>))  <span class="comment"># 解密</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USE_RSA</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成密钥可保存.pem格式文件</span></span><br><span class="line"><span class="string">    1024位的证书，加密时最大支持117个字节，解密时为128；</span></span><br><span class="line"><span class="string">    2048位的证书，加密时最大支持245个字节，解密时为256。</span></span><br><span class="line"><span class="string">    加密大文件时需要先用AES或者DES加密，再用RSA加密密钥，详细见文档</span></span><br><span class="line"><span class="string">    文档:https://stuvel.eu/files/python-rsa-doc/usage.html#generating-keys</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, number=<span class="number">1024</span></span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param number: 公钥、私钥</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.pubkey, self.privkey = rsa.newkeys(number)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rsaEncrypt</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param test: str</span></span><br><span class="line"><span class="string">        :return: bytes</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        content = text.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        crypto = rsa.encrypt(content, self.pubkey)</span><br><span class="line">        <span class="keyword">return</span> crypto</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rsaDecrypt</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param text:bytes</span></span><br><span class="line"><span class="string">        :return: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        content = rsa.decrypt(text, self.privkey)</span><br><span class="line">        con = content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">return</span> con</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">savePem</span>(<span class="params">self, path_name, text</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param path_name: 保存路径</span></span><br><span class="line"><span class="string">        :param text: str</span></span><br><span class="line"><span class="string">        :return:bytes</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"PEM"</span> <span class="keyword">in</span> path_name.upper():</span><br><span class="line">            path_name = path_name[:-<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'{}.pem'</span>.<span class="built_in">format</span>(path_name), <span class="string">'bw'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(text.save_pkcs1())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readPem</span>(<span class="params">self, path_name, key_type</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param path_name: 密钥文件</span></span><br><span class="line"><span class="string">        :param key_type:类型</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'pubkey'</span> <span class="keyword">in</span> key_type:</span><br><span class="line">            self.pubkey = rsa.PublicKey.load_pkcs1(path_name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.privkey = rsa.PublicKey.load_pkcs1(path_name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, message, priv_key=<span class="literal">None</span>, hash_method=<span class="string">'SHA-1'</span></span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        生成明文的哈希签名以便还原后对照</span></span><br><span class="line"><span class="string">        :param message: str</span></span><br><span class="line"><span class="string">        :param priv_key:</span></span><br><span class="line"><span class="string">        :param hash_method: 哈希的模式</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="literal">None</span> == priv_key:</span><br><span class="line">            priv_key = self.privkey</span><br><span class="line">        <span class="keyword">return</span> rsa.sign(message.encode(), priv_key, hash_method)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkSign</span>(<span class="params">self, mess, result, pubkey=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        验证签名：传入解密后明文、签名、公钥，验证成功返回哈希方法，失败则报错</span></span><br><span class="line"><span class="string">        :param mess: str</span></span><br><span class="line"><span class="string">        :param result: bytes</span></span><br><span class="line"><span class="string">        :param pubkey:</span></span><br><span class="line"><span class="string">        :return: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="literal">None</span> == pubkey:</span><br><span class="line">            pubkey = self.privkey</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = rsa.verify(mess, result, pubkey)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USE_DES</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    des(key,[mode], [IV], [pad], [pad mode])</span></span><br><span class="line"><span class="string">    key:必须正好8字节</span></span><br><span class="line"><span class="string">    mode（模式）：ECB、CBC</span></span><br><span class="line"><span class="string">    iv:CBC模式中必须提供长8字节</span></span><br><span class="line"><span class="string">    pad:填充字符</span></span><br><span class="line"><span class="string">    padmode:加密填充模式PAD_NORMAL or PAD_PKCS5</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, iv</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(key, <span class="built_in">bytes</span>):</span><br><span class="line">            key = <span class="built_in">bytes</span>(key, encoding=<span class="string">"utf8"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(iv, <span class="built_in">bytes</span>):</span><br><span class="line">            iv = <span class="built_in">bytes</span>(iv, encoding=<span class="string">"utf8"</span>)</span><br><span class="line">        self.key = key</span><br><span class="line">        self.iv = iv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        DES 加密</span></span><br><span class="line"><span class="string">        :param text: 原始字符串</span></span><br><span class="line"><span class="string">        :return: 加密后字符串，bytes</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(text, <span class="built_in">bytes</span>):</span><br><span class="line">            text = <span class="built_in">bytes</span>(text, <span class="string">"utf-8"</span>)</span><br><span class="line">        secret_key = self.key</span><br><span class="line">        iv = self.iv</span><br><span class="line">        k = des(secret_key, CBC, iv, pad=<span class="literal">None</span>, padmode=PAD_PKCS5)</span><br><span class="line">        en = k.encrypt(text, padmode=PAD_PKCS5)</span><br><span class="line">        <span class="keyword">return</span> en</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">descrypt</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        DES 解密</span></span><br><span class="line"><span class="string">        :param text: 加密后的字符串，bytes</span></span><br><span class="line"><span class="string">        :return:  解密后的字符串</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        secret_key = self.key</span><br><span class="line">        iv = self.iv</span><br><span class="line">        k = des(secret_key, CBC, iv, pad=<span class="literal">None</span>, padmode=PAD_PKCS5)</span><br><span class="line">        de = k.decrypt(text, padmode=PAD_PKCS5)</span><br><span class="line">        <span class="keyword">return</span> de.decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USE_DES3</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    new(key, mode, *args, **kwargs)</span></span><br><span class="line"><span class="string">    key:必须8bytes倍数介于16-24</span></span><br><span class="line"><span class="string">    mode：</span></span><br><span class="line"><span class="string">    iv:初始化向量适用于MODE_CBC、MODE_CFB、MODE_OFB、MODE_OPENPGP，4种模式</span></span><br><span class="line"><span class="string">        ``MODE_CBC``, ``MODE_CFB``, and ``MODE_OFB``长度为8bytes</span></span><br><span class="line"><span class="string">        ```MODE_OPENPGP```加密时8bytes解密时10bytes</span></span><br><span class="line"><span class="string">        未提供默认随机生成</span></span><br><span class="line"><span class="string">    nonce：仅在 ``MODE_EAX`` and ``MODE_CTR``模式中使用</span></span><br><span class="line"><span class="string">            ``MODE_EAX``建议16bytes</span></span><br><span class="line"><span class="string">            ``MODE_CTR``建议[0, 7]长度</span></span><br><span class="line"><span class="string">            未提供则随机生成</span></span><br><span class="line"><span class="string">    segment_size：分段大小，仅在 ``MODE_CFB``模式中使用，长度为8倍数，未指定则默认为8</span></span><br><span class="line"><span class="string">    mac_len：适用``MODE_EAX``模式，身份验证标记的长度（字节），它不能超过8（默认值）</span></span><br><span class="line"><span class="string">    initial_value：适用```MODE_CTR```，计数器的初始值计数器块。默认为**0**。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.mode = DES3.MODE_ECB</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        传入明文</span></span><br><span class="line"><span class="string">        :param text:bytes类型，长度是KEY的倍数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(text, <span class="built_in">bytes</span>):</span><br><span class="line">            text = <span class="built_in">bytes</span>(text, <span class="string">'utf-8'</span>)</span><br><span class="line">        x = <span class="built_in">len</span>(text) % <span class="number">8</span></span><br><span class="line">        text = text+<span class="string">b'\0'</span>*x</span><br><span class="line">        cryptor = DES3.new(self.key, self.mode)</span><br><span class="line">        ciphertext = cryptor.encrypt(text)</span><br><span class="line">        <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, text</span>):</span><br><span class="line">        cryptor = DES3.new(self.key, self.mode)</span><br><span class="line">        plain_text = cryptor.decrypt(text)</span><br><span class="line">        st = <span class="built_in">str</span>(plain_text.decode(<span class="string">"utf-8"</span>)).rstrip(<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> st</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">USE_MD5</span>(<span class="params">test</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(test, <span class="built_in">bytes</span>):</span><br><span class="line">        test = <span class="built_in">bytes</span>(test, <span class="string">'utf-8'</span>)</span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    m.update(test)</span><br><span class="line">    <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">USE_HMAC</span>(<span class="params">key, text</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(key, <span class="built_in">bytes</span>):</span><br><span class="line">        key = <span class="built_in">bytes</span>(key, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(text, <span class="built_in">bytes</span>):</span><br><span class="line">        text = <span class="built_in">bytes</span>(text, <span class="string">'utf-8'</span>)</span><br><span class="line">    h = hmac.new(key, text, digestmod=<span class="string">'MD5'</span>)</span><br><span class="line">    <span class="keyword">return</span> h.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">USE_SHA</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(text, <span class="built_in">bytes</span>):</span><br><span class="line">        text = <span class="built_in">bytes</span>(text, <span class="string">'utf-8'</span>)</span><br><span class="line">    sha = hashlib.sha1(text)</span><br><span class="line">    encrypts = sha.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> encrypts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    aes_test = USE_AES(<span class="string">"assssssssdfasasasasa"</span>)</span><br><span class="line">    a = aes_test.encrypt(<span class="string">"测试"</span>)</span><br><span class="line">    b = aes_test.decodebytes(a)</span><br><span class="line">    rsa_test = USE_RSA()</span><br><span class="line">    a = rsa_test.rsaEncrypt(<span class="string">"测试加密"</span>)</span><br><span class="line">    b = rsa_test.rsaDecrypt(a)</span><br><span class="line">    des_test = USE_DES(<span class="string">b"12345678"</span>, <span class="string">b"12345678"</span>)</span><br><span class="line">    a = des_test.encrypt(<span class="string">"测试加密"</span>)</span><br><span class="line">    b = des_test.descrypt(a)</span><br><span class="line">    des3_test = USE_DES3(<span class="string">b"123456789qazxswe"</span>)</span><br><span class="line">    a = des3_test.encrypt(<span class="string">"测试加密"</span>)</span><br><span class="line">    b = des3_test.decrypt(a)</span><br><span class="line">    md5_test = USE_MD5(<span class="string">"测试签名"</span>)</span><br><span class="line">    hmac_test = USE_HMAC(<span class="string">"123456"</span>, <span class="string">"测试"</span>)</span><br><span class="line">    sha_test = USE_SHA(<span class="string">"测试加密"</span>)</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>python逆向_常见混淆</title>
    <url>/2022/09/12/python%E9%80%86%E5%90%91_%E5%B8%B8%E8%A7%81%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[<html><head></head><body><h1 id="python逆向-常见混淆"><a href="#python逆向-常见混淆" class="headerlink" title="python逆向_常见混淆"></a>python逆向_常见混淆</h1><h2 id="eval加密"><a href="#eval加密" class="headerlink" title="eval加密"></a>eval加密</h2><p>把一段字符串当做js代码去执行</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1eval(function(){alert(100);return 200})()</span><br></pre></td></tr></tbody></table></figure>

<p>例子: 漫画柜,空中网 之后会单独写一篇漫画柜的解密。</p>
<h2 id="变量名混淆"><a href="#变量名混淆" class="headerlink" title="变量名混淆"></a>变量名混淆</h2><ol>
<li>把变量名、函数名、参数名等，替换成没有语义，看着又很像的名字。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">_0x21dd83、_0x21dd84、_0x21dd85</span><br></pre></td></tr></tbody></table></figure>

<p>​	2.用十六进制文本去表示一个字符串</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">\x56\x49\x12\x23</span><br></pre></td></tr></tbody></table></figure>

<p>​    3.利用JS能识别的编码来做混淆<br>JS是Unicode编码，本身就能识别这种编码。类似的一些变量名，函数名都可以用这个表示，并且调用。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> 类似:</span><br><span class="line"> </span><br><span class="line"> \u6210\u529f表示中文字符(成功)。</span><br><span class="line"> </span><br><span class="line"> 类似:</span><br><span class="line"> </span><br><span class="line"> \u0053\u0074\u0072\u0069\u006e\u0067.\u0066\u0072\u006f\u006d\u0043\u0068\u0061\u0072\u0043\u006f\u0064\u0065就代表String.fromCharCode</span><br><span class="line"> </span><br><span class="line"> 类似:</span><br><span class="line"></span><br><span class="line">('')['\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72']['\x66\x72\x6f\x6d\x43\x68\x61\x72\x43\x6f\x64\x65'];效果等同于String.fromCharCode</span><br></pre></td></tr></tbody></table></figure>

<p>​	4.把一大堆方法名、字符串等存到数组中，这个数组可以是上千个成员。然后调用的时候，取数组成员去用</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var arr = ["Date","getTime"];</span><br><span class="line">var time = new window[arr[0]]()[arr[1]]();</span><br><span class="line">console.log(time);</span><br></pre></td></tr></tbody></table></figure>

<p>​	5.字符串加密后发送到前端，然后前端调用对应的函数去解密，得到明文</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var arr = ['xxxx']</span><br><span class="line"></span><br><span class="line">// 定义的解密函数</span><br><span class="line">function dec(str){</span><br><span class="line">  return 'push'</span><br><span class="line">}</span><br><span class="line">test[dec(arr[0])](200);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a>控制流平坦化</h2><p>将顺序执行的代码混淆成乱序执行,并加以混淆</p>
<p>以下两段代码的执行结果是相同的:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> // 正常形态</span><br><span class="line">function test(a){</span><br><span class="line">   var b = a;</span><br><span class="line">   b += 1;</span><br><span class="line">   b += 2;</span><br><span class="line">   b += 3;</span><br><span class="line">   b += 4;</span><br><span class="line">   return a + b</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">// 乱序形态</span><br><span class="line">//（这里比较简单,在很多加密网站上case 后面往往不是数字或字符串,而是类似 YFp[15][45][4]这样的对象，相当恶心）</span><br><span class="line">function test1(a){</span><br><span class="line">  var arr = [1,2,3,4,5,6]</span><br><span class="line">  for(var i = 0, i &lt; arr.lenght, i++){</span><br><span class="line">    switch (arr[i]) {</span><br><span class="line">     case 4:</span><br><span class="line">        b += 3;</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        b += 1;</span><br><span class="line">      break;</span><br><span class="line">      case 1:</span><br><span class="line">        var b = a;</span><br><span class="line">      break;</span><br><span class="line">      case 3:</span><br><span class="line">        b += 2;</span><br><span class="line">      break;</span><br><span class="line">      case 6:</span><br><span class="line">        return a + b</span><br><span class="line">      case 5:</span><br><span class="line">        b += 4;</span><br><span class="line">      break;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">// 结果都是30 但是test1看着费劲</span><br><span class="line">console.log(test1(10));</span><br><span class="line">console.log(test(10));</span><br></pre></td></tr></tbody></table></figure>

<h2 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h2><p>把多行代码压缩成一行</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">function test(a){</span><br><span class="line">   var b = a;</span><br><span class="line">   var c = b + 1;</span><br><span class="line">   var d = b + 2;</span><br><span class="line">   var e = b + 3;</span><br><span class="line">   var f = b + 4;</span><br><span class="line">   return e + f</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line">// 压缩一下</span><br><span class="line">function test1(a){</span><br><span class="line">  var b,c,d,e,f</span><br><span class="line">  return f = (e = (d = ( c = (b = a,b + 1),b + 2),b + 3),b + 4),e + f</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
</search>
