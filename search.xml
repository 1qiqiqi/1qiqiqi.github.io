<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker容器命令</title>
    <url>/2022/07/07/Docker%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker容器命令"><a href="#Docker容器命令" class="headerlink" title="Docker容器命令"></a>Docker容器命令</h1><h3 id="Docker将镜像转为容器"><a href="#Docker将镜像转为容器" class="headerlink" title="Docker将镜像转为容器"></a>Docker将镜像转为容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>



<h3 id="查看docker容器状态"><a href="#查看docker容器状态" class="headerlink" title="查看docker容器状态"></a>查看docker容器状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs 容器名称</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像命令</title>
    <url>/2022/07/07/Docker%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker常用镜像命令"><a href="#Docker常用镜像命令" class="headerlink" title="Docker常用镜像命令"></a>Docker常用镜像命令</h1><p>这些是最基本的Docker镜像命令，也是最有用的</p>
<h3 id="镜像名组成"><a href="#镜像名组成" class="headerlink" title="镜像名组成"></a>镜像名组成</h3><p>name:tags tags指版本号 列如：mysql:5.3</p>
<h3 id="systemctl-start-docker"><a href="#systemctl-start-docker" class="headerlink" title="systemctl start docker"></a>systemctl start docker</h3><p>开启docker 的作用</p>
<h3 id="systemctl-status-docker"><a href="#systemctl-status-docker" class="headerlink" title="systemctl status docker"></a>systemctl status docker</h3><p>查看docker的状态 是运行还是dead</p>
<h3 id="systemctl-stop-docker"><a href="#systemctl-stop-docker" class="headerlink" title="systemctl stop docker"></a>systemctl stop docker</h3><p>关闭docker</p>
<h3 id="docker-pull-镜像名"><a href="#docker-pull-镜像名" class="headerlink" title="docker pull 镜像名"></a>docker pull 镜像名</h3><p>(从Dockerhub官网上面找列如nginx,如果不指定版本 那么就是最新的版本 latest)</p>
<h3 id="docker-save-o-镜像名-tar"><a href="#docker-save-o-镜像名-tar" class="headerlink" title="docker save -o 镜像名.tar"></a>docker save -o 镜像名.tar</h3><p>将镜像打包成一个压缩包</p>
<h3 id="docker-load-i-镜像名-tar"><a href="#docker-load-i-镜像名-tar" class="headerlink" title="docker load -i 镜像名.tar"></a>docker load -i 镜像名.tar</h3><p>将压缩包解压为一个镜像</p>
<h3 id="docker-rmi-镜像名或者镜像ID"><a href="#docker-rmi-镜像名或者镜像ID" class="headerlink" title="docker rmi 镜像名或者镜像ID"></a>docker rmi 镜像名或者镜像ID</h3><p>删除镜像</p>
<h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>查看镜像</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux目录结构</title>
    <url>/2022/08/10/Liunx%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><p>登录到Linux系统之后，我们需要先来熟悉一下Linux的目录结构。在Linux系统中，也是存在目录的</p>
<p>概念的，但是Linux的目录结构和Windows的目录结构是存在比较多的差异的 在Windows目录下，是</p>
<p>一个一个的盘符(C盘、D盘、E盘)，目录是归属于某一个盘符的。Linux系统中的目录有以下特点：</p>
<p><strong>A. &#x2F;</strong> <strong>是所有目录的顶点</strong></p>
<p><strong>B.</strong> <strong>目录结构像一颗倒挂的树</strong></p>
<p><strong>Linux</strong> <strong>和</strong> <strong>Windows**<strong>的目录结构对比</strong></strong>:**</p>
<p><img src="https://s2.loli.net/2022/08/10/TABI8jumZ2NLQyU.png" alt="Snipaste_2022-08-10_16-32-19.png"></p>
<p>linux目录如下：</p>
<p><img src="https://s2.loli.net/2022/08/10/ndclbBogFMRDLAS.png" alt="image-20220810164434267"></p>
<p><img src="https://s2.loli.net/2022/08/10/z7uIxCRnGjrE86L.png" alt="image-20220810164702276"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux软件安装</title>
    <url>/2022/08/10/Liunx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Linux软件安装"><a href="#Linux软件安装" class="headerlink" title="Linux软件安装"></a>Linux软件安装</h2><h3 id="软件安装方式"><a href="#软件安装方式" class="headerlink" title="软件安装方式"></a>软件安装方式</h3><p><img src="C:\Users\13772\Desktop\img\image-20220810223414152.png" alt="image-20220810223414152"></p>
<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>上述我们介绍了Linux系统软件安装的四种形式，接下来我们就通过第一种(二进制发布包)形式来安装</p>
<p>JDK。 JDK对应的二进制发布包，在课程资料中已经提供，如下：JDK具体安装步骤如下：</p>
<p><strong>1).</strong> <strong>上传安装包</strong></p>
<p>使用FinalShell自带的上传工具将jdk的二进制发布包上传到Linux</p>
<p>由于上述在进行文件上传时，选择的上传目录为根目录 &#x2F;，上传完毕后，我们执行指令 cd &#x2F; 切换到</p>
<p>根目录下，查看上传的安装包。</p>
<p><img src="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20220810223814390.png" alt="image-20220810223814390"></p>
<p><strong>2).</strong> <strong>解压安装包</strong></p>
<p>执行如下指令，将上传上来的压缩包进行解压，并通过-C参数指定解压文件存放目录为</p>
<p>&#x2F;usr&#x2F;local。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure>

<p><strong>3).</strong> <strong>配置环境变量</strong></p>
<p>使用vim命令修改&#x2F;etc&#x2F;profile文件，在文件末尾加入如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_171 </span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>1具体操作指令如下:</p>
<p>1). 编辑&#x2F;etc&#x2F;profile文件，进入命令模式 </p>
<p>vim &#x2F;etc&#x2F;profile </p>
<p>2). 在命令模式中，输入指令 G ， 切换到文件最后 </p>
<p>G </p>
<p>3). 在命令模式中输入 i&#x2F;a&#x2F;o 进入插入模式，然后切换到文件最后一行 </p>
<p>i </p>
<p>4). 将上述的配置拷贝到文件中 </p>
<p>JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_171 </p>
<p>PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH </p>
<p>5). 从插入模式，切换到指令模式 </p>
<p>ESC </p>
<p>6). 按:进入底行模式，然后输入wq，回车保存 </p>
<p>:wq </p>
<p><strong>4).</strong> <strong>重新加载<strong><strong>profile</strong></strong>文件</strong></p>
<p>为了使更改的配置立即生效，需要重新加载profile文件，执行命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p><strong>5).</strong> <strong>检查安装是否成功</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a><strong>安装</strong>Tomcat</h2><h3 id="1-3-1-Tomcat安装"><a href="#1-3-1-Tomcat安装" class="headerlink" title="1.3.1 Tomcat安装"></a>1.3.1 Tomcat安装</h3><p>Tomcat的安装和上述JDK的安装采用相同的方式，都是使用二进制发布包的形式进行安装，在我们的</p>
<p>资料目录下，也已经准备了Tomcat的安装包：</p>
<p>具体安装步骤如下：</p>
<p><strong>1).</strong> <strong>上传安装包</strong></p>
<p>使用FinalShell自带的上传工具将Tomcat的二进制发布包上传到Linux(与前面上传JDK安装包步骤</p>
<p>一致)。</p>
<p><strong>2).</strong> <strong>解压安装包</strong></p>
<p>将上传上来的安装包解压到指定目录&#x2F;usr&#x2F;local下，执行命令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-7.0.57.tar.gz -C /usr/local </span><br></pre></td></tr></table></figure>

<h5 id="3-启动Tomcat"><a href="#3-启动Tomcat" class="headerlink" title="3). 启动Tomcat"></a><strong>3).</strong> 启动Tomcat</h5><p>进入Tomcat的bin目录启动服务。执行命令为: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/apache-tomcat-7.0.57/ </span><br><span class="line"></span><br><span class="line">cd bin </span><br><span class="line"></span><br><span class="line">sh startup.sh或者./startup.sh </span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-Tomcat进程查看"><a href="#1-3-2-Tomcat进程查看" class="headerlink" title="1.3.2 Tomcat进程查看"></a>1.3.2 Tomcat进程查看</h3><p>上述我们将Tomcat启动完成之后，并不能知道Tomcat是否正常运行，那么我们验证Tomcat启动是否</p>
<p>成功，有多种方式，我们这里主要介绍常见的两种方式：</p>
<p><strong>1).</strong> <strong>查看启动日志</strong></p>
<p>Tomcat的启动日志输出在Tomcat的安装目录下的logs目录中，Tomcat的启动及运行日志文件名为</p>
<p>catalina.out，所以我们查看Tomcat启动日志，主要可以通过两条指令，如下：</p>
<p>只要Tomcat在启动的过程中，日志输出没有报错，基本可以判定Tomcat启动成功了。</p>
<p>1). 分页查询Tomcat的日志信息 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more /usr/local/apache-tomcat-7.0.57/logs/catalina.out </span><br></pre></td></tr></table></figure>

<p>2). 查询日志文件尾部的50行记录 </p>
<p>tail -50 &#x2F;usr&#x2F;local&#x2F;apache-tomcat-7.0.57&#x2F;logs&#x2F;catalina.out </p>
<p><strong>2).</strong> <strong>查询系统进程</strong></p>
<p>我们也可以通过Linux系统的查看系统进程的指令，来判定Tomcat进程是否存在，从而判定Tomcat是</p>
<p>否启动。执行如下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef|grep tomcat </span><br></pre></td></tr></table></figure>

<p><strong>ps</strong> 命令是linux下非常强大的进程查看命令，通过ps -ef可以查看当前运行的所有进程的详细</p>
<p>信息</p>
<p><strong>“|”</strong> 在Linux中称为管道符，可以将前一个命令的结果输出给后一个命令作为输入</p>
<p>使用ps命令查看进程时，经常配合管道符和查找命令 grep 一起使用，来查看特定进程</p>
<p><strong>1.3.3</strong> <strong>防火墙操作</strong></p>
<p>前面我们已经通过日志的方式及查看系统进程的方式，验证了Tomcat服务已经正常启动，接下来我们</p>
<p>就可以尝试访问一下。访问地址：<strong><a href="http://192.168.138.130:8080/">http://192.168.138.130:8080</a></strong>，我们发现是访问不到的。</p>
<p>那为什么tomcat启动成功了，但就是访问不到呢？原因就在于Linux系统的防火墙，系统安装完毕</p>
<p>后，系统启动时，防火墙自动启动，防火墙拦截了所有端口的访问。接下来我们就需要学习一下，如何</p>
<p>操作防火墙，具体指令如下：</p>
<p><img src="C:\Users\13772\Desktop\img\image-20220810225507945.png" alt="image-20220810225507945"></p>
<p>那么我们要想访问到Tomcat，就可以采取两种类型的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<p>关闭之后，再次访问Tomcat，就可以访问到了。</p>
<p>systemctl stop firewalld </p>
<p>1注意: 上面我们也提到了，直接关闭系统的防火墙，是不建议的，因为这样会造成系统不安全。</p>
<p><strong>B.</strong> 开放Tomcat的端口号8080</p>
<p>执行指令:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">①. 先开启系统防火墙 systemctl start firewalld </span><br><span class="line">②. 再开放<span class="number">8080</span>端口号 firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">8080</span>/tcp --permanent </span><br><span class="line">③. 重新加载防火墙 firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>执行上述的操作之后，就开放了当前系统中的8080端口号，再次访问Tomcat。</p>
<h5 id="1-3-4停止Tomcat"><a href="#1-3-4停止Tomcat" class="headerlink" title="1.3.4停止Tomcat"></a>1.3.4停止Tomcat</h5><p>在Linux系统中，停止Tomcat服务的方式主要有两种：</p>
<p><strong>1).</strong> 运行Tomcat提供的脚本文件</p>
<p>在Tomcat安装目录下有一个bin目录，这个目录中存放的是tomcat的运行脚本文件，其中有一个脚本</p>
<p>就是用于停止tomcat服务的。</p>
<p>我们可以切换到bin目录，并执行如下指令，来停止Tomcat服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh shutdown.sh</span><br><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure>

<h5 id="2-结束Tomcat进程"><a href="#2-结束Tomcat进程" class="headerlink" title="2). 结束Tomcat进程"></a><strong>2).</strong> 结束Tomcat进程</h5><p>我们可以先通过 ps -ef|grep tomcat 指令查看tomcat进程的信息，从进程信息中获取tomcat</p>
<p>服务的进程号。然后通过kill -9 的形式，来杀死系统进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 79947</span><br></pre></td></tr></table></figure>

<h2 id="1-4-安装MySQL"><a href="#1-4-安装MySQL" class="headerlink" title="1.4 安装MySQL"></a>1.4 安装MySQL</h2><p><strong>1.4.1 MySQL****安装</strong></p>
<p>对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了</p>
<p>解一下什么rpm？</p>
<p><strong>RPM****：</strong>全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安</p>
<p>装软件的工具。</p>
<p>我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下：</p>
<p><strong>1).</strong> <strong>检测当前系统是否安装过<strong><strong>MySQL</strong></strong>相关数据库</strong></p>
<p>需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa 查询当前系统中安装的所有软件 </span><br><span class="line">rpm -qa | grep mysql 查询当前系统中安装的名称带mysql的软件 </span><br><span class="line">rpm -qa | grep mariadb 查询当前系统中安装的名称带mariadb的软件</span><br></pre></td></tr></table></figure>

<p><strong>2).</strong> <strong>卸载现有的<strong><strong>MySQL</strong></strong>数据库</strong></p>
<p>在rpm中，卸载软件的语法为</p>
<p>那么，我们就可以通过指令，卸载 mariadb，具体指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\13772\Desktop\img\image-20220810231126992.png" alt="image-20220810231126992"></p>
<p>我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Liunx上传文件报错原因</title>
    <url>/2022/08/10/Liunx%E4%B8%8A%E4%BC%A0%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h2 id="Liunx上传文件报错原因"><a href="#Liunx上传文件报错原因" class="headerlink" title="Liunx上传文件报错原因"></a>Liunx上传文件报错原因</h2><p>今天在上传JDK8的时候报错了，原因竟然是SSH连接的用户名必须为root才能上传</p>
<p><img src="https://s2.loli.net/2022/08/10/6bLJNWmunwCz2tc.png" alt="image-20220810183742904"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Liunx项目部署</title>
    <url>/2022/08/11/Liunx%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="Liunx项目部署"><a href="#Liunx项目部署" class="headerlink" title="Liunx项目部署"></a>Liunx项目部署</h2><h3 id="手动部署项目"><a href="#手动部署项目" class="headerlink" title="手动部署项目"></a>手动部署项目</h3><h5 id="1-在IDEA中开发Springboot并且打jar包"><a href="#1-在IDEA中开发Springboot并且打jar包" class="headerlink" title="1). 在IDEA中开发Springboot并且打jar包"></a><strong>1).</strong> 在IDEA中开发Springboot并且打jar包</h5><p><img src="https://s2.loli.net/2022/08/11/pVD91TygAXvkIHY.png" alt="image-20220811185344874"></p>
<h5 id="2-将jar包上传到Liunx服务器"><a href="#2-将jar包上传到Liunx服务器" class="headerlink" title="2). 将jar包上传到Liunx服务器"></a><strong>2).</strong> 将jar包上传到Liunx服务器</h5><p>通过 rz 指令，将打好的jar包上传至Linux服务器的 &#x2F;usr&#x2F;local&#x2F;app 目录下。 先执行指令创</p>
<p>建app目录</p>
<h5 id="3-启动Springboot程序"><a href="#3-启动Springboot程序" class="headerlink" title="3). 启动Springboot程序"></a><strong>3).</strong> 启动Springboot程序</h5><p>由于我们的项目已经打成jar包上传上来到Linux服务器，我们只需要运行这个jar包项目就启动起来</p>
<p>了，所以只需要执行如下指令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar helloworld-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<h5 id="4-检查防火墙，确保8080端口没有被防火墙给端掉"><a href="#4-检查防火墙，确保8080端口没有被防火墙给端掉" class="headerlink" title="4). 检查防火墙，确保8080端口没有被防火墙给端掉"></a><strong>4).</strong> 检查防火墙，确保8080端口没有被防火墙给端掉</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<p>如果防火墙没有放开8080端口，还需要放开对应的端口号，执行如下指令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure>

<h5 id="5-访问测试"><a href="#5-访问测试" class="headerlink" title="5). 访问测试"></a><strong>5).</strong> 访问测试</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.166.130:8087/backend/page/login/login.html</span><br></pre></td></tr></table></figure>

<h5 id="6-后台运行项目"><a href="#6-后台运行项目" class="headerlink" title="6). 后台运行项目"></a><strong>6).</strong> 后台运行项目</h5><p>当前这个demo工程我们已经部署成功了，并且我们也可以访问项目了。但是这个工程目前是存在问题</p>
<p>的，就是当前我们项目启动的这个窗口被霸屏占用了，如果我们把这个窗口关闭掉(或ctrl+c)，当前</p>
<p>服务也就访问不到了，我们可以试一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar helloworld-1.0-SNAPSHOT.jar &amp;&gt; hello.log &amp;</span><br></pre></td></tr></table></figure>

<h2 id="基于Shell脚本自动部署"><a href="#基于Shell脚本自动部署" class="headerlink" title="基于Shell脚本自动部署"></a>基于Shell脚本自动部署</h2><p>这个搞一下午了还没搞好，</p>
<p>如何在使用git的时候不用重复输入账号和密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper stor</span><br></pre></td></tr></table></figure>

<p>输入上面的命令</p>
<p>以上命令会在当前linux机器的 &#x2F;home&#x2F;用户名 下新建一个.git-credentials的隐藏文件，把用户名和密码写入这个文件</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓7.0以上添加Fiddler证书到系统根证书</title>
    <url>/2022/07/31/OpenSSL%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="安卓7-0以上添加Fiddler证书到系统根证书（模拟器）"><a href="#安卓7-0以上添加Fiddler证书到系统根证书（模拟器）" class="headerlink" title="安卓7.0以上添加Fiddler证书到系统根证书（模拟器）"></a>安卓7.0以上添加Fiddler证书到系统根证书（模拟器）</h1><p><a href="https://null119.lanzoul.com/iewv205n22ad">安装链接</a></p>
<h2 id="1、cer证书转pem"><a href="#1、cer证书转pem" class="headerlink" title="1、cer证书转pem"></a>1、cer证书转pem</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform der -in FiddlerRoot.cer的目录 -out 同层目录/Fiddler.pem</span><br></pre></td></tr></table></figure>

<h2 id="2、获取pem证书hash"><a href="#2、获取pem证书hash" class="headerlink" title="2、获取pem证书hash"></a>2、获取pem证书hash</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -in Fiddler.pem</span><br></pre></td></tr></table></figure>

<h3 id="3、将pem证书改名为hash-0"><a href="#3、将pem证书改名为hash-0" class="headerlink" title="3、将pem证书改名为hash.0"></a>3、将pem证书改名为hash.0</h3><h3 id="4、将证书上传到手机或模拟器"><a href="#4、将证书上传到手机或模拟器" class="headerlink" title="4、将证书上传到手机或模拟器"></a>4、将证书上传到手机或模拟器</h3><p><img src="https://s2.loli.net/2022/07/31/qwbx3ZUteK4ASr8.png" alt="Snipaste_2022-07-31_15-15-25.png"></p>
]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>SMMS照片下载至压缩包</title>
    <url>/2022/08/02/SMMS%E7%85%A7%E7%89%87%E4%B8%8B%E8%BD%BD%E8%87%B3%E5%8E%8B%E7%BC%A9%E5%8C%85/</url>
    <content><![CDATA[<h1 id="SMMS照片下载至压缩包"><a href="#SMMS照片下载至压缩包" class="headerlink" title="SMMS照片下载至压缩包"></a>SMMS照片下载至压缩包</h1><p>进入下面的地址</p>
<p><img src="https://s2.loli.net/2022/08/02/TgvbkMdXDUpWPqw.png" alt="image-20220802090045671"></p>
<p>按F12，打开调式器，在控制台输入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @?: *********************************************************************</span><br><span class="line"> * @Author: Weidows</span><br><span class="line"> * @Date: 2021-07-07 20:30:59</span><br><span class="line"> * @LastEditors: Weidows</span><br><span class="line"> * @LastEditTime: 2021-07-09 00:05:15</span><br><span class="line"> * @FilePath: \awesome-image-collector\implements\SM.MS-collector.js</span><br><span class="line"> * @Description:</span><br><span class="line"> * @!: *********************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  // 引入库函数</span><br><span class="line">  const jsZip = document.createElement(&quot;script&quot;),</span><br><span class="line">    collector = document.createElement(&quot;script&quot;);</span><br><span class="line">  jsZip.src = &quot;https://cdn.bootcdn.net/ajax/libs/jszip/3.5.0/jszip.min.js&quot;;</span><br><span class="line">  collector.src =</span><br><span class="line">    &quot;https://cdn.jsdelivr.net/gh/Weidows-projects/awesome-image-collector@master/dist/collector.min.js&quot;;</span><br><span class="line">  document</span><br><span class="line">    .getElementsByTagName(&quot;head&quot;)[0]</span><br><span class="line">    .appendChild(jsZip)</span><br><span class="line">    .appendChild(collector);</span><br><span class="line"></span><br><span class="line">  await Promise.all([</span><br><span class="line">    new Promise(resolve =&gt; jsZip.onload = () =&gt; window.JSZip &amp;&amp; resolve()),</span><br><span class="line">    new Promise(resolve =&gt; collector.onload = () =&gt; window.start &amp;&amp; resolve()),</span><br><span class="line">  ]);</span><br><span class="line">  smmsCollector();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// ======================== 添加样式 ========================</span><br><span class="line">function smmsCollector() &#123;</span><br><span class="line">  // 下载图片按钮 (不主动下载,按按钮时才下载)</span><br><span class="line">  let downloadButton = document.createElement(&quot;button&quot;);</span><br><span class="line">  downloadButton.type = &quot;button&quot;;</span><br><span class="line">  downloadButton.innerText = &quot;下载本页面图片&quot;;</span><br><span class="line">  downloadButton.style.width = &quot;100%&quot;;</span><br><span class="line">  downloadButton.addEventListener(&quot;click&quot;, function () &#123;</span><br><span class="line">    // 调用入口函数</span><br><span class="line">    start(document.getElementsByClassName(&quot;fancybox&quot;));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 全选CheckBox按钮</span><br><span class="line">  let deleteButton = document.createElement(&quot;button&quot;);</span><br><span class="line">  deleteButton.type = &quot;button&quot;;</span><br><span class="line">  deleteButton.innerHTML = &quot;全选CheckBox按钮&quot;;</span><br><span class="line">  deleteButton.style.width = &quot;100%&quot;;</span><br><span class="line">  deleteButton.addEventListener(&quot;click&quot;, function () &#123;</span><br><span class="line">    let checkBoxes = document.getElementsByClassName(&quot;filedelete&quot;);</span><br><span class="line">    for (const checkbox of checkBoxes) &#123;</span><br><span class="line">      checkbox.checked = !checkbox.checked;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 创建标签</span><br><span class="line">  let downloadLi = document.createElement(&quot;li&quot;);</span><br><span class="line">  let deleteLi = document.createElement(&quot;li&quot;);</span><br><span class="line">  downloadLi.id = &quot;downloader&quot;;</span><br><span class="line">  deleteLi.id = &quot;deleter&quot;;</span><br><span class="line">  downloadLi.appendChild(downloadButton);</span><br><span class="line">  deleteLi.appendChild(deleteButton);</span><br><span class="line"></span><br><span class="line">  // 追加标签</span><br><span class="line">  if (document.getElementById(&quot;downloader&quot;) == null) &#123;</span><br><span class="line">    document</span><br><span class="line">      .getElementsByClassName(&quot;sidebar-menu tree&quot;)[0]</span><br><span class="line">      .appendChild(downloadLi);</span><br><span class="line">    document</span><br><span class="line">      .getElementsByClassName(&quot;sidebar-menu tree&quot;)[0]</span><br><span class="line">      .appendChild(deleteLi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时页面显示：</p>
<p><img src="https://s2.loli.net/2022/08/02/eWQDy4ldmNXxzvb.png" alt="image-20220802090338705"></p>
<p>就可以了</p>
]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis安装教程</title>
    <url>/2022/07/21/Redis%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B(windows)/</url>
    <content><![CDATA[<h1 id="Redis安装教程"><a href="#Redis安装教程" class="headerlink" title="Redis安装教程"></a>Redis安装教程</h1><p>[安装地址链接](<a href="https://github.com/microsoftarchive/redis/releases">Releases · microsoftarchive&#x2F;redis (github.com)</a>)</p>
<p><img src="https://s2.loli.net/2022/07/21/b5dmoDWpJIgaKs7.png" alt="image-20220721233543796"></p>
<p>安装好后放在：</p>
<p><img src="https://s2.loli.net/2022/07/21/pqJP1uMBg5TaRDL.png" alt="image-20220721233710217"></p>
<p>启动服务：点开redis-serve.exe 打开客户端点开redis-cli.exe</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis命令大全</title>
    <url>/2022/07/04/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h1><p>本文记录常用的Redis命令 方便以后复习使用</p>
<h3 id="在服务器上使用Redis-命令"><a href="#在服务器上使用Redis-命令" class="headerlink" title="在服务器上使用Redis 命令"></a>在服务器上使用Redis 命令</h3><h4 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$redis<span class="operator">-</span>cli</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> PING</span><br><span class="line"> </span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<h4 id="远程使用"><a href="#远程使用" class="headerlink" title="远程使用"></a>远程使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line"> </span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<h3 id="字符串常用命令"><a href="#字符串常用命令" class="headerlink" title="字符串常用命令"></a>字符串常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET key value #设置一个key-value 键值对</span><br><span class="line">GET key #获取key对应的value</span><br><span class="line">SETEX key seconds value #设置key的有效时间指向value</span><br><span class="line">SETNX KEY VALUE #在key不存在时 才会设置VALUE</span><br></pre></td></tr></table></figure>

<h4 id="String在Redis中所需要的常识"><a href="#String在Redis中所需要的常识" class="headerlink" title="String在Redis中所需要的常识"></a>String在Redis中所需要的常识</h4><ol>
<li>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</li>
<li>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</li>
<li>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</li>
</ol>
<h4 id="实列"><a href="#实列" class="headerlink" title="实列"></a>实列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">SET</span> name &quot;redis.net.cn&quot;</span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">GET</span> name</span><br><span class="line">&quot;redis.net.cn&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Redis-keys命令"><a href="#Redis-keys命令" class="headerlink" title="Redis keys命令"></a>Redis keys命令</h3><ol>
<li><a href="https://www.redis.net.cn/order/3528.html">DEL key</a> 该命令用于在 key 存在是删除 key</li>
<li><a href="https://www.redis.net.cn/order/3530.html">EXISTS key</a> 检查给定 key 是否存在</li>
<li><a href="https://www.redis.net.cn/order/3531.html">EXPIRE key</a> seconds 为给定 key 设置过期时间。</li>
<li><a href="https://www.redis.net.cn/order/3536.html">MOVE key db</a> 将当前数据库的 key 移动到给定的数据库 db 当中。</li>
</ol>
<h3 id="Redis-集合"><a href="#Redis-集合" class="headerlink" title="Redis 集合"></a>Redis 集合</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS w3ckey</span><br><span class="line"> </span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure>

<p>在以上实例中我们通过 <strong>SADD</strong> 命令向名为 w3ckey 的集合插入的三个元素。</p>
<h3 id="Redis-哈希"><a href="#Redis-哈希" class="headerlink" title="Redis 哈希"></a>Redis 哈希</h3><h4 id="实列-1"><a href="#实列-1" class="headerlink" title="实列"></a>实列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; HMSET w3ckey name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot; likes 20 visitors 23000</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; HGETALL w3ckey</span><br><span class="line"> </span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;redis tutorial&quot;</span><br><span class="line">3) &quot;description&quot;</span><br><span class="line">4) &quot;redis basic commands for caching&quot;</span><br><span class="line">5) &quot;likes&quot;</span><br><span class="line">6) &quot;20&quot;</span><br><span class="line">7) &quot;visitors&quot;</span><br><span class="line">8) &quot;23000&quot;</span><br></pre></td></tr></table></figure>

<p>在以上实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 w3ckey 中</p>
<h4 id="哈希命令"><a href="#哈希命令" class="headerlink" title="哈希命令"></a>哈希命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.HDEL key field2 [field2] 删除一个或多个哈希表字段</span><br><span class="line">2.HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。</span><br><span class="line">3.HGET key field 获取存储在哈希表中指定字段的值</span><br><span class="line">4.HGETALL key 获取在哈希表中指定 key 的所有字段和值</span><br><span class="line">7.HKEYS key 获取所有哈希表中的字段</span><br><span class="line">8.HLEN key 获取哈希表中字段的数量</span><br></pre></td></tr></table></figure>

<h3 id="Redis-列表"><a href="#Redis-列表" class="headerlink" title="Redis 列表"></a>Redis 列表</h3><h4 id="实列-2"><a href="#实列-2" class="headerlink" title="实列"></a>实列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; LPUSH w3ckey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH w3ckey mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH w3ckey mysql</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE w3ckey 0 10</span><br><span class="line"> </span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure>

<p>在以上实例中我们使用了 <strong>LPUSH</strong> 将三个值插入了名为 w3ckey 的列表当中。</p>
<p>列表命令：</p>
<ol>
<li><a href="https://www.redis.net.cn/order/3582.html">LLEN key</a> 获取列表长度</li>
<li><a href="https://www.redis.net.cn/order/3583.html">LPOP key</a> 移出并获取列表的第一个元素</li>
<li><a href="https://www.redis.net.cn/order/3586.html">LRANGE key start stop</a> 获取列表指定范围内的元素</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/06/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<p>thanks for your listenning</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Python模块</title>
    <url>/2022/08/01/python%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="Python模块"><a href="#Python模块" class="headerlink" title="Python模块"></a>Python模块</h1><h2 id="为什么需要模块？"><a href="#为什么需要模块？" class="headerlink" title="为什么需要模块？"></a>为什么需要模块？</h2><p>大多数应用项目往往具有功能要求多、性能要求高的特点，由此导致的结果是使得程序代码复杂而且庞大。当程序代码多达几百行、几千行甚至上万行时，为了加快开发进度、提高开发效率，需要团队协作、分工合作开发程序。如果缺少有效的组织方式，那么不仅使得协同开发难以做到，而且程序的调试将变得异常艰难，后期的维护和升级更加困难重重。这时候就需要模块化。</p>
<h2 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h2><h3 id="1-大模块"><a href="#1-大模块" class="headerlink" title="1.大模块"></a>1.大模块</h3><p>大模块即“包（Package）”。<br>一个相对大型的程序通常包含多个文件，按照功能相近的原则，可将这些文件分组，每组包含若干个文件，每个组常被称为“包”。每个“包”即所谓的“大模块”。</p>
<h3 id="2-中模块"><a href="#2-中模块" class="headerlink" title="2.中模块"></a>2.中模块</h3><p>中模块即一个文件。<br>为了提高代码的可维护性，可将项目中的所有自定义函数进行归类分组，以文件形式组织同类函数，因此，每个文件的功能相对单一，每个文件包含的代码相对较少。这对项目管理和代码的重复利用十分有利。多数计算机语言均支持类似的组织代码方式，Python也不例外。在Python中，一个.py文件常被称为一个模块（Module）</p>
<h3 id="3-小模块"><a href="#3-小模块" class="headerlink" title="3.小模块"></a>3.小模块</h3><p>模块即一个函数。<br>函数也是模块化设计的产物，通过函数实现程序功能是模块化设计思想的一种很好的体现。一个模块文件通常是由若干个函数或类组成的。</p>
<h2 id="关于模块的几个概念"><a href="#关于模块的几个概念" class="headerlink" title="关于模块的几个概念"></a>关于模块的几个概念</h2><p>模块具有层次性，因此模块又可被分为内置函数、内置模块、第三方模块和自定义模块。<br>内置函数是Python的标准函数，可被直接调用。<br>内置模块是Python的标准库，必须通过import语句引用后才可使用。内置模块文件默认安装在Python的“安装路径\Python\PythonXXX\lib”下，即安装在lib文件夹下。<br>第三方模块是指由第三方开发的、实现各种特定功能的模块，又被称为“第三方库”。数量众多的第三方库是Python优越性的重要体现。<br>自定义模块是指由开发者自行设计的模块</p>
<h2 id="关于模块测试"><a href="#关于模块测试" class="headerlink" title="关于模块测试"></a>关于模块测试</h2><p>由if语句组织相关的测试代码，它的工作原理是：当运行模块文件本身时，Python解释器将特殊变量（内置全局变量）<strong>name__的值置为字符串__main__，因此__name</strong>&#x3D;&#x3D;’<strong>main</strong>‘成立；如果该模块被其他程序所引用，那么__name__的值会被置为引用它的程序文件名（不包括.py），此时，<strong>name</strong>&#x3D;&#x3D;’<strong>main</strong>‘不再成立，所以测试语句块不会被执行。因此，模块中的测试代码只用于测试模块本身的正确性，不会对引用它的模块造成影响。</p>
<h2 id="引入模块的四种方式"><a href="#引入模块的四种方式" class="headerlink" title="引入模块的四种方式"></a>引入模块的四种方式</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>引用一个名为fibonacci的模块，该模块的文件名为fibonacci.py。<br>再如：<br>上述语句引用3个名为fibonacci、geometric、arithmetic的模块，3个模块对应的文件名为fibonacci.py、geometric.py和arithmetic.py。<br>由此可见，import可一次性导入多个模块，模块之间必须以“,”隔开。</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>形式如下：<br>由于别名往往比较简洁，因而引用模块中的对象和方法更加便捷。当采用此方式引用模块中的对象或方法时，必须使用别名。</p>
<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>引用模块的第三种方式<br>形式如下：<br>从模块中导入指定的函数、变量或类，可对导入的对象或方法（函数）指定别名以简化引用</p>
<p>在这种方式下，引用模块中的对象或方法（函数）的形式必须是“模块.对象或方法的别名”，例如，geometric.geo1(2,3,6)。</p>
<h3 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h3><p>导入模块中的所有对象和方法（函数）。“*”被称为“通配符”，意为全部、所有。<br>虽然方式四可一次性导入模块中的所有对象和方法（函数），但是通常不建议这么做，因为它极有可能引起命名冲突（Name Conflict），即该模块中的对象名或函数名与被导入的其他模块中的对象名或函数名重名，从而导致冲突。</p>
<h2 id="模块是如何被找到并引用的"><a href="#模块是如何被找到并引用的" class="headerlink" title="模块是如何被找到并引用的"></a>模块是如何被找到并引用的</h2><p>sys.path通常由以下几部分组成：<br>（1）脚本文件所在的路径，即当前路径。<br>（2）PYTHONPATH系统变量设定的路径。<br>（3）默认安装路径。</p>
<h3 id="动态修改sys-path"><a href="#动态修改sys-path" class="headerlink" title="动态修改sys.path"></a>动态修改sys.path</h3><p>通过sys.path.append(‘路径’)添加所需路径，它属于一种动态修改sys.path的方法。所谓“动态”，是指程序退出后，将删除添加的路径信息，恢复sys.path的内容</p>
<h3 id="静态修改sys-path"><a href="#静态修改sys-path" class="headerlink" title="静态修改sys.path"></a>静态修改sys.path</h3><p>可通过以下两种方式静态修改sys.path：<br>· 在系统环境变量中新建变量PYTHONPATH，然后添加所需路径，即PYTHONPATH &#x3D;e:\myprj。<br>· 直接在Path系统环境变量中添加所需路径，即Path&#x3D;[各种路径]; e:\myprj，或者Path&#x3D;%PATH%; e:\myprj。前者表示在现有各种路径后添加所需路径，后者表示在Path变量现有值的基础上添加一项新的内容e:\myprj。上述两种方法均以“;”作为分隔符。<br>通过静态修改法添加的路径是静态的，永久有效</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="同级目录文件"><a href="#同级目录文件" class="headerlink" title="同级目录文件"></a>同级目录文件</h3><p>目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- love.py</span><br><span class="line">|-- me.py</span><br></pre></td></tr></table></figure>

<p>me中引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import love</span><br><span class="line">love.min()</span><br></pre></td></tr></table></figure>

<h3 id="子级目录文件"><a href="#子级目录文件" class="headerlink" title="子级目录文件"></a>子级目录文件</h3><p>目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- yep</span><br><span class="line">	--fuck</span><br><span class="line">|-- me.py</span><br></pre></td></tr></table></figure>

<p>me中引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from yep import fuck</span><br><span class="line">fuck.fuckyou()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>leancloud失效解决方案</title>
    <url>/2022/08/03/leancloud%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="leancloud失效解决方案"><a href="#leancloud失效解决方案" class="headerlink" title="leancloud失效解决方案"></a>leancloud失效解决方案</h1><h2 id="1-点击LeanCloud设置"><a href="#1-点击LeanCloud设置" class="headerlink" title="1.点击LeanCloud设置"></a>1.点击LeanCloud设置</h2><p>进入到域名绑定后，点击Api访问域名，输入域名</p>
<p>域名解析：xxx.cherlyonly.cn 后面两个是小姐姐的已经备案好的域名 前面xxx涉随便你怎么写</p>
<p>然后将CNAME复制提交给她 </p>
<p><img src="https://s1.328888.xyz/2022/08/03/OUPRB.png" alt="image-20220803123606916"></p>
<h2 id="2-进入到主题配置文件"><a href="#2-进入到主题配置文件" class="headerlink" title="2.进入到主题配置文件"></a>2.进入到主题配置文件</h2><p>将ServerURL替换掉</p>
<p><img src="https://s1.328888.xyz/2022/08/03/OU8VP.png" alt="image-20220803123757028"></p>
<h2 id="3-修改CDN下的third-party-provider"><a href="#3-修改CDN下的third-party-provider" class="headerlink" title="3.修改CDN下的third_party_provider"></a>3.修改CDN下的third_party_provider</h2><p><img src="https://s1.328888.xyz/2022/08/03/OUg6R.png" alt="image-20220803124036256"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2022/07/23/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol>
<li>安装Git</li>
<li>安装Node.js</li>
<li>安装Hexo</li>
<li>GitHub创建个人仓库</li>
<li>生成SSH添加到GitHub</li>
<li>将hexo部署到GitHub</li>
<li>设置个人域名</li>
<li>发布文章</li>
</ol>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）选择 Git Bash Here，然后依次输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo框架的安装</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>依旧用<code>hexo -v</code>查看一下版本</p>
<p>至此就全部安装完了。</p>
<p>接下来初始化一下hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd myblog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹目录下有：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li>** _config.yml: 博客的配置文件**</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>首先，你先要有一个GitHub账户，去注册一个吧。</p>
<p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库</p>
<p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。</p>
<p>点击create repository。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d002150a2eb02a0358d1c88199e4e726.png" alt="img"></p>
<h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>


<p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>


<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>


<p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p>
<p>注意deploy时可能要你输入username和password。</p>
<h3 id="安装butterfly主题"><a href="#安装butterfly主题" class="headerlink" title="安装butterfly主题"></a>安装butterfly主题</h3><p>在你的 Hexo 根目录里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br></pre></td></tr></table></figure>

<p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>

<p>在 hexo 的根目录创建一个文件，并把主题目录的内容复制到 去。 （ 注意： 复制的是主题的 _config.yml ，而不是 hexo 的 _config.yml_config.butterfly.yml_config.yml_config.butterfly.yml)</p>
<p>注意： 不要把主题目录的 删掉_config.yml</p>
]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>python存储csv文件</title>
    <url>/2022/08/03/python%E5%AD%98%E5%82%A8csv%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="python存储csv文件"><a href="#python存储csv文件" class="headerlink" title="python存储csv文件"></a>python存储csv文件</h1><p>源代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line">headers = [&quot;username&quot;,&quot;age&quot;,&quot;height&quot;]</span><br><span class="line">values = [(&quot;张三&quot;,&quot;18&quot;,&quot;180&quot;),(&quot;李四&quot;,&quot;19&quot;,&quot;190&quot;),(&quot;王五&quot;,&quot;18&quot;,&quot;160&quot;)]</span><br><span class="line">def csv_1():</span><br><span class="line">    headers = [&quot;username&quot;, &quot;age&quot;, &quot;height&quot;]</span><br><span class="line">    values = [(&quot;张三&quot;, &quot;18&quot;, &quot;180&quot;), (&quot;李四&quot;, &quot;19&quot;, &quot;190&quot;), (&quot;王五&quot;, &quot;18&quot;, &quot;160&quot;)]</span><br><span class="line">    with open(&quot;classroom1.csv&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;,newline=&quot;&quot;) as fp:</span><br><span class="line">        new_fp = csv.writer(fp)</span><br><span class="line">        new_fp.writerow(headers)</span><br><span class="line">        new_fp.writerows(values)</span><br><span class="line"></span><br><span class="line">def csv_2():</span><br><span class="line">    headers = [&quot;username&quot;, &quot;age&quot;, &quot;height&quot;]</span><br><span class="line">    values = [&#123;&quot;username&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;18&quot;,&quot;height&quot;:&quot;180&quot;&#125;,&#123;&quot;username&quot;:&quot;李四&quot;,&quot;age&quot;:&quot;19&quot;,&quot;height&quot;:&quot;190&quot;&#125;,&#123;&quot;username&quot;:&quot;王五&quot;,&quot;age&quot;:&quot;18&quot;,&quot;height&quot;:&quot;160&quot;&#125;]</span><br><span class="line">    with open(&quot;classroom2.csv&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;,newline=&quot;&quot;) as fp:</span><br><span class="line">        writer = csv.DictWriter(fp,headers)</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        writer.writerows(values)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # csv_1()</span><br><span class="line">    csv_2()</span><br></pre></td></tr></table></figure>

<p>csv2长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username,age,height</span><br><span class="line">张三,18,180</span><br><span class="line">李四,19,190</span><br><span class="line">王五,18,160</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件基础</title>
    <url>/2022/08/03/python%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="python数据预处理"><a href="#python数据预处理" class="headerlink" title="python数据预处理"></a>python数据预处理</h1><p>user_profile.csv:  这个文件太大 就复制少一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">,userid,cms_segid,cms_group_id,final_gender_code,age_level,pvalue_level,occupation,new_user_class_level </span><br><span class="line">0,234,0,5,2,5,,0,3.0</span><br><span class="line">1,523,5,2,2,2,1.0,1,2.0</span><br><span class="line">2,612,0,8,1,2,2.0,0,</span><br><span class="line">3,1670,0,4,2,4,,0,</span><br><span class="line">4,2545,0,10,1,4,,0,</span><br><span class="line">5,3644,49,6,2,6,2.0,0,2.0</span><br><span class="line">6,5777,44,5,2,5,2.0,0,2.0</span><br><span class="line">7,6211,0,9,1,3,,0,2.0</span><br><span class="line">8,6355,2,1,2,1,1.0,0,4.0</span><br><span class="line">9,6823,43,5,2,5,2.0,0,1.0</span><br><span class="line">10,6972,5,2,2,2,2.0,1,2.0</span><br><span class="line">11,9293,0,5,2,5,,0,4.0</span><br><span class="line">12,9510,55,8,1,2,2.0,0,2.0</span><br><span class="line">13,10122,33,4,2,4,2.0,0,2.0</span><br><span class="line">14,10549,0,4,2,4,2.0,0,</span><br><span class="line">15,10812,0,4,2,4,,0,</span><br><span class="line">16,10912,0,4,2,4,2.0,0,</span><br><span class="line">17,10996,0,5,2,5,,0,4.0</span><br><span class="line">18,11256,8,2,2,2,1.0,0,3.0</span><br><span class="line">19,11310,31,4,2,4,1.0,0,4.0</span><br></pre></td></tr></table></figure>

<p>ads_sample.csv：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">,user_id,adgroup_id,pid,nonclk,clk,date</span><br><span class="line">0,581738,1,430548_1007,1,0,2021-03-07 14:14:04</span><br><span class="line">1,449818,3,430548_1007,1,0,2021-03-13 09:26:18</span><br><span class="line">2,914836,4,430548_1007,1,0,2021-03-13 12:47:59</span><br><span class="line">3,914836,5,430548_1007,1,0,2021-03-13 12:50:29</span><br><span class="line">4,399907,8,430548_1007,1,0,2021-03-09 12:09:18</span><br><span class="line">5,628137,9,430548_1007,1,0,2021-03-12 01:48:55</span><br><span class="line">6,298139,9,430539_1007,1,0,2021-03-11 08:29:53</span><br><span class="line">7,775475,9,430548_1007,1,0,2021-03-12 11:50:36</span><br><span class="line">8,555266,11,430539_1007,1,0,2021-03-09 13:18:56</span><br><span class="line">9,117840,11,430548_1007,1,0,2021-03-06 10:12:23</span><br><span class="line">10,739815,11,430539_1007,1,0,2021-03-07 08:03:07</span><br><span class="line">11,623911,11,430548_1007,1,0,2021-03-13 05:41:41</span><br><span class="line">12,623911,11,430548_1007,1,0,2021-03-11 05:26:48</span><br><span class="line">13,421590,11,430548_1007,1,0,2021-03-06 09:29:04</span><br><span class="line">14,976358,13,430548_1007,1,0,2021-03-07 19:35:49</span><br><span class="line">15,286630,13,430539_1007,1,0,2021-03-08 12:42:59</span><br><span class="line">16,286630,13,430539_1007,1,0,2021-03-09 08:20:47</span><br><span class="line">17,771431,13,430548_1007,1,0,2021-03-07 18:44:27</span><br></pre></td></tr></table></figure>

<p>在做数据分析处理时要用到的一系列操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proProcess</span>(<span class="params">filename1,filename2</span>):</span><br><span class="line">     <span class="comment">#加载文件</span></span><br><span class="line">     df1 = pd.read_csv(filename1)</span><br><span class="line">     <span class="comment"># df = pd.DataFrame(data,columns=title,dtype=float)</span></span><br><span class="line">     <span class="comment"># title = [&#x27;data&#x27;, &#x27;feature_names&#x27;]</span></span><br><span class="line">     <span class="comment"># a = [[&#x27;2015年&#x27;, 137462.0],</span></span><br><span class="line">     <span class="comment">#      [&#x27;2015年&#x27;, 137462.0],</span></span><br><span class="line">     <span class="comment">#      [nan, nan],</span></span><br><span class="line">     <span class="comment">#      [nan, nan]]</span></span><br><span class="line">     <span class="comment">#去重</span></span><br><span class="line">     df1 = df1.drop_duplicates()</span><br><span class="line">     <span class="comment">#去除缺失值</span></span><br><span class="line">     df1 = df1.dropna()</span><br><span class="line">     <span class="comment"># 去重</span></span><br><span class="line">     df1 = df1.drop_duplicates()</span><br><span class="line">     <span class="comment"># 去除缺失值</span></span><br><span class="line">     df1 = df1.dropna()</span><br><span class="line"></span><br><span class="line">     <span class="comment">#填补数值</span></span><br><span class="line">     <span class="comment"># df = df.Age.fillna(df.Age.mean())</span></span><br><span class="line">     <span class="built_in">print</span>(df1)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 加载文件</span></span><br><span class="line">     df2 = pd.read_csv(filename2)</span><br><span class="line">     <span class="comment"># df = pd.DataFrame(data,columns=title,dtype=float)</span></span><br><span class="line">     <span class="comment"># title = [&#x27;data&#x27;, &#x27;feature_names&#x27;]</span></span><br><span class="line">     <span class="comment"># a = [[&#x27;2015年&#x27;, 137462.0],</span></span><br><span class="line">     <span class="comment">#      [&#x27;2015年&#x27;, 137462.0],</span></span><br><span class="line">     <span class="comment">#      [nan, nan],</span></span><br><span class="line">     <span class="comment">#      [nan, nan]]</span></span><br><span class="line">     <span class="comment"># 去重</span></span><br><span class="line">     df2 = df2.drop_duplicates()</span><br><span class="line">     <span class="comment"># 去除缺失值</span></span><br><span class="line">     df2 = df2.dropna()</span><br><span class="line">     <span class="comment"># 去重</span></span><br><span class="line">     df2 = df2.drop_duplicates()</span><br><span class="line">     <span class="comment"># 去除缺失值</span></span><br><span class="line">     df2 = df2.dropna()</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 填补数值</span></span><br><span class="line">     <span class="comment"># df = df.Age.fillna(df.Age.mean())</span></span><br><span class="line">     <span class="built_in">print</span>(df2)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     <span class="comment"># data = [[&#x27;Google&#x27;, 10], [&#x27;Runoob&#x27;, 12], [&#x27;Wiki&#x27;, 13], [nan, nan], [&#x27;Wiki&#x27;, 13]]</span></span><br><span class="line">     <span class="comment"># title = [&#x27;Site&#x27;, &#x27;Age&#x27;]</span></span><br><span class="line">     filename1 = <span class="string">&#x27;user_profile.csv&#x27;</span></span><br><span class="line">     filename2 = <span class="string">&#x27;ads_sample.csv&#x27;</span></span><br><span class="line">     proProcess(filename1,filename2)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件基础</title>
    <url>/2022/08/01/python%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Python文件基础"><a href="#Python文件基础" class="headerlink" title="Python文件基础"></a>Python文件基础</h1><h2 id="关于文件的几点注意事项"><a href="#关于文件的几点注意事项" class="headerlink" title="关于文件的几点注意事项"></a>关于文件的几点注意事项</h2><h3 id="1-文件对象属性"><a href="#1-文件对象属性" class="headerlink" title="1.文件对象属性"></a>1.文件对象属性</h3><p>打开一个文件后，得到一个文件对象fp，通过它可以获得与该文件相关的各种信息。以下是与文件对象相关的所有属性。<br>· fp.closed：如果文件已被关闭，则返回True；否则返回False。<br>· fp.mode：打开文件的模式。<br>· fp.name：得到已被打开的文件的文件名。</p>
<h3 id="2-列表中出现字符串“-ufeff”及其解决方案"><a href="#2-列表中出现字符串“-ufeff”及其解决方案" class="headerlink" title="2.列表中出现字符串“\ufeff”及其解决方案"></a>2.列表中出现字符串“\ufeff”及其解决方案</h3><p>举例36：\ufeff问题及其解决办法。<br>上述程序打开一个示例文件，但从结果中发现，在读取的内容中出现了\ufeff，而真正的文件内容是从“你好”开始的。<br>解决办法如下：<br>从上述改进后的程序中可以看出，解决\ufeff问题的关键在于通过utf-8-sig编码格式对字符串进行转码：decode(‘utf-8-sig’)。<br>由此得到启发，如果在打开文件时直接采用utf-8-sig编码格式，那么能不能解决这个乱码问题？答案是令人惊喜的，请看：<br>真的解决了！这是为什么呢？<br>实际上，需要从以下两种编码格式的本质加以阐述。<br>（1）UTF-8编码。它以字节为编码单元，字节顺序在所有系统中都相同，不存在字节序的问题，因此它并不需要字节序标记（Byte Order Mark，BOM）。<br>（2）utf-8-sig编码。<strong>它是一种带BOM的UTF-8编码格式</strong>，存在字节序的问题，必须带BOM以标识字节序，而BOM即字符U+FEFF。<strong>从Unicode 3.2开始，U+FEFF只能出现在字节流的开头</strong>，只能用于标识字节序。由此可知，列表中的字符串“\ufeff”并不是乱码，而是由于编码格式不一致才出现的。</p>
<h2 id="利用Pygal模块对JSON格式的数据进行可视化"><a href="#利用Pygal模块对JSON格式的数据进行可视化" class="headerlink" title="利用Pygal模块对JSON格式的数据进行可视化"></a>利用Pygal模块对JSON格式的数据进行可视化</h2><p>[参考文档](<a href="https://zhuanlan.zhihu.com/p/341450079">Pygal，可导出矢量图的Python可视化利器 - 知乎 (zhihu.com)</a>)</p>
<h3 id="安装并导入Pygal"><a href="#安装并导入Pygal" class="headerlink" title="安装并导入Pygal"></a>安装并导入Pygal</h3><p>使用pip或者conda进行安装，在命令行输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pygal</span><br></pre></td></tr></table></figure>

<h3 id="雷达图"><a href="#雷达图" class="headerlink" title="雷达图"></a>雷达图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">radar_chart = pygal.Radar()</span><br><span class="line">radar_chart.title = <span class="string">&#x27;V8 benchmark results&#x27;</span></span><br><span class="line">radar_chart.x_labels = [<span class="string">&#x27;Richards&#x27;</span>, <span class="string">&#x27;DeltaBlue&#x27;</span>, <span class="string">&#x27;Crypto&#x27;</span>, <span class="string">&#x27;RayTrace&#x27;</span>, <span class="string">&#x27;EarleyBoyer&#x27;</span>, <span class="string">&#x27;RegExp&#x27;</span>, <span class="string">&#x27;Splay&#x27;</span>, <span class="string">&#x27;NavierStokes&#x27;</span>]</span><br><span class="line">radar_chart.add(<span class="string">&#x27;Chrome&#x27;</span>, [<span class="number">6395</span>, <span class="number">8212</span>, <span class="number">7520</span>, <span class="number">7218</span>, <span class="number">12464</span>, <span class="number">1660</span>, <span class="number">2123</span>, <span class="number">8607</span>])</span><br><span class="line">radar_chart.add(<span class="string">&#x27;Firefox&#x27;</span>, [<span class="number">7473</span>, <span class="number">8099</span>, <span class="number">11700</span>, <span class="number">2651</span>, <span class="number">6361</span>, <span class="number">1044</span>, <span class="number">3797</span>, <span class="number">9450</span>])</span><br><span class="line">radar_chart.add(<span class="string">&#x27;Opera&#x27;</span>, [<span class="number">3472</span>, <span class="number">2933</span>, <span class="number">4203</span>, <span class="number">5229</span>, <span class="number">5810</span>, <span class="number">1828</span>, <span class="number">9013</span>, <span class="number">4669</span>])</span><br><span class="line">radar_chart.add(<span class="string">&#x27;IE&#x27;</span>, [<span class="number">43</span>, <span class="number">41</span>, <span class="number">59</span>, <span class="number">79</span>, <span class="number">144</span>, <span class="number">136</span>, <span class="number">34</span>, <span class="number">102</span>])</span><br><span class="line">radar_chart.render()</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://s2.loli.net/2022/08/01/zxv9W8fr71P3ew6.png" alt="image-20220801102051712"></p>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python程序打包pyinstaller</title>
    <url>/2022/08/03/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>安装pyinstaller 在控制台输入就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure>

<p><a href="https://imgloc.com/i/OnuaU"><img src="https://s1.328888.xyz/2022/08/03/OnuaU.png" alt="OnuaU.png"></a></p>
<p>python程序打包pyinstaller</p>
<p><img src="https://s1.328888.xyz/2022/08/03/OnFSC.png"></p>
<p>然后再在控制台输入Pyinstaller -F -w 文件名.py</p>
<p>注意：环境得是Anaconda : 3.6.0</p>
<p><a href="https://imgloc.com/i/ORN9y"><img src="https://s1.328888.xyz/2022/08/03/ORN9y.png" alt="ORN9y.png"></a></p>
<p>此时会生成build和dist ，dist里面会有一个exe文件 点击就可以运行</p>
<p><a href="https://imgloc.com/i/OR0TP"><img src="https://s1.328888.xyz/2022/08/03/OR0TP.png" alt="OR0TP.png"></a></p>
<p><a href="https://imgloc.com/i/ORFGU"><img src="https://s1.328888.xyz/2022/08/03/ORFGU.png" alt="ORFGU.png"></a></p>
<p><a href="%5B(11%E6%9D%A1%E6%B6%88%E6%81%AF">参考文档</a> [Python教程]保姆版教使用Pyinstaller 打包python成exe文件_王同学在这的博客-CSDN博客_pycharm打包多个py](<a href="https://blog.csdn.net/flyskymood/article/details/123668136">https://blog.csdn.net/flyskymood/article/details/123668136</a>))</p>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python词频分析</title>
    <url>/2022/08/03/python%E8%AF%8D%E9%A2%91%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="python词频分析"><a href="#python词频分析" class="headerlink" title="python词频分析"></a>python词频分析</h1><p>文本名：结果50.txt：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datasets labels testing used real test synthetic different contains</span><br><span class="line">vol ieee pp analysis machine transactions pattern intelligence trans learning journal  acm  based</span><br><span class="line">tree l2 l1 ac trees pc ab se template latent sm decision uk 70 go minutiae mc fr sw es</span><br><span class="line">arxiv query preprint queries 2017 abs corr qi 2016 ba 2015 101 fo 2014 glass 2018 networks brox image recommendation</span><br><span class="line">face x1 recognition facial faces database ii expression x2 age identity alignment person expressions veriﬁcation sign sketch im identiﬁcation wild</span><br><span class="line">matrix xi vector denotes th denote norm matrices yi xt respectively element vectors tr elements operator covariance product let diagonal</span><br><span class="line">bound complete theorem complexity problem lower upper np extension bounds whether arguments hard af bounded given stable argument ap regret</span><br><span class="line">context event co events mod car cc contexts ut road modeling nd bridge aj activity els neuron ff 360</span><br><span class="line">function space distance eq linear kernel loss functions deﬁned objective parameter parameters using equation term two problem following vector non</span><br><span class="line">object features feature detection level image objects segmentation region semantic local based regions box bounding spatial pooling detector cnn using</span><br><span class="line">pp proc conf vis comput int 2014 vol recognit 2016 english 2011 pm intell springer inf det notes res syst</span><br><span class="line">scale large language visual v1 v2 natural fei discovery mining u1 ng machines data support 2010 multi ijcv challenge machine</span><br><span class="line">images dataset ground truth datasets data image real training synthetic contains different scenes world scene used annotations benchmark annotated categories</span><br><span class="line">graph local edge matching nodes node global edges graphs cluster constraint clusters set two constraints similarity structure vertices pairwise tree</span><br><span class="line">set error test training average mean score used values evaluation number data different table sets metrics testing validation performance results</span><br><span class="line">learning deep neural networks wang li zhang liu 2016 2017 2018 pp chen convolutional yang 2015 processing image cvpr sun</span><br><span class="line">system human systems user ai visual people information interaction understanding models uncertainty control applications research users data task gaze model</span><br><span class="line">point points camera position direction surface rotation plane center outliers projection angle cloud two normal registration set orientation along positions</span><br><span class="line">section paper experiments end results study described details following sec work experimental present main presented analysis detailed implementation see next</span><br><span class="line">results performance method methods table proposed accuracy better art state comparison compared also baseline model best show fig shown datasets</span><br><span class="line">model distribution probability random variable gaussian variables sampling distributions inference density models data prior likelihood bayesian mixture probabilities conditional variational</span><br><span class="line">gradient block update convergence blocks vs stochastic algorithm updated least descent updates rs mm residual wavelet algo gradients greedy method</span><br><span class="line">time algorithm number step cost search solution iteration instances optimal size complexity computation sat steps computational iterations polynomial total times</span><br><span class="line">based methods problem approach proposed work method algorithms data learning approaches problems also propose optimization framework however algorithm related used</span><br><span class="line">introduction pt ps gt 33 cl closure dp 200 400 ft lk sound nc 600 mt fs mp rational nm</span><br><span class="line">domain class learning target label samples classiﬁcation data classes source training task supervised labels adaptation cross classiﬁer loss multi transfer</span><br><span class="line">size rate binary batch memory 100 code normalization 64 codes quantization 128 256 learning length bit gpu 32 training epochs</span><br><span class="line">al et rain proposed wang removal zhang li liu methods recently based chen streaks recent yang zhu deraining works introduced</span><br><span class="line">let set proof every since deﬁnition lemma rule follows consider following thus proposition theorem case formula true one assume holds</span><br><span class="line">one may however case also would even thus small could since possible number due example cases large two information different</span><br><span class="line">table input adversarial loss output image generation generative generated gan decoder translation images encoder generator generate style discriminator s1 f1</span><br><span class="line">fig figure shown right shows left example top row line results see bottom two red false show lines examples vi</span><br><span class="line">part attributes attribute work supported ni grant material stereo project version authors w1 photometric ﬁxation fc w2 water duration media</span><br><span class="line">set logic knowledge relation model semantics reasoning models program rules epistemic relations sets base properties answer abstract formulas programs interpretation</span><br><span class="line">explanation text explanations question word words questions open sentence zi answer xk post answers participants concepts document answering intention gadget</span><br><span class="line">data rank sparse clustering low representation dimensional tensor subspace si bi ri spectral dictionary pca high sparsity completion recovery s0</span><br><span class="line">video motion view frame frames temporal depth sequence sequences videos ﬂow camera optical views time rgb using tracking dynamic cameras</span><br><span class="line">online tracking term association long exp available 32 ti short graphics landmark lda 55 else 49 tracker pn interactive po</span><br><span class="line">intelligence artiﬁcial 40 30 50 60 2021 ci 2019 80 300 35 2020 aaai 100 27 00 ui 20 150</span><br><span class="line">university research science computer degree engineering received technology china interests department institute mail include ph vision currently professor learning school</span><br><span class="line">3d pose shape estimation 2d model reconstruction body human head poses using images shapes landmarks depth hand appearance surface based</span><br><span class="line">image images resolution map noise pixel pixels light high depth color maps quality super low using ﬁeld ﬁlter channel saliency</span><br><span class="line">de index ieee di terms member information 1000 2000 org sk sa la 500 http dk requires dx www publications</span><br><span class="line">action state actions planning states plan agent goal initial policy appendix pr transition robot observation observations set belief reward goals</span><br><span class="line">network layer model deep training layers learning trained networks cnn architecture neural convolutional attention two pre input feature end models</span><br><span class="line">log path st references change paths return ij y1 ad inequality publication accepted ds worker hm final xn wk information</span><br><span class="line">pp proceedings conference international vol journal theory acm max pages press springer xj volume systems statistics new 2007 programming statistical</span><br><span class="line">agents agent group game groups player games strategy utility value p1 social p2 players items allocation communication cs preferences ln</span><br><span class="line">vision computer conference ieee recognition pattern pp international proceedings cvpr 2015 image 2017 2016 iccv european 2018 2013 pages object</span><br><span class="line">supplementary embeddings dp lp text english w2 expansion document sentences dx languages</span><br></pre></td></tr></table></figure>

<p>源代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gettext</span>():</span><br><span class="line">    txt = <span class="built_in">open</span>(<span class="string">&quot;结果50.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,errors=<span class="string">&#x27;ignore&#x27;</span>).read()</span><br><span class="line">    txt = txt.lower()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&#x27;!&quot;#$&amp;()*+,-./:;&lt;=&gt;?@[\\]^_&#123;|&#125;·~‘’&#x27;</span>:</span><br><span class="line">        txt = txt.replace(ch,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> txt</span><br><span class="line">txt = gettext()</span><br><span class="line">words = txt.split()</span><br><span class="line"><span class="built_in">print</span>(words)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    counts[word] = counts.get(word,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">items = <span class="built_in">list</span>(counts.items())</span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># print(items)</span></span><br><span class="line">words = []</span><br><span class="line">counts = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    words.append(items[i][<span class="number">0</span>])</span><br><span class="line">    counts.append(items[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(words)</span></span><br><span class="line"><span class="comment"># print(counts)</span></span><br><span class="line">c = (</span><br><span class="line">    Bar()</span><br><span class="line">    .add_xaxis(words)</span><br><span class="line">    .add_yaxis(<span class="string">&quot;次数&quot;</span>, counts)</span><br><span class="line">    .reversal_axis()</span><br><span class="line">    .set_series_opts(label_opts=opts.LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line">    .set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;英文词出现字数&quot;</span>))</span><br><span class="line">    .render(<span class="string">&quot;英文词出现字数.html&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><img src="https://s1.328888.xyz/2022/08/03/OqR0g.png" alt="image-20220803172136919"></p>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python面向对象基础</title>
    <url>/2022/08/01/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="python面向对象基础"><a href="#python面向对象基础" class="headerlink" title="python面向对象基础"></a>python面向对象基础</h1><h2 id="init-方法"><a href="#init-方法" class="headerlink" title="init_()方法"></a><em>init</em>_()方法</h2><p><em>init</em><em>()方法又被称为“构造函数”，它有以下4个特性。<br>（1）该方法很特殊。init前后均有双下画线“__”，它的<u>第一个参数必须是“self”</u>，其意义同其他方法一样，而其他参数用于设置实例的属性，数量不限。该方法不能使用return语句。<br>（2）__init</em>_()方法可在类中的任何位置被定义。<br>（3）在由类创建一个新的实例时，该方法被自动调用一次。即每创建一个实例，该方法都会被调用一次。<br>（4）常用该方法定义实例的属性，但定义实例的属性不局限于该方法。换言之，在其他方法中同样可以定义实例的属性。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>实例方法是类中定义的没有加任何装饰符的一般方法，即不加@classmethod和@staticmethod标记的方法。<strong>如果实例方法有n个形式参数，那么在由类调用时，实际参数必须为n个；而在由实例调用时，实际参数则只需要n-1个，因为第一个参数被系统默认为实例本身。由于这个规定，所以，如果实例方法是无参数函数，那么实例无法调用该方法，只有类可以调用它</strong>。因此，实例方法一般至少需要一个参数self，它代表类的对象（实例）</p>
<h2 id="类方法及其装饰符——-classmethod"><a href="#类方法及其装饰符——-classmethod" class="headerlink" title="类方法及其装饰符——@classmethod"></a>类方法及其装饰符——@classmethod</h2><p>@classmethod是一个函数装饰符，用它装饰的方法不是实例方法，而是类方法。类方法只能被类调用，而不能被实例调用，常被用于方法重载。<br>类方法的第一个参数必须是cls，表示类本身；而实例方法的第一个参数是self，表示该类的一个实例。当类由子类继承时，在调用类方法时，传入的类变量cls的实际参数是子类，而非父类。对于类方法，既可由类调用，也可由类的实例调用。<br>假设类方法有n个形式参数，如果由类调用它，则需要传递的实际参数只能为n-1个，第一个参数默认为类本身；如果由实例调用它，则需要传递的实际参数为n个。</p>
<h2 id="静态方法及其装饰符——-staticmethod"><a href="#静态方法及其装饰符——-staticmethod" class="headerlink" title="静态方法及其装饰符——@staticmethod"></a>静态方法及其装饰符——@staticmethod</h2><p>@staticmethod也是一个函数装饰符，用它装饰的方法是静态方法。静态方法属于类方法，不是实例方法，可将它理解成全局函数，因此可被类或类的实例调用。在调用时，它不会被隐式地传入任何参数。也就是说，静态方法可以没有任何参数。例如，举例5中的静态方法show_help()，它在程序中的作用是实现一个类的简单帮助功能。<br>由于静态方法无内定的隐性参数，所以，调用静态方法时的实际参数个数必须与形式参数个数严格一致。<br>为什么要引入静态方法？有时候需要将一组逻辑上相关的函数放在一个类里，便于组织代码。例如，可将类中被其他多个方法调用的通用方法定义为静态方法。一般而言，如果一个方法不需要使用self参数，它就适合被定义为静态方法。</p>
<h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><p>由类的定义可知，如果要向实例传递参数，则必须定义和使用“构造函数”。由此可见构造函数的重要性！<br>那么，构造函数能否被继承、该如何被继承，子类又如何定义自己的属性呢？<br>解决上述问题的办法是，在定义子类的构造函数中显式地调用父类的构造函数，一般来说有两种方式。</p>
<h3 id="1-继承构造函数的第一种方式"><a href="#1-继承构造函数的第一种方式" class="headerlink" title="1.继承构造函数的第一种方式"></a>1.继承构造函数的第一种方式</h3><p>第一种方式是经典方式，它的形式如下：<br>其中，括号内的第一个参数必须为self ，余下的参数即父类的实例属性。例如，Animal.<strong>init</strong>(self,name,sex,classtype)。<br>要特别提醒的是，当以这种方式调用时，第一个参数self必须被显式传递，它不会被隐式传递，即必须为self，如果被省略，则将报错；其余参数则为父类的实例属性，直接复制父类的实例属性即可。<br>此方式既可被用在单继承场合，也可被用在多继承场合。</p>
<h3 id="2-继承构造函数的第二种方式"><a href="#2-继承构造函数的第二种方式" class="headerlink" title="2.继承构造函数的第二种方式"></a>2.继承构造函数的第二种方式</h3><p>第二种方式为新式方式，它的形式如下：<br>其中，内置函数super(子类,self)用于表示子类的父类，它有两个参数——子类与self；而__init__(参数1,参数2, )为构造函数，与第一种方式不同的是，它不需要self参数，所有参数均为父类的实例属性。<br>例如，super(Bird,self).<strong>init</strong>(name,sex,classtype)，此处，<strong>super()的第一个参数是子类，也就是正在定义构造函数的类；第二个参数必须为self，它代表子类的对象。很显然，此方式过于烦琐</strong>，所幸的是，Python 3将上述方式改为更简洁的形式，但两者完全等效，如下：<br>换言之，Python 3的第二种方式采用以下形式：<br>以下简单地介绍内置函数super()的语法形式。<br>其中，<br>· type：类，是一个子类。<br>· object-or-type：一般为self。</p>
<h3 id="3-关于继承的一个重要特性"><a href="#3-关于继承的一个重要特性" class="headerlink" title="3.关于继承的一个重要特性"></a>3.关于继承的一个重要特性</h3><p>如果只是简单地在<strong>子类中定义一个构造函数而不调用父类的构造函数，那么此方式被称为“重构”</strong>。以此方式定义的子类通常无法继承父类的属性和方法。<strong>但是，如果子类不引用父类的任何属性，那么父类的方法可被继承和引用</strong>。<br>举例25：<br>运行上述程序后，得到如下结果：<br>由举例25可知，虽然子类并没有继承父类的构造函数，但由于父类的方法describe()不引用任何属性，因此它可被子类对象b1所调用。<br>综上所述，在定义子类的构造函数时，一般应继承父类的构造函数，这样子类也能拥有父类的所有属性和方法。<br>子类的构造函数继承父类的构造函数的原理（执行过程）如下：<br>实例化对象a → a调用子类__init__() → 子类__init__()继承父类__init__() → 调用父类__init__()。<br>再举一个单继承的例子，以对类的继承问题进行归纳。通过该例，可进一步理解继承的概念及其有关要点。</p>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的递归遍历_二叉树01</title>
    <url>/2022/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9101/</url>
    <content><![CDATA[<h1 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h1><blockquote>
<p>一看就会，一写就废！</p>
</blockquote>
<p>这次我们要好好谈一谈递归，为什么很多同学看递归算法都是“一看就会，一写就废”。</p>
<p>主要是对递归不成体系，没有方法论，<strong>每次写递归算法 ，都是靠玄学来写代码</strong>，代码能不能编过都靠运气。</p>
<p><strong>本篇将介绍前后中序的递归写法，一些同学可能会感觉很简单，其实不然，我们要通过简单题目把方法论确定下来，有了方法论，后面才能应付复杂的递归。</strong></p>
<p>这里帮助大家确定下来递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p>好了，我们确认了递归的三要素，接下来就来练练手：</p>
<p><strong>以下以前序遍历为例：</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br></pre></td></tr></table></figure>

<p>单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：</p>
<p>前序遍历：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么前序遍历写出来之后，中序和后序遍历就不难理解了，代码如下：</p>
<p>中序遍历：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时大家可以做一做leetcode上三道题目，分别是：</p>
<ul>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历(opens new window)</a></li>
</ul>
<p>可能有同学感觉前后中序遍历的递归太简单了，要打迭代法（非递归），别急，我们明天打迭代法，打个通透！</p>
<h3 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">proTravesal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Travesal(root,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Travesal</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    Travesal(root.left,result);</span><br><span class="line">    Travesal(root.right,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Travesal</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Travesal(root.left,result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    Travesal(root.right,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Travesal</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Travesal(root.left,result);</span><br><span class="line">    Travesal(root.right,result);</span><br><span class="line">    result.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的迭代遍历_二叉树02</title>
    <url>/2022/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9102/</url>
    <content><![CDATA[<h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><blockquote>
<p>听说还可以用非递归的方式</p>
</blockquote>
<p>看完本篇大家可以使用迭代法，再重新解决如下三道leetcode上的题目：</p>
<ul>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历(opens new window)</a></li>
</ul>
<p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p>
<p>我们在<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">栈与队列：匹配问题都是栈的强项 (opens new window)</a>中提到了，<strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。</p>
<h2 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="#前序遍历（迭代法）"></a><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>前序遍历（迭代法）</h2><p>我们先看一下前序遍历。</p>
<p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p>
<p>此时会发现貌似使用迭代法写出前序遍历并不难，确实不难。</p>
<p><strong>此时是不是想改一点前序遍历代码顺序就把中序遍历搞出来了？</strong></p>
<p>其实还真不行！</p>
<p>但接下来，<strong>再用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。</strong></p>
<h2 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="#中序遍历（迭代法）"></a><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>中序遍历（迭代法）</h2><p>为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：</p>
<ol>
<li><strong>处理：将元素放进result数组中</strong></li>
<li><strong>访问：遍历节点</strong></li>
</ol>
<p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p>
<p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p>
<p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" alt="二叉树中序遍历（迭代法）"></p>
<p><strong>中序遍历，可以写出如下代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="#后序遍历（迭代法）"></a><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>后序遍历（迭代法）</h2><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200808200338924.png" alt="前序到后序"></p>
<p><strong>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E6%80%BB%E7%BB%93">#</a>总结</h1><p>此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。</p>
<p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p>
<p>上面这句话，可能一些同学不太理解，建议自己亲手用迭代法，先写出来前序，再试试能不能写出中序，就能理解了。</p>
<p><strong>那么问题又来了，难道 二叉树前后中序遍历的迭代法实现，就不能风格统一么（即前序遍历 改变代码顺序就可以实现中序 和 后序）？</strong></p>
<p>当然可以，这种写法，还不是很好理解，我们将在下一篇文章里重点讲解，敬请期待！</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.pop();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.push(temp.right);</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.push(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">// 先把最左边的节点全都压入栈当中 如果没有左孩子节点了的话 栈弹出一个元素 再看弹出元素的右孩子</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !que.isEmpty()) &#123;</span><br><span class="line">                	<span class="keyword">if</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                         que.push(cur);</span><br><span class="line">                         cur = cur.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                	<span class="keyword">else</span> &#123;</span><br><span class="line">                        cur = que.pop();</span><br><span class="line">                        res.add(cur.val);</span><br><span class="line">                        cur = cur.right;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 中左右 -&gt; 中右左 -&gt; Collections.reverse</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.pop();</span><br><span class="line">            res.add(node.val); </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) que.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) que.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树层序遍历登场_二叉树03</title>
    <url>/2022/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9103%20/</url>
    <content><![CDATA[<h1 id="二叉树层序遍历登场！"><a href="#二叉树层序遍历登场！" class="headerlink" title="二叉树层序遍历登场！"></a>二叉树层序遍历登场！</h1><p>学会二叉树的层序遍历，可以一口气打完以下十题：</p>
<ul>
<li>102.二叉树的层序遍历</li>
<li>107.二叉树的层次遍历II</li>
<li>199.二叉树的右视图</li>
<li>637.二叉树的层平均值</li>
<li>429.N叉树的层序遍历</li>
<li>515.在每个树行中找最大值</li>
<li>116.填充每个节点的下一个右侧节点指针</li>
<li>117.填充每个节点的下一个右侧节点指针II</li>
<li>104.二叉树的最大深度</li>
<li>111.二叉树的最小深度</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnadnltbpjg309603w4qp.gif" alt="我要打十个"></p>
<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">力扣题目链接(opens new window)</a></p>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144842988.png" alt="102.二叉树的层序遍历"></p>
<p>思路：</p>
<p>我们之前讲过了三篇关于二叉树的深度优先遍历的文章：</p>
<ul>
<li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树：前中后序递归法(opens new window)</a></li>
<li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：前中后序迭代法(opens new window)</a></li>
<li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代方式统一写法(opens new window)</a></li>
</ul>
<p>接下来我们再来介绍二叉树的另一种遍历方式：层序遍历。</p>
<p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p>
<p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p>
<p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p>
<p>使用队列实现二叉树广度优先遍历，动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif" alt="102二叉树的层序遍历"></p>
<p>这样就实现了层序从左到右遍历二叉树。</p>
<p>代码如下：<strong>这份代码也可以作为二叉树层序遍历的模板，打十个就靠它了</strong>。</p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; res_01 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                res_01.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) que.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) que.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(res_01);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最大深度_二叉树04</title>
    <url>/2022/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9104/</url>
    <content><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p>
<p><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度"></p>
<p>返回它的最大深度 3 。</p>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="#递归法"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95">#</a>递归法</h2><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p>
<p><strong>而根节点的高度就是二叉树的最大深度</strong>，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。</p>
<p>这一点其实是很多同学没有想清楚的，很多题解同样没有讲清楚。</p>
<p>我先用后序遍历（左右中）来计算树的高度。</p>
<ol>
<li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(treenode* node)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>确定终止条件：如果为空节点的话，就返回0，表示高度为0。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line"><span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line"><span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure>

<p>所以整体c++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(treenode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码精简之后c++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxdepth</span>(root-&gt;left), <span class="built_in">maxdepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>精简之后的代码根本看不出是哪种遍历方式，也看不出递归三部曲的步骤，所以如果对二叉树的操作还不熟练，尽量不要直接照着精简代码来学。</strong></p>
<p>本题当然也可以使用前序，代码如下：(<strong>充分表现出求深度回溯的过程</strong>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getdepth</span><span class="params">(treenode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            depth++;    <span class="comment">// 深度+1</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;left, depth);</span><br><span class="line">            depth--;    <span class="comment">// 回溯，深度-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            depth++;    <span class="comment">// 深度+1</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;right, depth);</span><br><span class="line">            depth--;    <span class="comment">// 回溯，深度-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getdepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>可以看出使用了前序（中左右）的遍历顺序，这才是真正求深度的逻辑！</strong></p>
<p>注意以上代码是为了把细节体现出来，简化一下代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getdepth</span><span class="params">(treenode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getdepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="#迭代法"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>迭代法</h2><p>使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p>
<p>在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200810193056585.png" alt="层序遍历"></p>
<p>所以这道题的迭代法就是一道模板题，可以使用二叉树层序遍历的模板来解决的。</p>
<p>如果对层序遍历还不清楚的话，可以看这篇：<a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">二叉树：层序遍历登场！(opens new window)</a></p>
<p>c++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;treenode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                treenode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>rust:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">max_depth</span>(root: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.<span class="title function_ invoke__">is_none</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_depth</span>: <span class="type">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="built_in">vec!</span>[root.<span class="title function_ invoke__">unwrap</span>()];</span><br><span class="line">        <span class="keyword">while</span> !stack.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num</span> = stack.<span class="title function_ invoke__">len</span>();</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_i</span> <span class="keyword">in</span> <span class="number">0</span>..num&#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">top</span> = stack.<span class="title function_ invoke__">remove</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> top.<span class="title function_ invoke__">borrow_mut</span>().left.<span class="title function_ invoke__">is_some</span>()&#123;</span><br><span class="line">                    stack.<span class="title function_ invoke__">push</span>(top.<span class="title function_ invoke__">borrow_mut</span>().left.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> top.<span class="title function_ invoke__">borrow_mut</span>().right.<span class="title function_ invoke__">is_some</span>()&#123;</span><br><span class="line">                    stack.<span class="title function_ invoke__">push</span>(top.<span class="title function_ invoke__">borrow_mut</span>().right.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max_depth+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max_depth</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们可以顺便解决一下n叉树的最大深度问题</p>
<h1 id="559-n叉树的最大深度"><a href="#559-n叉树的最大深度" class="headerlink" title="#559.n叉树的最大深度"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#_559-n%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">#</a>559.n叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个 n 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>例如，给定一个 3叉树 :</p>
<p><img src="https://img-blog.csdnimg.cn/2021020315313214.png" alt="559.n叉树的最大深度"></p>
<p>我们应返回其最大深度，3。</p>
<p>思路：</p>
<p>依然可以提供递归法和迭代法，来解决这个问题，思路是和二叉树思路一样的，直接给出代码如下：</p>
<h2 id="递归法-1"><a href="#递归法-1" class="headerlink" title="#递归法"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E9%80%92%E5%BD%92%E6%B3%95-2">#</a>递归法</h2><p>c++代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            depth = <span class="built_in">max</span> (depth, <span class="built_in">maxdepth</span>(root-&gt;children[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="#迭代法"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E8%BF%AD%E4%BB%A3%E6%B3%95-2">#</a>迭代法</h2><p>依然是层序遍历，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; node-&gt;children.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[j]) que.<span class="built_in">push</span>(node-&gt;children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="其他语言版本"><a href="#其他语言版本" class="headerlink" title="#其他语言版本"></a><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">#</a>其他语言版本</h1><h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><p>递归法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">   que.offer(root); </span><br><span class="line">   <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line">       res++;</span><br><span class="line">       <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="literal">null</span>) que.offer(node.left);</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="literal">null</span>) que.offer(node.right);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="n叉树的最大深度"><a href="#n叉树的最大深度" class="headerlink" title="n叉树的最大深度"></a>n叉树的最大深度</h3>]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>对称二叉树_二叉树05</title>
    <url>/2022/08/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9105/</url>
    <content><![CDATA[<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144607387.png" alt="101. 对称二叉树"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p><strong>首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！</strong></p>
<p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p>
<p>那么如果比较呢？</p>
<p>比较的是两个子树的里侧和外侧的元素是否相等。如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203144624414.png" alt="101. 对称二叉树1"></p>
<p>那么遍历的顺序应该是什么样的呢？</p>
<p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p>
<p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p>
<p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p>
<p>其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。</p>
<p>说到这大家可能感觉我有点啰嗦，哪有这么多道理，上来就干就完事了。别急，我说的这些在下面的代码讲解中都有身影。</p>
<p>那么我们先来看看递归法的代码应该怎么写。</p>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="#递归法"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95">#</a>递归法</h2><p>递归三部曲</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p>
<p>返回值自然是bool类型。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bool compare(TreeNode* left, TreeNode* right)</span><br></pre></td></tr></table></figure>

<ol>
<li>确定终止条件</li>
</ol>
<p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p>
<p>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
<p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意这里我没有使用else</span></span><br></pre></td></tr></table></figure>

<p>注意上面最后一种情况，我没有使用else，而是elseif， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p>
<ol>
<li>确定单层递归的逻辑</li>
</ol>
<p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内测是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中（逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></table></figure>

<p>如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。</p>
<p>最后递归的C++整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>我给出的代码并不简洁，但是把每一步判断的逻辑都清楚的描绘出来了。</strong></p>
<p>如果上来就看网上各种简洁的代码，看起来真的很简单，但是很多逻辑都掩盖掉了，而题解可能也没有把掩盖掉的逻辑说清楚。</p>
<p><strong>盲目的照着抄，结果就是：发现这是一道“简单题”，稀里糊涂的就过了，但是真正的每一步判断逻辑未必想到清楚。</strong></p>
<p>当然我可以把如上代码整理如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">compare</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>这个代码就很简洁了，但隐藏了很多逻辑，条理不清晰，而且递归三部曲，在这里完全体现不出来。</strong></p>
<p><strong>所以建议大家做题的时候，一定要想清楚逻辑，每一步做什么。把道题目所有情况想到位，相应的代码写出来之后，再去追求简洁代码的效果。</strong></p>
<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="#迭代法"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E8%BF%AD%E4%BB%A3%E6%B3%95">#</a>迭代法</h2><p>这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。</p>
<p>这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（<strong>注意这不是层序遍历</strong>）</p>
<h3 id="使用队列"><a href="#使用队列" class="headerlink" title="#使用队列"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97">#</a>使用队列</h3><p>通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif" alt="101.对称二叉树"></p>
<p>如下的条件判断和递归的逻辑是一样的。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);   <span class="comment">// 将左子树头结点加入队列</span></span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);  <span class="comment">// 将右子树头结点加入队列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;  <span class="comment">// 接下来就要判断这两个树是否相互翻转</span></span><br><span class="line">            TreeNode* leftNode = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* rightNode = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;  <span class="comment">// 左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;left);   <span class="comment">// 加入左节点左孩子</span></span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;right); <span class="comment">// 加入右节点右孩子</span></span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;right);  <span class="comment">// 加入左节点右孩子</span></span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;left);  <span class="comment">// 加入右节点左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="使用栈"><a href="#使用栈" class="headerlink" title="#使用栈"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E4%BD%BF%E7%94%A8%E6%A0%88">#</a>使用栈</h3><p>细心的话，其实可以发现，这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的。</p>
<p>只要把队列原封不动的改成栈就可以了，我下面也给出了代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; st; <span class="comment">// 这里改成了栈</span></span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* leftNode = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* rightNode = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(leftNode-&gt;left);</span><br><span class="line">            st.<span class="built_in">push</span>(rightNode-&gt;right);</span><br><span class="line">            st.<span class="built_in">push</span>(leftNode-&gt;right);</span><br><span class="line">            st.<span class="built_in">push</span>(rightNode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>这次我们又深度剖析了一道二叉树的“简单题”，大家会发现，真正的把题目搞清楚其实并不简单，leetcode上accept了和真正掌握了还是有距离的。</p>
<p>我们介绍了递归法和迭代法，递归依然通过递归三部曲来解决了这道题目，如果只看精简的代码根本看不出来递归三部曲是如果解题的。</p>
<p>在迭代法中我们使用了队列，需要注意的是这不是层序遍历，而且仅仅通过一个容器来成对的存放我们要比较的元素，知道这一本质之后就发现，用队列，用栈，甚至用数组，都是可以的。</p>
<p>如果已经做过这道题目的同学，读完文章可以再去看看这道题目，思考一下，会有不一样的发现！</p>
<h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="#相关题目推荐"></a><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E6%8E%A8%E8%8D%90">#</a>相关题目推荐</h2><p>这两道题目基本和本题是一样的，只要稍加修改就可以AC。</p>
<ul>
<li>100.相同的树</li>
<li>572.另一个树的子树</li>
</ul>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><p>递归法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 此时可以知道目前的左右节点相等</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较左节点的左节点和右节点的右节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">A</span> <span class="operator">=</span> compare(left.left,right.right);</span><br><span class="line">        <span class="comment">// 比较右节点的左节点和左节点的右节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">B</span> <span class="operator">=</span> compare(left.right,right.left);</span><br><span class="line">        <span class="keyword">return</span> A &amp;&amp; B;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	que.offer(root.left);</span><br><span class="line">	que.offer(root.right);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line">		left = que.poll();</span><br><span class="line">		right = que.poll();</span><br><span class="line">		<span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span> || left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        que.offer(left.left);</span><br><span class="line">        que.offer(right.right);</span><br><span class="line">        que.offer(left.right);</span><br><span class="line">        que.offer(right.left);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的所有路径_二叉树07</title>
    <url>/2022/08/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9107/</url>
    <content><![CDATA[<h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: <img src="https://img-blog.csdnimg.cn/2021020415161576.png" alt="257.二叉树的所有路径1"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。</p>
<p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。</p>
<p>前序遍历以及回溯的过程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151702443.png" alt="257.二叉树的所有路径"></p>
<p>我们先使用递归的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="#递归"></a><a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E9%80%92%E5%BD%92">#</a>递归</h2><ol>
<li>递归函数函数参数以及返回值</li>
</ol>
<p>要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result)</span><br></pre></td></tr></table></figure>

<ol>
<li>确定递归终止条件</li>
</ol>
<p>再写递归的时候都习惯了这么写：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (cur == NULL) &#123;</span><br><span class="line">    终止处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。</p>
<p><strong>那么什么时候算是找到了叶子节点？</strong> 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。</p>
<p>所以本题的终止条件是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) &#123;</span><br><span class="line">    终止处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。</p>
<p>再来看一下终止处理的逻辑。</p>
<p>这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，在把这个string 放进 result里。</p>
<p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p>
<p>可能有的同学问了，我看有些人的代码也没有回溯啊。</p>
<p><strong>其实是有回溯的，只不过隐藏在函数调用时的参数赋值里</strong>，下文我还会提到。</p>
<p>这里我们先使用vector结构的path容器来记录路径，那么终止处理逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 遇到叶子节点</span></span><br><span class="line">    string sPath;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 将path里记录的路径转为string格式</span></span><br><span class="line">        sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">        sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 记录最后一个节点（叶子节点）</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(sPath); <span class="comment">// 收集一个路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>确定单层递归逻辑</li>
</ol>
<p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path.push_back(cur-&gt;val);</span><br></pre></td></tr></table></figure>

<p>然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。</p>
<p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (cur-&gt;left) &#123;</span><br><span class="line">    traversal(cur-&gt;left, path, result);</span><br><span class="line">&#125;</span><br><span class="line">if (cur-&gt;right) &#123;</span><br><span class="line">    traversal(cur-&gt;right, path, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。</p>
<p>那么回溯要怎么回溯呢，一些同学会这么写，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">&#125;</span><br><span class="line">path.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>

<p>这个回溯就要很大的问题，我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong>，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。</p>
<p><strong>所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！</strong></p>
<p>那么代码应该这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么本题整体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;   </span><br><span class="line">    List&lt;Integer&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    traversal(root,paths,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">    paths.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuidler</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;paths.size() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            sb.append(paths.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(paths.get(paths.size() - <span class="number">1</span>));</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.left,paths,res);</span><br><span class="line">        paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        traversal(root.right,paths,res);</span><br><span class="line">        paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>完全二叉树_二叉树06</title>
    <url>/2022/08/02/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9106/</url>
    <content><![CDATA[<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>以上方法都是按照普通二叉树来做的，对于完全二叉树特性不了解的同学可以看这篇 <a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于二叉树，你该了解这些！ (opens new window)</a>，这篇详细介绍了各种二叉树的特性。</p>
<p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p>
<p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p>
<p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p>
<p>完全二叉树（一）如图： <img src="https://img-blog.csdnimg.cn/20201124092543662.png" alt="222.完全二叉树的节点个数"></p>
<p>完全二叉树（二）如图： <img src="https://img-blog.csdnimg.cn/20201124092634138.png" alt="222.完全二叉树的节点个数1"></p>
<p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量</p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="keyword">while</span>(leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            leftNode = leftNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            right++;</span><br><span class="line">            rightNode = rightNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (left+<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>左叶子之和_二叉树08</title>
    <url>/2022/08/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9108/</url>
    <content><![CDATA[<h1 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">力扣题目链接(opens new window)</a></p>
<p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151927654.png" alt="404.左叶子之和1"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p>
<p>因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：<strong>如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子</strong></p>
<p>大家思考一下如下图中二叉树，左叶子之和究竟是多少？</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151949672.png" alt="404.左叶子之和"></p>
<p><strong>其实是0，因为这棵树根本没有左叶子！</strong></p>
<p>那么<strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p>
<p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (node-&gt;left != NULL &amp;&amp; node-&gt;left-&gt;left == NULL &amp;&amp; node-&gt;left-&gt;right == NULL) &#123;</span><br><span class="line">    左叶子节点处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。。</p>
<p>递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int</p>
<p>使用题目中给出的函数就可以了。</p>
<ol>
<li>确定终止条件</li>
</ol>
<p>依然是</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (root == NULL) return 0;</span><br></pre></td></tr></table></figure>

<ol>
<li>确定单层递归的逻辑</li>
</ol>
<p>当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"><span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                                                <span class="comment">// 中</span></span><br><span class="line"><span class="type">int</span> midValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;</span><br><span class="line">    midValue = root-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum = midValue + leftValue + rightValue;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>

<p>整体递归代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="type">int</span> midValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// 中</span></span><br><span class="line">            midValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = midValue + leftValue + rightValue;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码精简之后如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> midValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            midValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> midValue + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            value = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + right + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法："><a href="#迭代法：" class="headerlink" title="迭代法："></a>迭代法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		que.offer(root);</span><br><span class="line">		<span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line">			<span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">			<span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>) res += node.left.val;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) que.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) que.offer(node.right);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>找树左下角的值_二叉树09</title>
    <url>/2022/08/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9109/</url>
    <content><![CDATA[<h1 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<p>示例 1:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204152956836.png" alt="513.找树左下角的值"></p>
<p>示例 2:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153017586.png" alt="513.找树左下角的值1"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本地要找出树的最后一行找到最左边的值。此时大家应该想起用层序遍历是非常简单的了，反而用递归的话会比较难一点。</p>
<p>我们依然还是先介绍递归法。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？</p>
<p>没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。</p>
<p>我们来分析一下题目：在树的<strong>最后一行</strong>找到<strong>最左边的值</strong>。</p>
<p>首先要是最后一行，然后是最左边的值。</p>
<p>如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。</p>
<p>如果对二叉树深度和高度还有点疑惑的话，请看：<a href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html">110.平衡二叉树 (opens new window)</a>。</p>
<p>所以要找深度最大的叶子节点。</p>
<p><strong>那么如果找最左边的呢？可以使用前序遍历，这样才先优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。</strong></p>
<p>递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。</p>
<p>本题还需要类里的两个全局变量，maxLen用来记录最大深度，maxleftValue记录最大深度最左节点的数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxLen = INT_MIN;   <span class="comment">// 全局变量 记录最大深度</span></span><br><span class="line"><span class="type">int</span> maxleftValue;       <span class="comment">// 全局变量 最大深度最左节点的数值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> leftLen)</span></span></span><br></pre></td></tr></table></figure>

<p>有的同学可能疑惑，为啥不能递归函数的返回值返回最长深度呢？</p>
<p>其实很多同学都对递归函数什么时候要有返回值，什么时候不能有返回值很迷茫。</p>
<p><strong>如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！</strong></p>
<p>初学者可能对这个结论不太理解，别急，后面我会安排一道题目专门讲递归函数的返回值问题。这里大家暂时先了解一下。</p>
<p>本题我们是要遍历整个树找到最深的叶子节点，需要遍历整棵树，所以递归函数没有返回值。</p>
<ol>
<li>确定终止条件</li>
</ol>
<p>当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftLen &gt; maxLen) &#123;</span><br><span class="line">        maxLen = leftLen;           <span class="comment">// 更新最大深度</span></span><br><span class="line">        maxleftValue = root-&gt;val;   <span class="comment">// 最大深度最左面的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>确定单层递归的逻辑</li>
</ol>
<p>在找最大深度的时候，递归的过程中依然要使用回溯，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">                    <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;left) &#123;   <span class="comment">// 左</span></span><br><span class="line">    leftLen++; <span class="comment">// 深度加一</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, leftLen);</span><br><span class="line">    leftLen--; <span class="comment">// 回溯，深度减一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">    leftLen++; <span class="comment">// 深度加一</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, leftLen);</span><br><span class="line">    leftLen--; <span class="comment">// 回溯，深度减一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        findLeftValue(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findLeftValue</span> <span class="params">(TreeNode root,<span class="type">int</span> left)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; deep) &#123;</span><br><span class="line">                value = root.val;</span><br><span class="line">                deep = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) findLeftValue(root.left,left + <span class="number">1</span>);<span class="comment">// 细节</span></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) findLeftValue(root.right,left + <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跌代法就很简单 就是一个层序遍历 这里就不写了</p>
]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>路径总和_二叉树10</title>
    <url>/2022/08/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9110/</url>
    <content><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h1><p><a href="https://leetcode.cn/problems/path-sum/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: 给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<p><img src="https://img-blog.csdnimg.cn/20210203160355234.png" alt="112.路径总和1"></p>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我们要遍历从根节点到叶子节点的的路径看看总和是不是目标和。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树</p>
<ol>
<li>确定递归函数的参数和返回类型</li>
</ol>
<p>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。</p>
<p>再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li>
</ul>
<p>而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2021020316051216.png" alt="112.路径总和"></p>
<p>图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。</p>
<p>所以代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bool traversal(treenode* cur, int count)   // 注意函数的返回类型</span><br></pre></td></tr></table></figure>

<ol>
<li>确定终止条件</li>
</ol>
<p>首先计数器如何统计这一条路径的和呢？</p>
<p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p>
<p>如果最后count &#x3D;&#x3D; 0，同时到了叶子节点的话，说明找到了目标和。</p>
<p>如果遍历到了叶子节点，count不为0，就是没找到。</p>
<p>递归终止条件代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == 0) return true; // 遇到叶子节点，并且计数为0</span><br><span class="line">if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return false; // 遇到叶子节点而没有找到合适的边，直接返回</span><br></pre></td></tr></table></figure>

<ol>
<li>确定单层递归的逻辑</li>
</ol>
<p>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。</p>
<p>递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count - cur-&gt;left-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count - cur-&gt;right-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。</p>
<p>回溯隐藏在<code>traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)</code>这里， 因为把<code>count - cur-&gt;left-&gt;val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p>
<p>为了把回溯的过程体现出来，可以改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">    count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">    count -= cur-&gt;right-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="整体代码如下："><a href="#整体代码如下：" class="headerlink" title="整体代码如下："></a>整体代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> Isfind(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Isfind</span><span class="params">(TreeNode root,<span class="type">int</span> count)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">         count -= root.val;</span><br><span class="line">         <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> Isfind(root.left,count - root.val);</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> Isfind(root.right,count - root.val);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代法："><a href="#迭代法：" class="headerlink" title="迭代法："></a>迭代法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	Deque&lt;TreeNode&gt; que0 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; que1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que0.push(root);</span><br><span class="line">        que1.push(root.val);</span><br><span class="line">        <span class="keyword">while</span>(!que0.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que0.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> que1.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; sum == targeSum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) &#123;</span><br><span class="line">                que0.push(node.left);</span><br><span class="line">                que1.push(sum+node.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                que0.push(node.right);</span><br><span class="line">                que1.push(sum+node.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>从中序与后序遍历序列构造二叉树_二叉树11</title>
    <url>/2022/08/07/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9111/</url>
    <content><![CDATA[<h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接(opens new window)</a></p>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意: 你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder &#x3D; [9,3,15,20,7] 后序遍历 postorder &#x3D; [9,15,7,20,3] 返回如下的二叉树：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154316774.png" alt="106. 从中序与后序遍历序列构造二叉树1"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。</p>
<p>如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。</p>
<p>流程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树"></p>
<p>那么代码应该怎么写呢？</p>
<p>说到一层一层切割，就应该想到了递归。</p>
<p>来看一下一共分几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;  <span class="comment">// 方便根据数值查找位置</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先把中序遍历的所有元素位置存入map</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++) &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接返回调用函数</span></span><br><span class="line">        <span class="keyword">return</span> findNode(inorder,<span class="number">0</span>,inorder.length,postorder,<span class="number">0</span>,postorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> begin01,<span class="type">int</span> end01,<span class="type">int</span>[] postorder,<span class="type">int</span> begin02,<span class="type">int</span> end02)</span> &#123;</span><br><span class="line">        <span class="comment">// 遵循左闭右开的原则</span></span><br><span class="line">        <span class="keyword">if</span>(begin01 &gt;= end01 || begin02 &gt;= end02) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 找到在中序的数组中的元素 进行或许的切割</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> map.get(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">LenOfleft</span> <span class="operator">=</span> target - begin01; <span class="comment">// 左边数组的长度</span></span><br><span class="line">        <span class="comment">// 切割左数组</span></span><br><span class="line">        root.left = findNode(inorder,begin01,target,postorder,begin02,begin02+LenOfleft);</span><br><span class="line">        root.right = fintNode(inorder,target+<span class="number">1</span>,end01,postorder,begin02+LenOfleft,end02-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">相关题</a></p>
]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>合并二叉树_二叉树12</title>
    <url>/2022/08/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9112/</url>
    <content><![CDATA[<h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">力扣题目链接(opens new window)</a></p>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153634809.png" alt="617.合并二叉树"></p>
<p>注意: 合并必须从两个树的根节点开始。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？</p>
<p>其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="#递归"></a><a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92">#</a>递归</h2><p>二叉树使用递归，就要想使用前中后哪种遍历方式？</p>
<p><strong>本题使用哪种遍历都是可以的！</strong></p>
<p>我们下面以前序遍历为例。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjjq8h16g30e20cwnpd.gif" alt="617.合并二叉树"></p>
<p>那么我们来按照递归三部曲来解决：</p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong></li>
</ol>
<p>首先那么要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>确定终止条件：</strong></li>
</ol>
<p>因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 &#x3D;&#x3D; NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。</p>
<p>反过来如果t2 &#x3D;&#x3D; NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2</span><br><span class="line">if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>确定单层递归的逻辑：</strong></li>
</ol>
<p>单层递归的逻辑就比较好些了，这里我们用重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。</p>
<p>那么单层递归中，就要把两棵树的元素加到一起。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">t1-&gt;val += t2-&gt;val;</span><br></pre></td></tr></table></figure>

<p>接下来t1 的左子树是：合并 t1左子树 t2左子树之后的左子树。</p>
<p>t1 的右子树：是 合并 t1右子树 t2右子树之后的右子树。</p>
<p>最终t1就是合并之后的根节点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合并二叉树，也是二叉树操作的经典题目，如果没有接触过的话，其实并不简单，因为我们习惯了操作一个二叉树，一起操作两个二叉树，还会有点懵懵的。</p>
<p>这不是我们第一次操作两棵二叉树了，在<a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html">二叉树：我对称么？ (opens new window)</a>中也一起操作了两棵二叉树。</p>
<p>迭代法中，一般一起操作两个树都是使用队列模拟类似层序遍历，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。</p>
<p>最后拓展中，我给了一个操作指针的野路子，大家随便看看就行了，如果学习C++的话，可以在去研究研究。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><p>递归法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">	<span class="keyword">if</span>(root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">	root1.val += root2.val;</span><br><span class="line">    root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">    root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的最小绝对差_二叉树14</title>
    <url>/2022/08/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9114/</url>
    <content><![CDATA[<h1 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">力扣题目链接(opens new window)</a></p>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20201014223400123.png" alt="530二叉搜索树的最小绝对差"></p>
<p>提示：树中至少有 2 个节点。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p>
<p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p>
<p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p>
<p><strong>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</strong></p>
<p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 统计有序数组的最小差值</span></span><br><span class="line">            result = <span class="built_in">min</span>(result, vec[i] - vec[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p>
<p>需要用一个pre节点记录一下cur节点的前一个节点。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153247458.png" alt="530.二叉搜索树的最小绝对差"></p>
<p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> result = INT_MAX;</span><br><span class="line">TreeNode* pre;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left);   <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span>)&#123;       <span class="comment">// 中</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    pre = cur; <span class="comment">// 记录前一个</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是不是看上去也并不复杂！</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>看过这两篇<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：听说递归能做的，栈也能做！ (opens new window)</a>，<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代方式的写法就不能统一一下么？ (opens new window)</a>文章之后，不难写出两种中序遍历的迭代法。</p>
<p>下面我给出其中的一种中序遍历的迭代法，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;              <span class="comment">// 中</span></span><br><span class="line">                    result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。</strong></p>
<p>同时要学会在递归遍历的过程中如何记录前后两个指针，这也是一个小技巧，学会了还是很受用的。</p>
<p>后面我将继续介绍一系列利用二叉搜索树特性的题目。</p>
<p>Java代码如下：</p>
<p>递归法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">TreeNode pre;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	pre = <span class="literal">null</span>;</span><br><span class="line">	travesal(root);</span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travesal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	travesal(root.left)</span><br><span class="line">	<span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; min &gt; Math.abs(root.val - pre.val)) &#123;</span><br><span class="line">		min = Math.abs(root.val - pre.val);</span><br><span class="line">	&#125;</span><br><span class="line">	pre = root;</span><br><span class="line">	travesal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(cur !=<span class="literal">null</span> || !que.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            que.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = que.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; min &gt; Math.abs(pre.val - cur.val)) &#123;</span><br><span class="line">                min = Math.abs(pre.val - cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉搜索树_二叉树13</title>
    <url>/2022/08/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9113/</url>
    <content><![CDATA[<h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210203144334501.png" alt="98.验证二叉搜索树"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p>
<p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">traversal</span>(root);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">    <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); <span class="comment">// 不加这句在leetcode上也可以过，但最好加上</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。</p>
<p>这道题目比较容易陷入两个陷阱：</p>
<ul>
<li>陷阱1</li>
</ul>
<p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。</p>
<p>写出了类似这样的代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。</strong>所以以上代码的判断逻辑是错误的。</p>
<p>例如： [10,5,15,null,null,6,20] 这个case：</p>
<p><img src="https://img-blog.csdnimg.cn/20200812191501419.png" alt="二叉搜索树"></p>
<p>节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！</p>
<ul>
<li>陷阱2</li>
</ul>
<p>样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。</p>
<p>此时可以初始化比较元素为longlong的最小值。</p>
<p>问题可以进一步演进：如果样例中根节点的val 可能是longlong的最小值 又要怎么办呢？文中会解答。</p>
<p>了解这些陷阱之后我们来看一下代码应该怎么写：</p>
<p>递归三部曲：</p>
<ul>
<li>确定递归函数，返回值以及参数</li>
</ul>
<p>要定义一个longlong的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有int最小值，所以定义为longlong的类型，初始化为longlong最小值。</p>
<p>注意递归函数要有bool类型的返回值， 我们在<a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有bool类型的返回值。</p>
<p>其实本题是同样的道理，我们在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值</span><br><span class="line">bool isValidBST(TreeNode* root)</span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>如果是空节点 是不是二叉搜索树呢？</p>
<p>是的，二叉搜索树也可以为空！</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (root == NULL) return true;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>中序遍历，一直更新maxVal，一旦发现maxVal &gt;&#x3D; root-&gt;val，就返回false，注意元素相同时候也要返回false。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><p>递归法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode max;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">   <span class="keyword">if</span>(!left) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(max != <span class="literal">null</span> &amp;&amp; max.val &gt;= root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	max = root;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBst(root.right);</span><br><span class="line">	<span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span> || !que.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            que.push(cur);</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> que.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur.val &gt;= pre.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先_二叉树15</title>
    <url>/2022/08/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9115/</url>
    <content><![CDATA[<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://img-blog.csdnimg.cn/20201016173414722.png" alt="236. 二叉树的最近公共祖先"></p>
<p>示例 1: 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p>示例 2: 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p>
<p>那么二叉树如何可以自底向上查找呢？</p>
<p>回溯啊，二叉树回溯的过程就是从低到上。</p>
<p>后序遍历就是天然的回溯过程，最先处理的一定是叶子节点。</p>
<p>接下来就看如何判断一个节点是节点q和节点p的公共公共祖先呢。</p>
<p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong></p>
<p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong></p>
<p>使用后序遍历，回溯的过程，就是从低向上遍历节点，一旦发现满足第一种情况的节点，就是最近公共节点了。</p>
<p><strong>但是如果p或者q本身就是最近公共祖先呢？其实只需要找到一个节点是p或者q的时候，直接返回当前节点，无需继续递归子树。如果接下来的遍历中找到了后继节点满足第一种情况则修改返回值为后继节点，否则，继续返回已找到的节点即可。为什么满足第一种情况的节点一定是p或q的后继节点呢?大家可以仔细思考一下。</strong></p>
<p>递归三部曲：</p>
<ul>
<li>确定递归函数返回值以及参数</li>
</ul>
<p>需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。</p>
<p>但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode * ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)</span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>如果找到了 节点p或者q，或者遇到空节点，就返回。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (root == q || root == p || root == NULL) return root;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层递归逻辑</li>
</ul>
<p>值得注意的是 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。</p>
<p>我们在<a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>中说了 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！</p>
<p>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</p>
<p>搜索一条边的写法：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (递归函数(root-&gt;left)) return ;</span><br><span class="line"></span><br><span class="line">if (递归函数(root-&gt;right)) return ;</span><br></pre></td></tr></table></figure>

<p>搜索整个树写法：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure>

<p>看出区别了没？</p>
<p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong>。</p>
<p>那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2021020415105872.png" alt="236.二叉树的最近公共祖先"></p>
<p>就像图中一样直接返回7，多美滋滋。</p>
<p>但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。</p>
<p>因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure>

<p>所以此时大家要知道我们要遍历整棵树。知道这一点，对本题就有一定深度的理解了。</p>
<p>那么先用left和right接住左子树和右子树的返回值，代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br></pre></td></tr></table></figure>

<p><strong>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解</strong></p>
<p><strong>如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然</strong>。</p>
<p>这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢？</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p>
<p>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</p>
<p>这里点也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p>
<p>那么如果left和right都为空，则返回left或者right都是可以的，也就是返回空。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span>  &#123; <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么寻找最小公共祖先，完整流程图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/202102041512582.png" alt="236.二叉树的最近公共祖先2"></p>
<p><strong>从图中，大家可以看到，我们是如何回溯遍历整棵二叉树，将结果返回给头结点的！</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题目刷过的同学未必真正了解这里面回溯的过程，以及结果是如何一层一层传上去的。</p>
<p><strong>那么我给大家归纳如下三点</strong>：</p>
<ol>
<li>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。</li>
<li>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</li>
<li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</li>
</ol>
<p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p>
<p>本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span>(p == root || q == root || root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    	<span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">   		<span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    	<span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数组在哈希表中的应用</title>
    <url>/2022/07/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="数组在哈希表中的应用"><a href="#数组在哈希表中的应用" class="headerlink" title="数组在哈希表中的应用"></a>数组在哈希表中的应用</h1><p><a href="https://leetcode.cn/problems/valid-anagram/">题目链接</a></p>
<h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><p>伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名：String t,string s</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">hash</span>[<span class="number">26</span>] <span class="number">0</span>~<span class="number">25</span> -&gt; a~z</span><br><span class="line"><span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(t)</span>:</span><br><span class="line">	hash[t[i] - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j in <span class="title function_">range</span><span class="params">(s)</span>:</span><br><span class="line">	hash[s[i] - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:hash)&#123;</span><br><span class="line">	<span class="keyword">if</span> i!=<span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除二叉搜索树中的节点_二叉树16</title>
    <url>/2022/08/09/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E4%BA%8C%E5%8F%89%E6%A0%9116/</url>
    <content><![CDATA[<h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">力扣题目链接(opens new window)</a></p>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。</p>
<p>示例:</p>
<p><img src="https://img-blog.csdnimg.cn/20201020171048265.png" alt="450.删除二叉搜索树中的节点"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>搜索树的节点删除要比节点增加复杂的多，有很多情况需要考虑，做好心里准备。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归三部曲：</p>
<ul>
<li>确定递归函数参数以及返回值</li>
</ul>
<p>说道递归函数的返回值，在<a href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html">二叉树：搜索树中的插入操作 (opens new window)</a>中通过递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">TreeNode* deleteNode(TreeNode* root, int key)</span><br></pre></td></tr></table></figure>

<p>1</p>
<ul>
<li>确定终止条件</li>
</ul>
<p>遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (root == nullptr) return root;</span><br></pre></td></tr></table></figure>

<p>1</p>
<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>这里就把二叉搜索树中删除节点遇到的情况都搞清楚。</p>
<p>有以下五种情况：</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p>第五种情况有点难以理解，看下面动画：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p>
<p>动画中棵二叉搜索树中，删除元素7， 那么删除节点（元素7）的左孩子就是5，删除节点（元素7）的右子树的最左面节点是元素8。</p>
<p>将删除节点（元素7）的左孩子放到删除节点（元素7）的右子树的最左面节点（元素8）的左孩子上，就是把5为根节点的子树移到了8的左孩子的位置。</p>
<p>要删除的节点（元素7）的右孩子（元素9）为新的根节点。.</p>
<p>这样就完成删除元素7的逻辑，最好动手画一个图，尝试删除一个节点试试。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> delete(root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">delete</span><span class="params">(TreeNode root,<span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(root.val &gt; key) root.left = delete(root.left,key);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key) <span class="type">root</span> <span class="variable">right</span> <span class="operator">=</span> delete(root.right,key);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.right;</span><br><span class="line">		<span class="keyword">while</span>(tmp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			tmp = tmp.left;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp.left = root.left;</span><br><span class="line">		<span class="keyword">return</span> root.right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。</p>
<p><strong>因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整</strong>。</p>
<p>这里我们依然使用递归函数的返回值来完成把节点从二叉树中移除的操作。</p>
<p><strong>这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚</strong>。</p>
<p>而且就算想清楚了，对应的代码也未必可以写出来，所以<strong>这道题目即考察思维逻辑，也考察代码能力</strong>。</p>
<p>递归中我给出了两种写法，推荐大家学会第一种（利用搜索树的特性）就可以了，第二种递归写法其实是比较绕的。</p>
<p>最后我也给出了相应的迭代法，就是模拟递归法中的逻辑来删除节点，但需要一个pre记录cur的父节点，方便做删除操作。</p>
<p>迭代法其实不太容易写出来，所以如果是初学者的话，彻底掌握第一种递归写法就够了</p>
]]></content>
      <categories>
        <category>算法简史</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A801/</url>
    <content><![CDATA[<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接(opens new window)</a></p>
<p>题意：给定两个数组，编写一个函数来计算它们的交集。</p>
<p><img src="https://s2.loli.net/2022/07/22/x4yNsaYlTSwroHL.png" alt="349. 两个数组的交集"></p>
<p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>关于本题，我录制了讲解视频：<a href="https://www.bilibili.com/video/BV1ba411S7wu">学透哈希表，set使用有技巧！Leetcode：349. 两个数组的交集 (opens new window)</a>，看视频配合题解，事半功倍。</p>
<p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p>
<p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</strong></p>
<p>这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。</p>
<p>那么用数组来做哈希表也是不错的选择，例如<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词(opens new window)</a></p>
<p>但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p>
<p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p>
<p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p>
<p>此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：</p>
<ul>
<li>std::set</li>
<li>std::multiset</li>
<li>std::unordered_set</li>
</ul>
<p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p>
<p>思路如图所示：</p>
<p><img src="https://s2.loli.net/2022/07/22/6RG3uhyqpUTOLN8.png" alt="set哈希法"></p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    		<span class="comment">// 通过两个hashSet 分别来存储nums1中出现的元素，返回结果</span></span><br><span class="line">    		Set&lt;Integer&gt; hash1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    		Set&lt;Integer&gt; hash2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> i:nums1) &#123;</span><br><span class="line">                hash1.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> i:nums2) &#123;</span><br><span class="line">                <span class="keyword">if</span>(hash1.contains(i)) &#123;</span><br><span class="line">                    hash2.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//将结果几何转为数组</span></span><br><span class="line">        	<span class="keyword">return</span> hash2.stream().mapToInt(x -&gt; x).toArray();;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐数_哈希表</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A802/</url>
    <content><![CDATA[<h1 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1><p><a href="https://leetcode.cn/problems/happy-number/">力扣题目链接(opens new window)</a></p>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p><strong>示例：</strong></p>
<p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 &#x3D; 82<br>8^2 + 2^2 &#x3D; 68<br>6^2 + 8^2 &#x3D; 100<br>1^2 + 0^2 + 0^2 &#x3D; 1</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目看上去貌似一道数学问题，其实并不是！</p>
<p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p>
<p>正如：<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！ (opens new window)</a>中所说，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p>
<p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<p>判断sum是否重复出现就可以使用unordered_set。</p>
<p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">    	// 构建哈希表 来存储每一次的sum 如果sum重复出现即为死循环 就退出</span><br><span class="line">    	Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();</span><br><span class="line">    	</span><br><span class="line">    	while(n!=1 &amp;&amp; !hashSet.contains(n))&#123;</span><br><span class="line">    		hashSet.add(n);</span><br><span class="line">    	    int n = getNextNumber(n);</span><br><span class="line">    	&#125;</span><br><span class="line">    	return n == 1;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getNextNumber(int n) &#123;</span><br><span class="line">    	int res = 0;</span><br><span class="line">    	while(n&gt;0) &#123;</span><br><span class="line">    		int tail = n % 10;</span><br><span class="line">    		res += tail*tail;</span><br><span class="line">    		int n /= 10;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和_哈希表</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A803/</url>
    <content><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<p>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</p>
<p>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</p>
<p>所以返回 [0, 1]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>建议看一下我录的这期视频：<a href="https://www.bilibili.com/video/BV1aT41177mK">梦开始的地方，Leetcode：1.两数之和 (opens new window)</a>，结合本题解来学习，事半功倍。</p>
<p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p>
<p>建议大家做这道题目之前，先做一下这两道</p>
<ul>
<li><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词(opens new window)</a></li>
<li><a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集(opens new window)</a></li>
</ul>
<p><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词 (opens new window)</a>这道题目是用数组作为哈希表来解决哈希问题，<a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集 (opens new window)</a>这道题目是通过set作为哈希表来解决哈希问题。</p>
<p>首先我在强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p>
<p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p>
<p>那么我们就应该想到使用哈希法了。</p>
<p>因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p>再来看一下使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
<li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li>
</ul>
<p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。</p>
<p>C++中map，有三种类型：</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。</p>
<p>同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 更多哈希表的理论知识请看<a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！ (opens new window)</a>。</p>
<p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</strong> 使用其他语言的录友注意了解一下自己所用语言的数据结构就行。</p>
<p>接下来需要明确两点：</p>
<ul>
<li><strong>map用来做什么</strong></li>
<li><strong>map中key和value分别表示什么</strong></li>
</ul>
<p>map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下表，这样才能找到与当前元素相匹配的（也就是相加等于target）</p>
<p>接下来是map中key和value分别表示什么。</p>
<p>这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。</p>
<p>那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。</p>
<p>所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下表}。</p>
<p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素比配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p>
<p>过程如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一"></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202708.png" alt="过程二"></p>
<h3 id="java代码："><a href="#java代码：" class="headerlink" title="java代码："></a>java代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    	<span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">		Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">			temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp)) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                resp[<span class="number">1</span>] = map.get(temp);</span><br><span class="line">            &#125;</span><br><span class="line">			map.put(nums[i],i);</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>赎金信_哈希表</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A805/</url>
    <content><![CDATA[<h1 id="赎金信-哈希表"><a href="#赎金信-哈希表" class="headerlink" title="赎金信_哈希表"></a>赎金信_哈希表</h1><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接(opens new window)</a></p>
<p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<p><strong>注意：</strong></p>
<p>你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目和<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词 (opens new window)</a>很像，<a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242.有效的字母异位词 (opens new window)</a>相当于求 字符串a 和 字符串b 是否可以相互组成 ，而这道题目是求 字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。</p>
<p>本题判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，但是这里需要注意两点。</p>
<ul>
<li>第一点“为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思” 这里<em>说明杂志里面的字母不可重复使用。</em></li>
<li>第二点 “你可以假设两个字符串均只含有小写字母。” <em>说明只有小写字母</em>，这一点很重要</li>
</ul>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>那么第一个思路其实就是暴力枚举了，两层for循环，不断去寻找，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 在ransomNote中找到和magazine相同的字符</span></span><br><span class="line">                <span class="keyword">if</span> (magazine[i] == ransomNote[j]) &#123;</span><br><span class="line">                    ransomNote.<span class="built_in">erase</span>(ransomNote.<span class="built_in">begin</span>() + j); <span class="comment">// ransomNote删除这个字符</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果ransomNote为空，则说明magazine的字符可以组成ransomNote</span></span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">length</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里时间复杂度是比较高的，而且里面还有一个字符串删除也就是erase的操作，也是费时的，当然这段代码也可以过这道题。</p>
<h3 id="哈希解法"><a href="#哈希解法" class="headerlink" title="哈希解法"></a>哈希解法</h3><p>因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。</p>
<p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p>
<p>依然是数组在哈希法中的应用。</p>
<p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">   			<span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">   			<span class="keyword">while</span>(<span class="type">char</span> c:magazine) &#123;</span><br><span class="line">   				nums[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">   			&#125;</span><br><span class="line">   			<span class="keyword">while</span>(<span class="type">char</span> c:ransomNote) &#123;</span><br><span class="line">   				nums[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">   			&#125;</span><br><span class="line">   			<span class="keyword">while</span>(<span class="type">int</span> i:nums) &#123;</span><br><span class="line">   				<span class="keyword">if</span>(i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和_哈希表</title>
    <url>/2022/07/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%93%88%E5%B8%8C%E8%A1%A806/</url>
    <content><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接(opens new window)</a></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>注意[0， 0， 0， 0] 这组数据</strong></p>
<h3 id="哈希解法"><a href="#哈希解法" class="headerlink" title="哈希解法"></a>哈希解法</h3><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。</p>
<p>把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。</p>
<p>去重的过程不好处理，有很多小细节，如果在面试中很难想到位。</p>
<p>时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。</p>
<p>大家可以尝试使用哈希法写一写，就知道其困难的程度了。</p>
<p>哈希法C++代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[j], c = -(a + b)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">//三元组元素a去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">2</span></span><br><span class="line">                        &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]</span><br><span class="line">                        &amp;&amp; nums[j<span class="number">-1</span>] == nums[j<span class="number">-2</span>]) &#123; <span class="comment">// 三元组元素b去重</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> c = <span class="number">0</span> - (nums[i] + nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (set.<span class="built_in">find</span>(c) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], c&#125;);</span><br><span class="line">                    set.<span class="built_in">erase</span>(c);<span class="comment">// 三元组元素c去重</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    set.<span class="built_in">insert</span>(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。</p>
<p>而且使用哈希法 在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也是可以在leetcode上通过，但是程序的执行时间依然比较长 。</p>
<p>接下来我来介绍另一个解法：双指针法，<strong>这道题目使用双指针法 要比哈希法高效一些</strong>，那么来讲解一下具体实现的思路。</p>
<p>动画效果如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p>
<p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p>
<p>依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于 a &#x3D; nums[i]，b &#x3D; nums[left]，c &#x3D; nums[right]。</p>
<p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p>
<p>时间复杂度：O(n^2)。</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        	List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">HashList</span>&lt;&gt;();</span><br><span class="line">        	Arrays.sort(nums);</span><br><span class="line">    		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    		<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">    				left = i+<span class="number">1</span>;</span><br><span class="line">    				right = nums.length-<span class="number">1</span>;</span><br><span class="line">    				<span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">    					temp = nums[i] + nums[left] + nums[right];</span><br><span class="line">    					<span class="keyword">if</span>(temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                            left++;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">    				&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>哈希表</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串_字符串01</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B201/</url>
    <content><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接(opens new window)</a></p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p>
<p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先说一说题外话：</p>
<p>对于这道题目一些同学直接用C++里的一个库函数 reverse，调一下直接完事了， 相信每一门编程语言都有这样的库函数。</p>
<p>如果这么做题的话，这样大家不会清楚反转字符串的实现原理了。</p>
<p>但是也不是说库函数就不能用，是要分场景的。</p>
<p>如果在现场面试中，我们什么时候使用库函数，什么时候不要用库函数呢？</p>
<p><strong>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</strong></p>
<p>毕竟面试官一定不是考察你对库函数的熟悉程度， 如果使用python和java 的同学更需要注意这一点，因为python、java提供的库函数十分丰富。</p>
<p><strong>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</strong></p>
<p>建议大家平时在leetcode上练习算法的时候本着这样的原则去练习，这样才有助于我们对算法的理解。</p>
<p>不要沉迷于使用库函数一行代码解决题目之类的技巧，不是说这些技巧不好，而是说这些技巧可以用来娱乐一下。</p>
<p>真正自己写的时候，要保证理解可以实现是相应的功能。</p>
<p>接下来再来讲一下如何解决反转字符串的问题。</p>
<p>大家应该还记得，我们已经讲过了<a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">206.反转链表 (opens new window)</a>。</p>
<p>在反转链表中，使用了双指针的方法。</p>
<p>那么反转字符串依然是使用双指针的方法，只不过对于字符串的反转，其实要比链表简单一些。</p>
<p>因为字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。</p>
<p>如果对数组和链表原理不清楚的同学，可以看这两篇，<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于链表，你该了解这些！ (opens new window)</a>，<a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">必须掌握的数组理论知识 (opens new window)</a>。</p>
<p>对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p>
<p>以字符串<code>hello</code>为例，过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp0fvi91pfg30de0akwnq.gif" alt="344.反转字符串"></p>
<p>不难写出如下C++代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>()/<span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环里只要做交换s[i] 和s[j]操作就可以了，那么我这里使用了swap 这个库函数。大家可以使用。</p>
<p>因为相信大家都知道交换函数如何实现，而且这个库函数仅仅是解题中的一部分， 所以这里使用库函数也是可以的。</p>
<p>swap可以有两种实现。</p>
<p>一种就是常见的交换数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp = s[i];</span><br><span class="line">s[i] = s[j];</span><br><span class="line">s[j] = tmp;</span><br></pre></td></tr></table></figure>

<p>一种就是通过位运算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s[i] ^= s[j];</span><br><span class="line">s[j] ^= s[i];</span><br><span class="line">s[i] ^= s[j];</span><br></pre></td></tr></table></figure>

<p>这道题目还是比较简单的，但是我正好可以通过这道题目说一说在刷题的时候，使用库函数的原则。</p>
<p>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</p>
<p>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</p>
<p>本着这样的原则，我没有使用reverse库函数，而使用swap库函数。</p>
<p><strong>在字符串相关的题目中，库函数对大家的诱惑力是非常大的，因为会有各种反转，切割取词之类的操作</strong>，这也是为什么字符串的库函数这么丰富的原因。</p>
<p>相信大家本着我所讲述的原则来做字符串相关的题目，在选择库函数的角度上会有所原则，也会有所收获。</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    	<span class="keyword">while</span>(i&lt;j) &#123;</span><br><span class="line">    		temp = s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格_字符串03</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B203/</url>
    <content><![CDATA[<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">力扣题目链接(opens new window)</a></p>
<p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1： 输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果想把这道题目做到极致，就不要只用额外的辅助空间了！</p>
<p>首先扩充数组到每个空格替换成”%20”之后的大小。</p>
<p>然后从后向前替换空格，也就是双指针法，过程如下：</p>
<p>i指向新长度的末尾，j指向旧长度的末尾。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1go6qmevhgpg20du09m4qp.gif" alt="替换空格"></p>
<p>有同学问了，为什么要从后向前填充，从前向后填充不行么？</p>
<p>从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。</p>
<p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p>
<p>这么做有两个好处：</p>
<ol>
<li>不用申请新数组。</li>
<li>从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。</li>
</ol>
<p>时间复杂度，空间复杂度均超过100%的用户。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.png" alt="img"></p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="type">char</span> c:s.toCharArray()) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">    		sb.append(<span class="string">&#x27;   &#x27;</span>)</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">    s += sb.toString();</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            arr[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            arr[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            arr[right] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        left--;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串II_字符串02</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B202/</url>
    <content><![CDATA[<h1 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “bacdfeg”</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目其实也是模拟，实现题目中规定的反转规则就可以了。</p>
<p>一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。</p>
<p>其实在遍历字符串的过程中，只要让 i +&#x3D; (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p>
<p>因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。</p>
<p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p>
<p>性能如下： <img src="https://code-thinking.cdn.bcebos.com/pics/541_%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.png" alt="img"></p>
<p>那么这里具体反转的逻辑我们要不要使用库函数呢，其实用不用都可以，使用reverse来实现反转也没毛病，毕竟不是解题关键部分。</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length;i+=<span class="number">2</span>*k) &#123;</span><br><span class="line">            start = i;</span><br><span class="line">            end = Math.min(start+k-<span class="number">1</span>,arr.length-<span class="number">1</span>);<span class="comment">// 关键代码</span></span><br><span class="line">            reverse(arr,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr,<span class="type">int</span> start,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end) &#123;</span><br><span class="line">            temp = arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转字符串里的单词_字符串04</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B204/</url>
    <content><![CDATA[<h1 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h1><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p>
<p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：<br>输入: “a good  example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>这道题目可以说是综合考察了字符串的多种操作。</strong></p>
<p>一些同学会使用split库函数，分隔单词，然后定义一个新的string字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。</p>
<p>所以这里我还是提高一下本题的难度：<strong>不要使用辅助空间，空间复杂度要求为O(1)。</strong></p>
<p>不能使用辅助空间之后，那么只能在原字符串上下功夫了。</p>
<p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p>
<p>所以解题思路如下：</p>
<ul>
<li>移除多余空格</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ul>
<p>举个例子，源字符串为：”the sky is blue “</p>
<ul>
<li>移除多余空格 : “the sky is blue”</li>
<li>字符串反转：”eulb si yks eht”</li>
<li>单词反转：”blue is sky the”</li>
</ul>
<p>这样我们就完成了翻转字符串里的单词。</p>
<p>思路很明确了，我们说一说代码的实现细节，就拿移除多余空格来说，一些同学会上来写如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>] &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除字符串最后面的空格</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除字符串最前面的空格</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很简单，从前向后遍历，遇到空格了就erase。</p>
<p>如果不仔细琢磨一下erase的时间复杂度，还以为以上的代码是O(n)的时间复杂度呢。</p>
<p>想一下真正的时间复杂度是多少，一个erase本来就是O(n)的操作，erase实现原理题目：<a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">数组：就移除个元素很难么？ (opens new window)</a>，最优的算法来移除元素也要O(n)。</p>
<p>erase操作上面还套了一个for循环，那么以上代码移除冗余空格的代码时间复杂度为O(n^2)。</p>
<p>那么使用双指针法来去移除空格，最后resize（重新设置）一下字符串的大小，就可以做到O(n)的时间复杂度。</p>
<p>如果对这个操作比较生疏了，可以再看一下这篇文章：<a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">数组：就移除个元素很难么？ (opens new window)</a>是如何移除元素的。</p>
<p>那么使用双指针来移除冗余空格代码如下： fastIndex走的快，slowIndex走的慢，最后slowIndex就标记着移除多余空格后新字符串的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>, fastIndex = <span class="number">0</span>; <span class="comment">// 定义快指针，慢指针</span></span><br><span class="line">    <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; fastIndex &lt; s.<span class="built_in">size</span>() &amp;&amp; s[fastIndex] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        fastIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; fastIndex &lt; s.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">        <span class="comment">// 去掉字符串中间部分的冗余空格</span></span><br><span class="line">        <span class="keyword">if</span> (fastIndex - <span class="number">1</span> &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; s[fastIndex - <span class="number">1</span>] == s[fastIndex]</span><br><span class="line">                &amp;&amp; s[fastIndex] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[slowIndex++] = s[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowIndex - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[slowIndex - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 去掉字符串末尾的空格</span></span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex); <span class="comment">// 重新设置字符串大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有的同学可能发现用erase来移除空格，在leetcode上性能也还行。主要是以下几点；：</p>
<ol>
<li>leetcode上的测试集里，字符串的长度不够长，如果足够长，性能差距会非常明显。</li>
<li>leetcode的测程序耗时不是很准确的。</li>
</ol>
<p>此时我们已经实现了removeExtraSpaces函数来移除冗余空格。</p>
<p>还做实现反转字符串的功能，支持反转字符串子区间，这个实现我们分别在<a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">344.反转字符串 (opens new window)</a>和<a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">541.反转字符串II (opens new window)</a>里已经讲过了。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// 反转字符串s中左闭又闭的区间[start, end]</span><br><span class="line">void reverse(string&amp; s, int start, int end) &#123;</span><br><span class="line">    for (int i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        swap(s[i], s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		<span class="comment">// 取出空余 </span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> removeEmpty(s);</span><br><span class="line">		<span class="comment">// 先整体 再局部翻转</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">		reverse(sb,start,end);</span><br><span class="line">        <span class="comment">// 局部翻转 单词</span></span><br><span class="line">        reverseWord(sb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> StringBuilder <span class="title function_">reverse</span><span class="params">(StringBuilder sb,<span class="type">int</span> start,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(start&lt;end) &#123;</span><br><span class="line">			<span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(end);</span><br><span class="line">			sb.setChar(start,temp);</span><br><span class="line">			sb.setChar(end,temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEmpty</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		start = <span class="number">0</span>;</span><br><span class="line">		end = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(start)==<span class="string">&#x27; &#x27;</span>)start++;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(end)==<span class="string">&#x27; &#x27;</span>)end--;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length()-<span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="keyword">while</span>(start &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span>(end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseString(sb,start,end-<span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串_字符串05</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B205/</url>
    <content><![CDATA[<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接(opens new window)</a></p>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：<br>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”</p>
<p>示例 2：<br>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”</p>
<p>限制：<br>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了让本题更有意义，提升一下本题难度：<strong>不能申请额外空间，只能在本串上操作</strong>。</p>
<p>不能使用额外空间的话，模拟在本串操作要实现左旋转字符串的功能还是有点困难的。</p>
<p>那么我们可以想一下上一题目<a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">字符串：花式反转还不够！ (opens new window)</a>中讲过，使用整体反转+局部反转就可以实现，反转单词顺序的目的。</p>
<p>这道题目也非常类似，依然可以通过局部反转+整体反转 达到左旋转的目的。</p>
<p>具体步骤为：</p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<p>最后就可以得到左旋n的目的，而不用定义新的字符串，完全在本串上操作。</p>
<p>例如 ：示例1中 输入：字符串abcdefg，n&#x3D;2</p>
<p>如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="img"></p>
<p>最终得到左旋2个单元的字符串：cdefgab</p>
<p>思路明确之后，那么代码实现就很简单了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时我们已经反转好多次字符串了，来一起回顾一下吧。</p>
<p>在这篇文章<a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">344.反转字符串 (opens new window)</a>，第一次讲到反转一个字符串应该怎么做，使用了双指针法。</p>
<p>然后发现<a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html">541. 反转字符串II (opens new window)</a>，这里开始给反转加上了一些条件，当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</p>
<p>后来在<a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">151.翻转字符串里的单词 (opens new window)</a>中，要对一句话里的单词顺序进行反转，发现先整体反转再局部反转 是一个很妙的思路。</p>
<p>最后再讲到本题，本题则是先局部反转再 整体反转，与<a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">151.翻转字符串里的单词 (opens new window)</a>类似，但是也是一种新的思路。</p>
<p>好了，反转字符串一共就介绍到这里，相信大家此时对反转字符串的常见操作已经很了解了。</p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>一些同学热衷于使用substr，来做这道题。 其实使用substr 和 反转 时间复杂度是一样的 ，都是O(n)，但是使用substr申请了额外空间，所以空间复杂度是O(n)，而反转方法的空间复杂度是O(1)。</p>
<p><strong>如果想让这套题目有意义，就不要申请额外空间。</strong></p>
<p>java代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseLeftWords(String s, int n) &#123;</span><br><span class="line">    	StringBuilder sb = new StringBuilder(s);</span><br><span class="line">    	// 先局部</span><br><span class="line">    	reverse(sb,0,n-1);</span><br><span class="line">    	reverse(sb,n,sb.length()-1);</span><br><span class="line">    	// 整体</span><br><span class="line">    	reverse(sb,0,sb.length()-1);</span><br><span class="line">    	return new String(sb);</span><br><span class="line">	&#125;</span><br><span class="line">	public void reverse(StringBuilder sb,int start,int end) &#123;</span><br><span class="line">		char temp = &#x27;a&#x27;;</span><br><span class="line">		while(start &lt; end) &#123;</span><br><span class="line">			temp = sb.charAt(temp);</span><br><span class="line">			sb.setChar(start,temp);</span><br><span class="line">			sb.setChar(end,sb.charAt(temp));</span><br><span class="line">			start++;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_代码随想列题</title>
    <url>/2022/07/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%8401/</url>
    <content><![CDATA[<h1 id="数组-代码随想列题"><a href="#数组-代码随想列题" class="headerlink" title="数组_代码随想列题"></a>数组_代码随想列题</h1><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>[题目链接](<a href="https://leetcode.cn/problems/binary-search/">Loading Question… - 力扣（LeetCode）</a>)</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4     </span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1  </span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了易于大家理解，我还录制了视频，可以看这里：<a href="https://www.bilibili.com/video/BV1fA4y1o715">手把手带你撕出正确的二分法(opens new window)</a></p>
<p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p>
<p>下面我用这两种区间的定义分别讲解两种不同的二分写法。</p>
<h3 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h3><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210311153055723.jpg" alt="704.二分查找"></p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 版本一</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]</span><br><span class="line">        while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效，所以用 &lt;=</span><br><span class="line">            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - 1; // target 在左区间，所以[left, middle - 1]</span><br><span class="line">            &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1; // target 在右区间，所以[middle + 1, right]</span><br><span class="line">            &#125; else &#123; // nums[middle] == target</span><br><span class="line">                return middle; // 数组中找到目标值，直接返回下标</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 未找到目标值</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h3><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<p>在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（<strong>注意和方法一的区别</strong>）</p>
<p><img src="https://img-blog.csdnimg.cn/20210311153123632.jpg" alt="704.二分查找1"></p>
<p>代码如下：（详细注释）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二分法是非常重要的基础算法，为什么很多同学对于二分法都是<strong>一看就会，一写就废</strong>？</p>
<p>其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。</p>
<p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p>
<p>本篇根据两种常见的区间定义，给出了两种二分法的写法，每一个边界为什么这么处理，都根据区间的定义做了详细介绍。</p>
<p>相信看完本篇应该对二分法有更深刻的理解了。</p>
<h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><p>左边第一个目标值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名 (nums数组,目标值)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= target) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left || right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右边第一个目标值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法名 (nums数组,目标值)&#123;</span><br><span class="line">	int left = 0;</span><br><span class="line">	int right = nums.length - 1;</span><br><span class="line">	while(left &lt; right) &#123;</span><br><span class="line">		mid = 1+(left+right)/2;</span><br><span class="line">		if(nums[mid]&lt;=target) left = mid;</span><br><span class="line">		else right = mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>重复的子字符串_字符串07</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B207/</url>
    <content><![CDATA[<h1 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接(opens new window)</a></p>
<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p>
<p>示例 2:<br>输入: “aba”<br>输出: False</p>
<p>示例 3:<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这又是一道标准的KMP的题目。</p>
<p>如果KMP还不够了解，可以看我的B站：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1PD4y1o7nd/">帮你把KMP算法学个通透！（理论篇）(opens new window)</a></li>
<li><a href="https://www.bilibili.com/video/BV1M5411j7Xx">帮你把KMP算法学个通透！（求next数组代码篇）(opens new window)</a></li>
</ul>
<p>我们在<a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">字符串：KMP算法精讲 (opens new window)</a>里提到了，在一个串中查找是否出现过另一个串，这是KMP的看家本领。</p>
<p>那么寻找重复子串怎么也涉及到KMP算法了呢？</p>
<p>这里就要说一说next数组了，next 数组记录的就是最长相同前后缀( <a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">字符串：KMP算法精讲 (opens new window)</a>这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] !&#x3D; -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。</p>
<p>最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1)</p>
<p>数组长度为：len。</p>
<p>如果len % (len - (next[len - 1] + 1)) &#x3D;&#x3D; 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。</p>
<p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p>
<p><strong>强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法</strong></p>
<p>如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2_1.png" alt="459.重复的子字符串_1"></p>
<p>next[len - 1] &#x3D; 7，next[len - 1] + 1 &#x3D; 8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。</p>
<p>(len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) &#x3D; 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。</p>
<h3 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    		<span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    		<span class="comment">// next数组</span></span><br><span class="line">    		getNext(next,s);</span><br><span class="line">    		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> s.length() - (next[s.length()-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    		<span class="keyword">return</span> s.length()%a == <span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next,String s)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s.charAt(j+<span class="number">1</span>) != s.charAt(i)) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j+<span class="number">1</span>) == s.charAt(i)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>实现 strStr()_字符串06</title>
    <url>/2022/07/25/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%AD%97%E7%AC%A6%E4%B8%B206/</url>
    <content><![CDATA[<h1 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h1><p><a href="https://leetcode.cn/problems/implement-strstr/">力扣题目链接(opens new window)</a></p>
<p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p>
<p>示例 1: 输入: haystack &#x3D; “hello”, needle &#x3D; “ll” 输出: 2</p>
<p>示例 2: 输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba” 输出: -1</p>
<p>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题是KMP 经典题目。</p>
<p>以下文字如果看不进去，可以看我的B站视频：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1PD4y1o7nd/">帮你把KMP算法学个通透！B站（理论篇）(opens new window)</a></li>
<li><a href="https://www.bilibili.com/video/BV1M5411j7Xx">帮你把KMP算法学个通透！（求next数组代码篇）(opens new window)</a></li>
</ul>
<p>KMP的经典思想就是:<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</strong></p>
<p>本篇将以如下顺序来讲解KMP，</p>
<ul>
<li>什么是KMP</li>
<li>KMP有什么用</li>
<li>什么是前缀表</li>
<li>为什么一定要用前缀表</li>
<li>如何计算前缀表</li>
<li>前缀表与next数组</li>
<li>使用next数组来匹配</li>
<li>时间复杂度分析</li>
<li>构造next数组</li>
<li>使用next数组来做匹配</li>
<li>前缀表统一减一 C++代码实现</li>
<li>前缀表（不减一）C++实现</li>
<li>总结</li>
</ul>
<p>读完本篇可以顺便把leetcode上28.实现strStr()题目做了。</p>
<h3 id="什么是KMP"><a href="#什么是KMP" class="headerlink" title="什么是KMP"></a>什么是KMP</h3><p>说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。</p>
<p>因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP</p>
<h3 id="KMP有什么用"><a href="#KMP有什么用" class="headerlink" title="KMP有什么用"></a>KMP有什么用</h3><p>KMP主要应用在字符串匹配上。</p>
<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p>
<p>其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。</p>
<p>没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。</p>
<p>不仅面试的时候可能写不出来，如果面试官问：<strong>next数组里的数字表示的是什么，为什么这么表示？</strong></p>
<p>估计大多数候选人都是懵逼的。</p>
<p>下面Carl就带大家把KMP的精髓，next数组弄清楚。</p>
<h3 id="什么是前缀表"><a href="#什么是前缀表" class="headerlink" title="什么是前缀表"></a>什么是前缀表</h3><p>写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？</p>
<p>next数组就是一个前缀表（prefix table）。</p>
<p>前缀表有什么作用呢？</p>
<p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p>
<p>为了清楚的了解前缀表的来历，我们来举一个例子：</p>
<p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>
<p>请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：</p>
<p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>
<p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>
<p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>
<p>如动画所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p>
<p>动画里，我特意把 子串<code>aa</code> 标记上了，这是有原因的，大家先注意一下，后面还会说道。</p>
<p>可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，会发现不匹配，此时就要从头匹配了。</p>
<p>但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。</p>
<p>此时就要问了<strong>前缀表是如何记录的呢？</strong></p>
<p>首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p>
<p>那么什么是前缀表：<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p>
<h3 id="最长公共前后缀？"><a href="#最长公共前后缀？" class="headerlink" title="最长公共前后缀？"></a>最长公共前后缀？</h3><p>文章中字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p>
<p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p>
<p><strong>正确理解什么是前缀什么是后缀很重要</strong>!</p>
<p>那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？</p>
<p>我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。</p>
<p><strong>因为前缀表要求的就是相同前后缀的长度。</strong></p>
<p>而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。</p>
<p>所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等…..。</p>
<h3 id="为什么一定要用前缀表"><a href="#为什么一定要用前缀表" class="headerlink" title="为什么一定要用前缀表"></a>为什么一定要用前缀表</h3><p>这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？</p>
<p>回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B21.png" alt="KMP精讲1"></p>
<p>然后就找到了下标2，指向b，继续匹配：如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B22.png" alt="KMP精讲2"></p>
<p>以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！</p>
<p><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。</strong></p>
<p>所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p>
<p><strong>很多介绍KMP的文章或者视频并没有把为什么要用前缀表？这个问题说清楚，而是直接默认使用前缀表。</strong></p>
<h3 id="如何计算前缀表"><a href="#如何计算前缀表" class="headerlink" title="如何计算前缀表"></a>如何计算前缀表</h3><p>接下来就要说一说怎么计算前缀表。</p>
<p>如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B25.png" alt="KMP精讲5"></p>
<p>长度为前1个字符的子串<code>a</code>，最长相同前后缀的长度为0。（注意字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>；<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。）</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B26.png" alt="KMP精讲6"> 长度为前2个字符的子串<code>aa</code>，最长相同前后缀的长度为1。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B27.png" alt="KMP精讲7"> 长度为前3个字符的子串<code>aab</code>，最长相同前后缀的长度为0。</p>
<p>以此类推： 长度为前4个字符的子串<code>aaba</code>，最长相同前后缀的长度为1。 长度为前5个字符的子串<code>aabaa</code>，最长相同前后缀的长度为2。 长度为前6个字符的子串<code>aabaaf</code>，最长相同前后缀的长度为0。</p>
<p>那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png" alt="KMP精讲8"></p>
<p>可以看出模式串与前缀表对应位置的数字表示的就是：<strong>下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p>
<p>再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"></p>
<p>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。</p>
<p>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p>
<p>所以要看前一位的 前缀表的数值。</p>
<p>前一个字符的前缀表的数值是2， 所有把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。</p>
<p>最后就在文本串中找到了和模式串匹配的子串了。</p>
<h3 id="前缀表与next数组"><a href="#前缀表与next数组" class="headerlink" title="前缀表与next数组"></a>前缀表与next数组</h3><p>很多KMP算法的时间都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？</p>
<p>next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。</p>
<p>为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。</p>
<p>其实<strong>这并不涉及到KMP的原理，而是具体实现，next数组即可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</strong></p>
<p>后面我会提供两种不同的实现代码，大家就明白了。</p>
<h3 id="使用next数组来匹配"><a href="#使用next数组来匹配" class="headerlink" title="使用next数组来匹配"></a>使用next数组来匹配</h3><p><strong>以下我们以前缀表统一减一之后的next数组来做演示</strong>。</p>
<p>有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。</p>
<p>注意next数组是新前缀表（旧前缀表统一减一了）。</p>
<p>匹配过程动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif" alt="KMP精讲4"></p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。</p>
<p>暴力的解法显而易见是O(n × m)，所以<strong>KMP在字符串匹配中极大的提高的搜索的效率。</strong></p>
<p>为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。</p>
<p>都知道使用KMP算法，一定要构造next数组。</p>
<h3 id="构造next数组"><a href="#构造next数组" class="headerlink" title="构造next数组"></a>构造next数组</h3><p>我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void getNext(int* next, const string&amp; s)</span><br></pre></td></tr></table></figure>

<p><strong>构造next数组其实就是计算模式串s，前缀表的过程。</strong> 主要有如下三步：</p>
<ol>
<li>初始化</li>
<li>处理前后缀不相同的情况</li>
<li>处理前后缀相同的情况</li>
</ol>
<p>接下来我们详解详解一下。</p>
<ol>
<li>初始化：</li>
</ol>
<p>定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。</p>
<p>然后还要对next数组进行初始化赋值，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br></pre></td></tr></table></figure>

<p>j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。</p>
<p>next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）</p>
<p>所以初始化next[0] &#x3D; j 。</p>
<ol>
<li>处理前后缀不相同的情况</li>
</ol>
<p>因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。</p>
<p>所以遍历模式串s的循环下标i 要从 1开始，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br></pre></td></tr></table></figure>

<p>如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。</p>
<p>怎么回退呢？</p>
<p>next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。</p>
<p>那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。</p>
<p>所以，处理前后缀不相同的情况代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">    j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>处理前后缀相同的情况</li>
</ol>
<p>如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (s[i] == s[j + 1]) &#123; // 找到相同的前后缀</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] = j;</span><br></pre></td></tr></table></figure>

<p>最后整体构建next数组的函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">            j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码构造next数组的逻辑流程动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt="KMP精讲3"></p>
<p>得到了next数组之后，就要用这个来做匹配了。</p>
<h3 id="使用next数组来做匹配"><a href="#使用next数组来做匹配" class="headerlink" title="使用next数组来做匹配"></a>使用next数组来做匹配</h3><p>在文本串s里 找是否出现过模式串t。</p>
<p>定义两个下标j 指向模式串起始位置，i指向文本串起始位置。</p>
<p>那么j初始值依然为-1，为什么呢？ <strong>依然因为next数组里记录的起始位置为-1。</strong></p>
<p>i就从0开始，遍历文本串，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) </span><br></pre></td></tr></table></figure>

<p>接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。</p>
<p>如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>]) &#123;</span><br><span class="line">    j = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == t[j + <span class="number">1</span>]) &#123;</span><br><span class="line">    j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。</p>
<p>本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == (t.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123;</span><br><span class="line">    <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么使用next数组，用模式串匹配文本串的整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// 因为next数组里记录的起始位置为-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">        j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">        j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == (t.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">        <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下：</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。</p>
<p>接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。</p>
<p>其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。</p>
<p>然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。</p>
<p>又给出了直接用前缀表作为next数组，来做匹配的实现代码。</p>
<p>可以说把KMP的每一个细微的细节都扣了出来，毫无遮掩的展示给大家了！</p>
<h3 id="java代码："><a href="#java代码：" class="headerlink" title="java代码："></a>java代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="comment">// 前缀 和 后缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j+<span class="number">1</span>)) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(j+<span class="number">1</span>)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(needle == <span class="literal">null</span> || needle.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(haystack.length() &lt; needle.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> [] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next,needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.length();i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j+<span class="number">1</span>)) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(hasystack.charAt(i) == needle.charAt(j+<span class="number">1</span>)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == needle.length() -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.length() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_代码随想列题02</title>
    <url>/2022/07/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%8402/</url>
    <content><![CDATA[<h1 id="代码随想录-数组02"><a href="#代码随想录-数组02" class="headerlink" title="代码随想录_数组02"></a>代码随想录_数组02</h1><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>[题目链接](<a href="https://leetcode.cn/problems/remove-element/">力扣 (leetcode.cn)</a>)</p>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len &#x3D; removeElement(nums, val);</p>
<p>&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。<br>&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br>for (int i &#x3D; 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2<br>输出：5, nums &#x3D; [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="https://www.bilibili.com/video/BV12A4y1Z7LP">本题B站视频讲解(opens new window)</a></p>
<p>有的同学可能说了，多余的元素，删掉不就得了。</p>
<p><strong>要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。</p>
<p>删除过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrc7x9tjg30du09m1ky.gif" alt="27.移除元素-暴力解法"></p>
<p>很明显暴力解法的时间复杂度是O(n^2)，这道题目暴力解法在leetcode上是可以过的。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 时间复杂度：O(n^2)</span><br><span class="line">// 空间复杂度：O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (nums[i] == val) &#123; // 发现需要移除的元素，就将数组集体向前移动一位</span><br><span class="line">                for (int j = i + 1; j &lt; size; j++) &#123;</span><br><span class="line">                    nums[j - 1] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span><br><span class="line">                size--; // 此时数组的大小-1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p>很多同学这道题目做的很懵，就是不理解 快慢指针究竟都是什么含义，所以一定要明确含义，后面的思路就更容易理解了。</p>
<p>删除过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p>
<p>很多同学不了解</p>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<p>后续都会一一介绍到，本题代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> in <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span> [] nums,<span class="type">int</span> val)</span> &#123;</span><br><span class="line">	<span class="comment">//快指针</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(fastIndex&lt;nums.length) &#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[fastIndex] != val) &#123;</span><br><span class="line">            nums[slowIndex++] = nums[fastIndex]</span><br><span class="line">        &#125;</span><br><span class="line">		fastIndex++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_代码随想列题03</title>
    <url>/2022/07/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%8403/</url>
    <content><![CDATA[<h1 id="代码随想录-数组03"><a href="#代码随想录-数组03" class="headerlink" title="代码随想录_数组03"></a>代码随想录_数组03</h1><h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接(opens new window)</a></p>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了易于大家理解，我还特意录制了视频，<a href="https://www.bilibili.com/video/BV1QB4y1D7ep">本题视频讲解(opens new window)</a></p>
<h3 id="暴力排序"><a href="#暴力排序" class="headerlink" title="暴力排序"></a>暴力排序</h3><p>最直观的想法，莫过于：每个数平方之后，排个序，美滋滋，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        for (int i = 0; i &lt; A.size(); i++) &#123;</span><br><span class="line">            A[i] *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(A.begin(), A.end()); // 快速排序</span><br><span class="line">        return A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个时间复杂度是 O(n + nlogn)， 可以说是O(nlogn)的时间复杂度，但为了和下面双指针法算法时间复杂度有鲜明对比，我记为 O(n + nlog n)。</p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p>
<p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p>
<p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p>
<p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p>
<p>如动画所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="img"></p>
<p>不难写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] new_nums =<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">new_index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[left]*nums[left] &lt; nums[right]*nums[right]) &#123;</span><br><span class="line">                new_nums[new_index++] = nums[left]*nums[left];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                new_nums[new_index++] = nums[right]*nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">       <span class="keyword">return</span> new_nums;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的时间复杂度为O(n)，相对于暴力排序的解法O(n + nlog n)还是提升不少的。</p>
<p><strong>这里还是说一下，大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。</strong></p>
<p>做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，</p>
<p>一样的代码多提交几次可能就击败百分之百了…..</p>
]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_代码随想列题04</title>
    <url>/2022/07/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%95%B0%E7%BB%8404/</url>
    <content><![CDATA[<h1 id="代码随想录-数组04"><a href="#代码随想录-数组04" class="headerlink" title="代码随想录_数组04"></a>代码随想录_数组04</h1><h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接(opens new window)</a></p>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>为了易于大家理解，我特意录制了B站视频<a href="https://www.bilibili.com/video/BV1tZ4y1q7XE">拿下滑动窗口！ | LeetCode 209 长度最小的子数组(opens new window)</a></p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int result = INT32_MAX; // 最终的结果</span><br><span class="line">        int sum = 0; // 子序列的数值之和</span><br><span class="line">        int subLength = 0; // 子序列的长度</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123; // 设置子序列起点为i</span><br><span class="line">            sum = 0;</span><br><span class="line">            for (int j = i; j &lt; nums.size(); j++) &#123; // 设置子序列终止位置为j</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                if (sum &gt;= s) &#123; // 一旦发现子序列和超过了s，更新result</span><br><span class="line">                    subLength = j - i + 1; // 取子序列的长度</span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br><span class="line">        return result == INT32_MAX ? 0 : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p>
<p>那么滑动窗口如何用一个for循环来完成这个操作呢。</p>
<p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p>
<p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p>
<p>此时难免再次陷入 暴力解法的怪圈。</p>
<p>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p>
<p>那么问题来了， 滑动窗口的起始位置如何移动呢？</p>
<p>这里还是以题目中的示例来举例，s&#x3D;7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p>
<p>最后找到 4，3 是最短距离。</p>
<p>其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>
<p>在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p>
<p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210312160441942.png" alt="leetcode_209"></p>
<p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min_length</span> <span class="operator">=</span> Interge.MAX_VALUE;</span><br><span class="line">    	<span class="keyword">while</span>(fastIndex&lt;nums.length) &#123;</span><br><span class="line">            sum += nums[fastIndex];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                sum -= nums[slowIndex++];</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">            min_length = min_length &lt; fastIndex - slowIndex+<span class="number">1</span> ? min_length:fastIndex - slowIndex+<span class="number">1</span>;</span><br><span class="line">    		fastIndex++;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">min_length</span> <span class="operator">=</span>= MAX_VALUE?<span class="number">0</span>:min_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><ul>
<li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li>
<li><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串(opens new window)</a></li>
</ul>
]]></content>
      <categories>
        <category>算法简史</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>用栈实现队列_栈02</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9702/</url>
    <content><![CDATA[<h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣题目链接(opens new window)</a></p>
<p>使用栈实现队列的下列操作：</p>
<p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p>
<p>示例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> <span class="built_in">MyQueue</span>();</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">peek</span>();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">empty</span>(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道模拟题，不涉及到具体算法，考察的就是对栈和队列的掌握程度。</p>
<p>使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈<strong>一个输入栈，一个输出栈</strong>，这里要注意输入栈和输出栈的关系。</p>
<p>下面动画模拟以下队列的执行过程如下：</p>
<p>执行语句：<br>queue.push(1);<br>queue.push(2);<br>queue.pop(); <strong>注意此时的输出栈的操作</strong><br>queue.push(3);<br>queue.push(4);<br>queue.pop();<br>queue.pop();<strong>注意此时的输出栈的操作</strong><br>queue.pop();<br>queue.empty();</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2"></p>
<p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p>
<p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p>
<p>在代码实现的时候，会发现pop() 和 peek()两个函数功能类似，代码实现上也是类似的，可以思考一下如何把代码抽象一下。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>可以看出peek()的实现，直接复用了pop()。</p>
<p>再多说一些代码开发上的习惯问题，在工业级别代码开发中，最忌讳的就是 实现一个类似的函数，直接把代码粘过来改一改就完事了。</p>
<p>这样的项目代码会越来越乱，<strong>一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！（踩过坑的人自然懂）</strong></p>
<p>工作中如果发现某一个功能自己要经常用，同事们可能也会用到，自己就花点时间把这个功能抽象成一个好用的函数或者工具类，不仅自己方便，也方面了同事们。</p>
<p>同事们就会逐渐认可你的工作态度和工作能力，自己的口碑都是这么一点一点积累起来的！在同事圈里口碑起来了之后，你就发现自己走上了一个正循环，以后的升职加薪才少不了你！哈哈哈</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    	stackIn.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!stackOut.isEmpty()) &#123;</span><br><span class="line">    		stackOut.pop();</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">while</span>(!stackIn.isEmpty()) &#123;</span><br><span class="line">    			stackOut.push(stackIn.pop());</span><br><span class="line">    		&#125;</span><br><span class="line">    		stackOut.pop();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!stackOut.isEmpty()) <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    	<span class="keyword">while</span>(!stackIn.isEmpty()) &#123;</span><br><span class="line">    			stackOut.push(stackIn.pop());</span><br><span class="line">    		&#125;</span><br><span class="line">    	<span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>用队列实现栈_栈01</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9701/</url>
    <content><![CDATA[<h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">力扣题目链接(opens new window)</a></p>
<p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<p>注意:</p>
<ul>
<li>你只能使用队列的基本操作– 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>（这里要强调是单向队列）</p>
<p>有的同学可能疑惑这种题目有什么实际工程意义，<strong>其实很多算法题目主要是对知识点的考察和教学意义远大于其工程实践的意义，所以面试题也是这样！</strong></p>
<p>刚刚做过<a href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html">栈与队列：我用栈来实现队列怎么样？ (opens new window)</a>的同学可能依然想着用一个输入队列，一个输出队列，就可以模拟栈的功能，仔细想一下还真不行！</p>
<p><strong>队列模拟栈，其实一个队列就够了</strong>，那么我们先说一说两个队列来实现栈的思路。</p>
<p><strong>队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。</strong></p>
<p>所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。</p>
<p>但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用又来备份的！</p>
<p>如下面动画所示，<strong>用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用</strong>，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。</p>
<p>模拟的队列执行语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);        </span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 注意弹出的操作       </span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">3</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">4</span>);       </span><br><span class="line">queue.<span class="built_in">pop</span>();  <span class="comment">// 注意弹出的操作    </span></span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">empty</span>();    </span><br></pre></td></tr></table></figure>

<p><img src="https://code-thinking.cdn.bcebos.com/gifs/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="225.用队列实现栈"></p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue1; <span class="comment">// 和栈中保持一样元素的队列</span></span><br><span class="line">    Queue&lt;Integer&gt; queue2; <span class="comment">// 辅助队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    	queue1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que1.isEmpty()) &#123;</span><br><span class="line">            temp = que1.poll();</span><br><span class="line">            <span class="keyword">if</span>(!que1.isEmpty()) &#123;</span><br><span class="line">                que2.offer(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que2.isEmpty()) &#123;</span><br><span class="line">            que1.offer(que2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que1.isEmpty()) &#123;</span><br><span class="line">            temp = que1.peek();</span><br><span class="line">            <span class="keyword">if</span>(!que1.isEmpty()) &#123;</span><br><span class="line">                que2.offer(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que2.isEmpty()) &#123;</span><br><span class="line">            que1.offer(que2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        que1.offer(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty() &amp;&amp; queue2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号_栈03</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9703/</url>
    <content><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">力扣题目链接(opens new window)</a></p>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p>示例 1:</p>
<ul>
<li>输入: “()”</li>
<li>输出: true</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: “()[]{}”</li>
<li>输出: true</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: “(]”</li>
<li>输出: false</li>
</ul>
<p>示例 4:</p>
<ul>
<li>输入: “([)]”</li>
<li>输出: false</li>
</ul>
<p>示例 5:</p>
<ul>
<li>输入: “{[]}”</li>
<li>输出: true</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p><strong>括号匹配是使用栈解决的经典问题。</strong></p>
<p>题意其实就像我们在写代码的过程中，要求括号的顺序是一样的，有左括号，相应的位置必须要有右括号。</p>
<p>如果还记得编译原理的话，编译器在 词法分析的过程中处理括号、花括号等这个符号的逻辑，也是使用了栈这种数据结构。</p>
<p>再举个例子，linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd a/b/c/../../</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用（其实可以出一道相应的面试题了）</p>
<p>所以栈在计算机领域中应用是非常广泛的。</p>
<p>有的同学经常会想学的这些数据结构有什么用，也开发不了什么软件，大多数同学说的软件应该都是可视化的软件例如APP、网站之类的，那都是非常上层的应用了，底层很多功能的实现都是基础的数据结构和算法。</p>
<p><strong>所以数据结构与算法的应用往往隐藏在我们看不到的地方！</strong></p>
<p>这里我就不过多展开了，先来看题。</p>
<h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><p>由于栈结构的特殊性，非常适合做对称匹配类的题目。</p>
<p>首先要弄清楚，字符串里的括号不匹配有几种情况。</p>
<p><strong>一些同学，在面试中看到这种题目上来就开始写代码，然后就越写越乱。</strong></p>
<p>建议要写代码之前要分析好有哪几种不匹配的情况，如果不动手之前分析好，写出的代码也会有很多问题。</p>
<p>先来分析一下 这里有三种不匹配的情况，</p>
<ol>
<li>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。 <img src="https://img-blog.csdnimg.cn/2020080915505387.png" alt="括号匹配1"></li>
<li>第二种情况，括号没有多余，但是 括号的类型没有匹配上。 <img src="https://img-blog.csdnimg.cn/20200809155107397.png" alt="括号匹配2"></li>
<li>第三种情况，字符串里右方向的括号多余了，所以不匹配。 <img src="https://img-blog.csdnimg.cn/20200809155115779.png" alt="括号匹配3"></li>
</ol>
<p>我们的代码只要覆盖了这三种不匹配的情况，就不会出问题，可以看出 动手之前分析好题目的重要性。</p>
<p>动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号"></p>
<p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</p>
<p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</p>
<p>第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false</p>
<p>那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。</p>
<p>分析完之后，代码其实就比较好写了，</p>
<p>但还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    	 Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    	 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">    	 	<span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">    	 		stack.add(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    	 	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">    	 		stack.add(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    	 	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">    	 		stack.add(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    	 	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;s.charAt(i) != stack.peek()) &#123;</span><br><span class="line">    	 		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">    	 &#125;</span><br><span class="line">    	 <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    	 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>删除字符串中的所有相邻重复项_栈04</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9704/</url>
    <content><![CDATA[<h1 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h1><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">力扣题目链接(opens new window)</a></p>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<ul>
<li>输入：”abbaca”</li>
<li>输出：”ca”</li>
<li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; S.length &lt;&#x3D; 20000</li>
<li>S 仅由小写英文字母组成。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>这道题目就像是我们玩过的游戏对对碰，如果相同的元素放在挨在一起就要消除。</p>
<p>可能我们在玩游戏的时候感觉理所当然应该消除，但程序又怎么知道该如果消除呢，特别是消除之后又有新的元素可能挨在一起。</p>
<p>此时游戏的后端逻辑就可以用一个栈来实现（我没有实际考察对对碰或者爱消除游戏的代码实现，仅从原理上进行推断）。</p>
<p>游戏开发可能使用栈结构，编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，例如：</p>
<p><img src="https://img-blog.csdnimg.cn/20210309093252776.png" alt="1047.删除字符串中的所有相邻重复项"></p>
<p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是<code>Segmentation fault</code>（当然不是所有的<code>Segmentation fault</code> 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。</p>
<p>而且<strong>在企业项目开发中，尽量不要使用递归！</strong>在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong></p>
<p>好了，题外话over，我们进入正题。</p>
<h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>本题要删除相邻相同元素，其实也是匹配问题，相同左元素相当于左括号，相同右元素就是相当于右括号，匹配上了就删除。</p>
<p>那么再来看一下本题：可以把字符串顺序放到一个栈中，然后如果相同的话 栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。</p>
<p>如动画所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047.删除字符串中的所有相邻重复项"></p>
<p>从栈中弹出剩余元素，此时是字符串ac，因为从栈里弹出的元素是倒序的，所以在对字符串进行反转一下，就得到了最终的结果。</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="comment">//ArrayDeque会比LinkedList在除了删除元素这一点外会快一点</span></span><br><span class="line">        <span class="comment">//参考：https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist</span></span><br><span class="line">        ArrayDeque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:arr) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; c == deque.peek()) &#123;</span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()) &#123;</span><br><span class="line">            str = deque.pop() + str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰表达式求值_栈05</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9705/</url>
    <content><![CDATA[<h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">力扣题目链接(opens new window)</a></p>
<p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 + , - , * , &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：</p>
<p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：</p>
<ul>
<li>输入: [“2”, “1”, “+”, “3”, “ * “]</li>
<li>输出: 9</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入: [“4”, “13”, “5”, “&#x2F;“, “+”]</li>
<li>输出: 6</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</li>
</ul>
<p>示例 3：</p>
<ul>
<li><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “ * “, “&#x2F;“, “ * “, “17”, “+”, “5”, “+”]</p>
</li>
<li><p>输出: 22</p>
</li>
<li><p>解释:该算式转化为常见的中缀算术表达式为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">((10 * (6 / ((9 + 3) * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5     </span><br><span class="line">= ((10 * 0) + 17) + 5     </span><br><span class="line">= (0 + 17) + 5    </span><br><span class="line">= 17 + 5    </span><br><span class="line">= 22    </span><br></pre></td></tr></table></figure></li>
</ul>
<p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</p>
<p>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</p>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在上一篇文章中<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047.删除字符串中的所有相邻重复项 (opens new window)</a>提到了 递归就是用栈来实现的。</p>
<p>所以<strong>栈与递归之间在某种程度上是可以转换的！</strong> 这一点我们在后续讲解二叉树的时候，会更详细的讲解到。</p>
<p>那么来看一下本题，<strong>其实逆波兰表达式相当于是二叉树中的后序遍历</strong>。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。</p>
<p>但我们没有必要从二叉树的角度去解决这个问题，只要知道逆波兰表达式是用后续遍历的方式把二叉树序列化了，就可以了。</p>
<p>在进一步看，本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么<strong>这岂不就是一个相邻字符串消除的过程，和<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047.删除字符串中的所有相邻重复项 (opens new window)</a>中的对对碰游戏是不是就非常像了。</strong></p>
<p>如动画所示： <img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p>
<p>相信看完动画大家应该知道，这和<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047. 删除字符串中的所有相邻重复项 (opens new window)</a>是差不错的，只不过本题不要相邻元素做消除了，而是做运算！</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    	Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    	<span class="keyword">for</span>(String s:tokens) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">    			deque.add(deque.pop()+deque.pop());</span><br><span class="line">    		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                deque.add(-(deque.pop()-deque.pop()));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                deque.add(deque.pop()*deque.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> deque.pop();</span><br><span class="line">                deque.add(B/A);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                deque.add(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>我们习惯看到的表达式都是中缀表达式，因为符合我们的习惯，但是中缀表达式对于计算机来说就不是很友好了。</p>
<p>例如：4 + 13 &#x2F; 5，这就是中缀表达式，计算机从左到右去扫描的话，扫到13，还要判断13后面是什么运算法，还要比较一下优先级，然后13还和后面的5做运算，做完运算之后，还要向前回退到 4 的位置，继续做加法，你说麻不麻烦！</p>
<p>那么将中缀表达式，转化为后缀表达式之后：[“4”, “13”, “5”, “&#x2F;“, “+”] ，就不一样了，计算机可以利用栈里顺序处理，不需要考虑优先级了。也不用回退了， <strong>所以后缀表达式对计算机来说是非常友好的。</strong></p>
<p>可以说本题不仅仅是一道好题，也展现出计算机的思考方式。</p>
<p>在1970年代和1980年代，惠普在其所有台式和手持式计算器中都使用了RPN（后缀表达式），直到2020年代仍在某些模型中使用了RPN。</p>
]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值_队列06</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9706/</url>
    <content><![CDATA[<h1 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">力扣题目链接(opens new window)</a></p>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>进阶：</p>
<p>你能在线性时间复杂度内解决此题吗？</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt="img"></p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li>
<li>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4</li>
<li>1 &lt;&#x3D; k &lt;&#x3D; nums.length</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是使用单调队列的经典题目。</p>
<p>难点是如何求一个区间里的最大值呢？ （这好像是废话），暴力一下不就得了。</p>
<p>暴力方法，遍历一遍的过程中每次从窗口中在找到最大的数值，这样很明显是$O(n × k)$的算法。</p>
<p>有的同学可能会想用一个大顶堆（优先级队列）来存放这个窗口里的k个数字，这样就可以知道最大的最大值是多少了， <strong>但是问题是这个窗口是移动的，而大顶堆每次只能弹出最大值，我们无法移除其他数值，这样就造成大顶堆维护的不是滑动窗口里面的数值了。所以不能用大顶堆。</strong></p>
<p>此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p>
<p>这个队列应该长这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。</p>
<p>这么个队列香不香，要是有现成的这种数据结构是不是更香了！</p>
<p><strong>可惜了，没有！ 我们需要自己实现这么个队列。</strong></p>
<p>然后在分析一下，队列里的元素一定是要排序的，而且要最大值放在出队口，要不然怎么知道最大值呢。</p>
<p>但如果把窗口里的元素都放进队列里，窗口移动的时候，队列需要弹出元素。</p>
<p>那么问题来了，已经排序之后的队列 怎么能把窗口要移除的元素（这个元素可不一定是最大值）弹出呢。</p>
<p>大家此时应该陷入深思…..</p>
<p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。</strong></p>
<p>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来一个单调队列</strong></p>
<p><strong>不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。</strong></p>
<p>来看一下单调队列如何维护队列里的元素。</p>
<p>动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif" alt="239.滑动窗口最大值"></p>
<p>对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。</p>
<p>此时大家应该怀疑单调队列里维护着{5, 4} 怎么配合窗口经行滑动呢？</p>
<p>设计单调队列的时候，pop，和push操作要保持如下规则：</p>
<ol>
<li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li>
<li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li>
</ol>
<p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p>
<p>为了更直观的感受到单调队列的工作过程，以题目示例为例，输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3，动画如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2"></p>
<p>那么我们用什么数据结构来实现这个单调队列呢？</p>
<p>使用deque最为合适，在文章<a href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">栈与队列：来看看栈和队列不为人知的一面 (opens new window)</a>中，我们就提到了常用的queue在没有指定容器的情况下，deque就是默认底层容器。</p>
<p>基于刚刚说过的单调队列pop和push的规则，代码不难实现，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123; <span class="comment">//单调队列（从大到小）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样我们就用deque实现了一个单调队列，接下来解决滑动窗口最大值的问题就很简单了，直接看代码吧。</p>
<h2 id="java代码如下："><a href="#java代码如下：" class="headerlink" title="java代码如下："></a>java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class MyQueue &#123;</span><br><span class="line">	Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.isEmpty() &amp;&amp; val == que.peek()) &#123;</span><br><span class="line">            que.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty() &amp;&amp; val &gt; que.getLast()) &#123;</span><br><span class="line">            que.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        que.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 初始化队列</span></span><br><span class="line">        <span class="type">Myqueue</span> <span class="variable">myque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myqueue</span>();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">            myque.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        res[count++] = myque.peek();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.length;i++) &#123;</span><br><span class="line">            myque.poll(nums[i-k]);</span><br><span class="line">            myque.add(nums[i]);</span><br><span class="line">            res[count++] = myque.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串_字符串01</title>
    <url>/2022/07/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%9707/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法简史</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>删除_链表01</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A801/</url>
    <content><![CDATA[<h1 id="删除-链表01"><a href="#删除-链表01" class="headerlink" title="删除_链表01"></a>删除_链表01</h1><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接(opens new window)</a></p>
<p>题意：删除链表中等于给定值 val 的所有节点。</p>
<p>示例 1：<br>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]</p>
<p>示例 2：<br>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]</p>
<p>示例 3：<br>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了方便大家理解，我特意录制了视频：<a href="https://www.bilibili.com/video/BV18B4y1s7R9">手把手带你学会操作链表，移除链表元素 (opens new window)</a>，结合视频在看本题解，事半功倍。</p>
<p>这里以链表 1 4 2 4 来举例，移除元素4。</p>
<p><img src="https://img-blog.csdnimg.cn/20210316095351161.png" alt="203_链表删除元素1"></p>
<p>如果使用C，C++编程语言的话，不要忘了还要从内存中删除这两个移除的节点， 清理节点内存之后如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210316095418280.png" alt="203_链表删除元素2"></p>
<p><strong>当然如果使用java ，python的话就不用手动管理内存了。</strong></p>
<p>还要说明一下，就算使用C++来做leetcode，如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p>
<p>这种情况下的移除操作，就是让节点next指针直接指向下下一个节点就可以了，</p>
<p>那么因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？</p>
<p>这里就涉及如下链表操作的两种方式：</p>
<ul>
<li><strong>直接使用原来的链表来进行删除操作。</strong></li>
<li><strong>设置一个虚拟头结点在进行删除操作。</strong></li>
</ul>
<p>来看第一种操作：直接使用原来的链表来进行移除。</p>
<p><img src="https://img-blog.csdnimg.cn/2021031609544922.png" alt="203_链表删除元素3"></p>
<p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p>
<p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</p>
<p><img src="https://img-blog.csdnimg.cn/20210316095512470.png" alt="203_链表删除元素4"></p>
<p>依然别忘将原头结点从内存中删掉。 <img src="https://img-blog.csdnimg.cn/20210316095543775.png" alt="203_链表删除元素5"></p>
<p>这样移除了一个头结点，是不是发现，在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p>
<p>那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p>
<p>其实<strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p>
<p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。</p>
<p><img src="https://img-blog.csdnimg.cn/20210316095619221.png" alt="203_链表删除元素6"></p>
<p>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。</p>
<p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p>
<p>来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。</p>
<p>最后呢在题目中，return 头结点的时候，别忘了 <code>return dummyNode-&gt;next;</code>， 这才是新的头结点</p>
<p>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加虚节点方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为删除可能涉及到头节点，所以设置dummy节点，统一操作</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>设计链表_链表02</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A802/</url>
    <content><![CDATA[<h1 id="设计链表-链表02"><a href="#设计链表-链表02" class="headerlink" title="设计链表_链表02"></a>设计链表_链表02</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接(opens new window)</a></p>
<p>题意：</p>
<p>在链表类中实现这些功能：</p>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200814200558953.png" alt="707示例"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>为了方便大家理解，我特意录制了视频：<a href="https://www.bilibili.com/video/BV1FU4y1X7WD">帮你把链表操作学个通透！LeetCode：707.设计链表 (opens new window)</a>，结合视频在看本题解，事半功倍。</p>
<p>如果对链表的基础知识还不太懂，可以看这篇文章：<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于链表，你该了解这些！(opens new window)</a></p>
<p>如果对链表的虚拟头结点不清楚，可以看这篇文章：<a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">链表：听说用虚拟头节点会方便很多？(opens new window)</a></p>
<p>删除链表节点： <img src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"></p>
<p>添加链表节点： <img src="https://img-blog.csdnimg.cn/20200806195134331.png" alt="链表-添加节点"></p>
<p>这道题目设计链表的五个接口：</p>
<ul>
<li>获取链表第index个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第index个节点前面插入一个节点</li>
<li>删除链表的第index个节点</li>
</ul>
<p>可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目</p>
<p><strong>链表操作的两种方式：</strong></p>
<ol>
<li>直接使用原来的链表来进行操作。</li>
<li>设置一个虚拟头结点在进行操作。</li>
</ol>
<p>下面采用的设置一个虚拟头结点（这样更方便一些，大家看代码就会感受出来）。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表最前面插入一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表的最后插入一个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转链表_链表03</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A803/</url>
    <content><![CDATA[<h1 id="翻转链表-链表03"><a href="#翻转链表-链表03" class="headerlink" title="翻转链表_链表03"></a>翻转链表_链表03</h1><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接(opens new window)</a></p>
<p>题意：反转一个单链表。</p>
<p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。</p>
<p>其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:</p>
<p><img src="https://img-blog.csdnimg.cn/20210218090901207.png" alt="206_反转链表"></p>
<p>之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改变next指针的方向。</p>
<p>那么接下来看一看是如何反转的呢？</p>
<p>我们拿有示例中的链表来举例，如动画所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="img"></p>
<p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p>
<p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p>
<p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p>
<p>接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。</p>
<p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = cur.next;<span class="comment">// 保存下一个节点</span></span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>两两交换链表中的节点_链表04</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A804/</url>
    <content><![CDATA[<h1 id="两两交换链表中的节点-链表04"><a href="#两两交换链表中的节点-链表04" class="headerlink" title="两两交换链表中的节点_链表04"></a>两两交换链表中的节点_链表04</h1><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接(opens new window)</a></p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="24.两两交换链表中的节点-题意"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目正常模拟就可以了。</p>
<p>建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p>
<p>对虚拟头结点的操作，还不熟悉的话，可以看这篇<a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">链表：听说用虚拟头节点会方便很多？ (opens new window)</a>。</p>
<p>接下来就是交换相邻两个元素了，<strong>此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序</strong></p>
<p>初始时，cur指向虚拟头结点，然后进行如下三步：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png" alt="24.两两交换链表中的节点1"></p>
<p>操作之后，链表如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png" alt="24.两两交换链表中的节点2"></p>
<p>看这个可能就更直观一些了：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png" alt="24.两两交换链表中的节点3"></p>
<p>java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">dummpy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">		dummpy.next = head;</span><br><span class="line">		pre.next = head;</span><br><span class="line">		<span class="keyword">while</span>(pre.next!=<span class="literal">null</span> &amp;&amp; pre.next.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">			pre.next = head.next;</span><br><span class="line">			pre.next.next = head;</span><br><span class="line">			head.next = tmp;</span><br><span class="line">			pre = head;</span><br><span class="line">			head = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dummpy.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第N个节点_链表05</title>
    <url>/2022/07/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A805/</url>
    <content><![CDATA[<h1 id="代码随想录-链表05"><a href="#代码随想录-链表05" class="headerlink" title="代码随想录_链表05"></a>代码随想录_链表05</h1><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接(opens new window)</a></p>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>进阶：你能尝试使用一趟扫描实现吗？</p>
<p>示例 1：</p>
<p><img src="https://s2.loli.net/2022/07/21/hLWKP3FJsnirElH.png" alt="19.删除链表的倒数第N个节点"></p>
<p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出：[1,2,3,5] 示例 2：</p>
<p>输入：head &#x3D; [1], n &#x3D; 1 输出：[] 示例 3：</p>
<p>输入：head &#x3D; [1,2], n &#x3D; 1 输出：[1]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p>
<p>思路是这样的，但要注意一些细节。</p>
<p>分为如下几步：</p>
<ul>
<li>首先这里我推荐大家使用虚拟头结点，这样方便处理删除实际头结点的逻辑，如果虚拟头结点不清楚，可以看这篇： <a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">链表：听说用虚拟头节点会方便很多？(opens new window)</a></li>
<li>定义fast指针和slow指针，初始值为虚拟头结点，如图：</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/21/yDqCI5BFOieLGjM.png" alt="img"></p>
<ul>
<li>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： <img src="https://s2.loli.net/2022/07/21/wvWEyq9OSzJNFks.png" alt="img"></li>
<li>fast和slow同时移动，直到fast指向末尾，如题： <img src="https://s2.loli.net/2022/07/21/gCJIHN9oaDP8WOX.png" alt="img"></li>
<li>删除slow指向的下一个节点，如图： <img src="https://s2.loli.net/2022/07/21/mZF7AtdsHQPrcgK.png" alt="img"></li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    		<span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">    		<span class="type">ListNode</span> <span class="variable">fastIndex</span> <span class="operator">=</span> dummy;</span><br><span class="line">        	<span class="type">ListNode</span> <span class="variable">slowIndex</span> <span class="operator">=</span> dummy;</span><br><span class="line">        	<span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                fastIndex = fastIndex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        	<span class="keyword">while</span>(fastIndex !=<span class="literal">null</span>) &#123;</span><br><span class="line">                pre = slowIndex;</span><br><span class="line">                fastIndex = fastIndex.next;</span><br><span class="line">                slowIndex = slowIndex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        	pre.next = slow.next;</span><br><span class="line">        	<span class="keyword">return</span> dummy.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表相交_链表06</title>
    <url>/2022/07/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A806/</url>
    <content><![CDATA[<h1 id="链表相交-链表06"><a href="#链表相交-链表06" class="headerlink" title="链表相交_链表06"></a>链表相交_链表06</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣题目链接(opens new window)</a></p>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png" alt="img"></p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p>示例 1：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221723.png" alt="img"></p>
<p>示例 2：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221749.png" alt="img"></p>
<p>示例 3：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221812.png" alt="img"><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221812.png" alt="img"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单来说，就是求两个链表交点节点的<strong>指针</strong>。 这里同学们要注意，交点不是数值相等，而是指针相等。</p>
<p>为了方便举例，假设节点元素数值相等，则节点指针相等。</p>
<p>看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_1.png" alt="面试题02.07.链表相交_1"></p>
<p>我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="面试题02.07.链表相交_2"></p>
<p>此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA &#x3D;&#x3D; curB，则找到交点。</p>
<p>否则循环退出返回空指针。</p>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">    	int lenA = 0;</span><br><span class="line">    	ListNode curA = headA;</span><br><span class="line">    	int lenB = 0;</span><br><span class="line">    	ListNode curB = headB;</span><br><span class="line">    	while(curA != null) &#123;</span><br><span class="line">    		lenA++;</span><br><span class="line">    		curA = curA.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	while(curB != null) &#123;</span><br><span class="line">    		lenB++;</span><br><span class="line">    		curB = curB.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	int gap = Math.abs(lenA-lenB);</span><br><span class="line">    	if(lenA &gt; lenB) &#123;</span><br><span class="line">    		while(gap-- &gt; 0) &#123;</span><br><span class="line">    			headA = headA.next;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125; else &#123;</span><br><span class="line">    		while(gap-- &gt; 0) &#123;</span><br><span class="line">    			headB = headB.next;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	while(headA != null) &#123;</span><br><span class="line">    		if(headA == headB) &#123;</span><br><span class="line">    			return headA;</span><br><span class="line">    		&#125;</span><br><span class="line">    		headA = headA.next;</span><br><span class="line">    		headB = headB.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录_链表理论</title>
    <url>/2022/07/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="代码随想录-链表理论"><a href="#代码随想录-链表理论" class="headerlink" title="代码随想录_链表理论"></a>代码随想录_链表理论</h1><h3 id="关于链表，你该了解这些！"><a href="#关于链表，你该了解这些！" class="headerlink" title="关于链表，你该了解这些！"></a>关于链表，你该了解这些！</h3><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链接的入口节点称为链表的头结点也就是head。</p>
<p>如图所示： <img src="https://img-blog.csdnimg.cn/20200806194529815.png" alt="链表1"></p>
<h1 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h1><p>接下来说一下链表的几种类型:</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>刚刚说的就是单链表。</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>单链表中的指针域只能指向节点的下一个节点。</p>
<p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p>
<p>双链表 既可以向前查询也可以向后查询。</p>
<p>如图所示： <img src="https://img-blog.csdnimg.cn/20200806194559317.png" alt="链表2"></p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表，顾名思义，就是链表首尾相连。</p>
<p>循环链表可以用来解决约瑟夫环问题。</p>
<p><img src="https://img-blog.csdnimg.cn/20200806194629603.png" alt="链表4"></p>
<h2 id="链表的存储方式"><a href="#链表的存储方式" class="headerlink" title="链表的存储方式"></a>链表的存储方式</h2><p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p>
<p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p>
<p>链表是通过指针域的指针链接在内存中各个节点。</p>
<p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806194613920.png" alt="链表3"></p>
<p>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p>
<h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><p>接下来说一说链表的定义。</p>
<p>链表节点的定义，很多同学在面试的时候都写不好。</p>
<p>这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p>
<p>而在面试的时候，一旦要自己手写链表，就写的错漏百出。</p>
<p>这里我给出C&#x2F;C++的定义链表节点方式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p>
<p>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p>
<p>通过自己定义构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>使用默认构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p>
<h3 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h3><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除D节点，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"></p>
<p>只要将C节点的next指针 指向E节点就可以了。</p>
<p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p>
<p>是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。</p>
<p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806195134331.png" alt="链表-添加节点"></p>
<p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p>
<p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>再把链表的特性和数组的特性进行一个对比，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806195200276.png" alt="链表-链表与数据性能对比"></p>
<p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<p>相信大家已经对链表足够的了解，后面我会讲解关于链表的高频面试题目，我们下期见！</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>吉他01</title>
    <url>/2022/07/21/%E5%90%89%E4%BB%9601/</url>
    <content><![CDATA[<h1 id="吉他01"><a href="#吉他01" class="headerlink" title="吉他01"></a>吉他01</h1><h3 id="音名："><a href="#音名：" class="headerlink" title="音名："></a>音名：</h3><p>C D E F G A B</p>
<h3 id="简谱名："><a href="#简谱名：" class="headerlink" title="简谱名："></a>简谱名：</h3><p>1 2 3 4 5 6 7</p>
<h3 id="唱名："><a href="#唱名：" class="headerlink" title="唱名："></a>唱名：</h3><p>Do Re Mi Fa Sol La Si (Do)</p>
<h3 id="合并来记"><a href="#合并来记" class="headerlink" title="合并来记"></a>合并来记</h3><p>C D E F G A B</p>
<p>1 2 3 4 5 6 7</p>
<p>Do Re Mi Fa Sol La Si (Do)</p>
]]></content>
      <categories>
        <category>吉他</category>
      </categories>
      <tags>
        <tag>吉他</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表_链表07</title>
    <url>/2022/07/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E9%93%BE%E8%A1%A807/</url>
    <content><![CDATA[<h1 id="环形链表-链表07"><a href="#环形链表-链表07" class="headerlink" title="环形链表_链表07"></a>环形链表_链表07</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣题目链接(opens new window)</a></p>
<p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><strong>说明</strong>：不允许修改给定的链表。</p>
<p><img src="https://img-blog.csdnimg.cn/20200816110112704.png" alt="循环链表"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目，不仅考察对链表的操作，而且还需要一些数学运算。</p>
<p>主要考察两知识点：</p>
<ul>
<li>判断链表是否环</li>
<li>如果有环，如何找到这个环的入口</li>
</ul>
<h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="#判断链表是否有环"></a><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF">#</a>判断链表是否有环</h3><p>可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p>
<p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢</p>
<p>首先第一点：<strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</strong></p>
<p>那么来看一下，<strong>为什么fast指针和slow指针一定会相遇呢？</strong></p>
<p>可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。</p>
<p>会发现最终都是这种情况， 如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210318162236720.png" alt="142环形链表1"></p>
<p>fast和slow各自再走一步， fast和slow就相遇了</p>
<p>这是因为fast是走两步，slow是走一步，<strong>其实相对于slow来说，fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo4xglk9yg30fs0b6u0x.gif" alt="141.环形链表"></p>
<h3 id="如果有环，如何找到这个环的入口"><a href="#如果有环，如何找到这个环的入口" class="headerlink" title="#如果有环，如何找到这个环的入口"></a><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E5%A6%82%E6%9E%9C%E6%9C%89%E7%8E%AF-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3">#</a>如果有环，如何找到这个环的入口</h3><p><strong>此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。</strong></p>
<p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210318162938397.png" alt="142环形链表2"></p>
<p>那么相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p>
<p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x + y) * 2 = x + y + n (y + z)</span><br></pre></td></tr></table></figure>

<p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p>
<p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p>
<p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p>
<p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p>
<p>这个公式说明什么呢？</p>
<p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p>
<p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p>
<p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>
<p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。</p>
<p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58gauidg30fw0bi4qr.gif" alt="142.环形链表II（求入口）"></p>
<p>那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。</p>
<p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">    	ListNode fastIndex = head;</span><br><span class="line">    	ListNode slowIndex = head;</span><br><span class="line">    	while(fastIndex != null &amp;&amp; fastIndex != null) &#123;</span><br><span class="line">    		fastIndex = fastindex.next.next;</span><br><span class="line">    		slowIndex = slowIndex.next;</span><br><span class="line">    		if(fastIndex == slowIndex) &#123;</span><br><span class="line">    			index1 = fastIndex;</span><br><span class="line">    			index2 = head;</span><br><span class="line">    			while(index1 != index2) &#123;</span><br><span class="line">    				index1 = index1.next;</span><br><span class="line">    				index2 = index2.next;</span><br><span class="line">    			&#125;</span><br><span class="line">    			return index1;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>天猫闲谈</title>
    <url>/2022/07/19/%E5%A4%A9%E7%8C%AB%E9%97%B2%E8%B0%88/</url>
    <content><![CDATA[<h1 id="天猫闲谈"><a href="#天猫闲谈" class="headerlink" title="天猫闲谈"></a>天猫闲谈</h1><h2 id="遇到的问题和解决方案"><a href="#遇到的问题和解决方案" class="headerlink" title="遇到的问题和解决方案"></a>遇到的问题和解决方案</h2><h3 id="SSL报错01"><a href="#SSL报错01" class="headerlink" title="SSL报错01"></a>SSL报错01</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;C:\ProgramData\Anaconda3\lib\site-packages\requests\adapters.py&quot;, line 512, in send</span><br><span class="line">    raise SSLError(e, request=request)</span><br><span class="line">requests.exceptions.SSLError: [SSL: TLSV1_ALERT_INTERNAL_ERROR] tlsv1 alert internal error (_ssl.c:833)</span><br></pre></td></tr></table></figure>

<p>使用了anaconda，貌似win10 anaconda python中SSL是无法正常使用的</p>
<h3 id="SSL报错02"><a href="#SSL报错02" class="headerlink" title="SSL报错02"></a>SSL报错02</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    raise SSLError(e, request=request)</span><br><span class="line">requests.exceptions.SSLError: HTTPSConnectionPool(host=&#x27;detail.tmall.com&#x27;, port=443): Max retries exceeded with url: /item.htm?spm=a220m.1000858.1000725.6.279262bdaFcN4o&amp;id=644251278102&amp;skuId=4811506167531&amp;areaId=430500&amp;user_id=3695246029&amp;cat_id=2&amp;is_b=1&amp;rn=fbac5ad264b425e565a06fe73f8dddc5 (Caused by SSLError(SSLEOFError(8, &#x27;EOF occurred in violation of protocol (_ssl.c:1129)&#x27;)))</span><br></pre></td></tr></table></figure>

<p>把代理和vpn都关掉就刑了</p>
<h3 id="遇到-u0026开头的数据"><a href="#遇到-u0026开头的数据" class="headerlink" title="遇到\u0026开头的数据"></a>遇到\u0026开头的数据</h3><p>在线网站解码uincode</p>
<p>[网站链接](<a href="https://www.bt.cn/tools/unicode.html">Unicode编码解码 (bt.cn)</a>)</p>
<p><img src="https://img1.imgtp.com/2022/07/20/cpv9DczW.png" alt="image-20220719210902845"></p>
<p>代码解码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str1 = &#x27;\u003d676464506778\u0026ns\u003d1\u0026abbucket\u003d20&#x27;</span><br><span class="line">str1 = str1.encode(&#x27;utf8&#x27;).decode(&#x27;unicode_escape&#x27;)</span><br><span class="line">print(str1)</span><br></pre></td></tr></table></figure>

<h3 id="JSON形式数据无法格式化"><a href="#JSON形式数据无法格式化" class="headerlink" title="JSON形式数据无法格式化"></a>JSON形式数据无法格式化</h3><p>[网站推荐](<a href="https://www.sojson.com/">JSON在线 | JSON解析格式化—SO JSON在线工具</a>)</p>
<h2 id="主页数据获取"><a href="#主页数据获取" class="headerlink" title="主页数据获取"></a>主页数据获取</h2><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">from lxml import etree</span><br><span class="line">headers = &#123;&#125;</span><br><span class="line">user_agent_list = [</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;</span><br><span class="line">    ]</span><br><span class="line"># 思路 先通过re正则表达式截取字符串 再转成json 提取后的detail_url 需要unicode解码 随后请求二级页面 保存到数据库</span><br><span class="line">headers[&#x27;User-Agent&#x27;] = random.choice(user_agent_list)</span><br><span class="line">headers[&#x27;cookie&#x27;] = &#x27;lid=tb9609426962; enc=BH1kwxit6G8cG+yyNm8RGSjGG7Ul6TPPC9cupRd7pcLOTHzbtGjUWvt+y1/lnpq20MnX/L2ib6fxGQgPVPErnDcEfbiBCMvSLjTaVe7Ke+Q=; xlly_s=1; t=1dc717b7817ec57908076132934639cf; tracknick=tb9609426962; lgc=tb9609426962; _tb_token_=e75e6f118fe1f; cookie2=1733e90542b3f845c3ae6495f5805686; dnk=tb9609426962; uc1=cookie21=U+GCWk/7pun3Y5w91g==&amp;existShop=false&amp;cookie14=UoexOtxinA35mw==&amp;cookie15=W5iHLLyFOGW7aA==&amp;cookie16=Vq8l+KCLySLZMFWHxqs8fwqnEw==&amp;pas=0; uc3=id2=UUphw2zWTYMnUcGdIA==&amp;lg2=U+GCWk/75gdr5Q==&amp;nk2=F5RMHyzSuEkCcKo1&amp;vt3=F8dCv4MTXkH24gx6sAo=; uc4=id4=0@U2grGNOhoAYQJI7x06Q9pDUuuKKF/Kxv&amp;nk4=0@FY4HWrWzC/MqtVcYArH9YSEDnCASDHo=; _l_g_=Ug==; unb=2209950509527; cookie1=BYBYyEkdr9rg6r9BkSz4NbO8O9IxtK9O+uxD9+ms0+g=; login=true; cookie17=UUphw2zWTYMnUcGdIA==; _nk_=tb9609426962; sgcookie=E100hATU0w94N3lFcvzLxXKWpFR/t6l5etXuPZwTQZw4C5dK7IMPctrGWC/zr3BN9BMQ8hG+G5eX+4MwnfuJ9a//JxrxaolzbVqljAcBsKt/s8c=; cancelledSubSites=empty; sg=27d; csg=06c4cb83; cna=dxpdG1ujxikCAW416kuUQRzQ; _med=dw:1280&amp;dh:720&amp;pw:1920&amp;ph:1080&amp;ist:0; _m_h5_tk=b13d35cfa8eba44fe9e718d2ab0a8db6_1658233336473; _m_h5_tk_enc=ca8261f26c330ffca5b111d34d3154c2; x5sec=7b22746d616c6c7365617263683b32223a223865636565636234376335353662326338396537313536376232646232393135434e336532705947454c6a42394d4341694b7a754a426f504d6a49774f546b314d4455774f5455794e7a73784d4f5057684b62352f2f2f2f2f77453d227d; res=scroll:990*7119-client:497*561-offset:497*7119-screen:1280*720; pnm_cku822=098#E1hvIvvUvbZvjQCkvvvvvjiWRLLUsjl8n2s9zjrCPmPwsjtPRFLWsjinPFcwQj0evpvhvvmv9u9Cvv9vvUCCx++HVO9CvvwUvUVvwZjWKvhv8vvvvvCvpvvvvvvC9hCvmvZvvUUvphvUpQvv99CvpvkkvvmmvhCvm8UUvpCWCviPvvawafmxfX9Ojomxfa3lD1DlpqmxfwoOd5lPlnoOD40Owm0QD7zheTtYvtxr1WoKHkx/1WBlYCe4axRxfwLvd3ODN+LvaNpM+9vCvvOvCvvvphvRvpvhMMGvv29Cvvpvvvvv; tfstk=cSOGBdwdZdWs2wLyuC1siTHnulDRZ1iNbIR9TV1ISNQJVCOFiweUUjus-MoSb-1..; l=eBSVJC2cL0chGFjsBOfwourza77OSIRAguPzaNbMiOCPOc5H5XMfW6vz5eYMC3GVh6vDR3Wrj_IwBeYBqIY75O9StBALurkmn; isg=BOPj1cl9hRwO7kkrfnvS78pIcieN2HcaWtHIxxVAP8K5VAN2nagHasGGTiTadM8S&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># headers = &#123;</span><br><span class="line">#         &#x27;accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;,</span><br><span class="line">#         &#x27;accept-language&#x27;: &#x27;zh-CN,zh;q=0.9&#x27;,</span><br><span class="line">#         &#x27;cache-control&#x27;: &#x27;no-cache&#x27;,</span><br><span class="line"># &#125;</span><br><span class="line">for n in range(1,30):</span><br><span class="line">    url = &#x27;https://list.tmall.com/search_product.htm?spm=a220m.1000858.0.0.752962bd7xoYBT&amp;s=60&amp;q=%C5%AE%CA%BF%B0%FC&amp;sort=s&amp;style=g&amp;from=mallfp..pc_1_searchbutton&amp;type=pc#J_Filter&#x27;</span><br><span class="line">    resp = requests.get(url=url, headers=headers).text</span><br><span class="line">    # js_format = re.findall(&#x27;&quot;itemlist&quot;:(.*?),&quot;bottomsearch&quot;:&#x27;,resp)</span><br><span class="line">    # print(js_format)</span><br><span class="line">    html = etree.HTML(resp)</span><br><span class="line">    div_list = html.xpath(&#x27;//div[@class=&quot;page&quot;]/div/div[@id=&quot;content&quot;]/div/div[@id=&quot;J_ItemList&quot;]/div&#x27;)</span><br><span class="line">    print(len(div_list))</span><br><span class="line">    for i,v in enumerate(div_list):</span><br><span class="line">        price = v.xpath(&#x27;./div/p[@class=&quot;productPrice&quot;]/em/text()&#x27;)</span><br><span class="line">        sell_num = v.xpath(&#x27;./div/p[@class=&quot;productStatus&quot;]/span/em/text()&#x27;)</span><br><span class="line">        shop_name = v.xpath(&#x27;./div/div[@class=&quot;productShop&quot;]/a/text()&#x27;)</span><br><span class="line">        count_num = v.xpath(&#x27;./div/p[@class=&quot;productStatus&quot;]/span/a/text()&#x27;)</span><br><span class="line">        print(price,sell_num,shop_name,count_num)</span><br><span class="line">    # print(resp)</span><br><span class="line">    print(&quot;end!!!&quot;)</span><br><span class="line">    break</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src="https://img1.imgtp.com/2022/07/20/SagBQra1.png" alt="image-20220719213614328"></p>
<h2 id="二级页面"><a href="#二级页面" class="headerlink" title="二级页面"></a>二级页面</h2><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">import random</span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">headers = &#123;&#125;</span><br><span class="line">user_agent_list = [</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;</span><br><span class="line">    ]</span><br><span class="line"># 思路 先通过re正则表达式截取字符串 再转成json 提取后的detail_url 需要unicode解码 随后请求二级页面 保存到数据库</span><br><span class="line">headers[&#x27;User-Agent&#x27;] = random.choice(user_agent_list)</span><br><span class="line">headers[&#x27;cookie&#x27;] = &#x27;lid=tb9609426962; enc=BH1kwxit6G8cG+yyNm8RGSjGG7Ul6TPPC9cupRd7pcLOTHzbtGjUWvt+y1/lnpq20MnX/L2ib6fxGQgPVPErnDcEfbiBCMvSLjTaVe7Ke+Q=; xlly_s=1; t=1dc717b7817ec57908076132934639cf; tracknick=tb9609426962; lgc=tb9609426962; _tb_token_=e75e6f118fe1f; cookie2=1733e90542b3f845c3ae6495f5805686; dnk=tb9609426962; uc1=cookie21=U+GCWk/7pun3Y5w91g==&amp;existShop=false&amp;cookie14=UoexOtxinA35mw==&amp;cookie15=W5iHLLyFOGW7aA==&amp;cookie16=Vq8l+KCLySLZMFWHxqs8fwqnEw==&amp;pas=0; uc3=id2=UUphw2zWTYMnUcGdIA==&amp;lg2=U+GCWk/75gdr5Q==&amp;nk2=F5RMHyzSuEkCcKo1&amp;vt3=F8dCv4MTXkH24gx6sAo=; uc4=id4=0@U2grGNOhoAYQJI7x06Q9pDUuuKKF/Kxv&amp;nk4=0@FY4HWrWzC/MqtVcYArH9YSEDnCASDHo=; _l_g_=Ug==; unb=2209950509527; cookie1=BYBYyEkdr9rg6r9BkSz4NbO8O9IxtK9O+uxD9+ms0+g=; login=true; cookie17=UUphw2zWTYMnUcGdIA==; _nk_=tb9609426962; sgcookie=E100hATU0w94N3lFcvzLxXKWpFR/t6l5etXuPZwTQZw4C5dK7IMPctrGWC/zr3BN9BMQ8hG+G5eX+4MwnfuJ9a//JxrxaolzbVqljAcBsKt/s8c=; cancelledSubSites=empty; sg=27d; csg=06c4cb83; cna=dxpdG1ujxikCAW416kuUQRzQ; pnm_cku822=098#E1hvUpvUvbZvUpCkvvvvvjiWRLLUQjn8RLSvgjthPmPp6jnmPFLpljlhRF59QjtjR8OCvvpvvhHhRvhvCvvvphvvvpvVvUCvpvvvKvhv8vvvphvvvvvvvvCmpQvvv4vvvhxHvvvC4vvvBZZvvvHZvvCHBpvvvxoUvpvjvpC2p+Lve49Cvv9vvhj2ZnnXsQ9CvhQmp+fVjakK5uyTWDKt5BwsRfwrfuVHR4VzWkZnD70Oj8TZfvDr1EAK5dUf8KBlDf8rejOd+87JViIwaHFXSfpAhC3qVUcn+3mO5jIU29hvCPMMvvv=; _m_h5_tk=b13d35cfa8eba44fe9e718d2ab0a8db6_1658233336473; _m_h5_tk_enc=ca8261f26c330ffca5b111d34d3154c2; isg=BCEhGC7I5yaGiEvRiK1wxZRWMO07zpXAVP9KXYPxaSi06kC8yR5TkOhrTB7sIi34; l=eBSVJC2cL0chG4RGBO5Zlurza77t6BOb8sPzaNbMiInca1rfTHWe_NCHUyYk7dtjgt5FrexPUcfRbdh6JSaLRFkDBeYCKXIpBbvy8e1..; tfstk=cwAfB72iPoqXNDn54tgrQGNAvU5GCBD5yxsyl02dXzRLKfg5f51meWSCAc9gV17OP&#x27;</span><br><span class="line"></span><br><span class="line">url = &#x27;https://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.6.279262bdaFcN4o&amp;id=644251278102&amp;skuId=4811506167531&amp;areaId=430500&amp;user_id=3695246029&amp;cat_id=2&amp;is_b=1&amp;rn=fbac5ad264b425e565a06fe73f8dddc5&#x27;</span><br><span class="line">resp = requests.get(url=url, headers=headers).text</span><br><span class="line"># print(resp)</span><br><span class="line">try:</span><br><span class="line">    place = re.findall(r&#x27;&lt;li title=.*?&gt;质地:&amp;nbsp;(.*?)&lt;/li&gt;&#x27;,resp)</span><br><span class="line">    place = &#x27;&#x27;.join(place)</span><br><span class="line">except Exception as e:</span><br><span class="line">    place = &#x27;&#x27;</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    popular = re.findall(r&#x27;&lt;li title=.*?&gt;流行元素:&amp;nbsp;(.*?)&lt;/li&gt;&#x27;,resp)</span><br><span class="line">    popular = &#x27;&#x27;.join(popular)</span><br><span class="line">except Exception as e:</span><br><span class="line">    popular = &#x27;&#x27;</span><br><span class="line">    print(e)</span><br><span class="line"># try:</span><br><span class="line">#     color = re.findall(r&#x27;&lt;li title=.*?&gt;颜色分类:&amp;nbsp;(.*?)&lt;/li&gt;&#x27;,resp)</span><br><span class="line">#     color = &#x27;&#x27;.join(color)</span><br><span class="line"># except Exception as e:</span><br><span class="line">#     color = &#x27;&#x27;</span><br><span class="line">#     print(e)</span><br><span class="line">try:</span><br><span class="line">    up_time = re.findall(r&#x27;&lt;li title=.*?&gt;上市时间:&amp;nbsp;(.*?)&lt;/li&gt;&#x27;,resp)</span><br><span class="line">    up_time  = &#x27;&#x27;.join(up_time )</span><br><span class="line">except Exception as e:</span><br><span class="line">    up_time  = &#x27;&#x27;</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    style = re.findall(r&quot;&lt;li title=.*?&gt;款式:&amp;nbsp;(.*?)&lt;/li&gt;&quot;,resp)</span><br><span class="line">    style = &#x27;&#x27;.join(style)</span><br><span class="line">except Exception as e:</span><br><span class="line">    style = &#x27;&#x27;</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    size = re.findall(r&quot;&lt;li title=.*?&gt;大小:&amp;nbsp;(.*?)&lt;/li&gt;&quot;,resp)</span><br><span class="line">    size = &#x27;&#x27;.join(size)</span><br><span class="line">except Exception as e:</span><br><span class="line">    size = &#x27;&#x27;</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    popular_name = re.findall(r&quot;&lt;li title=.*?&gt;流行款式名称:&amp;nbsp;(.*?)&lt;/li&gt;&quot;,resp)</span><br><span class="line">    popular_name = &#x27;&#x27;.join(popular_name)</span><br><span class="line">except Exception as e:</span><br><span class="line">    popular_name = &#x27;&#x27;</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    sell_way = re.findall(r&quot;&lt;li title=.*?&gt;销售渠道类型:&amp;nbsp;(.*?)&lt;/li&gt;&quot;,resp)</span><br><span class="line">    sell_way = &#x27;&#x27;.join(sell_way)</span><br><span class="line">except Exception as e:</span><br><span class="line">    sell_way = &#x27;&#x27;</span><br><span class="line">    print(e)</span><br><span class="line">try:</span><br><span class="line">    brand = re.findall(r&#x27;title=&quot;&amp;nbsp;.*?&gt;品牌:&amp;nbsp;(.*?)&lt;/li&gt;&#x27;,resp)</span><br><span class="line">    brand = &#x27;&#x27;.join(brand)</span><br><span class="line">except Exception as e:</span><br><span class="line">    brand = &#x27;&#x27;</span><br><span class="line">    print(e)</span><br><span class="line">print(place,popular,style,up_time,size,popular_name,sell_way,brand)</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src="https://img1.imgtp.com/2022/07/20/1AtXFqL3.png" alt="image-20220719213736527"></p>
<h2 id="网页开发者工具源码展示："><a href="#网页开发者工具源码展示：" class="headerlink" title="网页开发者工具源码展示："></a>网页开发者工具源码展示：</h2><p><img src="https://img1.imgtp.com/2022/07/20/XjNIdKxg.png" alt="image-20220719213948250"></p>
<p><img src="https://img1.imgtp.com/2022/07/20/ZscOvUTw.png" alt="image-20220719214014226"></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">import requests</span><br><span class="line">import re,time</span><br><span class="line">from lxml import etree</span><br><span class="line">import mysql.connector</span><br><span class="line">#连接数据库</span><br><span class="line">mydb = mysql.connector.connect(</span><br><span class="line">    host = &#x27;localhost&#x27;,</span><br><span class="line">    user = &#x27;root&#x27;,</span><br><span class="line">    password = &#x27;dlq668713&#x27;,</span><br><span class="line">    database = &#x27;love&#x27;,</span><br><span class="line">    auth_plugin=&#x27;mysql_native_password&#x27;,</span><br><span class="line">)</span><br><span class="line">mycursor = mydb.cursor()</span><br><span class="line">sql = &#x27;INSERT INTO tm_bag (price,sell_num,shop_name,count_num,place, popular, style, up_time, size, popular_name, sell_way, brand) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)&#x27;</span><br><span class="line">user_agent_list = [</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;,</span><br><span class="line">        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 &quot;,</span><br><span class="line">        &quot;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;</span><br><span class="line">    ]</span><br><span class="line">def get_detail(url):</span><br><span class="line">    headers = &#123;&#125;</span><br><span class="line">    headers[&#x27;User-Agent&#x27;] = random.choice(user_agent_list)</span><br><span class="line">    headers[&#x27;cookie&#x27;] = &#x27;lid=tb9609426962; enc=BH1kwxit6G8cG+yyNm8RGSjGG7Ul6TPPC9cupRd7pcLOTHzbtGjUWvt+y1/lnpq20MnX/L2ib6fxGQgPVPErnDcEfbiBCMvSLjTaVe7Ke+Q=; xlly_s=1; t=1dc717b7817ec57908076132934639cf; tracknick=tb9609426962; lgc=tb9609426962; _tb_token_=e75e6f118fe1f; cookie2=1733e90542b3f845c3ae6495f5805686; dnk=tb9609426962; uc1=cookie21=U+GCWk/7pun3Y5w91g==&amp;existShop=false&amp;cookie14=UoexOtxinA35mw==&amp;cookie15=W5iHLLyFOGW7aA==&amp;cookie16=Vq8l+KCLySLZMFWHxqs8fwqnEw==&amp;pas=0; uc3=id2=UUphw2zWTYMnUcGdIA==&amp;lg2=U+GCWk/75gdr5Q==&amp;nk2=F5RMHyzSuEkCcKo1&amp;vt3=F8dCv4MTXkH24gx6sAo=; uc4=id4=0@U2grGNOhoAYQJI7x06Q9pDUuuKKF/Kxv&amp;nk4=0@FY4HWrWzC/MqtVcYArH9YSEDnCASDHo=; _l_g_=Ug==; unb=2209950509527; cookie1=BYBYyEkdr9rg6r9BkSz4NbO8O9IxtK9O+uxD9+ms0+g=; login=true; cookie17=UUphw2zWTYMnUcGdIA==; _nk_=tb9609426962; sgcookie=E100hATU0w94N3lFcvzLxXKWpFR/t6l5etXuPZwTQZw4C5dK7IMPctrGWC/zr3BN9BMQ8hG+G5eX+4MwnfuJ9a//JxrxaolzbVqljAcBsKt/s8c=; cancelledSubSites=empty; sg=27d; csg=06c4cb83; cna=dxpdG1ujxikCAW416kuUQRzQ; pnm_cku822=098#E1hvUpvUvbZvUpCkvvvvvjiWRLLUQjn8RLSvgjthPmPp6jnmPFLpljlhRF59QjtjR8OCvvpvvhHhRvhvCvvvphvvvpvVvUCvpvvvKvhv8vvvphvvvvvvvvCmpQvvv4vvvhxHvvvC4vvvBZZvvvHZvvCHBpvvvxoUvpvjvpC2p+Lve49Cvv9vvhj2ZnnXsQ9CvhQmp+fVjakK5uyTWDKt5BwsRfwrfuVHR4VzWkZnD70Oj8TZfvDr1EAK5dUf8KBlDf8rejOd+87JViIwaHFXSfpAhC3qVUcn+3mO5jIU29hvCPMMvvv=; _m_h5_tk=b13d35cfa8eba44fe9e718d2ab0a8db6_1658233336473; _m_h5_tk_enc=ca8261f26c330ffca5b111d34d3154c2; isg=BCEhGC7I5yaGiEvRiK1wxZRWMO07zpXAVP9KXYPxaSi06kC8yR5TkOhrTB7sIi34; l=eBSVJC2cL0chG4RGBO5Zlurza77t6BOb8sPzaNbMiInca1rfTHWe_NCHUyYk7dtjgt5FrexPUcfRbdh6JSaLRFkDBeYCKXIpBbvy8e1..; tfstk=cwAfB72iPoqXNDn54tgrQGNAvU5GCBD5yxsyl02dXzRLKfg5f51meWSCAc9gV17OP&#x27;</span><br><span class="line">    resp = requests.get(url=url, headers=headers).text</span><br><span class="line">    # print(resp)</span><br><span class="line">    try:</span><br><span class="line">        place = re.findall(r&#x27;&lt;li title=.*?&gt;质地:&amp;nbsp;(.*?)&lt;/li&gt;&#x27;, resp)</span><br><span class="line">        place = &#x27;&#x27;.join(place)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        place = &#x27;&#x27;</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        popular = re.findall(r&#x27;&lt;li title=.*?&gt;流行元素:&amp;nbsp;(.*?)&lt;/li&gt;&#x27;, resp)</span><br><span class="line">        popular = &#x27;&#x27;.join(popular)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        popular = &#x27;&#x27;</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        up_time = re.findall(r&#x27;&lt;li title=.*?&gt;上市时间:&amp;nbsp;(.*?)&lt;/li&gt;&#x27;, resp)</span><br><span class="line">        up_time = &#x27;&#x27;.join(up_time)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        up_time = &#x27;&#x27;</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        style = re.findall(r&quot;&lt;li title=.*?&gt;款式:&amp;nbsp;(.*?)&lt;/li&gt;&quot;, resp)</span><br><span class="line">        style = &#x27;&#x27;.join(style)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        style = &#x27;&#x27;</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        size = re.findall(r&quot;&lt;li title=.*?&gt;大小:&amp;nbsp;(.*?)&lt;/li&gt;&quot;, resp)</span><br><span class="line">        size = &#x27;&#x27;.join(size)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        size = &#x27;&#x27;</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        popular_name = re.findall(r&quot;&lt;li title=.*?&gt;流行款式名称:&amp;nbsp;(.*?)&lt;/li&gt;&quot;, resp)</span><br><span class="line">        popular_name = &#x27;&#x27;.join(popular_name)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        popular_name = &#x27;&#x27;</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        sell_way = re.findall(r&quot;&lt;li title=.*?&gt;适用对象:&amp;nbsp;(.*?)&lt;/li&gt;&quot;, resp)</span><br><span class="line">        sell_way = &#x27;&#x27;.join(sell_way)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        sell_way = &#x27;&#x27;</span><br><span class="line">        print(e)</span><br><span class="line">    try:</span><br><span class="line">        brand = re.findall(r&#x27;title=&quot;&amp;nbsp;.*?&gt;品牌:&amp;nbsp;(.*?)&lt;/li&gt;&#x27;, resp)</span><br><span class="line">        brand = &#x27;&#x27;.join(brand)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        brand = &#x27;&#x27;</span><br><span class="line">        print(e)</span><br><span class="line">    return place, popular, style, up_time, size, popular_name, sell_way, brand</span><br><span class="line">def main(n):</span><br><span class="line">    headers = &#123;&#125;</span><br><span class="line">    headers[&#x27;User-Agent&#x27;] = random.choice(user_agent_list)</span><br><span class="line">    headers[&#x27;cookie&#x27;] = r&#x27;lid=tb9609426962; enc=BH1kwxit6G8cG+yyNm8RGSjGG7Ul6TPPC9cupRd7pcLOTHzbtGjUWvt+y1/lnpq20MnX/L2ib6fxGQgPVPErnDcEfbiBCMvSLjTaVe7Ke+Q=; xlly_s=1; t=1dc717b7817ec57908076132934639cf; tracknick=tb9609426962; lgc=tb9609426962; _tb_token_=e75e6f118fe1f; cookie2=1733e90542b3f845c3ae6495f5805686; dnk=tb9609426962; uc1=cookie21=U+GCWk/7pun3Y5w91g==&amp;existShop=false&amp;cookie14=UoexOtxinA35mw==&amp;cookie15=W5iHLLyFOGW7aA==&amp;cookie16=Vq8l+KCLySLZMFWHxqs8fwqnEw==&amp;pas=0; uc3=id2=UUphw2zWTYMnUcGdIA==&amp;lg2=U+GCWk/75gdr5Q==&amp;nk2=F5RMHyzSuEkCcKo1&amp;vt3=F8dCv4MTXkH24gx6sAo=; uc4=id4=0@U2grGNOhoAYQJI7x06Q9pDUuuKKF/Kxv&amp;nk4=0@FY4HWrWzC/MqtVcYArH9YSEDnCASDHo=; _l_g_=Ug==; unb=2209950509527; cookie1=BYBYyEkdr9rg6r9BkSz4NbO8O9IxtK9O+uxD9+ms0+g=; login=true; cookie17=UUphw2zWTYMnUcGdIA==; _nk_=tb9609426962; sgcookie=E100hATU0w94N3lFcvzLxXKWpFR/t6l5etXuPZwTQZw4C5dK7IMPctrGWC/zr3BN9BMQ8hG+G5eX+4MwnfuJ9a//JxrxaolzbVqljAcBsKt/s8c=; cancelledSubSites=empty; sg=27d; csg=06c4cb83; cna=dxpdG1ujxikCAW416kuUQRzQ; _med=dw:1280&amp;dh:720&amp;pw:1920&amp;ph:1080&amp;ist:0; _m_h5_tk=b13d35cfa8eba44fe9e718d2ab0a8db6_1658233336473; _m_h5_tk_enc=ca8261f26c330ffca5b111d34d3154c2; res=scroll:990*7119-client:497*561-offset:497*7119-screen:1280*720; pnm_cku822=098#E1hv9QvUvbZvUpCkvvvvvjiWRLLUsjEmRLzZgjYHPmPvgjYWRLLh1jtERsMZlj3EPF9Cvvpvvvvv29hvCPMMvvmUvpvjmvmC9jHCs89Cvv9vvUCCxKeNCf9Cvm9vvvvvphvvvvvvvOCvpv9HvvmmvhCvmhWvvUUvphvUI9vv99CvpvkkmvhvLv2qGvvjn/An3w0AhjHCTWex6fItb9TxfwCl5dUf8z7+kEys+FUp+8c6zEAfwxzXS47BhC3qVUcnDOmOejIUDajxALwpEcqwaNoxdB9vvpvVvvpvvhCvi9hvCvvv9UU=; tfstk=c-iVBV0e_nKqn2gEzuZwCN-KgSaAZD4g8gyToBG54iQc8S4ci2CTEBR_UJBPsrf..; l=eBSVJC2cL0chGz92BO5Zlurza77tBIOb8sPzaNbMiInca69RtF670NCHUYlWSdtjgtfEYetPUcfRbdCq13Upgei9W5lBe82taY96-; isg=BLKy6xf0BBvYPzgk1_DzyOOzA_iUQ7bdA_rZiHyKpmVQD1MJZNN77Mxt_6uzfy51; x5sec=7b22746d616c6c7365617263683b32223a2235646430336337316634366132656461373162303239653737383936393134634349574232355947454b2b42753943457635627636774561447a49794d446b354e5441314d446b314d6a63374d54446a316f536d2b662f2f2f2f3842227d&#x27;</span><br><span class="line">    url = &#x27;https://list.tmall.com/search_product.htm?spm=a220m.1000858.0.0.752962bd7xoYBT&amp;s=&#123;&#125;&amp;q=%C5%AE%CA%BF%B0%FC&amp;sort=s&amp;style=g&amp;from=mallfp..pc_1_searchbutton&amp;type=pc#J_Filter&#x27;.format(n*30)</span><br><span class="line">    # print(url)</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    resp = requests.get(url=url, headers=headers).text</span><br><span class="line">    html = etree.HTML(resp)</span><br><span class="line">    div_list = html.xpath(&#x27;//div[@class=&quot;page&quot;]/div/div[@id=&quot;content&quot;]/div/div[@id=&quot;J_ItemList&quot;]/div&#x27;)</span><br><span class="line">    print(len(div_list))</span><br><span class="line">    for i,v in enumerate(div_list):</span><br><span class="line">        print(&quot;进来了！！！&quot;)</span><br><span class="line">        data = []</span><br><span class="line">        try:</span><br><span class="line">            price = v.xpath(&#x27;./div/p[@class=&quot;productPrice&quot;]/em/text()&#x27;)</span><br><span class="line">            price = &#x27;&#x27;.join(price)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            price = &#x27;&#x27;</span><br><span class="line">            print(&quot;no price&quot;)</span><br><span class="line">        try:</span><br><span class="line">            sell_num = v.xpath(&#x27;./div/p[@class=&quot;productStatus&quot;]/span/em/text()&#x27;)</span><br><span class="line">            sell_num = &#x27;&#x27;.join(sell_num).replace(&#x27;+&#x27;,&#x27;&#x27;).replace(&#x27;笔&#x27;,&#x27;&#x27;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            sell_num = &#x27;&#x27;</span><br><span class="line">            print(&quot;no sell_num&quot;)</span><br><span class="line">        try:</span><br><span class="line">            shop_name = v.xpath(&#x27;./div/div[@class=&quot;productShop&quot;]/a/text()&#x27;)</span><br><span class="line">            shop_name = &#x27;&#x27;.join(shop_name).replace(r&#x27;\n&#x27;,&#x27;&#x27;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            shop_name = &#x27;&#x27;</span><br><span class="line">            print(&quot;no shop_name&quot;)</span><br><span class="line">        try:</span><br><span class="line">            count_num = v.xpath(&#x27;./div/p[@class=&quot;productStatus&quot;]/span/a/text()&#x27;)</span><br><span class="line">            count_num = &#x27;&#x27;.join(count_num)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            count_num = &#x27;&#x27;</span><br><span class="line">            print(&quot;no count_num&quot;)</span><br><span class="line">        try:</span><br><span class="line">            href = v.xpath(&#x27;./div/div[@class=&quot;productImg-wrap&quot;]/a/@href&#x27;)</span><br><span class="line">            href = &#x27;&#x27;.join(href)</span><br><span class="line">            href = r&#x27;https:&#x27;+href</span><br><span class="line">        except Exception as e:</span><br><span class="line">            href = &#x27;&#x27;</span><br><span class="line">            print(&quot;no href&quot;)</span><br><span class="line">        print(href)</span><br><span class="line">        # print(price,sell_num,shop_name,count_num,href)</span><br><span class="line">        try:</span><br><span class="line">            place, popular, style, up_time, size, popular_name, sell_way, brand = get_detail(href)</span><br><span class="line">            if brand == &#x27;&#x27;:</span><br><span class="line">                place, popular, style, up_time, size, popular_name, sell_way, brand = get_detail(href)</span><br><span class="line">            if sell_way == &#x27;&#x27;:</span><br><span class="line">                place, popular, style, up_time, size, popular_name, sell_way, brand = get_detail(href)</span><br><span class="line">            if popular_name == &#x27;&#x27;:</span><br><span class="line">                place, popular, style, up_time, size, popular_name, sell_way, brand = get_detail(href)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;详情页&quot;)</span><br><span class="line">            print(e)</span><br><span class="line">        print(place, popular, style, up_time, size, popular_name, sell_way, brand)</span><br><span class="line">        try:</span><br><span class="line">            data.append(price)</span><br><span class="line">            data.append(sell_num)</span><br><span class="line">            data.append(shop_name)</span><br><span class="line">            data.append(count_num)</span><br><span class="line">            data.append(place)</span><br><span class="line">            data.append(popular)</span><br><span class="line">            data.append(style)</span><br><span class="line">            data.append(up_time)</span><br><span class="line">            data.append(size)</span><br><span class="line">            data.append(popular_name)</span><br><span class="line">            data.append(sell_way)</span><br><span class="line">            data.append(brand)</span><br><span class="line">            data = tuple(data)</span><br><span class="line">            mycursor.execute(sql, data)</span><br><span class="line">            mydb.commit()</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;添加错误&quot;)</span><br><span class="line">            print(e)</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line">    # print(resp)</span><br><span class="line">    print(&quot;end!!!&quot;)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    for n in range(1,2):</span><br><span class="line">        try:</span><br><span class="line">            print(&quot;正在爬第:&quot;+str(n)+&quot;页&quot;)</span><br><span class="line">            main(n)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;first blood!&quot;)</span><br><span class="line">        if(n%14==0):</span><br><span class="line">            time.sleep(60)</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    print(&quot;所耗时间：&quot;)</span><br><span class="line">    print(t2-t1)</span><br></pre></td></tr></table></figure>

<h2 id="很尴尬"><a href="#很尴尬" class="headerlink" title="很尴尬"></a>很尴尬</h2><p>详情页的总是有验证码反爬，以后再想想办法吧</p>
<p>目前是这个鬼样子：</p>
<p><img src="https://img1.imgtp.com/2022/07/20/ULq6Bk79.png" alt="image-20220719230132308"></p>
]]></content>
      <categories>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序电脑端抓包成功</title>
    <url>/2022/08/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%93%E5%8C%85%E6%88%90%E5%8A%9F/</url>
    <content><![CDATA[<h1 id="微信小程序电脑端抓包成功"><a href="#微信小程序电脑端抓包成功" class="headerlink" title="微信小程序电脑端抓包成功"></a>微信小程序电脑端抓包成功</h1><h3 id="1-删除WMPFRuntime下的文件"><a href="#1-删除WMPFRuntime下的文件" class="headerlink" title="1.删除WMPFRuntime下的文件"></a>1.删除WMPFRuntime下的文件</h3><p>通过任务管理器找到该文件，右键打开文件位置，删除文件(记得先关掉vx才能删除)</p>
<p><img src="https://s2.loli.net/2022/08/01/P8SgjxBsalvfIF9.png" alt="image-20220801221221116.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\hhh\AppData\Roaming\Tencent\WeChat\XPlugin\Plugins\WMPFRuntime</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/08/01/7GxiEdAQc2ODpIb.png" alt="image-20220801221331236.png"></p>
<h2 id="2-重新打开微信进入小程序"><a href="#2-重新打开微信进入小程序" class="headerlink" title="2.重新打开微信进入小程序"></a>2.重新打开微信进入小程序</h2><p>打开小程序后，fiddle就能抓到包了</p>
<p><img src="https://s2.loli.net/2022/08/04/mwxEOZSfNonD5Ga.jpg" alt="image-20220801221626752.png"></p>
<p>小知识点(大佬教的)：小程序登录的原理是通过微信的wxlogin接口获取一个code，然后把code传到后端，后端调用微信的接口将code解成openid(一小程序中用户唯一标识)</p>
<h2 id="3-pycharm中测试"><a href="#3-pycharm中测试" class="headerlink" title="3.pycharm中测试"></a>3.pycharm中测试</h2><p>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &#x27;https://api.shuidichou.com/api/charity/love-home/find-love-help-case-v2&#x27;</span><br><span class="line">data = &#123;</span><br><span class="line">    &#x27;Host&#x27;: &#x27;api.shuidichou.com&#x27;,</span><br><span class="line">    &#x27;Connection&#x27;: &#x27;keep-alive&#x27;,</span><br><span class="line">    &#x27;Content-Length&#x27;: &#x27;102&#x27;,</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;&#x27;,</span><br><span class="line">    &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,</span><br><span class="line">    &#x27;Referer&#x27;: &#x27;https://servicewechat.com/wx6855c0f0e9cbb26e/74/page-frame.html&#x27;,</span><br><span class="line">    &#x27;AuthorizationV2&#x27;:&#x27;&#x27;,</span><br><span class="line">    &#x27;currentPage&#x27;:2,</span><br><span class="line">    &#x27;pageSize&#x27;:10,</span><br><span class="line">    &#x27;thirdType&#x27;:464</span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url=url,data=data).json()</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><img src="https://s2.loli.net/2022/08/01/ZCX6I5KVsPHyY9u.png" alt="image-20220801225401920.png"></p>
]]></content>
      <categories>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序采集失败原因</title>
    <url>/2022/07/31/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%87%87%E9%9B%86%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h1 id="微信小程序采集失败原因"><a href="#微信小程序采集失败原因" class="headerlink" title="微信小程序采集失败原因"></a>微信小程序采集失败原因</h1><p>现在微信都更新到了7..0以上的版本，使用charles抓包工具已经无法再抓到接口的数据。原因如下：安卓系统 7.0 以下版本，不管微信任意版本，都会信任系统提供的证书<br>安卓系统 7.0 以上版本，微信 7.0 以下版本，微信会信任系统提供的证书<br>安卓系统 7.0 以上版本，微信 7.0 以上版本，微信只信任它自己配置的证书列表</p>
]]></content>
      <categories>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/06/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>没有吃饭</p>
]]></content>
  </entry>
  <entry>
    <title>数据库操作SQL</title>
    <url>/2022/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/</url>
    <content><![CDATA[<p>这次编写的内容是数据库SQL的操作实列 以后要是不会直接从这个武器库拿就是</p>
<hr>
<h1 id="实列"><a href="#实列" class="headerlink" title="实列"></a>实列</h1><h3 id="01-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"><a href="#01-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。" class="headerlink" title="01.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"></a>01.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。</h3><p>试列出计算机系所开课程（CS标志）的最高成绩、最低成绩和平均成绩。如果某门课程的成绩不全（即“成绩”中有NULL出现），则该课程不予统计，结果按“课程号”升序排列。正确的SQL语句是</p>
<p><img src="https://img-blog.csdnimg.cn/8c9d734958ed4a8daa3070201f309889.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATG92ZSA2,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 课程号，<span class="built_in">MAX</span>(成绩)，<span class="built_in">MIN</span>(成绩)，<span class="built_in">AVG</span>(成绩) <span class="keyword">FROM</span> 选课</span><br><span class="line"><span class="keyword">WHERE</span> 课程号 <span class="keyword">Like</span> ‘CS<span class="operator">%</span>’ <span class="keyword">GROUP</span> <span class="keyword">BY</span> 课程号 <span class="keyword">HAVING</span> 课程号 <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> 课程号 <span class="keyword">FROM</span> 选课 <span class="keyword">WHERE</span> 成绩 <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 课程号</span><br></pre></td></tr></table></figure>

<h3 id="02-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"><a href="#02-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。" class="headerlink" title="02.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"></a>02.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。</h3><p>列出最少选修了三门课程的学生姓名。正确的SQL语句是</p>
<p>图片如上所示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 姓名　<span class="keyword">FROM</span> 学生　<span class="keyword">WHERE</span> 学号 <span class="keyword">IN</span>　</span><br><span class="line">(<span class="keyword">SELECT</span> 学号　<span class="keyword">FROM</span> 选课　<span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号　<span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="03-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"><a href="#03-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。" class="headerlink" title="03.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"></a>03.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。</h3><p>查询缺成绩的学生名及课程号。正确的SQL语句是</p>
<p><img src="https://img-blog.csdnimg.cn/26c14ddd06ce40bb91c54c036c04ce18.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATG92ZSA2,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 姓名，课程号 <span class="keyword">FROM</span> 学生，选课 <span class="keyword">WHERE</span> 学生.学号<span class="operator">=</span>选课.学号 <span class="keyword">AND</span> 成绩 <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<h3 id="04-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"><a href="#04-如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。" class="headerlink" title="04.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。"></a>04.如下几个表所示学生、课程和选课关系，用SQL语言实现下列操作。</h3><p>查询1996年出生的学生姓名及其秋季所修课程的课程号及成绩。正确的SQL语句是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 姓名，课程号，成绩 <span class="keyword">FROM</span> 学生，选课，课程 <span class="keyword">WHERE</span> 学生.学号<span class="operator">=</span>选课.学号 <span class="keyword">AND</span> 选课.课程号<span class="operator">=</span>课程.课程号 <span class="keyword">AND</span> <span class="keyword">Year</span>(出生日期)<span class="operator">=</span><span class="number">1996</span> <span class="keyword">AND</span> 开课学期<span class="operator">=</span>’秋’</span><br></pre></td></tr></table></figure>

<h3 id="05-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"><a href="#05-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。" class="headerlink" title="05.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"></a>05.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。</h3><p><img src="https://img-blog.csdnimg.cn/9c2aed7fa5b74fc9b69def057c6812d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATG92ZSA2,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>求既学过“1001”号课，又学过“2002”号课的所有学生的学号。正确的SQL语句是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 学号　<span class="keyword">FROM</span> 选课　<span class="keyword">WHERE</span> 课号＝‘<span class="number">1001</span>’ <span class="keyword">AND</span></span><br><span class="line">学号 <span class="keyword">IN</span>　(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 学号　<span class="keyword">FROM</span> 选课　<span class="keyword">WHERE</span> 课号＝‘<span class="number">2002</span>’ )</span><br></pre></td></tr></table></figure>

<p>我的想法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 学号 <span class="keyword">FROM</span> 选课 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号 <span class="keyword">HAVING</span> 课号 <span class="operator">=</span><span class="operator">=</span> ‘<span class="number">1001</span>’ <span class="keyword">AND</span> 课号 <span class="operator">=</span><span class="operator">=</span> ‘<span class="number">2002</span>’</span><br></pre></td></tr></table></figure>

<h3 id="06-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"><a href="#06-如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。" class="headerlink" title="06.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。"></a>06.如下几个表所示学生、课程、必修课和选课关系，用SQL语言实现下列操作。</h3><p>列出各门课的平均成绩、最高成绩、最低成绩和选课人数。正确的SQL语句是</p>
<p>图片如上所示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 课号，<span class="built_in">AVG</span>(成绩)，<span class="built_in">MAX</span>(成绩)，<span class="built_in">MIN</span>(成绩)，<span class="built_in">COUNT</span>(学号)　</span><br><span class="line"><span class="keyword">FROM</span> 选课　<span class="keyword">GROUP</span> <span class="keyword">BY</span> 课号</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语02</title>
    <url>/2022/07/06/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD02/</url>
    <content><![CDATA[<h1 id="英语口语02"><a href="#英语口语02" class="headerlink" title="英语口语02"></a>英语口语02</h1><h3 id="精算能力"><a href="#精算能力" class="headerlink" title="精算能力"></a>精算能力</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math can be helpful for balancing your budget,</span><br><span class="line">because...</span><br><span class="line">you will have a good understanding of how to make sure that </span><br><span class="line">your costs are less than the money you have</span><br></pre></td></tr></table></figure>

<p>balancing your budget 平衡收支</p>
<p>your costs are less than the money you have 收入大于支出</p>
<h3 id="入不敷出"><a href="#入不敷出" class="headerlink" title="入不敷出"></a>入不敷出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">People who are terrible at math are likely to go into debt</span><br><span class="line">because...</span><br><span class="line">they don&#x27;t know how much money they have versus how much money they spent.</span><br></pre></td></tr></table></figure>

<p>go into debt 负债</p>
<h3 id="满足好奇心"><a href="#满足好奇心" class="headerlink" title="满足好奇心"></a>满足好奇心</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Science feeds the natural curiosity,</span><br><span class="line"></span><br><span class="line">for example...</span><br><span class="line"></span><br><span class="line">The curiosity of uncovering why the sun sets in the west,</span><br><span class="line"></span><br><span class="line">why the sky is blue,how fish breathes in water</span><br><span class="line"></span><br><span class="line">and other everyday scenarios</span><br></pre></td></tr></table></figure>

<p>natural curiosity 好奇心</p>
<p>sun sets in the west 日落西山</p>
<p>everyday scenarios 日常场景</p>
]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>学习口语</title>
    <url>/2022/07/05/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD01/</url>
    <content><![CDATA[<h1 id="第一天英语口语"><a href="#第一天英语口语" class="headerlink" title="第一天英语口语"></a>第一天英语口语</h1><p>这些内容是非常好的英语口语资产 能帮助大伙快速起飞</p>
<h3 id="梅花香自苦寒来"><a href="#梅花香自苦寒来" class="headerlink" title="梅花香自苦寒来"></a>梅花香自苦寒来</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in order to feel alive,</span><br><span class="line">i have to do things that make me feel uncomfortable,</span><br><span class="line">because...</span><br><span class="line">as human beings,</span><br><span class="line">we become who we are through challenges.</span><br></pre></td></tr></table></figure>

<p>feel alive 有滋有味的活着</p>
<p>do things that make me feel uncomfortable 折磨自己</p>
<p>we become who we are through challenges 高手从磨难中来</p>
<h3 id="培养顿感"><a href="#培养顿感" class="headerlink" title="培养顿感"></a>培养顿感</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">by taking risks,</span><br><span class="line">you will learn to overcome your fears,</span><br><span class="line">for example...</span><br><span class="line">you will likely find that you care less about what people think and about what could go wrong</span><br></pre></td></tr></table></figure>

<p>overcome your fears 克服恐惧</p>
<p>care less about what people think and about what could go wrong 大心脏</p>
<h3 id="敢拼敢闯"><a href="#敢拼敢闯" class="headerlink" title="敢拼敢闯"></a>敢拼敢闯</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all successful people have taken risks,failed and picked themselves up,</span><br><span class="line">because they believe that</span><br><span class="line">those who never venture far </span><br><span class="line">will never know might have been if they had tired to do things beyond what they had already mastered.</span><br></pre></td></tr></table></figure>

<p>taken risks,failed and picked themselves up 屡战屡败</p>
<p>never venture far 不敢越雷池半步</p>
<p>to do things beyond what they had already mastered 勇敢尝试</p>
<h3 id="言传身教"><a href="#言传身教" class="headerlink" title="言传身教"></a>言传身教</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">we want our children to take risks and try things outside their</span><br><span class="line">comfort zones,</span><br><span class="line">but to help them we need to set a good example,</span><br><span class="line">because...</span><br><span class="line">we can&#x27;t expect our kids to go out and conquer the world</span><br><span class="line">if we are hiding in our room.</span><br></pre></td></tr></table></figure>

<p>take risks and try things outside their comfort zones 勇敢试错</p>
<p>set a good example 树立榜样</p>
<p>go out and conquer the world 打天下</p>
<p>hiding in the room 龟缩不前</p>
<p><u>这些都是打基础后面会越来越爽,越来越轻松，爽到飞起</u></p>
]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语03</title>
    <url>/2022/07/12/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD03/</url>
    <content><![CDATA[<h1 id="英语口语03"><a href="#英语口语03" class="headerlink" title="英语口语03"></a>英语口语03</h1><h3 id="精力充沛"><a href="#精力充沛" class="headerlink" title="精力充沛"></a>精力充沛</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i will try to get into the routine of getting up early in the morning and go to bed</span><br><span class="line">early at night,</span><br><span class="line">so that...</span><br><span class="line">i will have a better sleeping pattern which enables me to be more energetic throughtout the day</span><br></pre></td></tr></table></figure>

<h3 id="三省吾身"><a href="#三省吾身" class="headerlink" title="三省吾身"></a>三省吾身</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i think it&#x27;s important to refresh my mind about the current situation,</span><br><span class="line">by vasualizing long,middle,short term goals everyday </span><br><span class="line">because...</span><br><span class="line">sometimes it&#x27;s easy to lose the big picture when we are immersing yourself in detailed executions.</span><br><span class="line">But it&#x27;s also easy to miss out the detailed executions when we are grasping the big picture</span><br></pre></td></tr></table></figure>

<h3 id="熬夜伤身"><a href="#熬夜伤身" class="headerlink" title="熬夜伤身"></a>熬夜伤身</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">being a night owl could hurt our health</span><br><span class="line">because...</span><br><span class="line">staying up late will disrupts your sleep-wake cycle...</span><br><span class="line">which can affect your mental functioning and energy levels the next day.</span><br></pre></td></tr></table></figure>

<p><em><strong>*不要找借口，不要找理由，把这些宝贵资产全部拿下*</strong></em></p>
<p><em><strong>*足够的时间，足够的方法论支撑，不可能拿不下的。*</strong></em></p>
<p><em><strong>*今天的辛苦就是明天的幸福，道理就是这么简单。*</strong></em></p>
]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语04</title>
    <url>/2022/07/13/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD04/</url>
    <content><![CDATA[<h1 id="英语口语04"><a href="#英语口语04" class="headerlink" title="英语口语04"></a>英语口语04</h1><h3 id="心中有蓝图"><a href="#心中有蓝图" class="headerlink" title="心中有蓝图"></a>心中有蓝图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you should have a version for the future,</span><br><span class="line">something you want to do or accomplish,</span><br><span class="line">because...</span><br><span class="line">when you map out your goals,</span><br><span class="line">you will focus on things that can help you achieve what you want in life.</span><br></pre></td></tr></table></figure>

<h3 id="打开适应度"><a href="#打开适应度" class="headerlink" title="打开适应度"></a>打开适应度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if you just do what you are pretty good at already,</span><br><span class="line">you will not triggle adaptability.</span><br><span class="line">because...</span><br><span class="line">mastery is not just about putting in 10000 hours,</span><br><span class="line">just doing something over and over again does&#x27;t make you </span><br><span class="line">better at something,</span><br><span class="line">it&#x27;s about 100 hours of deliberate practice.</span><br></pre></td></tr></table></figure>

<h3 id="苦练成才"><a href="#苦练成才" class="headerlink" title="苦练成才"></a>苦练成才</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">to reach your peak performance level,</span><br><span class="line">you need to challenge yourself,</span><br><span class="line">because...</span><br><span class="line">you can&#x27;t expect to evolve and reach new heights if </span><br><span class="line">you only stick to your normal habits and lifestyle.</span><br></pre></td></tr></table></figure>

<p><strong>世界上最甜蜜的事，就是极致内化之后的自动脑补。</strong></p>
<p><strong>不必消耗脑流量，直接下意识输出。</strong></p>
<p><strong>就像弹钢琴一样。</strong></p>
<p><strong>练至精熟之境，你不必在意手指，</strong></p>
<p><strong>手指自动会落在适合的琴键上，并一瞬间打开最精确的力度和准度。</strong></p>
<p><strong>这种境界，你不去体会，必遗憾终身。</strong></p>
]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语05</title>
    <url>/2022/07/14/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD05/</url>
    <content><![CDATA[<h1 id="英语口语05"><a href="#英语口语05" class="headerlink" title="英语口语05"></a>英语口语05</h1><h3 id="行动是良药"><a href="#行动是良药" class="headerlink" title="行动是良药"></a>行动是良药</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">negative emotions are a call to action,</span><br><span class="line">i mean...</span><br><span class="line">if you feel crappy,</span><br><span class="line">it&#x27;s because that your brain is telling you that </span><br><span class="line">there&#x27;s a problem that&#x27;s unaddressed,</span><br><span class="line">and you&#x27;re supposed to do something.</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：第一句话种复数接a call to action，是没问题的，母语者语流*</strong></em></p>
<h3 id="种瓜得瓜"><a href="#种瓜得瓜" class="headerlink" title="种瓜得瓜"></a>种瓜得瓜</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">happiness requires struggles,</span><br><span class="line">because...</span><br><span class="line">Joy doesn&#x27;t sprout out of the ground,</span><br><span class="line">if you want something,you have to work for it,</span><br><span class="line">what you reap what you sow</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：母语者语流种蕴含着天然的合理节奏，比中英翻译要合理得多。*</strong></em></p>
<p><em><strong>*大白话就是说的时候节奏很自然，语流清晰而地道。*</strong></em></p>
<h3 id="机会成本"><a href="#机会成本" class="headerlink" title="机会成本"></a>机会成本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Everything comes with a inherent sacrifice(有利有弊)</span><br><span class="line">what we gain is also what we lose,</span><br><span class="line">like...</span><br><span class="line">the person you marry is the person you fight with,</span><br><span class="line">the house you buy is the house you repair,</span><br><span class="line">the dream job you take is the job you stress over</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：例证时的排比，宛若长江三叠浪，节奏中力度十足，掷地有声。*</strong></em></p>
<p><em><strong>*我们现阶段要达到的境界，就是在中文表达中，或日常所见所闻，慢慢感受到从“中文俗语”到“英文语流”的无缝连接。*</strong></em></p>
<p><em><strong>*这样一来，中英文的互换，就变得极其轻松。*</strong></em></p>
<p><em><strong>*流利度也慢慢得到体现。*</strong></em></p>
]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语06</title>
    <url>/2022/07/15/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD06/</url>
    <content><![CDATA[<h1 id="英语口语06"><a href="#英语口语06" class="headerlink" title="英语口语06"></a>英语口语06</h1><h3 id="朝九晚五"><a href="#朝九晚五" class="headerlink" title="朝九晚五"></a>朝九晚五</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the dark side of 9-5 job is that</span><br><span class="line">you&#x27;re exchanging your time for money,</span><br><span class="line">like...</span><br><span class="line">you spent an hour at your job,you get paied for that hour,</span><br><span class="line">for example,</span><br><span class="line">you could work your ass off,like...80 hours a week and make a certain</span><br><span class="line">amount of money...</span><br><span class="line">the problem is...</span><br><span class="line">next week you want to make that same amount,</span><br><span class="line">you still have to spend 80 hours a week.</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：概念落地+例证说明，潇洒利落，层次分明。*</strong></em></p>
<p><em><strong>*如果你不赞同这个观点，你也可以拿他当一个返利，比如，啊，有些人说朝九晚五不行，他们的逻辑是….但我认为…*</strong></em></p>
<p><em><strong>*口语中，拿自己不赞同的观点开刷，是非常聪明的打法。*</strong></em></p>
<h3 id="大负翁"><a href="#大负翁" class="headerlink" title="大负翁"></a>大负翁</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Many bussiness owners end up in debt,</span><br><span class="line">because...</span><br><span class="line">they are struggling to keep the personal finances afloat</span><br><span class="line">while running a business which is not yet making money.</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：短小精悍，犀利非常。*</strong></em></p>
<p><em><strong>*特别是后面逻辑链中的长句，宛若美酒，越品越香。*</strong></em></p>
<p><em><strong>*while代表伴随动作，同时发生。*</strong></em></p>
<p><em><strong>*which引导从句，修饰business.*</strong></em></p>
<h3 id="利滚利"><a href="#利滚利" class="headerlink" title="利滚利"></a>利滚利</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Debt feels free when you are swipping your card,</span><br><span class="line">but it is a illusion,</span><br><span class="line">because...</span><br><span class="line">the higher the interest rate, the more you&#x27;ll end up paying for the debt,</span><br><span class="line">Also,the longer it takes you to pay off the debt,the more interest you&#x27;ll pay.</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：这个框架非常好，攻击力强悍霸道。*</strong></em></p>
<p><em><strong>*后面自带两个比较级，组成长句，更是威力非凡。*</strong></em></p>
<p><em><strong>*请注意此语流中的用词，细细体会。*</strong></em></p>
]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语08</title>
    <url>/2022/07/18/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD08/</url>
    <content><![CDATA[<h1 id="英语口语08"><a href="#英语口语08" class="headerlink" title="英语口语08"></a>英语口语08</h1><h3 id="处世态度不同"><a href="#处世态度不同" class="headerlink" title="处世态度不同"></a>处世态度不同</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There has always been a diffrence in attitude betwen the younger and</span><br><span class="line">older generations.</span><br><span class="line">because...</span><br><span class="line">Everyone wants to live and behave in his own way,no one wants to</span><br><span class="line">compromise with his or her values and views,</span><br><span class="line">and over time,</span><br><span class="line">the attitude has agumented the gernerations gap.</span><br><span class="line">and it is wider day-by-day</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：这种直接洞察人性的答案，其实是具备很大威力的。*</strong></em></p>
<p><em><strong>*因为如果你的答题经验足够丰富，你就可以知道一个本质：*</strong></em></p>
<p><em><strong>*几乎所有分析类问题的回答，其实都可以用人性来解决其中一个或几个维度。*</strong></em></p>
<p><em><strong>*注意over time后面的句式，核心词可以替换成很多东西，*</strong></em></p>
<p><em><strong>*非常有用。*</strong></em></p>
<h3 id="价值观不同"><a href="#价值观不同" class="headerlink" title="价值观不同"></a>价值观不同</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all generations have their own set of values and views,</span><br><span class="line">because...</span><br><span class="line">Every generation have a certain time under certain circumstances</span><br><span class="line">and conditions.</span><br><span class="line">in the mean time...</span><br><span class="line">Every generation wants to uphold the principles they believe in</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：*</strong></em><em><strong>*人生在世，不可能让所有人都喜欢你。*</strong></em></p>
<p><em><strong>*因为每个人的生活处境，对世界的认知，以及思维习惯都不一样*</strong></em></p>
<p><em><strong>*通过一代人的角度来分析事物，配以人性的辅助，*</strong></em></p>
<p><em><strong>*寥寥数语，却具备深度洞察力，以及理性的包容，*</strong></em></p>
<p><em><strong>*令人闻之激赏。*</strong></em></p>
<p><em><strong>*高能动词“have”“live”“want”三星连携，一气呵成。*</strong></em></p>
<h3 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">school is very important because it is where you establish the building blocks</span><br><span class="line">of your knowledge.</span><br><span class="line">for example...</span><br><span class="line">you will begin to learn basic subjects that you will be able to </span><br><span class="line">apply in real life.</span><br><span class="line">and you will learn important social skills as you interact with other </span><br><span class="line">students.</span><br></pre></td></tr></table></figure>

<p><em><strong>*establish the building blocks*</strong></em> <em><strong>*of your knowledge*</strong></em> <em><strong>*建立体系*</strong></em></p>
<p><em><strong>*basic subjects that you will be able to apply in real life*</strong></em> <em><strong>*实用的知识*</strong></em></p>
<p><em><strong>*social skills as you interact with other students*</strong></em> <em><strong>*人际交往的技巧*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*知识体系的建立，必须从小接受良好的教育。*</strong></em></p>
<p><em><strong>*而一个认知力很厉害的人，往往就是通过教育，建立了自己的认知体系。*</strong></em></p>
<p><em><strong>*此语流一个观点+例证，鲜明清晰，让人听得不累。*</strong></em></p>
<p><em><strong>*有时候也没必要一定要太复杂，一个好玩的例子，其实已经是功力的展现。*</strong></em></p>
<p><em><strong>*词伙“*</strong></em><em><strong>*establish the building blocks*</strong></em> <em><strong>*of your knowledge*</strong></em><em><strong>*”具象化非常漂亮，而其后两个长句，*</strong></em></p>
<p><em><strong>*一个that从句，一个as从句，低调而华丽。*</strong></em></p>
]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语07</title>
    <url>/2022/07/16/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD07/</url>
    <content><![CDATA[<h1 id="英语口语07"><a href="#英语口语07" class="headerlink" title="英语口语07"></a>英语口语07</h1><h3 id="固定收入"><a href="#固定收入" class="headerlink" title="固定收入"></a>固定收入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Most full-time employees have a fixed salaries,</span><br><span class="line">so...</span><br><span class="line">they can properly budget their money based on their expenses,</span><br><span class="line">because...</span><br><span class="line">they have a clear idea about how much to expect in their bank </span><br><span class="line">account every month.</span><br></pre></td></tr></table></figure>

<p><em><strong>*fixed salaries*</strong></em> <em><strong>*固定收入*</strong></em></p>
<p><em><strong>*budget*</strong></em> <em><strong>*their*</strong></em> <em><strong>*money based on*</strong></em> <em><strong>*their*</strong></em> <em><strong>*expenses*</strong></em> <em><strong>*收支平衡*</strong></em></p>
<p><em><strong>*how much to expect in*</strong></em> <em><strong>*their*</strong></em> <em><strong>*bank account*</strong></em> <em><strong>*收入预期*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*观点+逻辑链，是最有效率的打击方法之一。*</strong></em></p>
<p><em><strong>*逻辑中的推导（so…）, 因果（because）, 必须在平时内化语流中，刻意留意，才能在实战中屡屡打出暴击效果。*</strong></em></p>
<h3 id="固定日程"><a href="#固定日程" class="headerlink" title="固定日程"></a>固定日程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Full-time employees work a fixed schedule,</span><br><span class="line">for a lot of people,it is crucial to have a specific and consistent work time each day,</span><br><span class="line">because...</span><br><span class="line">it allows them to plan around their schedules,</span><br><span class="line">rather than waiting for a rotating schedule from a part-time job.</span><br></pre></td></tr></table></figure>

<p><em><strong>*fixed schedule*</strong></em> <em><strong>*固定日程*</strong></em></p>
<p><em><strong>*a specific and consistent work time each day*</strong></em> <em><strong>*具体且不变的时间安排*</strong></em> </p>
<p><em><strong>*plan around*</strong></em> <em><strong>*their*</strong></em> <em><strong>*work schedule*</strong></em><em><strong>*s 围绕工作安排来计划各种事务*</strong></em></p>
<p><em><strong>*a rotating schedule*</strong></em> <em><strong>*多变的日程计划*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*切入点，把人物带进来。*</strong></em></p>
<p><em><strong>*张三，李四，大部分人，小部分人，*</strong></em></p>
<p><em><strong>*只要把人物带进来，并站在他们的角度上，就有话可说。*</strong></em></p>
<p><em><strong>*同学们参考罗翔老师的说话技巧。*</strong></em></p>
<p><em><strong>*It*</strong></em><em><strong>*’*</strong></em><em><strong>*s crucial…+because it allows…, 是实战价值非常强悍的框架。*</strong></em></p>
<p><em><strong>*最后rather than+名词或从句，也是出战率非常高的句式。*</strong></em></p>
<h3 id="懈怠"><a href="#懈怠" class="headerlink" title="懈怠"></a>懈怠</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if we don&#x27;t like we work,</span><br><span class="line">it&#x27;s easy for us to be drawn to the things that we want to do</span><br><span class="line">like...</span><br><span class="line">scrolling TikTok,or reading music blogs,</span><br><span class="line">rather than the things we have to do,</span><br><span class="line">this tension possibly causes fatigue.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语09</title>
    <url>/2022/07/20/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD09/</url>
    <content><![CDATA[<h1 id="英语口语09"><a href="#英语口语09" class="headerlink" title="英语口语09"></a>英语口语09</h1><h3 id="钱财安身"><a href="#钱财安身" class="headerlink" title="钱财安身"></a>钱财安身</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Money can buy the security and safety for yourself and your loved ones,</span><br><span class="line">because...</span><br><span class="line">Human beings needs money to pay for all the things that make your life</span><br><span class="line">possible.</span><br><span class="line">such as...</span><br><span class="line">shelter,food,healthcare,and a good education</span><br></pre></td></tr></table></figure>

<p><em><strong>*security and safety*</strong></em> 安全感</p>
<p><em><strong>*all the things that make your life possible*</strong></em> <em><strong>*刚需*</strong></em></p>
<p><em><strong>*shelter, food, healthcare, and a good education*</strong></em> <em><strong>*基本需求*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*例证有两种打法，最简单的一种就是名词摆放，直接将名词列举出来。*</strong></em></p>
<p><em><strong>*比如别人问你，你为什么喜欢你的工作，*</strong></em></p>
<p><em><strong>*你可以直接把工作的福利摆出来，*</strong></em></p>
<p><em><strong>*这是最简单直接的打法，在无话可说的时候，非常实用。*</strong></em></p>
<p><em><strong>*在这个语流中，如果仔细观察，三个词伙，其实是不断的递进和具象化，将一个概念不断地落地。*</strong></em></p>
<h3 id="贫穷的陷阱"><a href="#贫穷的陷阱" class="headerlink" title="贫穷的陷阱"></a>贫穷的陷阱</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">most people have a hard time differentiating &#x27;wants&#x27; and &#x27;needs&#x27;,</span><br><span class="line">i mean...</span><br><span class="line">they use a word &#x27;needs&#x27; for almost everything they purchase,</span><br><span class="line">causing them have to actually believe that they &#x27;have to&#x27; spend money.</span><br></pre></td></tr></table></figure>

<p><em><strong>*have a hard time differentiating “wants” and “needs”*</strong></em> </p>
<p><em><strong>*分不清刚需和欲望*</strong></em></p>
<p><em><strong>*use the word ‘need’ for almost everything they purchase*</strong></em></p>
<p><em><strong>*购物癖*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*三个非常重要的句式，核心词替换都非常方便*</strong></em></p>
<p><em><strong>*Have hard time doing sth*</strong></em></p>
<p><em><strong>*Use the word*</strong></em> <em><strong>*“*</strong></em><em><strong>*A*</strong></em> <em><strong>*”*</strong></em> <em><strong>*for sth*</strong></em></p>
<p><em><strong>*Causing+从句，引导一个原因*</strong></em></p>
<p><em><strong>*在背诵的时候，可以从这三个句式开始。*</strong></em></p>
<p><em><strong>*值得注意的是，这个语流中，有文字游戏的意味，这种技法非常高明。*</strong></em></p>
<h3 id="财务能力"><a href="#财务能力" class="headerlink" title="财务能力"></a>财务能力</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Poor financial education have a long-lasting impact on individuals and</span><br><span class="line">their families.</span><br><span class="line">the financial education can make a difference.</span><br><span class="line">because...</span><br><span class="line">it can equal you with the knowledge,skills,confidence to </span><br><span class="line">take charge of your life.</span><br><span class="line">and build a more secure future for yourself and your families.</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people lose money in stock market because they think the investing is</span><br><span class="line">the ticket to getting rich quickly.</span><br><span class="line">for example...</span><br><span class="line">they see wealthy day traders show off money and fancy cars...</span><br><span class="line">and they think it&#x27;s money.</span><br><span class="line">but the 99% of time they lose money following them,</span><br></pre></td></tr></table></figure>

<p><em><strong>*The*</strong></em> <em><strong>*ticket to getting rich quickly*</strong></em> <em><strong>*一夜暴富*</strong></em></p>
<p><em><strong>*wealthy day traders*</strong></em> <em><strong>*短线炒家*</strong></em></p>
<p><em><strong>*easy money*</strong></em> <em><strong>*很容易赚的钱*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*贪心，单单整个人性，已经可以解决很多问题。*</strong></em></p>
<p><em><strong>*只要你了解人性，你就永远有话可说。*</strong></em></p>
<p><em><strong>*在这个语流中，关于投资的三个很重要的词伙，凝结在了一起。*</strong></em></p>
<p><em><strong>*当我们在记忆语流时，也就连锁记忆了词伙，一举两得。*</strong></em></p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">演绎以下一分钟三十秒的语流，训练节奏和气息</span><br><span class="line">在不改变词伙的情况下，自己可以改动一些句子和单词，不必拘泥</span><br><span class="line">重在开口练习，不要纠结，放开其他东西。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Describe the important decision you made recently.</span><br><span class="line"></span><br><span class="line">I used to be a shy person who would feel depressed all the time...</span><br><span class="line">I think the main reason is because </span><br><span class="line">I cared too much about what people think.</span><br><span class="line">so i made the decision couple of years ago</span><br><span class="line">decided that... </span><br><span class="line">i wanna be a guy who has more confidence in his judgments </span><br><span class="line">and feels more alive.</span><br><span class="line">and one of my friends told me that </span><br><span class="line">to achieve that goal, </span><br><span class="line">I need do things that are out of my comfort zone...</span><br><span class="line">So that I will learn to overcome my fears,</span><br><span class="line">for example...</span><br><span class="line">I will likely find that I care less about what people think</span><br><span class="line">and about what could go wrong.</span><br><span class="line">and...</span><br><span class="line">in order to feel to feel alive,</span><br><span class="line">I need to do things that make me feel uncomfortable,</span><br><span class="line">because...</span><br><span class="line">as human beings,</span><br><span class="line">we become who we are through challenges.</span><br><span class="line">for example...</span><br><span class="line">all successful people have taken risks, failed and picked themselves up,</span><br><span class="line">because they believe that those who never venture far </span><br><span class="line">will never know what might have been if they had tired to do things beyond what they had already mastered.</span><br><span class="line"></span><br><span class="line">逆推：</span><br><span class="line">Describe a piece of advice you received ...</span><br><span class="line">describe the important lesson you learned in high school...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语10</title>
    <url>/2022/07/21/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD10/</url>
    <content><![CDATA[<h1 id="英语口语10"><a href="#英语口语10" class="headerlink" title="英语口语10"></a>英语口语10</h1><h3 id="光阴似箭"><a href="#光阴似箭" class="headerlink" title="光阴似箭"></a>光阴似箭</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time is the most valuable things on earth,</span><br><span class="line">we can&#x27;t afford to let it go by without maximizing it,</span><br><span class="line">because...</span><br><span class="line">it is one of the few things that can&#x27;t be measured in terms of money</span><br><span class="line">time never come back,when it&#x27;s gone,it&#x27;s gone</span><br></pre></td></tr></table></figure>

<p><em><strong>*we can’t afford to let it go by without maximizing*</strong></em> <em><strong>*it*</strong></em></p>
<p><em><strong>*有效利用*</strong></em></p>
<p><em><strong>*Time*</strong></em> <em><strong>*never comes back, when it’s gone, it’s gone*</strong></em></p>
<p><em><strong>*时光一去不复返*</strong></em></p>
<p><em><strong>*it*</strong></em> <em><strong>*is one of the few things that can’t be measured in terms of money*</strong></em></p>
<p><em><strong>*无法用金钱衡量*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*大家想一想，和时间一样，不能用金钱衡量的还有那些，*</strong></em></p>
<p><em><strong>*并且这些东西如何融入这个框架中。*</strong></em></p>
<p><em><strong>*体会一下举一反三的快感。*</strong></em></p>
<h3 id="恶习"><a href="#恶习" class="headerlink" title="恶习"></a>恶习</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Most people have developed a &#x27;productivity_busting habit&#x27; over years,</span><br><span class="line">for example...</span><br><span class="line">they check their emails compulsively throughout the day or</span><br><span class="line">get interrupted whenever the phone buzzes,</span><br><span class="line">the worst part is when the habit is formed,it is hard to break.</span><br></pre></td></tr></table></figure>

<p><em><strong>*productivity-busting habits*</strong></em> <em><strong>*损害效率的习惯*</strong></em></p>
<p><em><strong>*check their emails compulsively throughout the day*</strong></em> <em><strong>*信息强迫症*</strong></em></p>
<p><em><strong>*get interrupted whenever their phone buzzes*</strong></em> <em><strong>*无时不刻要回复信息*</strong></em></p>
<p><em><strong>*when the habit is formed, it’s hard to break*</strong></em> <em><strong>*根深蒂固*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*尽量避免对你效率产生危害的习惯。*</strong></em></p>
<p><em><strong>*一旦这种习惯被剔除，你的有效时间会大大增加。*</strong></em></p>
<p><em><strong>*这个语流中的两个例子，请大家代入情景去思考和记忆。*</strong></em></p>
<p><em><strong>*你的邮箱，你的手机，你的聊天工具……*</strong></em></p>
<h3 id="逃避情绪自耗"><a href="#逃避情绪自耗" class="headerlink" title="逃避情绪自耗"></a>逃避情绪自耗</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">staying busy is a way to avoid painful feels,</span><br><span class="line">because...</span><br><span class="line">if you are super busy,</span><br><span class="line">you are unable to focus on what&#x27;s bothering you or</span><br><span class="line">what&#x27;s causing you to feel longly and insecure.</span><br></pre></td></tr></table></figure>

<p><em><strong>*painful feelings*</strong></em> </p>
<p><em><strong>*伤心事*</strong></em></p>
<p><em><strong>*feel lonely and insecure*</strong></em> </p>
<p><em><strong>*孤独和惶恐*</strong></em></p>
<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*重点：代入感*</strong></em></p>
<p><em><strong>*能不能将语流变成你生活中的一个个场景？*</strong></em></p>
<p><em><strong>*比如这个语流，我们可以代入我们伤心或茫然的时刻。*</strong></em></p>
<p><em><strong>*这就是高度内化（mental representation）的第二阶段。*</strong></em></p>
<h3 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">University education will not only give the students a opportunity to</span><br><span class="line">gain in-depth knowledge</span><br><span class="line">but also to develop skills such as communication,</span><br><span class="line">presentation and problem-solving,</span><br><span class="line">while enhancing the ability to work as part of a team</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*在这个简简单单的语流中，大学吸收知识的四个关键点，每一个点都踩到了。*</strong></em></p>
<p><em><strong>*而这一切，全是在电光石火之中，瞬间输出。*</strong></em></p>
<p><em><strong>*速度，力度，精度俱全。*</strong></em></p>
<p><em><strong>*这个语流并不是说句式有多漂亮，但胜在简单有效。*</strong></em></p>
<p><em><strong>*框架中，*</strong></em></p>
<p><em><strong>*Not only+but also+while组成行云流水的长句。*</strong></em> </p>
<p><em><strong>*————————————————————*</strong></em></p>
<p><em><strong>*今天把大脑放空，先别记着去记忆了。*</strong></em></p>
<p><em><strong>*试着在不看中文对接的情况学，把学到的每个语流回忆起来，并试着把它跟你的生活联系在一起。*</strong></em></p>
<p><em><strong>*不要有压力，想到多少就是多少。*</strong></em></p>
<p><em><strong>*语言内化，其实就是一个游戏。*</strong></em></p>
<p> <em><strong>*_________________*</strong></em></p>
<p><em><strong>*what do you think about time management?*</strong></em></p>
<p><em><strong>*I*</strong></em> <em><strong>*know nothing about time management*</strong></em><em><strong>*…*</strong></em></p>
<p><em><strong>*the only thing i know for sure is that*</strong></em></p>
<p><em><strong>*time is one of the few things that can’t be measured*</strong></em><em><strong>*&#x2F;*</strong></em> <em><strong>*in terms of*</strong></em> </p>
<p><em><strong>*money…*</strong></em></p>
<p><em><strong>*it never comes back,*</strong></em> <em><strong>*you know,*</strong></em> <em><strong>*when it’s gone, it’s gone*</strong></em></p>
<p><em><strong>*So…*</strong></em> </p>
<p><em><strong>*I can’t afford to let it go by*</strong></em><em><strong>*&#x2F;*</strong></em> <em><strong>*without maximizing*</strong></em><em><strong>*&#x2F;*</strong></em> <em><strong>*the time*</strong></em> <em><strong>*I*</strong></em> <em><strong>*have*</strong></em> </p>
<p><em><strong>*so yeah*</strong></em></p>
<p><em><strong>*i will do everything i can in my power to maximize it…*</strong></em></p>
<p><em><strong>*for example…*</strong></em></p>
<p><em><strong>*i will try to get into the routine of getting up early in the morning*</strong></em></p>
<p><em><strong>*and go*</strong></em><em><strong>*ing*</strong></em> <em><strong>*to bed early at night…*</strong></em></p>
<p><em><strong>*so that*</strong></em> <em><strong>*i will have a better sleeping pattern*</strong></em> </p>
<p><em><strong>*which enables m*</strong></em><em><strong>*e to*</strong></em> <em><strong>*have*</strong></em> <em><strong>*m*</strong></em><em><strong>*ore time*</strong></em> </p>
<p><em><strong>*To*</strong></em> <em><strong>*focus on the important things in my life,*</strong></em></p>
<p><em><strong>*and…*</strong></em></p>
<p><em><strong>*Because*</strong></em> <em><strong>*our brains tend to be most alert*</strong></em><em><strong>*&#x2F;*</strong></em> <em><strong>*in the morning*</strong></em><em><strong>*, right?*</strong></em></p>
<p><em><strong>*So*</strong></em><em><strong>*…*</strong></em> </p>
<p><em><strong>*to*</strong></em> <em><strong>*increase*</strong></em> <em><strong>*my*</strong></em> <em><strong>*productivity at wor*</strong></em><em><strong>*k*</strong></em> <em><strong>*for this day,*</strong></em></p>
<p><em><strong>*i will try to*</strong></em> <em><strong>*get into the state of flow of deep work early in the day*</strong></em></p>
<p><em><strong>*while the rest of the world*</strong></em><em><strong>*&#x2F;*</strong></em> </p>
<p><em><strong>*is asleep*</strong></em><em><strong>*.*</strong></em></p>
]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语口语11</title>
    <url>/2022/07/22/%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD11/</url>
    <content><![CDATA[<h1 id="英语口语11"><a href="#英语口语11" class="headerlink" title="英语口语11"></a>英语口语11</h1><h3 id="一件令你悲伤的事"><a href="#一件令你悲伤的事" class="headerlink" title="一件令你悲伤的事:"></a>一件令你悲伤的事:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i lost my dog after a year of long battle,</span><br><span class="line">a year before i had been told that her liver was died and she had only 6 months,</span><br><span class="line">After my dog died, i didn&#x27;t know what to deal with myself</span><br><span class="line">and i couldn&#x27;t get myself together,</span><br><span class="line">i have this massive a pit of depression inside of me,</span><br><span class="line">...</span><br><span class="line">one day,i woke up,i was sitting there in my bed</span><br><span class="line">and i didn&#x27;t know what i was supposed to do next,</span><br><span class="line">it was like my brain had spilt in half,</span><br><span class="line">anyway, it took me three years to get over it</span><br></pre></td></tr></table></figure>

<p><em><strong>*注*</strong></em><em><strong>*：*</strong></em></p>
<p><em><strong>*两点。*</strong></em></p>
<p><em><strong>*一，*</strong></em><em><strong>*情绪是很多话题的导火线，熟悉运用各种情绪的叙事，可以很快打开话题。*</strong></em></p>
<p><em><strong>*比如悲伤的话题，可以衍生至：一件你不愿想起的事，一件你很难忘记的事，说说你的的宠物，*</strong></em></p>
<p><em><strong>*二，*</strong></em><em><strong>*一件令你成长的事，一件令你感悟的事……*</strong></em></p>
<p><em><strong>*这个语流我用了中英文对照，但不是翻译，而是意译，让大家体会一下叙述性语流的特点。*</strong></em></p>
<h3 id="积极主动"><a href="#积极主动" class="headerlink" title="积极主动"></a>积极主动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">being proactive,</span><br><span class="line">it means you take actions that be intented to cause changes</span><br><span class="line">rather than reacting to changes,</span><br><span class="line">like...</span><br><span class="line">if you want to sellproducts,</span><br><span class="line">instead of focusing on how people these days don&#x27;t appreciate good products,</span><br><span class="line">you focus on how can you improve your product so that your customers can&#x27;t live without it.</span><br></pre></td></tr></table></figure>

<p><em><strong>*make actions that are intended to cause changes*</strong></em> <em><strong>*主动改变现状的行动*</strong></em></p>
<p><em><strong>*rather than just reacting to change*</strong></em> <em><strong>*被动接受变化*</strong></em></p>
<p><em><strong>*can’t live without it*</strong></em> <em><strong>*割舍不下*</strong></em></p>
<p><em><strong>*注：场景化的运用，非常重要。*</strong></em></p>
<p><em><strong>*proactive是一个实战性非常高的概念，而且天然具备极多的可扩展性。*</strong></em></p>
<h3 id="方法灵活"><a href="#方法灵活" class="headerlink" title="方法灵活"></a>方法灵活</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Strategic thinkers take the time to plan out the best solution to a problem,</span><br><span class="line">so...</span><br><span class="line">rather than relying on a standard problem-solving method,</span><br><span class="line">they will try to take different approach to a problem,</span><br><span class="line">and deal with it in a more creative manner</span><br></pre></td></tr></table></figure>

<p><em><strong>*注：*</strong></em></p>
<p><em><strong>*这是一个对我人生极其重要的语流。*</strong></em></p>
<p><em><strong>*对我的影响至深。*</strong></em></p>
<p><em><strong>*方法总比苦难多，至理名言。*</strong></em></p>
<p><em><strong>*句式方面，rather than提前，后面接主句，非常地道的语流展现手法。*</strong></em></p>
<p><em><strong>*后半部分的三个高质量词伙的运用，也非常方便串联式记忆。*</strong></em></p>
]]></content>
      <categories>
        <category>口语</category>
      </categories>
      <tags>
        <tag>英语口语</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法理论基础_回溯01</title>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h1 id="回溯算法理论基础"><a href="#回溯算法理论基础" class="headerlink" title="回溯算法理论基础"></a>回溯算法理论基础</h1><h2 id="题目分类大纲如下："><a href="#题目分类大纲如下：" class="headerlink" title="#题目分类大纲如下："></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B">#</a>题目分类大纲如下：</h2><p><img src="https://img-blog.csdnimg.cn/20210219192050666.png" alt="回溯算法大纲"></p>
<p>可以配合我的B站视频：<a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇） (opens new window)</a>一起学习！</p>
<h2 id="什么是回溯法"><a href="#什么是回溯法" class="headerlink" title="#什么是回溯法"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%BA%AF%E6%B3%95">#</a>什么是回溯法</h2><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p>
<p>在二叉树系列中，我们已经不止一次，提到了回溯，例如<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E9%80%92%E5%BD%92%E5%B8%A6%E7%9D%80%E5%9B%9E%E6%BA%AF.html">二叉树：以为使用了递归，其实还隐藏着回溯 (opens new window)</a>。</p>
<p>回溯是递归的副产品，只要有递归就会有回溯。</p>
<p><strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong>。</p>
<h2 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="#回溯法的效率"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87">#</a>回溯法的效率</h2><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p>
<p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<p>那么既然回溯法并不高效为什么还要用它呢？</p>
<p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p>
<p>此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。</p>
<h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="#回溯法解决的问题"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">#</a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><strong>相信大家看着这些之后会发现，每个问题，都不简单！</strong></p>
<p>另外，会有一些同学可能分不清什么是组合，什么是排列？</p>
<p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p>
<p>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p>
<p>记住组合无序，排列有序，就可以了。</p>
<h2 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="#如何理解回溯法"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E6%B3%95">#</a>如何理解回溯法</h2><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p>
<p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p>
<p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
<p>这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。</p>
<h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="#回溯法模板"></a><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF">#</a>回溯法模板</h2><p>这里给出Carl总结的回溯算法模板。</p>
<p>在讲<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归 (opens new window)</a>中我们说了递归三部曲，这里我再给大家列出回溯三部曲。</p>
<ul>
<li>回溯函数模板返回值以及参数</li>
</ul>
<p>在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。</p>
<p>回溯算法中函数返回值一般为void。</p>
<p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p>
<p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p>
<p>回溯函数伪代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void backtracking(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li>回溯函数终止条件</li>
</ul>
<p>既然是树形结构，那么我们在讲解<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归 (opens new window)</a>的时候，就知道遍历树形结构一定要有终止条件。</p>
<p>所以回溯也有要终止条件。</p>
<p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p>
<p>所以回溯函数终止条件伪代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>回溯搜索的遍历过程</li>
</ul>
<p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210130173631174.png" alt="回溯算法理论基础"></p>
<p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p>
<p>回溯函数遍历过程伪代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); // 递归</span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p>
<p>backtracking这里自己调用自己，实现递归。</p>
<p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p>
<p>分析完过程，回溯算法模板框架如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p>
<p>如果从来没有学过回溯算法的录友们，看到这里会有点懵，后面开始讲解具体题目的时候就会好一些了，已经做过回溯法题目的录友，看到这里应该会感同身受了。</p>
]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>组合_回溯02</title>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF01/</url>
    <content><![CDATA[<h1 id="第77题-组合"><a href="#第77题-组合" class="headerlink" title="第77题. 组合"></a>第77题. 组合</h1><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接(opens new window)</a></p>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:<br>输入: n &#x3D; 4, k &#x3D; 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p>
<p>也可以直接看我的B站视频：<a href="https://www.bilibili.com/video/BV1ti4y1L7cv#reply3733925949">带你学透回溯算法-组合问题（对应力扣题目：77.组合）(opens new window)</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>本题这是回溯法的经典题目。</p>
<p>直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：n &#x3D; 100, k &#x3D; 3 那么就三层for循环，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = j + <span class="number">1</span>; u &lt;= n; n++) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果n为100，k为50呢，那就50层for循环，是不是开始窒息</strong>。</p>
<p><strong>此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来！</strong></p>
<p>咋整？</p>
<p>回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望。</p>
<p>那么回溯法怎么暴力搜呢？</p>
<p>上面我们说了<strong>要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题</strong>。</p>
<p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p>
<p>此时递归的层数大家应该知道了，例如：n为100，k为50的情况下，就是递归50层。</p>
<p>一些同学本来对递归就懵，回溯法中递归还要嵌套for循环，可能就直接晕倒了！</p>
<p>如果脑洞模拟回溯搜索的过程，绝对可以让人窒息，所以需要抽象图形结构来进一步理解。</p>
<p><strong>我们在<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>中说道回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了</strong>。</p>
<p>那么我把组合问题抽象为如下树形结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195223940.png" alt="77.组合"></p>
<p>可以看出这个棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不在重复取。</p>
<p>第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。</p>
<p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p>
<p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p>
<p>那么如何在这个树上遍历，然后收集到我们要的结果集呢？</p>
<p><strong>图中每次搜索到了叶子节点，我们就找到了一个结果</strong>。</p>
<p>相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。</p>
<p>在<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>中我们提到了回溯法三部曲，那么我们按照回溯法三部曲开始正式讲解代码了。</p>
<h2 id="回溯法三部曲"><a href="#回溯法三部曲" class="headerlink" title="#回溯法三部曲"></a><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯法三部曲</h2><ul>
<li>递归函数的返回值以及参数</li>
</ul>
<p>在这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br></pre></td></tr></table></figure>

<p>其实不定义这两个全局遍历也是可以的，把这两个变量放进递归函数的参数里，但函数里参数太多影响可读性，所以我定义全局变量了。</p>
<p>函数里一定有两个参数，既然是集合n里面取k的数，那么n和k是两个int型的参数。</p>
<p>然后还需要一个参数，为int型变量startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n] ）。</p>
<p>为什么要有这个startIndex呢？</p>
<p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</strong>。</p>
<p>从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢，靠的就是startIndex。</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195328976.png" alt="77.组合2"></p>
<p>所以需要startIndex来记录下一层递归，搜索的起始位置。</p>
<p>那么整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件单一结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span></span><br></pre></td></tr></table></figure>

<ul>
<li>回溯函数终止条件</li>
</ul>
<p>什么时候到达所谓的叶子节点了呢？</p>
<p>path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。</p>
<p>如图红色部分：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195407907.png" alt="77.组合3"></p>
<p>此时用result二维数组，把path保存起来，并终止本层递归。</p>
<p>所以终止条件代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>单层搜索的过程</li>
</ul>
<p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195242899.png" alt="77.组合1"></p>
<p>如此我们才遍历完图中的这棵树。</p>
<p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123; <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点 </span></span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。</p>
<p>backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。</p>
<p>关键地方都讲完了，组合问题C++完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点 </span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不写</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不写</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还记得我们在<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>中给出的回溯法模板么？</p>
<p>如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比一下本题的代码，是不是发现有点像！</strong> 所以有了这个模板，就有解题的大体方向，不至于毫无头绪。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>组合问题是回溯法解决的经典问题，我们开始的时候给大家列举一个很形象的例子，就是n为100，k为50的话，直接想法就需要50层for循环。</p>
<p>从而引出了回溯法就是解决这种k层for循环嵌套的问题。</p>
<p>然后进一步把回溯法的搜索过程抽象为树形结构，可以直观的看出搜索的过程。</p>
<p>接着用回溯法三部曲，逐步分析了函数参数、终止条件和单层搜索的过程。</p>
<h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>我们说过，回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。</p>
<p>在遍历的过程中有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个遍历的范围是可以剪枝优化的，怎么优化呢？</p>
<p>来举一个例子，n &#x3D; 4，k &#x3D; 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。</p>
<p>这么说有点抽象，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210130194335207.png" alt="77.组合4"></p>
<p>图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。</p>
<p><strong>所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置</strong>。</p>
<p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p>
<p>注意代码中i，就是for循环里选择的起始位置。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">for (int i = startIndex; i &lt;= n; i++) &#123;</span><br></pre></td></tr></table></figure>

<p>接下来看一下优化过程如下：</p>
<ol>
<li>已经选择的元素个数：path.size();</li>
<li>还需要的元素个数为: k - path.size();</li>
<li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。</p>
<p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p>
<p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p>
<p>所以优化之后的for循环是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置</span><br></pre></td></tr></table></figure>

<p>优化后整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123; <span class="comment">// 优化的地方</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剪枝总结"><a href="#剪枝总结" class="headerlink" title="#剪枝总结"></a><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%89%AA%E6%9E%9D%E6%80%BB%E7%BB%93">#</a>剪枝总结</h2><p>本篇我们准对求组合问题的回溯法代码做了剪枝优化，这个优化如果不画图的话，其实不好理解，也不好讲清楚。</p>
<p>所以我依然是把整个回溯过程抽象为一棵树形结构，然后可以直观的看出，剪枝究竟是剪的哪里</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkdeList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span> &#123;</span><br><span class="line">	backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;=n - (k - path.size()) + <span class="number">1</span>;i++) &#123; <span class="comment">// 其实这个剪枝我还是不太明白</span></span><br><span class="line">           path.add(i);</span><br><span class="line">           backtracking(n,k,i + <span class="number">1</span>);</span><br><span class="line">           path.removeLast();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和III_回溯03</title>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF02/</url>
    <content><![CDATA[<h1 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h1><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣题目链接(opens new window)</a></p>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>示例 1: 输入: k &#x3D; 3, n &#x3D; 7 输出: [[1,2,4]]</p>
<p>示例 2: 输入: k &#x3D; 3, n &#x3D; 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题就是在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合。</p>
<p>相对于<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>，无非就是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,…,9]。</p>
<p>想到这一点了，做过<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>之后，本题是简单一些了。</p>
<p>本题k相当于了树的深度，9（因为整个集合就是9个数）就是树的宽度。</p>
<p>例如 k &#x3D; 2，n &#x3D; 4的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） &#x3D; 2, n（和） &#x3D; 4的组合。</p>
<p>选取过程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195717975.png" alt="216.组合总和III"></p>
<p>图中，可以看出，只有最后取到集合（1，3）和为4 符合条件。</p>
<h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h2><ul>
<li><strong>确定递归函数参数</strong></li>
</ul>
<p>和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>一样，依然需要一维数组path来存放符合条件的结果，二维数组result来存放结果集。</p>
<p>这里我依然定义path 和 result为全局变量。</p>
<p>至于为什么取名为path？从上面树形结构中，可以看出，结果其实就是一条根节点到叶子节点的路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br></pre></td></tr></table></figure>

<p>接下来还需要如下参数：</p>
<ul>
<li>targetSum（int）目标和，也就是题目中的n。</li>
<li>k（int）就是题目中要求k个数的集合。</li>
<li>sum（int）为已经收集的元素的总和，也就是path里元素的总和。</li>
<li>startIndex（int）为下一层for循环搜索的起始位置。</li>
</ul>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>其实这里sum这个参数也可以省略，每次targetSum减去选取的元素数值，然后判断如果targetSum为0了，说明收集到符合条件的结果了，我这里为了直观便于理解，还是加一个sum参数。</p>
<p>还要强调一下，回溯法中递归函数参数很难一次性确定下来，一般先写逻辑，需要啥参数了，填什么参数。</p>
<ul>
<li>确定终止条件</li>
</ul>
<p>什么时候终止呢？</p>
<p>在上面已经说了，k其实就已经限制树的深度，因为就取k个元素，树再往下深了没有意义。</p>
<p>所以如果path.size() 和 k相等了，就终止。</p>
<p>如果此时path里收集到的元素和（sum） 和targetSum（就是题目描述的n）相同了，就用result收集当前的结果。</p>
<p>所以 终止代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == targetSum) result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>单层搜索过程</strong></li>
</ul>
<p>本题和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>区别之一就是集合固定的就是9个数[1,…,9]，所以for循环固定i&lt;&#x3D;9</p>
<p>如图： <img src="https://img-blog.csdnimg.cn/20201123195717975.png" alt="216.组合总和III"></p>
<p>处理过程就是 path收集每次选取的元素，相当于树型结构里的边，sum来统计path里元素的总和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">    sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>别忘了处理过程 和 回溯过程是一一对应的，处理有加，回溯就要有减！</strong></p>
<p>参照<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>中的模板，不难写出如下C++代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="comment">// targetSum：目标和，也就是题目中的n。</span></span><br><span class="line">    <span class="comment">// k：题目中要求k个数的集合。</span></span><br><span class="line">    <span class="comment">// sum：已经收集的元素的总和，也就是path里元素的总和。</span></span><br><span class="line">    <span class="comment">// startIndex：下一层for循环搜索的起始位置。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            sum += i; <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">            sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="#剪枝"></a><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E5%89%AA%E6%9E%9D">#</a>剪枝</h2><p>这道题目，剪枝操作其实是很容易想到了，想必大家看上面的树形图的时候已经想到了。</p>
<p>如图： <img src="https://img-blog.csdnimg.cn/2020112319580476.png" alt="216.组合总和III1"></p>
<p>已选元素总和如果已经大于n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉。</p>
<p>那么剪枝的地方一定是在递归终止的地方剪，剪枝代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; targetSum) &#123; <span class="comment">// 剪枝操作</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.html">回溯算法：组合问题再剪剪枝 (opens new window)</a>一样，for循环的范围也可以剪枝，i &lt;&#x3D; 9 - (k - path.size()) + 1就可以了。</p>
<p>最后C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; targetSum) &#123; <span class="comment">// 剪枝操作</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123; <span class="comment">// 剪枝</span></span><br><span class="line">            sum += i; <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">            sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E6%80%BB%E7%BB%93">#</a>总结</h1><p>开篇就介绍了本题与<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>的区别，相对来说加了元素总和的限制，如果做完<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>再做本题在合适不过。</p>
<p>分析完区别，依然把问题抽象为树形结构，按照回溯三部曲进行讲解，最后给出剪枝的优化。</p>
<p>相信做完本题，大家对组合问题应该有初步了解了</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123; <span class="comment">// k 个数组成和为n k的范围为1~9</span></span><br><span class="line">    backtracking(k,n,<span class="number">1</span>)；</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 剪枝细节</span></span><br><span class="line">    <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>) res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;= <span class="number">9</span>;i++) &#123;</span><br><span class="line">        path.add(i);</span><br><span class="line">        sum -= i;</span><br><span class="line">        backtracking(k,sum,startIndex+<span class="number">1</span>);</span><br><span class="line">        sum += i;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>电话号码的字母组合_回溯04</title>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF03/</url>
    <content><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣题目链接(opens new window)</a></p>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://img-blog.csdnimg.cn/2020102916424043.png" alt="17.电话号码的字母组合"></p>
<p>示例: 输入：”23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>从示例上来说，输入”23”，最直接的想法就是两层for循环遍历了吧，正好把组合的情况都输出了。</p>
<p>如果输入”233”呢，那么就三层for循环，如果”2333”呢，就四层for循环…….</p>
<p>大家应该感觉出和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>遇到的一样的问题，就是这for循环的层数如何写出来，此时又是回溯法登场的时候了。</p>
<p>理解本题后，要解决如下三个问题：</p>
<ol>
<li>数字和字母如何映射</li>
<li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来</li>
<li>输入1 * #按键等等异常情况</li>
</ol>
<h2 id="数字和字母如何映射"><a href="#数字和字母如何映射" class="headerlink" title="#数字和字母如何映射"></a><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84">#</a>数字和字母如何映射</h2><p>可以使用map或者定义一个二维数组，例如：string letterMap[10]，来做映射，我这里定义一个二维数组，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="回溯法来解决n个for循环的问题"><a href="#回溯法来解决n个for循环的问题" class="headerlink" title="#回溯法来解决n个for循环的问题"></a><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%9D%A5%E8%A7%A3%E5%86%B3n%E4%B8%AAfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98">#</a>回溯法来解决n个for循环的问题</h2><p>对于回溯法还不了解的同学看这篇：<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！(opens new window)</a></p>
<p>例如：输入：”23”，抽象为树形结构，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123200304469.png" alt="17. 电话号码的字母组合"></p>
<p>图中可以看出遍历的深度，就是输入”23”的长度，而叶子节点就是我们要收集的结果，输出[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p>
<p>回溯三部曲：</p>
<ul>
<li>确定回溯函数参数</li>
</ul>
<p>首先需要一个字符串s来收集叶子节点的结果，然后用一个字符串数组result保存起来，这两个变量我依然定义为全局。</p>
<p>再来看参数，参数指定是有题目中给的string digits，然后还要有一个参数就是int型的index。</p>
<p>注意这个index可不是 <a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>中的startIndex了。</p>
<p>这个index是记录遍历第几个数字了，就是用来遍历digits的（题目中给出数字字符串），同时index也表示树的深度。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; result;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; digits, <span class="type">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>例如输入用例”23”，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。</p>
<p>那么终止条件就是如果index 等于 输入的数字个数（digits.size）了（本来index就是用来遍历digits的）。</p>
<p>然后收集结果，结束本层递归。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层遍历逻辑</li>
</ul>
<p>首先要取index指向的数字，并找到对应的字符集（手机键盘的字符集）。</p>
<p>然后for循环来处理这个字符集，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;        <span class="comment">// 将index指向的数字转为int</span></span><br><span class="line">string letters = letterMap[digit];      <span class="comment">// 取数字对应的字符集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    s.<span class="built_in">push_back</span>(letters[i]);            <span class="comment">// 处理</span></span><br><span class="line">    <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);    <span class="comment">// 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">    s.<span class="built_in">pop_back</span>();                       / 回溯</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意这里for循环，可不像是在<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！ (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">回溯算法：求组合总和！ (opens new window)</a>中从startIndex开始遍历的</strong>。</p>
<p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77. 组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>都是是求同一个集合中的组合！</strong></p>
<p>注意：输入1 * #按键等等异常情况</p>
<p>代码中最好考虑这些异常情况，但题目的测试数据中应该没有异常情况的数据，所以我就没有加了。</p>
<p><strong>但是要知道会有这些异常，如果是现场面试中，一定要考虑到！</strong></p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        String [] Stringnums = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        backtracking(Stringnums,digits,<span class="number">1</span>); <span class="comment">// index记录深度</span></span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String[] Stringnums,String digits,<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index == digits.size()) &#123;</span><br><span class="line">        res.add(sb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> Stringnums[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tmp.length();i++) &#123;</span><br><span class="line">        sb.append(tmp.charAt(i));</span><br><span class="line">       	backtracking(stringnums,digits,index+<span class="number">1</span>); <span class="comment">// 回溯细节</span></span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和_回溯05</title>
    <url>/2022/08/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF04/</url>
    <content><![CDATA[<html><head></head><body><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p><a href="https://leetcode.cn/problems/combination-sum/">力扣题目链接(opens new window)</a></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</p>
<p>示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [  [2,2,2,2],  [2,3,3],  [3,5] ]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><a href="https://www.bilibili.com/video/BV1KT4y1M7HJ">B站视频讲解-组合总和(opens new window)</a></p>
<p>题目中的<strong>无限制重复被选取，吓得我赶紧想想 出现0 可咋办</strong>，然后看到下面提示：1 &lt;= candidates[i] &lt;= 200，我就放心了。</p>
<p>本题和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>和区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p>
<p>本题搜索的过程抽象成树形结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201223170730367.png" alt="39.组合总和"> 注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！</p>
<p>而在<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>中都可以知道要递归K层，因为要取k个元素的组合。</p>
<h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h2><ul>
<li>递归函数参数</li>
</ul>
<p>这里依然是定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。（这两个变量可以作为函数参数传入）</p>
<p>首先是题目中给出的参数，集合candidates, 和目标值target。</p>
<p>此外我还定义了int型的sum变量来统计单一结果path里的总和，其实这个sum也可以不用，用target做相应的减法就可以了，最后如何target==0就说明找到符合的结果了，但为了代码逻辑清晰，我依然用了sum。</p>
<p><strong>本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？</strong></p>
<p>我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>。</p>
<p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">17.电话号码的字母组合(opens new window)</a></p>
<p><strong>注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍</strong>。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p>在如下树形结构中：</p>
<p><img src="https://img-blog.csdnimg.cn/20201223170730367.png" alt="39.组合总和"></p>
<p>从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。</p>
<p>sum等于target的时候，需要收集结果，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; target) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (sum == target) {</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>单层for循环依然是从startIndex开始，搜索candidates集合。</p>
<p><strong>注意本题和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合 (opens new window)</a>、<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III (opens new window)</a>的一个区别是：本题元素为可重复选取的</strong>。</p>
<p>如何重复选取呢，看代码，注释部分：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    sum += candidates[i];</span><br><span class="line">    path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(candidates, target, sum, i); <span class="comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">    sum -= candidates[i];   <span class="comment">// 回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();        <span class="comment">// 回溯</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>在这个树形结构中：</p>
<p><img src="https://img-blog.csdnimg.cn/20201223170730367.png" alt="39.组合总和"></p>
<p>以及上面的版本一的代码大家可以看到，对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum &gt; target的话就返回。</p>
<p>其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。</p>
<p>那么可以在for循环的搜索范围上做做文章了。</p>
<p><strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历</strong>。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201223170809182.png" alt="39.组合总和1"></p>
<p>for循环剪枝代码如下：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++)</span><br></pre></td></tr></tbody></table></figure>

<h1 id="JAVA关键代码如下："><a href="#JAVA关键代码如下：" class="headerlink" title="JAVA关键代码如下："></a>JAVA关键代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">    Arrays.sort(candidates); <span class="comment">// 不排序也可以</span></span><br><span class="line">	backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> {</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">0</span>) {</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;candidates.length &amp;&amp; sum - candidates[i] &gt;= <span class="number">0</span>;i++) { <span class="comment">// 剪枝</span></span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        backtracking(candidates,sum,i);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        path.remove(candidates.size() -<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h1><p><a href="https://leetcode.cn/problems/combination-sum-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p>
<p>示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p>
<p>示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>区别在于解集不能包含重复的组合，也就是说树枝可以有重复的，但是每一层不能有重复的，说明需要提前把数组给排序，然后通过startIndex 来进行剪枝</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>分割回文串_回溯06</title>
    <url>/2022/08/14/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF05/</url>
    <content><![CDATA[<html><head></head><body><h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h1><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>关于本题，大家也可以看我在B站的视频讲解：<a href="https://www.bilibili.com/video/BV1c54y1e7k6">131.分割回文串（B站视频）(opens new window)</a></p>
<p>本题这涉及到两个关键问题：</p>
<ol>
<li>切割问题，有不同的切割方式</li>
<li>判断回文</li>
</ol>
<p>相信这里不同的切割方式可以搞懵很多同学了。</p>
<p>这种题目，想用for循环暴力解法，可能都不那么容易写出来，所以要换一种暴力的方式，就是回溯。</p>
<p>一些同学可能想不清楚 回溯究竟是如何切割字符串呢？</p>
<p>我们来分析一下切割，<strong>其实切割问题类似组合问题</strong>。</p>
<p>例如对于字符串abcdef：</p>
<ul>
<li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li>
<li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li>
</ul>
<p>感受出来了不？</p>
<p>所以切割问题，也可以抽象为一棵树形结构，如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p>
<p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p>
<p>此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p>
<h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h2><ul>
<li>递归函数参数</li>
</ul>
<p>全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 （这两个参数可以放到函数参数里）</p>
<p>本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。</p>
<p>在<a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">回溯算法：求组合总和（二） (opens new window)</a>中我们深入探讨了组合问题什么时候需要startIndex，什么时候不需要startIndex。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">vector&lt;string&gt; path; <span class="comment">// 放已经回文的子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span> </span>{</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归函数终止条件</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p>
<p>从树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止终止条件。</p>
<p><strong>那么在代码里什么是切割线呢？</strong></p>
<p>在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。</p>
<p>所以终止条件代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) {</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p><strong>来看看在递归循环，中如何截取子串呢？</strong></p>
<p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。</p>
<p>首先判断这个子串是不是回文，如果是回文，就加入在<code>vector&lt;string&gt; path</code>中，path用来记录切割过的回文子串。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i)) { <span class="comment">// 是回文子串</span></span><br><span class="line">        <span class="comment">// 获取[startIndex,i]在s中的子串</span></span><br><span class="line">        string str = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">push_back</span>(str);</span><br><span class="line">    } <span class="keyword">else</span> {                <span class="comment">// 如果不是则直接跳过</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>); <span class="comment">// 寻找i+1为起始位置的子串</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();        <span class="comment">// 回溯过程，弹出本次已经填在的子串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1</strong>。</p>
<h2 id="判断回文子串"><a href="#判断回文子串" class="headerlink" title="#判断回文子串"></a><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">#</a>判断回文子串</h2><p>最后我们看一下回文子串要如何判断了，判断一个字符串是否是回文。</p>
<p>可以使用双指针法，一个指针从前向后，一个指针从后先前，如果前后指针所指向的元素是相等的，就是回文字符串了。</p>
<p>那么判断回文的C++代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) {</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题目在leetcode上是中等，但可以说是hard的题目了，但是代码其实就是按照模板的样子来的。</p>
<p>那么难究竟难在什么地方呢？</p>
<p><strong>我列出如下几个难点：</strong></p>
<ul>
<li>切割问题可以抽象为组合问题</li>
<li>如何模拟那些切割线</li>
<li>切割问题中递归如何终止</li>
<li>在递归循环中如何截取子串</li>
<li>如何判断回文</li>
</ul>
<p><strong>我们平时在做难题的时候，总结出来难究竟难在哪里也是一种需要锻炼的能力</strong>。</p>
<p>一些同学可能遇到题目比较难，但是不知道题目难在哪里，反正就是很难。其实这样还是思维不够清晰，这种总结的能力需要多接触多锻炼。</p>
<p><strong>本题我相信很多同学主要卡在了第一个难点上：就是不知道如何切割，甚至知道要用回溯法，也不知道如何用。也就是没有体会到按照求组合问题的套路就可以解决切割</strong>。</p>
<p>如果意识到这一点，算是重大突破了。接下来就可以对着模板照葫芦画瓢。</p>
<p><strong>但接下来如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了</strong>。</p>
<p>关于模拟切割线，其实就是index是上一层已经确定了的分割线，i是这一层试图寻找的新分割线</p>
<p>除了这些难点，<strong>本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1</strong>。</p>
<p>所以本题应该是一个道hard题目了。</p>
<p><strong>可能刷过这道题目的录友都没感受到自己原来克服了这么多难点，就把这道题目AC了</strong>，这应该叫做无招胜有招，人码合一，哈哈哈。</p>
<h1 id="JAVA代码如下："><a href="#JAVA代码如下：" class="headerlink" title="JAVA代码如下："></a>JAVA代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> {</span><br><span class="line">       backTracking(s, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> lists;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span> {</span><br><span class="line">       <span class="keyword">if</span>(startIndex &gt;= s.length()) {</span><br><span class="line">           res.add(path);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;s.length();i++) {</span><br><span class="line">           <span class="keyword">if</span>(isHuiwen(s,startIndex,i)) {</span><br><span class="line">               <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(startIndex,i+<span class="number">1</span>);</span><br><span class="line">               path.add(tmp);</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           backtracking(s,i+<span class="number">1</span>);</span><br><span class="line">           path.remove(path.size() -<span class="number">1</span>);</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">   }</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isHuiwen</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> end)</span> {</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex, j = end; i &lt; j; i++, j--) {</span><br><span class="line">           <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) {</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>复原IP地址_回溯07</title>
    <url>/2022/08/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF06/</url>
    <content><![CDATA[<html><head></head><body><h1 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h1><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接(opens new window)</a></p>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1">192.168@1.1</a>“ 是 无效的 IP 地址。</p>
<p>示例 1：</p>
<ul>
<li>输入：s = “25525511135”</li>
<li>输出：[“255.255.11.135”,”255.255.111.35”]</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：s = “0000”</li>
<li>输出：[“0.0.0.0”]</li>
</ul>
<p>示例 3：</p>
<ul>
<li>输入：s = “1111”</li>
<li>输出：[“1.1.1.1”]</li>
</ul>
<p>示例 4：</p>
<ul>
<li>输入：s = “010010”</li>
<li>输出：[“0.10.0.10”,”0.100.1.0”]</li>
</ul>
<p>示例 5：</p>
<ul>
<li>输入：s = “101023”</li>
<li>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</li>
</ul>
<p>提示：</p>
<ul>
<li>0 &lt;= s.length &lt;= 3000</li>
<li>s 仅由数字组成</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF">#</a>思路</h1><p>做这道题目之前，最好先把<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>这个做了。</p>
<p>这道题目相信大家刚看的时候，应该会一脸茫然。</p>
<p>其实只要意识到这是切割问题，<strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>，和刚做过的<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>就十分类似了。</p>
<p>切割问题可以抽象为树型结构，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p>
<h2 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h2><ul>
<li>递归参数</li>
</ul>
<p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>中我们就提到切割问题类似组合问题。</p>
<p>startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。</p>
<p>本题我们还需要一个变量pointNum，记录添加逗点的数量。</p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;string&gt; result;<span class="comment">// 记录结果</span></span><br><span class="line"><span class="comment">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string&amp; s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> </span>{</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p>终止条件和<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>情况就不同了，本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。</p>
<p>pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。</p>
<p>然后验证一下第四段是否合法，如果合法就加入到结果集里</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pointNum == <span class="number">3</span>) { <span class="comment">// 逗点数量为3时，分隔结束</span></span><br><span class="line">    <span class="comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) {</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>中已经讲过在循环遍历中如何截取子串。</p>
<p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中 [startIndex, i] 这个区间就是截取的子串，需要判断这个子串是否合法。</p>
<p>如果合法就在字符串后面加上符号<code>.</code>表示已经分割。</p>
<p>如果不合法就结束本层循环，如图中剪掉的分支：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123203735933.png" alt="93.复原IP地址"></p>
<p>然后就是递归和回溯的过程：</p>
<p>递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符<code>.</code>），同时记录分割符的数量pointNum 要 +1。</p>
<p>回溯的时候，就将刚刚加入的分隔符<code>.</code> 删掉就可以了，pointNum也要-1。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, i)) { <span class="comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span></span><br><span class="line">        s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span> , <span class="string">'.'</span>);  <span class="comment">// 在i的后面插入一个逗点</span></span><br><span class="line">        pointNum++;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, i + <span class="number">2</span>, pointNum);   <span class="comment">// 插入逗点之后下一个子串的起始位置为i+2</span></span><br><span class="line">        pointNum--;                         <span class="comment">// 回溯</span></span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);         <span class="comment">// 回溯删掉逗点</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 不合法，直接结束本层循环</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="判断子串是否合法"><a href="#判断子串是否合法" class="headerlink" title="#判断子串是否合法"></a><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E5%88%A4%E6%96%AD%E5%AD%90%E4%B8%B2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95">#</a>判断子串是否合法</h2><p>最后就是在写一个判断段位是否是有效段位了。</p>
<p>主要考虑到如下三点：</p>
<ul>
<li>段位以0为开头的数字不合法</li>
<li>段位里有非正整数字符不合法</li>
<li>段位如果大于255了不合法</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s[start] == <span class="string">'0'</span> &amp;&amp; start != end) { <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) {</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; <span class="string">'9'</span> || s[i] &lt; <span class="string">'0'</span>) { <span class="comment">// 遇到非数字字符不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        num = num * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">255</span>) { <span class="comment">// 如果大于255了不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>中我列举的分割字符串的难点，本题都覆盖了。</p>
<p>而且本题还需要操作字符串添加逗号作为分隔符，并验证区间的合法性。</p>
<p>可以说是<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>的加强版。</p>
<p>在本文的树形结构图中，我已经把详细的分析思路都画了出来，相信大家看了之后一定会思路清晰不少！</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> result; <span class="comment">// 算是剪枝了</span></span><br><span class="line">        backTrack(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// startIndex: 搜索的起始位置， pointNum:添加逗点的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> {</span><br><span class="line">    	<span class="keyword">if</span>(pointNum == <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">if</span>(isValid(s,startIndex,s.length() -<span class="number">1</span>)) result.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;s.length();i++) {</span><br><span class="line">            <span class="keyword">if</span>(isVaild(s,startIndex,i)) {</span><br><span class="line">                s = s.substring(<span class="number">0</span>,i+<span class="number">1</span>) +<span class="string">"."</span>+substring(i+<span class="number">1</span>);</span><br><span class="line">                pointNum++;</span><br><span class="line">                backtracking(s,i+<span class="number">2</span>,pointNum);</span><br><span class="line">                pointNum--;</span><br><span class="line">                s = s.substring(<span class="number">0</span>,i+<span class="number">1</span>)+s.substring(i+<span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s,<span class="type">int</span> start;<span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">'0'</span> &amp;&amp; start != end) { <span class="comment">// 0开头的数字不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">'9'</span> || s.charAt(i) &lt; <span class="string">'0'</span>) { <span class="comment">// 遇到⾮数字字符不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) { <span class="comment">// 如果⼤于255了不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>子集问题（二）_回溯08</title>
    <url>/2022/08/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF07/</url>
    <content><![CDATA[<html><head></head><body><h1 id="子集问题（二）"><a href="#子集问题（二）" class="headerlink" title="子集问题（二）"></a>子集问题（二）</h1><h2 id="90-子集II"><a href="#90-子集II" class="headerlink" title="#90.子集II"></a><a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html#_90-%E5%AD%90%E9%9B%86ii">#</a>90.子集II</h2><p><a href="https://leetcode.cn/problems/subsets-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<ul>
<li>输入: [1,2,2]</li>
<li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>做本题之前一定要先做<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集 (opens new window)</a>。</p>
<p>这道题目和<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集 (opens new window)</a>区别就是集合里有重复元素了，而且求取的子集要去重。</p>
<p>那么关于回溯算法中的去重问题，<strong>在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II (opens new window)</a>中已经详细讲解过了，和本题是一个套路</strong>。</p>
<p><strong>剧透一下，后期要讲解的排列问题里去重也是这个套路，所以理解“树层去重”和“树枝去重”非常重要</strong>。</p>
<p>用示例中的[1, 2, 2] 来举例，如图所示： （<strong>注意去重需要先对集合排序</strong>）</p>
<p><img src="https://img-blog.csdnimg.cn/20201124195411977.png" alt="90.子集II"></p>
<p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p>
<p>本题就是其实就是<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">回溯算法：求子集问题！ (opens new window)</a>的基础上加上了去重，去重我们在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">回溯算法：求组合总和（三） (opens new window)</a>也讲过了</p>
<h1 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h1><p>本题也可以不使用used数组来去重，因为递归的时候下一个startIndex是i+1而不是0。</p>
<p>如果要是全排列的话，每次要从0开始遍历，为了跳过已入栈的元素，需要使用used。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下"></a>Java代码如下</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">( <span class="type">int</span>[] nums )</span> {</span><br><span class="line">	Arrays.sort(nums);</span><br><span class="line">    backtracking( nums, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">( <span class="type">int</span>[] nums, <span class="type">int</span> startIndex )</span> {</span><br><span class="line">	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;nums.length;i++) {</span><br><span class="line">		<span class="keyword">if</span>(i &gt; startIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">		path.add(nums[i]);</span><br><span class="line">		backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">		path.remove(path.size() -<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列_回溯09</title>
    <url>/2022/08/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF08/</url>
    <content><![CDATA[<html><head></head><body><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h1><p><a href="https://leetcode.cn/problems/permutations/">力扣题目链接(opens new window)</a></p>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<ul>
<li>输入: [1,2,3]</li>
<li>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>**如果对回溯算法基础还不了解的话，我还特意录制了一期视频：<a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇） (opens new window)</a>**可以结合题解和视频一起看，希望对大家理解回溯算法有所帮助。</p>
<p>此时我们已经学习了<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合问题 (opens new window)</a>、 <a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串 (opens new window)</a>和<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集问题 (opens new window)</a>，接下来看一看排列问题。</p>
<p>相信这个排列问题就算是让你用for循环暴力把结果搜索出来，这个暴力也不是很好写。</p>
<p>所以正如我们在<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于回溯算法，你该了解这些！ (opens new window)</a>所讲的为什么回溯法是暴力搜索，效率这么低，还要用它？</p>
<p><strong>因为一些问题能暴力搜出来就已经很不错了！</strong></p>
<p>我以[1,2,3]为例，抽象成树形结构如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p>
<h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h3><ul>
<li>递归函数参数</li>
</ul>
<p><strong>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方</strong>。</p>
<p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。</p>
<p>但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201209174225145.png" alt="46.全排列"></p>
<p>可以看出叶子节点，就是收割结果的地方。</p>
<p>那么什么时候，算是到达叶子节点呢？</p>
<p>当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 此时说明找到了一组</span></span><br><span class="line"><span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) {</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>这里和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合问题 (opens new window)</a>、<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.切割问题 (opens new window)</a>和<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集问题 (opens new window)</a>最大的不同就是for循环里不用startIndex了。</p>
<p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p>
<p><strong>而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">    used[i] = <span class="literal">true</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    used[i] = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">   LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">   <span class="type">boolean</span>[] used;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">       <span class="keyword">if</span> (nums.length == <span class="number">0</span>){</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       }</span><br><span class="line">       used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">       backtracking(nums);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   }</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">      	<span class="keyword">if</span>(path.size() == nums.length) {</span><br><span class="line">           res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++) {</span><br><span class="line">           <span class="keyword">if</span>(used[i]) {</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           used[i] = <span class="literal">true</span>;</span><br><span class="line">           path.add(nums[i]);</span><br><span class="line">           backtracking(nums);</span><br><span class="line">           path.removeLast();</span><br><span class="line">           used[i] = <span class="literal">false</span>;</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列_回溯10</title>
    <url>/2022/08/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF09/</url>
    <content><![CDATA[<html><head></head><body><h1 id="排列问题（二）"><a href="#排列问题（二）" class="headerlink" title="排列问题（二）"></a>排列问题（二）</h1><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="#47.全排列 II"></a><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#_47-%E5%85%A8%E6%8E%92%E5%88%97-ii">#</a>47.全排列 II</h2><p><a href="https://leetcode.cn/problems/permutations-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>示例 1：</p>
<ul>
<li>输入：nums = [1,1,2]</li>
<li>输出： [[1,1,2], [1,2,1], [2,1,1]]</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：nums = [1,2,3]</li>
<li>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 8</li>
<li>-10 &lt;= nums[i] &lt;= 10</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>**如果对回溯算法基础还不了解的话，我还特意录制了一期视频：<a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇） (opens new window)</a>**可以结合题解和视频一起看，希望对大家理解回溯算法有所帮助。</p>
<p>这道题目和<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列 (opens new window)</a>的区别在与<strong>给定一个可包含重复数字的序列</strong>，要返回<strong>所有不重复的全排列</strong>。</p>
<p>这里又涉及到去重了。</p>
<p>在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II (opens new window)</a>、<a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a>我们分别详细讲解了组合问题和子集问题如何去重。</p>
<p>那么排列问题其实也是一样的套路。</p>
<p><strong>还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</p>
<p>我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124201331223.png" alt="47.全排列II1"></p>
<p>图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p>
<p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p>
<p>在<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列 (opens new window)</a>中已经详解讲解了排列问题的写法，在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II (opens new window)</a>、<a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a>中详细讲解的去重的写法，所以这次我就不用回溯三部曲分析了，直接给出代码，如下：</p>
<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="#C++代码"></a><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#c-%E4%BB%A3%E7%A0%81">#</a>C++代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>{</span><br><span class="line">        <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) {</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) {</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) {</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="#拓展"></a><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%8B%93%E5%B1%95">#</a>拓展</h2><p>大家发现，去重最为关键的代码为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) {</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>**如果改成 <code>used[i - 1] == true</code>， 也是正确的!**，去重代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">true</span>) {</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p>
<p><strong>对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！</strong></p>
<p>这么说是不是有点抽象？</p>
<p>来来来，我就用输入: [1,1,1] 来举一个例子。</p>
<p>树层上去重(used[i - 1] == false)，的树形结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124201406192.png" alt="47.全排列II2"></p>
<p>树枝上去重（used[i - 1] == true）的树型结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124201431571.png" alt="47.全排列II3"></p>
<p>大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//存放结果</span></span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//暂存结果</span></span><br><span class="line">  List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">      <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      backtracking(nums);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  	</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) {</span><br><span class="line">          <span class="comment">// used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过</span></span><br><span class="line">          <span class="comment">// used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过</span></span><br><span class="line">          <span class="comment">// 如果同⼀树层nums[i - 1]使⽤过则直接跳过</span></span><br><span class="line">          <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; used[i -<span class="number">1</span>] == <span class="literal">false</span>) {</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span>(used[i] == <span class="literal">false</span>) {</span><br><span class="line">              used[i] = <span class="literal">true</span>;</span><br><span class="line">              path.add(nums[i]);</span><br><span class="line">          	backtracking(nums);</span><br><span class="line">          	path.remove(path.size() -<span class="number">1</span>);</span><br><span class="line">              used[i] = <span class="literal">false</span>;</span><br><span class="line">          }</span><br><span class="line">        </span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>瑞吉外卖-Day01</title>
    <url>/2022/08/15/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96_day01/</url>
    <content><![CDATA[<html><head></head><body><h1 id="瑞吉外卖-Day01"><a href="#瑞吉外卖-Day01" class="headerlink" title="瑞吉外卖-Day01"></a>瑞吉外卖-Day01</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><h5 id="软件开发整体介绍"><a href="#软件开发整体介绍" class="headerlink" title="软件开发整体介绍"></a>软件开发整体介绍</h5><h5 id="瑞吉外卖项目介绍"><a href="#瑞吉外卖项目介绍" class="headerlink" title="瑞吉外卖项目介绍"></a>瑞吉外卖项目介绍</h5><h5 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h5><h5 id="后台登录功能开发"><a href="#后台登录功能开发" class="headerlink" title="后台登录功能开发"></a>后台登录功能开发</h5><h5 id="后台退出功能开发"><a href="#后台退出功能开发" class="headerlink" title="后台退出功能开发"></a>后台退出功能开发</h5><h2 id="1-软件开发整体介绍"><a href="#1-软件开发整体介绍" class="headerlink" title="1. 软件开发整体介绍"></a>1. 软件开发整体介绍</h2><h5 id="作为一名软件开发工程师-我们需要了解在软件开发过程中的开发流程，-以及软件开发过程中涉及到的"><a href="#作为一名软件开发工程师-我们需要了解在软件开发过程中的开发流程，-以及软件开发过程中涉及到的" class="headerlink" title="作为一名软件开发工程师,我们需要了解在软件开发过程中的开发流程， 以及软件开发过程中涉及到的"></a>作为一名软件开发工程师,我们需要了解在软件开发过程中的开发流程， 以及软件开发过程中涉及到的</h5><h5 id="岗位角色，角色的分工、职责，-并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从"><a href="#岗位角色，角色的分工、职责，-并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从" class="headerlink" title="岗位角色，角色的分工、职责， 并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从"></a>岗位角色，角色的分工、职责， 并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从</h5><h5 id="软件开发流程、角色分工、软件环境-三个方面，来整体上介绍一下软件开发。"><a href="#软件开发流程、角色分工、软件环境-三个方面，来整体上介绍一下软件开发。" class="headerlink" title="软件开发流程、角色分工、软件环境 三个方面，来整体上介绍一下软件开发。"></a>软件开发流程、角色分工、软件环境 三个方面，来整体上介绍一下软件开发。</h5><h2 id="1-1-软件开发流程"><a href="#1-1-软件开发流程" class="headerlink" title="1.1 软件开发流程"></a>1.1 软件开发流程</h2><p><img src="https://s2.loli.net/2022/08/15/XqWAGMn9fDUeoct.png" alt="image-20220815181153178"></p>
<h5 id="1-第-1-阶段-需求分析"><a href="#1-第-1-阶段-需求分析" class="headerlink" title="1). 第 1 阶段: 需求分析"></a>1). 第 1 阶段: 需求分析</h5><h5 id="完成产品原型、需求规格说明书的编写。"><a href="#完成产品原型、需求规格说明书的编写。" class="headerlink" title="完成产品原型、需求规格说明书的编写。"></a>完成产品原型、需求规格说明书的编写。</h5><h5 id="产品原型，一般是通过网页-html-的形式展示当前的页面展示什么样的数据-页面的布局是什么样子"><a href="#产品原型，一般是通过网页-html-的形式展示当前的页面展示什么样的数据-页面的布局是什么样子" class="headerlink" title="产品原型，一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子"></a>产品原型，一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子</h5><h5 id="的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。"><a href="#的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。" class="headerlink" title="的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。"></a>的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。</h5><h5 id="需求规格说明书，-一般来说就是使用-Word-文档来描述当前项目有哪些功能，每一项功能的需求及"><a href="#需求规格说明书，-一般来说就是使用-Word-文档来描述当前项目有哪些功能，每一项功能的需求及" class="headerlink" title="需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及"></a>需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及</h5><h5 id="业务流程是什么样的，都会在文档中描述。"><a href="#业务流程是什么样的，都会在文档中描述。" class="headerlink" title="业务流程是什么样的，都会在文档中描述。"></a>业务流程是什么样的，都会在文档中描述。</h5><h5 id="2-第-2-阶段-设计"><a href="#2-第-2-阶段-设计" class="headerlink" title="2). 第 2 阶段: 设计"></a>2). 第 2 阶段: 设计</h5><h5 id="设计的内容包含-产品设计、UI界面设计、概要设计、详细设计、数据库设计。"><a href="#设计的内容包含-产品设计、UI界面设计、概要设计、详细设计、数据库设计。" class="headerlink" title="设计的内容包含 产品设计、UI界面设计、概要设计、详细设计、数据库设计。"></a>设计的内容包含 产品设计、UI界面设计、概要设计、详细设计、数据库设计。</h5><h5 id="在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到"><a href="#在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到" class="headerlink" title="在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到"></a>在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到</h5><h5 id="哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字"><a href="#哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字" class="headerlink" title="哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字"></a>哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字</h5><h5 id="段，字段类型都会在文档中描述清楚。"><a href="#段，字段类型都会在文档中描述清楚。" class="headerlink" title="段，字段类型都会在文档中描述清楚。"></a>段，字段类型都会在文档中描述清楚。</h5><h5 id="3-第-3-阶段-编码"><a href="#3-第-3-阶段-编码" class="headerlink" title="3). 第 3 阶段: 编码"></a>3). 第 3 阶段: 编码</h5><h5 id="编写项目代码、并完成单元测试。"><a href="#编写项目代码、并完成单元测试。" class="headerlink" title="编写项目代码、并完成单元测试。"></a>编写项目代码、并完成单元测试。</h5><h5 id="作为软件开发工程师，我们主要的工作就是在该阶段，-对分配给我们的模块功能，进行编码实现。编"><a href="#作为软件开发工程师，我们主要的工作就是在该阶段，-对分配给我们的模块功能，进行编码实现。编" class="headerlink" title="作为软件开发工程师，我们主要的工作就是在该阶段， 对分配给我们的模块功能，进行编码实现。编"></a>作为软件开发工程师，我们主要的工作就是在该阶段， 对分配给我们的模块功能，进行编码实现。编</h5><h5 id="码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。"><a href="#码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。" class="headerlink" title="码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。"></a>码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。</h5><h5 id="4-第-4-阶段-测试"><a href="#4-第-4-阶段-测试" class="headerlink" title="4). 第 4 阶段: 测试"></a>4). 第 4 阶段: 测试</h5><h5 id="在该阶段中主要由测试人员-对部署在测试环境的项目进行功能测试-并出具测试报告。"><a href="#在该阶段中主要由测试人员-对部署在测试环境的项目进行功能测试-并出具测试报告。" class="headerlink" title="在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。"></a>在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。</h5><h5 id="5-第-5-阶段-上线运维"><a href="#5-第-5-阶段-上线运维" class="headerlink" title="5). 第 5 阶段: 上线运维"></a>5). 第 5 阶段: 上线运维</h5><h5 id="在项目上线之前，-会由运维人员准备服务器上的软件环境安装、配置，-配置完毕后，-再将我们开发"><a href="#在项目上线之前，-会由运维人员准备服务器上的软件环境安装、配置，-配置完毕后，-再将我们开发" class="headerlink" title="在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发"></a>在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发</h5><h5 id="好的项目，部署在服务器上运行。"><a href="#好的项目，部署在服务器上运行。" class="headerlink" title="好的项目，部署在服务器上运行。"></a>好的项目，部署在服务器上运行。</h5><h5 id="我们作为软件开发工程师，-我们主要的任务是在编码阶段，-但是在一些小的项目组当中，-也会涉及"><a href="#我们作为软件开发工程师，-我们主要的任务是在编码阶段，-但是在一些小的项目组当中，-也会涉及" class="headerlink" title="我们作为软件开发工程师， 我们主要的任务是在编码阶段， 但是在一些小的项目组当中， 也会涉及"></a>我们作为软件开发工程师， 我们主要的任务是在编码阶段， 但是在一些小的项目组当中， 也会涉及</h5><h5 id="到数据库的设计、测试等方面的工作。"><a href="#到数据库的设计、测试等方面的工作。" class="headerlink" title="到数据库的设计、测试等方面的工作。"></a>到数据库的设计、测试等方面的工作。</h5><h3 id="1-2-角色分工"><a href="#1-2-角色分工" class="headerlink" title="1.2 角色分工"></a>1.2 角色分工</h3><p><img src="https://s2.loli.net/2022/08/15/CpOvhBlsnuadbAi.png" alt="image-20220815181218772"></p>
<h5 id="学习了软件开发的流程之后，-我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及"><a href="#学习了软件开发的流程之后，-我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及" class="headerlink" title="学习了软件开发的流程之后， 我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及"></a>学习了软件开发的流程之后， 我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及</h5><h5 id="各个角色的职责分工。"><a href="#各个角色的职责分工。" class="headerlink" title="各个角色的职责分工。"></a>各个角色的职责分工。</h5><h5 id="岗位-x2F-角色-职责-x2F-分工"><a href="#岗位-x2F-角色-职责-x2F-分工" class="headerlink" title="岗位/角色 职责/分工"></a>岗位/角色 职责/分工</h5><h5 id="项目经理-对整个项目负责，任务分配、把控进度"><a href="#项目经理-对整个项目负责，任务分配、把控进度" class="headerlink" title="项目经理 对整个项目负责，任务分配、把控进度"></a>项目经理 对整个项目负责，任务分配、把控进度</h5><h5 id="产品经理-进行需求调研，输出需求调研文档、产品原型等"><a href="#产品经理-进行需求调研，输出需求调研文档、产品原型等" class="headerlink" title="产品经理 进行需求调研，输出需求调研文档、产品原型等"></a>产品经理 进行需求调研，输出需求调研文档、产品原型等</h5><h5 id="UI设计师-根据产品原型输出界面效果图"><a href="#UI设计师-根据产品原型输出界面效果图" class="headerlink" title="UI设计师 根据产品原型输出界面效果图"></a>UI设计师 根据产品原型输出界面效果图</h5><h5 id="架构师-项目整体架构设计、技术选型等"><a href="#架构师-项目整体架构设计、技术选型等" class="headerlink" title="架构师 项目整体架构设计、技术选型等"></a>架构师 项目整体架构设计、技术选型等</h5><h5 id="开发工程师-功能代码实现"><a href="#开发工程师-功能代码实现" class="headerlink" title="开发工程师 功能代码实现"></a>开发工程师 功能代码实现</h5><h5 id="测试工程师-编写测试用例，输出测试报告"><a href="#测试工程师-编写测试用例，输出测试报告" class="headerlink" title="测试工程师 编写测试用例，输出测试报告"></a>测试工程师 编写测试用例，输出测试报告</h5><h5 id="运维工程师-软件环境搭建、项目上线"><a href="#运维工程师-软件环境搭建、项目上线" class="headerlink" title="运维工程师 软件环境搭建、项目上线"></a>运维工程师 软件环境搭建、项目上线</h5><h5 id="上述我们讲解的角色分工-是在一个项目组中比较标准的角色分工-但是在实际的项目中-有一些项"><a href="#上述我们讲解的角色分工-是在一个项目组中比较标准的角色分工-但是在实际的项目中-有一些项" class="headerlink" title="上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工, 但是在实际的项目中, 有一些项"></a>上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工, 但是在实际的项目中, 有一些项</h5><h5 id="目组由于人员配置紧张-可能并没有专门的架构师或测试人员-这个时候可能需要有项目经理或者程"><a href="#目组由于人员配置紧张-可能并没有专门的架构师或测试人员-这个时候可能需要有项目经理或者程" class="headerlink" title="目组由于人员配置紧张, 可能并没有专门的架构师或测试人员, 这个时候可能需要有项目经理或者程"></a>目组由于人员配置紧张, 可能并没有专门的架构师或测试人员, 这个时候可能需要有项目经理或者程</h5><h5 id="序员兼任。"><a href="#序员兼任。" class="headerlink" title="序员兼任。"></a>序员兼任。</h5><h3 id="1-3-软件环境"><a href="#1-3-软件环境" class="headerlink" title="1.3 软件环境"></a>1.3 软件环境</h3><h5 id="在我们日常的软件开发中，会涉及到软件开发中的三套环境，-那么这三套环境分别是-开发环境、测"><a href="#在我们日常的软件开发中，会涉及到软件开发中的三套环境，-那么这三套环境分别是-开发环境、测" class="headerlink" title="在我们日常的软件开发中，会涉及到软件开发中的三套环境， 那么这三套环境分别是: 开发环境、测"></a>在我们日常的软件开发中，会涉及到软件开发中的三套环境， 那么这三套环境分别是: 开发环境、测</h5><h5 id="试环境、生产环境。-接下来，我们分别介绍一下这三套环境的作用和特点。"><a href="#试环境、生产环境。-接下来，我们分别介绍一下这三套环境的作用和特点。" class="headerlink" title="试环境、生产环境。 接下来，我们分别介绍一下这三套环境的作用和特点。"></a>试环境、生产环境。 接下来，我们分别介绍一下这三套环境的作用和特点。</h5><h5 id="1-开发环境-development"><a href="#1-开发环境-development" class="headerlink" title="1). 开发环境(development)"></a>1). 开发环境(development)</h5><h5 id="我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。"><a href="#我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。" class="headerlink" title="我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。"></a>我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。</h5><h5 id="比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地，-也可以安装"><a href="#比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地，-也可以安装" class="headerlink" title="比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地， 也可以安装"></a>比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地， 也可以安装</h5><h5 id="在一台专门的服务器中，-这些应用软件仅仅在软件开发过程中使用，-项目测试、上线时，我们不会使"><a href="#在一台专门的服务器中，-这些应用软件仅仅在软件开发过程中使用，-项目测试、上线时，我们不会使" class="headerlink" title="在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用， 项目测试、上线时，我们不会使"></a>在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用， 项目测试、上线时，我们不会使</h5><h5 id="用这套环境了，这个环境就是开发环境。"><a href="#用这套环境了，这个环境就是开发环境。" class="headerlink" title="用这套环境了，这个环境就是开发环境。"></a>用这套环境了，这个环境就是开发环境。</h5><h5 id="2-测试环境-testing"><a href="#2-测试环境-testing" class="headerlink" title="2). 测试环境(testing)"></a>2). 测试环境(testing)</h5><h5 id="当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务"><a href="#当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务" class="headerlink" title="当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务"></a>当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务</h5><h5 id="器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境，-也就是测试"><a href="#器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境，-也就是测试" class="headerlink" title="器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境， 也就是测试"></a>器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境， 也就是测试</h5><h5 id="环境，用于项目测试，一般外部用户无法访问。"><a href="#环境，用于项目测试，一般外部用户无法访问。" class="headerlink" title="环境，用于项目测试，一般外部用户无法访问。"></a>环境，用于项目测试，一般外部用户无法访问。</h5><h5 id="3-生产环境-production"><a href="#3-生产环境-production" class="headerlink" title="3). 生产环境(production)"></a>3). 生产环境(production)</h5><h5 id="当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对"><a href="#当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对" class="headerlink" title="当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对"></a>当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对</h5><h5 id="外提供服务，这个线上环境也称之为生产环境。"><a href="#外提供服务，这个线上环境也称之为生产环境。" class="headerlink" title="外提供服务，这个线上环境也称之为生产环境。"></a>外提供服务，这个线上环境也称之为生产环境。</h5><h5 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识:"></a>拓展知识:</h5><h5 id="准生产环境-对于有的公司来说，项目功能开发好-并测试通过以后，并不是直接就上生"><a href="#准生产环境-对于有的公司来说，项目功能开发好-并测试通过以后，并不是直接就上生" class="headerlink" title="准生产环境: 对于有的公司来说，项目功能开发好, 并测试通过以后，并不是直接就上生"></a>准生产环境: 对于有的公司来说，项目功能开发好, 并测试通过以后，并不是直接就上生</h5><h5 id="产环境。为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环"><a href="#产环境。为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环" class="headerlink" title="产环境。为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环"></a>产环境。为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环</h5><h5 id="境中-测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的"><a href="#境中-测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的" class="headerlink" title="境中, 测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的"></a>境中, 测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的</h5><h5 id="克隆体，准生产环境的服务器配置-安装的应用软件-JDK、Tomcat、数据库、中间件-…"><a href="#克隆体，准生产环境的服务器配置-安装的应用软件-JDK、Tomcat、数据库、中间件-…" class="headerlink" title="克隆体，准生产环境的服务器配置, 安装的应用软件(JDK、Tomcat、数据库、中间件 …)"></a>克隆体，准生产环境的服务器配置, 安装的应用软件(JDK、Tomcat、数据库、中间件 …)</h5><h5 id="的版本都一样，这种环境也称为-“仿真环境”。"><a href="#的版本都一样，这种环境也称为-“仿真环境”。" class="headerlink" title="的版本都一样，这种环境也称为 “仿真环境”。"></a>的版本都一样，这种环境也称为 “仿真环境”。</h5><h5 id="ps-由于项目的性质和类型不同，有的项目可能不需要这个环境"><a href="#ps-由于项目的性质和类型不同，有的项目可能不需要这个环境" class="headerlink" title="ps.由于项目的性质和类型不同，有的项目可能不需要这个环境"></a>ps.由于项目的性质和类型不同，有的项目可能不需要这个环境</h5><h2 id="2-瑞吉外卖项目介绍"><a href="#2-瑞吉外卖项目介绍" class="headerlink" title="2. 瑞吉外卖项目介绍"></a>2. 瑞吉外卖项目介绍</h2><h5 id="在开发瑞吉外卖这个项目之前，我们需要全方位的来介绍一下当前我们学习的这个项目。接下来，我们"><a href="#在开发瑞吉外卖这个项目之前，我们需要全方位的来介绍一下当前我们学习的这个项目。接下来，我们" class="headerlink" title="在开发瑞吉外卖这个项目之前，我们需要全方位的来介绍一下当前我们学习的这个项目。接下来，我们"></a>在开发瑞吉外卖这个项目之前，我们需要全方位的来介绍一下当前我们学习的这个项目。接下来，我们</h5><h5 id="将从以下的五个方面，-来介绍瑞吉外卖这个项目。"><a href="#将从以下的五个方面，-来介绍瑞吉外卖这个项目。" class="headerlink" title="将从以下的五个方面， 来介绍瑞吉外卖这个项目。"></a>将从以下的五个方面， 来介绍瑞吉外卖这个项目。</h5><p><img src="https://s2.loli.net/2022/08/15/dcH16aKJ8kYoMCU.png" alt="image-20220815181240435"></p>
<h3 id="2-1-项目介绍"><a href="#2-1-项目介绍" class="headerlink" title="2.1 项目介绍"></a>2.1 项目介绍</h3><h5 id="阶段-功能实现"><a href="#阶段-功能实现" class="headerlink" title="阶段 功能实现"></a>阶段 功能实现</h5><h5 id="第一期-主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问"><a href="#第一期-主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问" class="headerlink" title="第一期 主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问"></a>第一期 主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问</h5><h5 id="第二期-主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便"><a href="#第二期-主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便" class="headerlink" title="第二期 主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便"></a>第二期 主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便</h5><h5 id="第三期-主要针对系统进行优化升级，提高系统的访问性能"><a href="#第三期-主要针对系统进行优化升级，提高系统的访问性能" class="headerlink" title="第三期 主要针对系统进行优化升级，提高系统的访问性能"></a>第三期 主要针对系统进行优化升级，提高系统的访问性能</h5><h5 id="本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括-系统管理后台-和"><a href="#本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括-系统管理后台-和" class="headerlink" title="本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括 系统管理后台 和"></a>本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括 系统管理后台 和</h5><h5 id="移动端应用-两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜"><a href="#移动端应用-两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜" class="headerlink" title="移动端应用 两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜"></a>移动端应用 两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜</h5><h5 id="品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加"><a href="#品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加" class="headerlink" title="品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加"></a>品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加</h5><h5 id="购物车、下单等。"><a href="#购物车、下单等。" class="headerlink" title="购物车、下单等。"></a>购物车、下单等。</h5><h5 id="本项目共分为-3-期进行开发："><a href="#本项目共分为-3-期进行开发：" class="headerlink" title="本项目共分为 3 期进行开发："></a>本项目共分为 3 期进行开发：</h5><p><img src="https://s2.loli.net/2022/08/15/au2QrT9yURLHjg3.png" alt="image-20220815181258405"></p>
<h3 id="2-2-产品原型"><a href="#2-2-产品原型" class="headerlink" title="2.2 产品原型"></a>2.2 产品原型</h3><h5 id="产品原型-，就是一款产品成型之前，由产品经理绘制的一个简单的框架，就是将页面的排版布局展现出"><a href="#产品原型-，就是一款产品成型之前，由产品经理绘制的一个简单的框架，就是将页面的排版布局展现出" class="headerlink" title="产品原型 ，就是一款产品成型之前，由产品经理绘制的一个简单的框架，就是将页面的排版布局展现出"></a>产品原型 ，就是一款产品成型之前，由产品经理绘制的一个简单的框架，就是将页面的排版布局展现出</h5><h5 id="来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的"><a href="#来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的" class="headerlink" title="来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的"></a>来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的</h5><h5 id="功能。"><a href="#功能。" class="headerlink" title="功能。"></a>功能。</h5><h5 id="1-管理端"><a href="#1-管理端" class="headerlink" title="1). 管理端"></a>1). 管理端</h5><h5 id="餐饮企业内部员工使用。-主要功能有"><a href="#餐饮企业内部员工使用。-主要功能有" class="headerlink" title="餐饮企业内部员工使用。 主要功能有:"></a>餐饮企业内部员工使用。 主要功能有:</h5><p><img src="https://s2.loli.net/2022/08/15/1zxQPM3bhgLjBXD.png" alt="image-20220815181455476"></p>
<h5 id="2-用户端"><a href="#2-用户端" class="headerlink" title="2). 用户端"></a>2). 用户端</h5><p><img src="https://s2.loli.net/2022/08/15/2l1JboiyKTruckR.png" alt="image-20220815181545849"></p>
<h5 id="移动端应用主要提供给消费者使用。主要功能有"><a href="#移动端应用主要提供给消费者使用。主要功能有" class="headerlink" title="移动端应用主要提供给消费者使用。主要功能有:"></a>移动端应用主要提供给消费者使用。主要功能有:</h5><h5 id="模块-描述"><a href="#模块-描述" class="headerlink" title="模块 描述"></a>模块 描述</h5><h5 id="登录-x2F-退"><a href="#登录-x2F-退" class="headerlink" title="登录/退"></a>登录/退</h5><h5 id="出"><a href="#出" class="headerlink" title="出"></a>出</h5><h5 id="在移动端-用户也需要登录后使用APP进行点餐"><a href="#在移动端-用户也需要登录后使用APP进行点餐" class="headerlink" title="在移动端, 用户也需要登录后使用APP进行点餐"></a>在移动端, 用户也需要登录后使用APP进行点餐</h5><h5 id="点餐-菜"><a href="#点餐-菜" class="headerlink" title="点餐-菜"></a>点餐-菜</h5><h5 id="单"><a href="#单" class="headerlink" title="单"></a>单</h5><h5 id="在点餐界面需要展示出菜品分类-x2F-套餐分类-并根据当前选择的分类加载其中的菜品"><a href="#在点餐界面需要展示出菜品分类-x2F-套餐分类-并根据当前选择的分类加载其中的菜品" class="headerlink" title="在点餐界面需要展示出菜品分类/套餐分类, 并根据当前选择的分类加载其中的菜品"></a>在点餐界面需要展示出菜品分类/套餐分类, 并根据当前选择的分类加载其中的菜品</h5><h5 id="信息-供用户查询选择"><a href="#信息-供用户查询选择" class="headerlink" title="信息, 供用户查询选择"></a>信息, 供用户查询选择</h5><h5 id="点餐-购"><a href="#点餐-购" class="headerlink" title="点餐-购"></a>点餐-购</h5><h5 id="物车"><a href="#物车" class="headerlink" title="物车"></a>物车</h5><h5 id="用户选中的菜品就会加入用户的购物车-主要包含-查询购物车、加入购物车、删除"><a href="#用户选中的菜品就会加入用户的购物车-主要包含-查询购物车、加入购物车、删除" class="headerlink" title="用户选中的菜品就会加入用户的购物车, 主要包含 查询购物车、加入购物车、删除"></a>用户选中的菜品就会加入用户的购物车, 主要包含 查询购物车、加入购物车、删除</h5><h5 id="购物车、清空购物车等功能"><a href="#购物车、清空购物车等功能" class="headerlink" title="购物车、清空购物车等功能"></a>购物车、清空购物车等功能</h5><h5 id="订单支"><a href="#订单支" class="headerlink" title="订单支"></a>订单支</h5><h5 id="付"><a href="#付" class="headerlink" title="付"></a>付</h5><h5 id="用户选完菜品-x2F-套餐后-可以对购物车菜品进行结算支付-这时就需要进行订单的支"><a href="#用户选完菜品-x2F-套餐后-可以对购物车菜品进行结算支付-这时就需要进行订单的支" class="headerlink" title="用户选完菜品/套餐后, 可以对购物车菜品进行结算支付, 这时就需要进行订单的支"></a>用户选完菜品/套餐后, 可以对购物车菜品进行结算支付, 这时就需要进行订单的支</h5><h5 id="付-1"><a href="#付-1" class="headerlink" title="付"></a>付</h5><h5 id="个人信"><a href="#个人信" class="headerlink" title="个人信"></a>个人信</h5><h5 id="息"><a href="#息" class="headerlink" title="息"></a>息</h5><h5 id="在个人中心页面中会展示当前用户的基本信息-用户可以管理收货地址-也可以查"><a href="#在个人中心页面中会展示当前用户的基本信息-用户可以管理收货地址-也可以查" class="headerlink" title="在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址, 也可以查"></a>在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址, 也可以查</h5><h5 id="询历史订单数据"><a href="#询历史订单数据" class="headerlink" title="询历史订单数据"></a>询历史订单数据</h5><h3 id="2-3-技术选型"><a href="#2-3-技术选型" class="headerlink" title="2.3 技术选型"></a>2.3 技术选型</h3><p><img src="https://s2.loli.net/2022/08/15/NPlZcFJ6IOk37LK.png" alt="image-20220815181605439"></p>
<h5 id="关于本项目的技术选型-我们将会从-用户层、网关层、应用层、数据层-这几个方面进行介绍，而对"><a href="#关于本项目的技术选型-我们将会从-用户层、网关层、应用层、数据层-这几个方面进行介绍，而对" class="headerlink" title="关于本项目的技术选型, 我们将会从 用户层、网关层、应用层、数据层 这几个方面进行介绍，而对"></a>关于本项目的技术选型, 我们将会从 用户层、网关层、应用层、数据层 这几个方面进行介绍，而对</h5><h5 id="于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。"><a href="#于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。" class="headerlink" title="于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。"></a>于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。</h5><h5 id="1-用户层"><a href="#1-用户层" class="headerlink" title="1). 用户层"></a>1). 用户层</h5><h5 id="本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue-js、ElementUI等技术。而在构建移"><a href="#本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue-js、ElementUI等技术。而在构建移" class="headerlink" title="本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI等技术。而在构建移"></a>本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI等技术。而在构建移</h5><h5 id="动端应用时，我们会使用到微信小程序。"><a href="#动端应用时，我们会使用到微信小程序。" class="headerlink" title="动端应用时，我们会使用到微信小程序。"></a>动端应用时，我们会使用到微信小程序。</h5><h5 id="2-网关层"><a href="#2-网关层" class="headerlink" title="2). 网关层"></a>2). 网关层</h5><h5 id="Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个"><a href="#Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个" class="headerlink" title="Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个"></a>Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个</h5><h5 id="比较重要的作用：-反向代理和负载均衡，-在进行项目部署时，要实现Tomcat的负载均衡，就可以通"><a href="#比较重要的作用：-反向代理和负载均衡，-在进行项目部署时，要实现Tomcat的负载均衡，就可以通" class="headerlink" title="比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通"></a>比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通</h5><h5 id="过Nginx来实现。"><a href="#过Nginx来实现。" class="headerlink" title="过Nginx来实现。"></a>过Nginx来实现。</h5><h5 id="3-应用层"><a href="#3-应用层" class="headerlink" title="3). 应用层"></a>3). 应用层</h5><h5 id="SpringBoot：-快速构建Spring项目-采用-“约定优于配置”-的思想-简化Spring项目的配置开"><a href="#SpringBoot：-快速构建Spring项目-采用-“约定优于配置”-的思想-简化Spring项目的配置开" class="headerlink" title="SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开"></a>SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开</h5><h5 id="发。"><a href="#发。" class="headerlink" title="发。"></a>发。</h5><h5 id="Spring-统一管理项目中的各种资源-bean-在web开发的各层中都会用到。"><a href="#Spring-统一管理项目中的各种资源-bean-在web开发的各层中都会用到。" class="headerlink" title="Spring: 统一管理项目中的各种资源(bean), 在web开发的各层中都会用到。"></a>Spring: 统一管理项目中的各种资源(bean), 在web开发的各层中都会用到。</h5><h5 id="SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进"><a href="#SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进" class="headerlink" title="SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进"></a>SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进</h5><h5 id="行整合，可以无缝集成。"><a href="#行整合，可以无缝集成。" class="headerlink" title="行整合，可以无缝集成。"></a>行整合，可以无缝集成。</h5><h5 id="SpringSession-主要解决在集群环境下的Session共享问题。"><a href="#SpringSession-主要解决在集群环境下的Session共享问题。" class="headerlink" title="SpringSession: 主要解决在集群环境下的Session共享问题。"></a>SpringSession: 主要解决在集群环境下的Session共享问题。</h5><h5 id="lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的"><a href="#lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的" class="headerlink" title="lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的"></a>lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的</h5><h5 id="javabean，都需要花时间去添加相应的getter-x2F-setter，也许还要去写构造器、equals等方法。"><a href="#javabean，都需要花时间去添加相应的getter-x2F-setter，也许还要去写构造器、equals等方法。" class="headerlink" title="javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法。"></a>javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法。</h5><h5 id="Swagger：-可以自动的帮助开发人员生成接口文档，并对接口进行测试。"><a href="#Swagger：-可以自动的帮助开发人员生成接口文档，并对接口进行测试。" class="headerlink" title="Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。"></a>Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。</h5><h5 id="4-数据层"><a href="#4-数据层" class="headerlink" title="4). 数据层"></a>4). 数据层</h5><h5 id="MySQL：-关系型数据库-本项目的核心业务数据都会采用MySQL进行存储。"><a href="#MySQL：-关系型数据库-本项目的核心业务数据都会采用MySQL进行存储。" class="headerlink" title="MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。"></a>MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。</h5><h5 id="MybatisPlus：-本项目持久层将会使用MybatisPlus来简化开发-基本的单表增删改查直接调用框"><a href="#MybatisPlus：-本项目持久层将会使用MybatisPlus来简化开发-基本的单表增删改查直接调用框" class="headerlink" title="MybatisPlus： 本项目持久层将会使用MybatisPlus来简化开发, 基本的单表增删改查直接调用框"></a>MybatisPlus： 本项目持久层将会使用MybatisPlus来简化开发, 基本的单表增删改查直接调用框</h5><h5 id="架提供的方法即可。"><a href="#架提供的方法即可。" class="headerlink" title="架提供的方法即可。"></a>架提供的方法即可。</h5><h5 id="Redis：-基于key-value格式存储的内存数据库-访问速度快-经常使用它做缓存-降低数据库访问"><a href="#Redis：-基于key-value格式存储的内存数据库-访问速度快-经常使用它做缓存-降低数据库访问" class="headerlink" title="Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存(降低数据库访问"></a>Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存(降低数据库访问</h5><h5 id="压力-提供访问效率-在后面的性能优化中会使用。"><a href="#压力-提供访问效率-在后面的性能优化中会使用。" class="headerlink" title="压力, 提供访问效率), 在后面的性能优化中会使用。"></a>压力, 提供访问效率), 在后面的性能优化中会使用。</h5><h5 id="5-工具"><a href="#5-工具" class="headerlink" title="5). 工具"></a>5). 工具</h5><h5 id="git-版本控制工具-在团队协作中-使用该工具对项目中的代码进行管理。"><a href="#git-版本控制工具-在团队协作中-使用该工具对项目中的代码进行管理。" class="headerlink" title="git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。"></a>git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。</h5><h5 id="maven-项目构建工具。"><a href="#maven-项目构建工具。" class="headerlink" title="maven: 项目构建工具。"></a>maven: 项目构建工具。</h5><h5 id="junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。"><a href="#junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。" class="headerlink" title="junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。"></a>junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。</h5><h3 id="2-4-功能架构"><a href="#2-4-功能架构" class="headerlink" title="2.4 功能架构"></a>2.4 功能架构</h3><p><img src="https://s2.loli.net/2022/08/15/VKvEQTPncJ51hNp.png" alt="image-20220815181648383"></p>
<h5 id="角色-权限操作"><a href="#角色-权限操作" class="headerlink" title="角色 权限操作"></a>角色 权限操作</h5><h5 id="后台系统管理员-登录后台管理系统，拥有后台系统中的所有操作权限"><a href="#后台系统管理员-登录后台管理系统，拥有后台系统中的所有操作权限" class="headerlink" title="后台系统管理员 登录后台管理系统，拥有后台系统中的所有操作权限"></a>后台系统管理员 登录后台管理系统，拥有后台系统中的所有操作权限</h5><h5 id="后台系统普通员工-登录后台管理系统，对菜品、套餐、订单等进行管理-不包含员工管理"><a href="#后台系统普通员工-登录后台管理系统，对菜品、套餐、订单等进行管理-不包含员工管理" class="headerlink" title="后台系统普通员工 登录后台管理系统，对菜品、套餐、订单等进行管理 (不包含员工管理)"></a>后台系统普通员工 登录后台管理系统，对菜品、套餐、订单等进行管理 (不包含员工管理)</h5><h5 id="C端用户-登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等"><a href="#C端用户-登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等" class="headerlink" title="C端用户 登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等"></a>C端用户 登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等</h5><h5 id="1-移动端前台功能"><a href="#1-移动端前台功能" class="headerlink" title="1). 移动端前台功能"></a>1). 移动端前台功能</h5><h5 id="手机号登录-微信登录-收件人地址管理-用户历史订单查询-菜品规格查询-购物车功能"><a href="#手机号登录-微信登录-收件人地址管理-用户历史订单查询-菜品规格查询-购物车功能" class="headerlink" title="手机号登录 , 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能"></a>手机号登录 , 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能</h5><h5 id="下单-分类及菜品浏览。"><a href="#下单-分类及菜品浏览。" class="headerlink" title=", 下单 , 分类及菜品浏览。"></a>, 下单 , 分类及菜品浏览。</h5><h5 id="2-系统管理后台功能"><a href="#2-系统管理后台功能" class="headerlink" title="2). 系统管理后台功能"></a>2). 系统管理后台功能</h5><h5 id="员工登录-x2F-退出-员工信息管理-分类管理-菜品管理-套餐管理-菜品口味管理-订单管"><a href="#员工登录-x2F-退出-员工信息管理-分类管理-菜品管理-套餐管理-菜品口味管理-订单管" class="headerlink" title="员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管"></a>员工登录/退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管</h5><h5 id="理-。"><a href="#理-。" class="headerlink" title="理 。"></a>理 。</h5><h3 id="2-5-角色"><a href="#2-5-角色" class="headerlink" title="2.5 角色"></a>2.5 角色</h3><h5 id="在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色：-后台系统管理员、后台系统"><a href="#在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色：-后台系统管理员、后台系统" class="headerlink" title="在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色： 后台系统管理员、后台系统"></a>在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色： 后台系统管理员、后台系统</h5><h5 id="普通员工、C端-移动端-用户。"><a href="#普通员工、C端-移动端-用户。" class="headerlink" title="普通员工、C端(移动端)用户。"></a>普通员工、C端(移动端)用户。</h5><p><img src="https://s2.loli.net/2022/08/15/nEwsjVAWSpoCd3x.png" alt="image-20220815181732164"></p>
<h2 id="3-开发环境搭建"><a href="#3-开发环境搭建" class="headerlink" title="3. 开发环境搭建"></a>3. 开发环境搭建</h2><h3 id="3-1-数据库环境搭建"><a href="#3-1-数据库环境搭建" class="headerlink" title="3.1 数据库环境搭建"></a>3.1 数据库环境搭建</h3><h4 id="3-1-1-创建数据库"><a href="#3-1-1-创建数据库" class="headerlink" title="3.1.1 创建数据库"></a>3.1.1 创建数据库</h4><h5 id="可以通过以下两种方式中的任意一种-来创建项目的数据库"><a href="#可以通过以下两种方式中的任意一种-来创建项目的数据库" class="headerlink" title="可以通过以下两种方式中的任意一种, 来创建项目的数据库:"></a>可以通过以下两种方式中的任意一种, 来创建项目的数据库:</h5><h5 id="1-图形界面"><a href="#1-图形界面" class="headerlink" title="1).图形界面"></a>1).图形界面</h5><h5 id="注意-本项目数据库的字符串-选择-utf8mb"><a href="#注意-本项目数据库的字符串-选择-utf8mb" class="headerlink" title="注意: 本项目数据库的字符串, 选择 utf8mb"></a>注意: 本项目数据库的字符串, 选择 utf8mb</h5><h5 id="2-命令行"><a href="#2-命令行" class="headerlink" title="2).命令行"></a>2).命令行</h5><h4 id="3-1-2-数据库表导入"><a href="#3-1-2-数据库表导入" class="headerlink" title="3.1.2 数据库表导入"></a>3.1.2 数据库表导入</h4><h5 id="项目的数据库创建好了之后-可以直接将-资料-x2F-数据模型-x2F-db-reggie-sql-直接导入到数据库中"><a href="#项目的数据库创建好了之后-可以直接将-资料-x2F-数据模型-x2F-db-reggie-sql-直接导入到数据库中" class="headerlink" title="项目的数据库创建好了之后, 可以直接将 资料/数据模型/db_reggie.sql 直接导入到数据库中,"></a>项目的数据库创建好了之后, 可以直接将 资料/数据模型/db_reggie.sql 直接导入到数据库中,</h5><h5 id="也可以通过两种方式实现"><a href="#也可以通过两种方式实现" class="headerlink" title="也可以通过两种方式实现:"></a>也可以通过两种方式实现:</h5><h5 id="1-图形界面-1"><a href="#1-图形界面-1" class="headerlink" title="1).图形界面"></a>1).图形界面</h5><h5 id="2-命令行-1"><a href="#2-命令行-1" class="headerlink" title="2).命令行"></a>2).命令行</h5><h5 id="注意-通过命令导入表结构时，注意sql文件不要放在中文目录中"><a href="#注意-通过命令导入表结构时，注意sql文件不要放在中文目录中" class="headerlink" title="注意: 通过命令导入表结构时，注意sql文件不要放在中文目录中"></a>注意: 通过命令导入表结构时，注意sql文件不要放在中文目录中</h5><h4 id="3-1-3-数据库表介绍"><a href="#3-1-3-数据库表介绍" class="headerlink" title="3.1.3 数据库表介绍"></a>3.1.3 数据库表介绍</h4><h5 id="数据库表导入之后-接下来介绍一下本项目中所涉及到的表结构"><a href="#数据库表导入之后-接下来介绍一下本项目中所涉及到的表结构" class="headerlink" title="数据库表导入之后, 接下来介绍一下本项目中所涉及到的表结构:"></a>数据库表导入之后, 接下来介绍一下本项目中所涉及到的表结构:</h5><h5 id="序号-表名-说明"><a href="#序号-表名-说明" class="headerlink" title="序号 表名 说明"></a>序号 表名 说明</h5><h5 id="1-employee-员工表"><a href="#1-employee-员工表" class="headerlink" title="1 employee 员工表"></a>1 employee 员工表</h5><h5 id="2-category-菜品和套餐分类表"><a href="#2-category-菜品和套餐分类表" class="headerlink" title="2 category 菜品和套餐分类表"></a>2 category 菜品和套餐分类表</h5><h5 id="3-dish-菜品表"><a href="#3-dish-菜品表" class="headerlink" title="3 dish 菜品表"></a>3 dish 菜品表</h5><h5 id="4-setmeal-套餐表"><a href="#4-setmeal-套餐表" class="headerlink" title="4 setmeal 套餐表"></a>4 setmeal 套餐表</h5><h5 id="5-setmeal-dish-套餐菜品关系表"><a href="#5-setmeal-dish-套餐菜品关系表" class="headerlink" title="5 setmeal_dish 套餐菜品关系表"></a>5 setmeal_dish 套餐菜品关系表</h5><h5 id="6-dish-flavor-菜品口味关系表"><a href="#6-dish-flavor-菜品口味关系表" class="headerlink" title="6 dish_flavor 菜品口味关系表"></a>6 dish_flavor 菜品口味关系表</h5><h5 id="7-user-用户表（C端）"><a href="#7-user-用户表（C端）" class="headerlink" title="7 user 用户表（C端）"></a>7 user 用户表（C端）</h5><h5 id="8-address-book-地址簿表"><a href="#8-address-book-地址簿表" class="headerlink" title="8 address_book 地址簿表"></a>8 address_book 地址簿表</h5><h5 id="9-shopping-cart-购物车表"><a href="#9-shopping-cart-购物车表" class="headerlink" title="9 shopping_cart 购物车表"></a>9 shopping_cart 购物车表</h5><h5 id="10-orders-订单表"><a href="#10-orders-订单表" class="headerlink" title="10 orders 订单表"></a>10 orders 订单表</h5><h5 id="11-order-detail-订单明细表"><a href="#11-order-detail-订单明细表" class="headerlink" title="11 order_detail 订单明细表"></a>11 order_detail 订单明细表</h5><h5 id="上述的表结构-我们目前先简单的结合页面原型了解一下-大概有那些表-每张表结构中存储什么样"><a href="#上述的表结构-我们目前先简单的结合页面原型了解一下-大概有那些表-每张表结构中存储什么样" class="headerlink" title="上述的表结构, 我们目前先简单的结合页面原型了解一下, 大概有那些表, 每张表结构中存储什么样"></a>上述的表结构, 我们目前先简单的结合页面原型了解一下, 大概有那些表, 每张表结构中存储什么样</h5><h5 id="的数据-有一个印象。对于具体的表结构-以及表结构中的字段-在讲解具体的功能开发时-我们再"><a href="#的数据-有一个印象。对于具体的表结构-以及表结构中的字段-在讲解具体的功能开发时-我们再" class="headerlink" title="的数据, 有一个印象。对于具体的表结构, 以及表结构中的字段, 在讲解具体的功能开发时, 我们再"></a>的数据, 有一个印象。对于具体的表结构, 以及表结构中的字段, 在讲解具体的功能开发时, 我们再</h5><h5 id="详细介绍。"><a href="#详细介绍。" class="headerlink" title="详细介绍。"></a>详细介绍。</h5><h3 id="3-2-Maven项目搭建"><a href="#3-2-Maven项目搭建" class="headerlink" title="3.2 Maven项目搭建"></a>3.2 Maven项目搭建</h3><h4 id="3-2-1-创建maven项目"><a href="#3-2-1-创建maven项目" class="headerlink" title="3.2.1 创建maven项目"></a>3.2.1 创建maven项目</h4><h5 id="1-在idea中创建maven-project-项目名称-reggie-take-out"><a href="#1-在idea中创建maven-project-项目名称-reggie-take-out" class="headerlink" title="1). 在idea中创建maven project, 项目名称 reggie_take_out"></a>1). 在idea中创建maven project, 项目名称 reggie_take_out</h5><p><img src="https://s2.loli.net/2022/08/15/zbgX3lHWFJOPemG.png" alt="image-20220815181857359"></p>
<h5 id="2-检查项目编码"><a href="#2-检查项目编码" class="headerlink" title="2). 检查项目编码"></a>2). 检查项目编码</h5><p><img src="https://s2.loli.net/2022/08/15/KUAHys1IrMVeqpE.png" alt="image-20220815181910429"></p>
<h5 id="3-检查maven配置"><a href="#3-检查maven配置" class="headerlink" title="3). 检查maven配置"></a>3). 检查maven配置</h5><p><img src="https://s2.loli.net/2022/08/15/oj7kn6HOK3ILDlZ.png" alt="image-20220815181925803"></p>
<h5 id="4-检查JDK版本"><a href="#4-检查JDK版本" class="headerlink" title="4). 检查JDK版本"></a>4). 检查JDK版本</h5><p><img src="https://s2.loli.net/2022/08/15/AaCElgjHtBXJe7W.png" alt="image-20220815181937778"></p>
<h5 id="JDK的版本选择1-8"><a href="#JDK的版本选择1-8" class="headerlink" title="JDK的版本选择1.8;"></a>JDK的版本选择1.8;</h5><h4 id="3-2-2-搭建基础环境"><a href="#3-2-2-搭建基础环境" class="headerlink" title="3.2.2 搭建基础环境"></a>3.2.2 搭建基础环境</h4><h5 id="1-在pom-xml中导入依赖"><a href="#1-在pom-xml中导入依赖" class="headerlink" title="1).在pom.xml中导入依赖"></a>1).在pom.xml中导入依赖</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;parent&gt;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.4.5&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.18.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.76&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-在工程的resources目录下创建application-yml文件-并引入配置"><a href="#2-在工程的resources目录下创建application-yml文件-并引入配置" class="headerlink" title="2).在工程的resources目录下创建application.yml文件,并引入配置"></a>2).在工程的resources目录下创建application.yml文件,并引入配置</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;groupId&gt;commons-lang&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-lang&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.23&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.4.5&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">port: 8080</span><br><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">#应用名称 , 可选</span><br><span class="line">name: reggie_take_out</span><br><span class="line">datasource:</span><br><span class="line">druid:</span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-创建包-com-itheima-reggie-并编写启动类"><a href="#3-创建包-com-itheima-reggie-并编写启动类" class="headerlink" title="3).创建包 com.itheima.reggie , 并编写启动类"></a>3).创建包 com.itheima.reggie , 并编写启动类</h5><h5 id="Slf4j"><a href="#Slf4j" class="headerlink" title="@Slf4j :"></a>@Slf4j :</h5><h5 id="是lombok中提供的注解-用来通过slf4j记录日志。"><a href="#是lombok中提供的注解-用来通过slf4j记录日志。" class="headerlink" title="是lombok中提供的注解, 用来通过slf4j记录日志。"></a>是lombok中提供的注解, 用来通过slf4j记录日志。</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">url: jdbc:mysql://localhost:3306/reggie?</span><br><span class="line">serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-</span><br><span class="line">8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br><span class="line">username: root</span><br><span class="line">password: root</span><br><span class="line">mybatis-plus:</span><br><span class="line">configuration:</span><br><span class="line">#在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span><br><span class="line">address_book ---&gt; AddressBook</span><br><span class="line">map-underscore-to-camel-case: true</span><br><span class="line">#日志输出</span><br><span class="line">log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">global-config:</span><br><span class="line">db-config:</span><br><span class="line">id-type: ASSIGN_ID</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">@Slf4j</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ReggieApplication {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">log.info("项目启动成功...");</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="当搭建完上述的基础环境之后-就可以通过引导类-启动该项目。"><a href="#当搭建完上述的基础环境之后-就可以通过引导类-启动该项目。" class="headerlink" title="当搭建完上述的基础环境之后, 就可以通过引导类, 启动该项目。"></a>当搭建完上述的基础环境之后, 就可以通过引导类, 启动该项目。</h5><h4 id="3-2-3-前端静态资源导入"><a href="#3-2-3-前端静态资源导入" class="headerlink" title="3.2.3 前端静态资源导入"></a>3.2.3 前端静态资源导入</h4><h5 id="我们作为服务端开发工程师，-我们课程学习的重心应该放在后端的业务代码上，-前端的页面我们只需"><a href="#我们作为服务端开发工程师，-我们课程学习的重心应该放在后端的业务代码上，-前端的页面我们只需" class="headerlink" title="我们作为服务端开发工程师， 我们课程学习的重心应该放在后端的业务代码上， 前端的页面我们只需"></a>我们作为服务端开发工程师， 我们课程学习的重心应该放在后端的业务代码上， 前端的页面我们只需</h5><h5 id="要导入课程资料中的前端资源，-前端页面的代码我们只需要能看懂即可。"><a href="#要导入课程资料中的前端资源，-前端页面的代码我们只需要能看懂即可。" class="headerlink" title="要导入课程资料中的前端资源， 前端页面的代码我们只需要能看懂即可。"></a>要导入课程资料中的前端资源， 前端页面的代码我们只需要能看懂即可。</h5><h5 id="1-导入静态资源"><a href="#1-导入静态资源" class="headerlink" title="1). 导入静态资源"></a>1). 导入静态资源</h5><h5 id="前端资源存放位置为-资料-x2F-前端资源"><a href="#前端资源存放位置为-资料-x2F-前端资源" class="headerlink" title="前端资源存放位置为 资料/前端资源 :"></a>前端资源存放位置为 资料/前端资源 :</h5><h5 id="将上述两个目录中的静态资源文件-导入到项目的resources目录下"><a href="#将上述两个目录中的静态资源文件-导入到项目的resources目录下" class="headerlink" title="将上述两个目录中的静态资源文件, 导入到项目的resources目录下:"></a>将上述两个目录中的静态资源文件, 导入到项目的resources目录下:</h5><p><img src="https://s2.loli.net/2022/08/15/Z368XJPHjKno1UG.png" alt="image-20220815182026354"></p>
<h5 id="2-创建配置类WebMvcConfig，设置静态资源映射"><a href="#2-创建配置类WebMvcConfig，设置静态资源映射" class="headerlink" title="2). 创建配置类WebMvcConfig，设置静态资源映射"></a>2). 创建配置类WebMvcConfig，设置静态资源映射</h5><h5 id="用于在Springboot项目中-默认静态资源的存放目录为-“classpath-x2F-resources-x2F-“"><a href="#用于在Springboot项目中-默认静态资源的存放目录为-“classpath-x2F-resources-x2F-“" class="headerlink" title="用于在Springboot项目中, 默认静态资源的存放目录为 : “classpath:/resources/“,"></a>用于在Springboot项目中, 默认静态资源的存放目录为 : “classpath:/resources/“,</h5><h5 id="“classpath-x2F-static-x2F-“-“classpath-x2F-public-x2F-“-而在我们的项目中静态资源存放在"><a href="#“classpath-x2F-static-x2F-“-“classpath-x2F-public-x2F-“-而在我们的项目中静态资源存放在" class="headerlink" title="“classpath:/static/“, “classpath:/public/“ ; 而在我们的项目中静态资源存放在"></a>“classpath:/static/“, “classpath:/public/“ ; 而在我们的项目中静态资源存放在</h5><h5 id="backend-front-目录中-那么这个时候要想访问到静态资源-就需要设置静态资源映射。"><a href="#backend-front-目录中-那么这个时候要想访问到静态资源-就需要设置静态资源映射。" class="headerlink" title="backend, front 目录中, 那么这个时候要想访问到静态资源, 就需要设置静态资源映射。"></a>backend, front 目录中, 那么这个时候要想访问到静态资源, 就需要设置静态资源映射。</h5><h5 id="3-访问测试"><a href="#3-访问测试" class="headerlink" title="3). 访问测试"></a>3). 访问测试</h5><h5 id="http-localhost-8080-backend-index-html"><a href="#http-localhost-8080-backend-index-html" class="headerlink" title="http://localhost:8080/backend/index.html"></a><a href="http://localhost:8080/backend/index.html">http://localhost:8080/backend/index.html</a></h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line">import</span><br><span class="line">org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line">@Slf4j</span><br><span class="line">@Configuration</span><br><span class="line">public class WebMvcConfig extends WebMvcConfigurationSupport {</span><br><span class="line">/**</span><br><span class="line">* 设置静态资源映射</span><br><span class="line">* @param registry</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">protected void addResourceHandlers(ResourceHandlerRegistry registry) {</span><br><span class="line">log.info("开始进行静态资源映射...");</span><br><span class="line">registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/back</span><br><span class="line">end/");</span><br><span class="line">registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/</span><br><span class="line">");</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-后台系统登录功能"><a href="#4-后台系统登录功能" class="headerlink" title="4. 后台系统登录功能"></a>4. 后台系统登录功能</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><h5 id="1-页面原型展示"><a href="#1-页面原型展示" class="headerlink" title="1). 页面原型展示"></a>1). 页面原型展示</h5><h5 id="2-登录页面成品展示"><a href="#2-登录页面成品展示" class="headerlink" title="2). 登录页面成品展示"></a>2). 登录页面成品展示</h5><p><img src="https://s2.loli.net/2022/08/15/jcg1HmbyWpuaqxr.png" alt="image-20220815182114156"></p>
<h5 id="登录页面存放目录-x2F-resources-x2F-backend-x2F-page-x2F-login-x2F-login-html"><a href="#登录页面存放目录-x2F-resources-x2F-backend-x2F-page-x2F-login-x2F-login-html" class="headerlink" title="登录页面存放目录 /resources/backend/page/login/login.html"></a>登录页面存放目录 /resources/backend/page/login/login.html</h5><h5 id="3-查看登录请求"><a href="#3-查看登录请求" class="headerlink" title="3). 查看登录请求"></a>3). 查看登录请求</h5><p><img src="https://s2.loli.net/2022/08/15/Lvf4xWUthwBJGbO.png" alt="image-20220815182134757"></p>
<h5 id="通过浏览器调试工具（F12），可以发现，点击登录按钮时，页面会发送请求（请求地址为-http-l"><a href="#通过浏览器调试工具（F12），可以发现，点击登录按钮时，页面会发送请求（请求地址为-http-l" class="headerlink" title="通过浏览器调试工具（F12），可以发现，点击登录按钮时，页面会发送请求（请求地址为 http://l"></a>通过浏览器调试工具（F12），可以发现，点击登录按钮时，页面会发送请求（请求地址为 <a href="http://l/">http://l</a></h5><h5 id="ocalhost-8080-x2F-employee-x2F-login-）并提交参数-username和password-请求参数为json格式"><a href="#ocalhost-8080-x2F-employee-x2F-login-）并提交参数-username和password-请求参数为json格式" class="headerlink" title="ocalhost:8080/employee/login ）并提交参数 username和password, 请求参数为json格式"></a>ocalhost:8080/employee/login ）并提交参数 username和password, 请求参数为json格式</h5><h5 id="数据-“username”-”admin”-”password”-”123456”-。"><a href="#数据-“username”-”admin”-”password”-”123456”-。" class="headerlink" title="数据 {“username”:”admin”,”password”:”123456”}。"></a>数据 {“username”:”admin”,”password”:”123456”}。</h5><h5 id="此时报-404-，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处"><a href="#此时报-404-，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处" class="headerlink" title="此时报 404 ，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处"></a>此时报 404 ，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处</h5><h5 id="理登录请求-；"><a href="#理登录请求-；" class="headerlink" title="理登录请求 ；"></a>理登录请求 ；</h5><h5 id="4-数据模型-employee表"><a href="#4-数据模型-employee表" class="headerlink" title="4). 数据模型(employee表)"></a>4). 数据模型(employee表)</h5><p><img src="https://s2.loli.net/2022/08/15/JWnPxeLYiAj1Rwa.png" alt="image-20220815182148542"></p>
<h5 id="5-前端页面分析"><a href="#5-前端页面分析" class="headerlink" title="5). 前端页面分析"></a>5). 前端页面分析</h5><p><img src="https://s2.loli.net/2022/08/15/39NhP5cCOwVf6Ez.png" alt="image-20220815182158908"></p>
<h5 id="当点击-“登录”-按钮-会触发Vue中定义的-handleLogin-方法"><a href="#当点击-“登录”-按钮-会触发Vue中定义的-handleLogin-方法" class="headerlink" title="当点击 “登录” 按钮, 会触发Vue中定义的 handleLogin 方法:"></a>当点击 “登录” 按钮, 会触发Vue中定义的 handleLogin 方法:</h5><h5 id="在上述的前端代码中-大家可以看到-发送登录的异步请求之后-获取到响应结果-在响应结果中至"><a href="#在上述的前端代码中-大家可以看到-发送登录的异步请求之后-获取到响应结果-在响应结果中至" class="headerlink" title="在上述的前端代码中, 大家可以看到, 发送登录的异步请求之后, 获取到响应结果, 在响应结果中至"></a>在上述的前端代码中, 大家可以看到, 发送登录的异步请求之后, 获取到响应结果, 在响应结果中至</h5><h5 id="少包含三个属性-code、data、msg-。"><a href="#少包含三个属性-code、data、msg-。" class="headerlink" title="少包含三个属性: code、data、msg 。"></a>少包含三个属性: code、data、msg 。</h5><h5 id="由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信"><a href="#由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信" class="headerlink" title="由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信"></a>由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信</h5><h5 id="息，存储在客户端的-localStorage-中了。"><a href="#息，存储在客户端的-localStorage-中了。" class="headerlink" title="息，存储在客户端的 localStorage 中了。"></a>息，存储在客户端的 localStorage 中了。</h5><h3 id="4-2-代码开发"><a href="#4-2-代码开发" class="headerlink" title="4.2 代码开发"></a>4.2 代码开发</h3><h4 id="4-2-1-基础准备工作"><a href="#4-2-1-基础准备工作" class="headerlink" title="4.2.1 基础准备工作"></a>4.2.1 基础准备工作</h4><h5 id="在进行登录功能的代码实现之前，-首先在我们的工程下创建包结构："><a href="#在进行登录功能的代码实现之前，-首先在我们的工程下创建包结构：" class="headerlink" title="在进行登录功能的代码实现之前， 首先在我们的工程下创建包结构："></a>在进行登录功能的代码实现之前， 首先在我们的工程下创建包结构：</h5><p><img src="https://s2.loli.net/2022/08/15/l3aZWwX2BOm7qy1.png" alt="image-20220815182230949"></p>
<h5 id="1-创建实体类Employee"><a href="#1-创建实体类Employee" class="headerlink" title="1). 创建实体类Employee"></a>1). 创建实体类Employee</h5><h5 id="该实体类主要用于和员工表-employee-进行映射。-该实体类，-也可以直接从资料-资料-x2F-实体类"><a href="#该实体类主要用于和员工表-employee-进行映射。-该实体类，-也可以直接从资料-资料-x2F-实体类" class="headerlink" title="该实体类主要用于和员工表 employee 进行映射。 该实体类， 也可以直接从资料( 资料/实体类"></a>该实体类主要用于和员工表 employee 进行映射。 该实体类， 也可以直接从资料( 资料/实体类</h5><h5 id="中拷贝工程中。"><a href="#中拷贝工程中。" class="headerlink" title=")中拷贝工程中。"></a>)中拷贝工程中。</h5><h5 id="所属包-com-itheima-reggie-entity"><a href="#所属包-com-itheima-reggie-entity" class="headerlink" title="所属包: com.itheima.reggie.entity"></a>所属包: com.itheima.reggie.entity</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 localStorage.setItem('userInfo',JSON.stringify(res.data))</span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-定义Mapper接口"><a href="#2-定义Mapper接口" class="headerlink" title="2). 定义Mapper接口"></a>2). 定义Mapper接口</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">@Data</span><br><span class="line">public class Employee implements Serializable {</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">private Long id;</span><br><span class="line">private String username;</span><br><span class="line">private String name;</span><br><span class="line">private String password;</span><br><span class="line">private String phone;</span><br><span class="line">private String sex;</span><br><span class="line">private String idNumber; //驼峰命名法 ---&gt; 映射的字段名为 id_number</span><br><span class="line">private Integer status;</span><br><span class="line">private LocalDateTime createTime;</span><br><span class="line">private LocalDateTime updateTime;</span><br><span class="line">@TableField(fill = FieldFill.INSERT)</span><br><span class="line">private Long createUser;</span><br><span class="line">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">private Long updateUser;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="在MybatisPlus中-自定义的Mapper接口-需要继承自-BaseMapper。"><a href="#在MybatisPlus中-自定义的Mapper接口-需要继承自-BaseMapper。" class="headerlink" title="在MybatisPlus中, 自定义的Mapper接口, 需要继承自 BaseMapper。"></a>在MybatisPlus中, 自定义的Mapper接口, 需要继承自 BaseMapper。</h5><h5 id="所属包-com-itheima-reggie-mapper"><a href="#所属包-com-itheima-reggie-mapper" class="headerlink" title="所属包: com.itheima.reggie.mapper"></a>所属包: com.itheima.reggie.mapper</h5><h5 id="3-Service接口"><a href="#3-Service接口" class="headerlink" title="3).Service接口"></a>3).Service接口</h5><h5 id="本项目的Service接口-在定义时需要继承自MybatisPlus提供的Service层接口-IService-这"><a href="#本项目的Service接口-在定义时需要继承自MybatisPlus提供的Service层接口-IService-这" class="headerlink" title="本项目的Service接口, 在定义时需要继承自MybatisPlus提供的Service层接口 IService, 这"></a>本项目的Service接口, 在定义时需要继承自MybatisPlus提供的Service层接口 IService, 这</h5><h5 id="样就可以直接调用-父接口的方法直接执行业务操作-简化业务层代码实现。"><a href="#样就可以直接调用-父接口的方法直接执行业务操作-简化业务层代码实现。" class="headerlink" title="样就可以直接调用 父接口的方法直接执行业务操作, 简化业务层代码实现。"></a>样就可以直接调用 父接口的方法直接执行业务操作, 简化业务层代码实现。</h5><h5 id="所属包-com-itheima-reggie-service"><a href="#所属包-com-itheima-reggie-service" class="headerlink" title="所属包: com.itheima.reggie.service"></a>所属包: com.itheima.reggie.service</h5><h5 id="4-Service实现类"><a href="#4-Service实现类" class="headerlink" title="4). Service实现类"></a>4). Service实现类</h5><h5 id="所属包-com-itheima-reggie-service-impl"><a href="#所属包-com-itheima-reggie-service-impl" class="headerlink" title="所属包: com.itheima.reggie.service.impl"></a>所属包: com.itheima.reggie.service.impl</h5><h5 id="5-Controller基础代码"><a href="#5-Controller基础代码" class="headerlink" title="5). Controller基础代码"></a>5). Controller基础代码</h5><h5 id="所属包-com-itheima-reggie-controller"><a href="#所属包-com-itheima-reggie-controller" class="headerlink" title="所属包: com.itheima.reggie.controller"></a>所属包: com.itheima.reggie.controller</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface EmployeeMapper extends BaseMapper&lt;Employee&gt;{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public interface EmployeeService extends IService&lt;Employee&gt; {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.itheima.reggie.entity.Employee;</span><br><span class="line">import com.itheima.reggie.mapper.EmployeeMapper;</span><br><span class="line">import com.itheima.reggie.service.EmployeeService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">@Service</span><br><span class="line">public class EmployeeServiceImpl extends ServiceImpl&lt;EmployeeMapper,Employee&gt;</span><br><span class="line">implements EmployeeService{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-导入通用结果类R"><a href="#6-导入通用结果类R" class="headerlink" title="6). 导入通用结果类R"></a>6). 导入通用结果类R</h5><h5 id="此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。"><a href="#此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。" class="headerlink" title="此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。"></a>此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。</h5><h5 id="所属包-com-itheima-reggie-common"><a href="#所属包-com-itheima-reggie-common" class="headerlink" title="所属包: com.itheima.reggie.common"></a>所属包: com.itheima.reggie.common</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping("/employee")</span><br><span class="line">public class EmployeeController {</span><br><span class="line">@Autowired</span><br><span class="line">private EmployeeService employeeService;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">/**</span><br><span class="line">* 通用返回结果，服务端响应的数据最终都会封装成此对象</span><br><span class="line">* @param &lt;T&gt;</span><br><span class="line">*/</span><br><span class="line">@Data</span><br><span class="line">public class R&lt;T&gt; {</span><br><span class="line">private Integer code; //编码： 1 成功， 0 和其它数字为失败</span><br><span class="line">private String msg; //错误信息</span><br><span class="line">private T data; //数据</span><br><span class="line">private Map map = new HashMap(); //动态数据</span><br><span class="line">public static &lt;T&gt; R&lt;T&gt; success(T object) {</span><br><span class="line">R&lt;T&gt; r = new R&lt;T&gt;();</span><br><span class="line">r.data = object;</span><br><span class="line">r.code = 1 ;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="A-如果业务执行结果为成功-构建R对象时-只需要调用-success-方法-如果需要返回数据传递"><a href="#A-如果业务执行结果为成功-构建R对象时-只需要调用-success-方法-如果需要返回数据传递" class="headerlink" title="A. 如果业务执行结果为成功, 构建R对象时, 只需要调用 success 方法; 如果需要返回数据传递"></a>A. 如果业务执行结果为成功, 构建R对象时, 只需要调用 success 方法; 如果需要返回数据传递</h5><h5 id="object-参数-如果无需返回-可以直接传递null。"><a href="#object-参数-如果无需返回-可以直接传递null。" class="headerlink" title="object 参数, 如果无需返回, 可以直接传递null。"></a>object 参数, 如果无需返回, 可以直接传递null。</h5><h5 id="B-如果业务执行结果为失败-构建R对象时-只需要调用error-方法-传递错误提示信息即可。"><a href="#B-如果业务执行结果为失败-构建R对象时-只需要调用error-方法-传递错误提示信息即可。" class="headerlink" title="B. 如果业务执行结果为失败, 构建R对象时, 只需要调用error 方法, 传递错误提示信息即可。"></a>B. 如果业务执行结果为失败, 构建R对象时, 只需要调用error 方法, 传递错误提示信息即可。</h5><h4 id="4-2-2-登录逻辑分析"><a href="#4-2-2-登录逻辑分析" class="headerlink" title="4.2.2 登录逻辑分析"></a>4.2.2 登录逻辑分析</h4><p><img src="https://s2.loli.net/2022/08/15/murFP9gxDXwMav2.png" alt="image-20220815182323964"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">return r;</span><br><span class="line">}</span><br><span class="line">public static &lt;T&gt; R&lt;T&gt; error(String msg) {</span><br><span class="line">R r = new R();</span><br><span class="line">r.msg = msg;</span><br><span class="line">r.code = 0 ;</span><br><span class="line">return r;</span><br><span class="line">}</span><br><span class="line">public R&lt;T&gt; add(String key, Object value) {</span><br><span class="line">this.map.put(key, value);</span><br><span class="line">return this;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="处理逻辑如下："><a href="#处理逻辑如下：" class="headerlink" title="处理逻辑如下："></a>处理逻辑如下：</h5><h5 id="①-将页面提交的密码password进行md5加密处理-得到加密后的字符串"><a href="#①-将页面提交的密码password进行md5加密处理-得到加密后的字符串" class="headerlink" title="①. 将页面提交的密码password进行md5加密处理, 得到加密后的字符串"></a>①. 将页面提交的密码password进行md5加密处理, 得到加密后的字符串</h5><h5 id="②-根据页面提交的用户名username查询数据库中员工数据信息"><a href="#②-根据页面提交的用户名username查询数据库中员工数据信息" class="headerlink" title="②. 根据页面提交的用户名username查询数据库中员工数据信息"></a>②. 根据页面提交的用户名username查询数据库中员工数据信息</h5><h5 id="③-如果没有查询到-则返回登录失败结果"><a href="#③-如果没有查询到-则返回登录失败结果" class="headerlink" title="③. 如果没有查询到, 则返回登录失败结果"></a>③. 如果没有查询到, 则返回登录失败结果</h5><h5 id="④-密码比对，如果不一致-则返回登录失败结果"><a href="#④-密码比对，如果不一致-则返回登录失败结果" class="headerlink" title="④. 密码比对，如果不一致, 则返回登录失败结果"></a>④. 密码比对，如果不一致, 则返回登录失败结果</h5><h5 id="⑤-查看员工状态，如果为已禁用状态，则返回员工已禁用结果"><a href="#⑤-查看员工状态，如果为已禁用状态，则返回员工已禁用结果" class="headerlink" title="⑤. 查看员工状态，如果为已禁用状态，则返回员工已禁用结果"></a>⑤. 查看员工状态，如果为已禁用状态，则返回员工已禁用结果</h5><h5 id="⑥-登录成功，将员工id存入Session-并返回登录成功结果"><a href="#⑥-登录成功，将员工id存入Session-并返回登录成功结果" class="headerlink" title="⑥. 登录成功，将员工id存入Session, 并返回登录成功结果"></a>⑥. 登录成功，将员工id存入Session, 并返回登录成功结果</h5><h4 id="4-2-3-代码实现"><a href="#4-2-3-代码实现" class="headerlink" title="4.2.3 代码实现"></a>4.2.3 代码实现</h4><h5 id="技术点说明"><a href="#技术点说明" class="headerlink" title="技术点说明:"></a>技术点说明:</h5><h5 id="A-由于需求分析时-我们看到前端发起的请求为post请求-所以服务端需要使用注解"><a href="#A-由于需求分析时-我们看到前端发起的请求为post请求-所以服务端需要使用注解" class="headerlink" title="A. 由于需求分析时, 我们看到前端发起的请求为post请求, 所以服务端需要使用注解"></a>A. 由于需求分析时, 我们看到前端发起的请求为post请求, 所以服务端需要使用注解</h5><h5 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h5><h5 id="B-由于前端传递的请求参数为json格式的数据-这里使用Employee对象接收-但是将json格式数"><a href="#B-由于前端传递的请求参数为json格式的数据-这里使用Employee对象接收-但是将json格式数" class="headerlink" title="B. 由于前端传递的请求参数为json格式的数据, 这里使用Employee对象接收, 但是将json格式数"></a>B. 由于前端传递的请求参数为json格式的数据, 这里使用Employee对象接收, 但是将json格式数</h5><h5 id="据封装到实体类中-在形参前需要加注解-RequestBody"><a href="#据封装到实体类中-在形参前需要加注解-RequestBody" class="headerlink" title="据封装到实体类中, 在形参前需要加注解@RequestBody"></a>据封装到实体类中, 在形参前需要加注解@RequestBody</h5><h6 id="x2F"><a href="#x2F" class="headerlink" title="/**"></a>/**</h6><h6 id="员工登录"><a href="#员工登录" class="headerlink" title="* 员工登录"></a>* 员工登录</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* @param request</span><br><span class="line">* @param employee</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@PostMapping("/login")</span><br><span class="line">public R&lt;Employee&gt; login(HttpServletRequest request,@RequestBody Employee</span><br><span class="line">employee){</span><br><span class="line">//1、将页面提交的密码password进行md5加密处理</span><br><span class="line">String password = employee.getPassword();</span><br><span class="line">password = DigestUtils.md5DigestAsHex(password.getBytes());</span><br><span class="line">//2、根据页面提交的用户名username查询数据库</span><br><span class="line">LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">queryWrapper.eq(Employee::getUsername,employee.getUsername());</span><br><span class="line">Employee emp = employeeService.getOne(queryWrapper);</span><br><span class="line">//3、如果没有查询到则返回登录失败结果</span><br><span class="line">if(emp == null){</span><br><span class="line">return R.error("登录失败");</span><br><span class="line">}</span><br><span class="line">//4、密码比对，如果不一致则返回登录失败结果</span><br><span class="line">if(!emp.getPassword().equals(password)){</span><br><span class="line">return R.error("登录失败");</span><br><span class="line">}</span><br><span class="line">//5、查看员工状态，如果为已禁用状态，则返回员工已禁用结果</span><br><span class="line">if(emp.getStatus() == 0 ){</span><br><span class="line">return R.error("账号已禁用");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-3-功能测试"><a href="#4-3-功能测试" class="headerlink" title="4.3 功能测试"></a>4.3 功能测试</h3><h5 id="代码实现完毕后-启动项目-访问url-http-localhost-8080-backend-page-login-log"><a href="#代码实现完毕后-启动项目-访问url-http-localhost-8080-backend-page-login-log" class="headerlink" title="代码实现完毕后, 启动项目, 访问url: http://localhost:8080/backend/page/login/log"></a>代码实现完毕后, 启动项目, 访问url: <a href="http://localhost:8080/backend/page/login/log">http://localhost:8080/backend/page/login/log</a></h5><h5 id="in-html-进行登录测试。"><a href="#in-html-进行登录测试。" class="headerlink" title="in.html , 进行登录测试。"></a>in.html , 进行登录测试。</h5><h5 id="在测试过程中，-可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各"><a href="#在测试过程中，-可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各" class="headerlink" title="在测试过程中， 可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各"></a>在测试过程中， 可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各</h5><h5 id="个对象的具体赋值情况。而且需要注意-在测试过程中，需要将所有的情况都覆盖到。"><a href="#个对象的具体赋值情况。而且需要注意-在测试过程中，需要将所有的情况都覆盖到。" class="headerlink" title="个对象的具体赋值情况。而且需要注意, 在测试过程中，需要将所有的情况都覆盖到。"></a>个对象的具体赋值情况。而且需要注意, 在测试过程中，需要将所有的情况都覆盖到。</h5><h5 id="1-问题说明"><a href="#1-问题说明" class="headerlink" title="1). 问题说明"></a>1). 问题说明</h5><h5 id="当我们在进行debug端点调试时-前端可能会出现如下问题-前端页面的控制台报出错误-超时"><a href="#当我们在进行debug端点调试时-前端可能会出现如下问题-前端页面的控制台报出错误-超时" class="headerlink" title="当我们在进行debug端点调试时, 前端可能会出现如下问题: 前端页面的控制台报出错误-超时;"></a>当我们在进行debug端点调试时, 前端可能会出现如下问题: 前端页面的控制台报出错误-超时;</h5><p><img src="https://s2.loli.net/2022/08/15/32pX4FBP61jlDgb.png" alt="image-20220815182406849"></p>
<h5 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2). 解决方案"></a>2). 解决方案</h5><h5 id="前端进行异步请求时-默认超时10000ms-可以将该值调大一些。"><a href="#前端进行异步请求时-默认超时10000ms-可以将该值调大一些。" class="headerlink" title="前端进行异步请求时, 默认超时10000ms , 可以将该值调大一些。"></a>前端进行异步请求时, 默认超时10000ms , 可以将该值调大一些。</h5><p><img src="https://s2.loli.net/2022/08/15/ofyRuihm9N1YSL3.png" alt="image-20220815182418678"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//6、登录成功，将员工id存入Session并返回登录成功结果</span><br><span class="line">request.getSession().setAttribute("employee",emp.getId());</span><br><span class="line">return R.success(emp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。"><a href="#由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。" class="headerlink" title="由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。"></a>由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。</h5><h2 id="5-后台系统退出功能"><a href="#5-后台系统退出功能" class="headerlink" title="5. 后台系统退出功能"></a>5. 后台系统退出功能</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><h5 id="在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面"><a href="#在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面" class="headerlink" title="在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面"></a>在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面</h5><h5 id="backend-x2F-index-html-，此时会在系统的右上角显示当前登录用户的姓名。"><a href="#backend-x2F-index-html-，此时会在系统的右上角显示当前登录用户的姓名。" class="headerlink" title="(backend/index.html)，此时会在系统的右上角显示当前登录用户的姓名。"></a>(backend/index.html)，此时会在系统的右上角显示当前登录用户的姓名。</h5><h5 id="如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。"><a href="#如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。" class="headerlink" title="如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。"></a>如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。</h5><h5 id="1-退出页面展示"><a href="#1-退出页面展示" class="headerlink" title="1). 退出页面展示"></a>1). 退出页面展示</h5><p><img src="https://s2.loli.net/2022/08/15/Zuw7F2hta5y9lxY.png" alt="image-20220815182529818"></p>
<h5 id="2-前端页面分析"><a href="#2-前端页面分析" class="headerlink" title="2).前端页面分析"></a>2).前端页面分析</h5><p><img src="https://s2.loli.net/2022/08/15/3P2g9DMpCwz7WN6.png" alt="image-20220815182542458"></p>
<h5 id="点击-将会调用一个js方法logout-在logout的方法中执行如下逻辑"><a href="#点击-将会调用一个js方法logout-在logout的方法中执行如下逻辑" class="headerlink" title="点击 将会调用一个js方法logout, 在logout的方法中执行如下逻辑:"></a>点击 将会调用一个js方法logout, 在logout的方法中执行如下逻辑:</h5><h5 id="A-发起post请求-调用服务端接口-x2F-employee-x2F-logout-执行退出操作"><a href="#A-发起post请求-调用服务端接口-x2F-employee-x2F-logout-执行退出操作" class="headerlink" title="A. 发起post请求, 调用服务端接口 /employee/logout 执行退出操作 ;"></a>A. 发起post请求, 调用服务端接口 /employee/logout 执行退出操作 ;</h5><h5 id="B-删除客户端-localStorage-中存储的用户登录信息-跳转至登录页面"><a href="#B-删除客户端-localStorage-中存储的用户登录信息-跳转至登录页面" class="headerlink" title="B. 删除客户端 localStorage 中存储的用户登录信息, 跳转至登录页面 ;"></a>B. 删除客户端 localStorage 中存储的用户登录信息, 跳转至登录页面 ;</h5><h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><h5 id="需要在Controller中创建对应的处理方法-接收页面发送的POST请求-x2F-employee-x2F-logout-，具"><a href="#需要在Controller中创建对应的处理方法-接收页面发送的POST请求-x2F-employee-x2F-logout-，具" class="headerlink" title="需要在Controller中创建对应的处理方法, 接收页面发送的POST请求 /employee/logout ，具"></a>需要在Controller中创建对应的处理方法, 接收页面发送的POST请求 /employee/logout ，具</h5><h5 id="体的处理逻辑："><a href="#体的处理逻辑：" class="headerlink" title="体的处理逻辑："></a>体的处理逻辑：</h5><h5 id="A-清理Session中的用户id"><a href="#A-清理Session中的用户id" class="headerlink" title="A. 清理Session中的用户id"></a>A. 清理Session中的用户id</h5><h5 id="B-返回结果"><a href="#B-返回结果" class="headerlink" title="B. 返回结果"></a>B. 返回结果</h5><h3 id="5-3-功能测试"><a href="#5-3-功能测试" class="headerlink" title="5.3 功能测试"></a>5.3 功能测试</h3><h5 id="1-代码实现完毕后-重启服务-访问登录界面-http-localhost-8080-backend-page-lo"><a href="#1-代码实现完毕后-重启服务-访问登录界面-http-localhost-8080-backend-page-lo" class="headerlink" title="1). 代码实现完毕后, 重启服务, 访问登录界面 http://localhost:8080/backend/page/lo"></a>1). 代码实现完毕后, 重启服务, 访问登录界面 <a href="http://localhost:8080/backend/page/lo">http://localhost:8080/backend/page/lo</a></h5><h5 id="gin-x2F-login-html"><a href="#gin-x2F-login-html" class="headerlink" title="gin/login.html ;"></a>gin/login.html ;</h5><h5 id="2-登录完成之后-进入到系统首页-backend-x2F-index-html-点击右上角-按钮-执行退出"><a href="#2-登录完成之后-进入到系统首页-backend-x2F-index-html-点击右上角-按钮-执行退出" class="headerlink" title="2). 登录完成之后, 进入到系统首页 backend/index.html, 点击右上角 按钮 执行退出"></a>2). 登录完成之后, 进入到系统首页 backend/index.html, 点击右上角 按钮 执行退出</h5><h5 id="操作-完成后看看是否可以跳转到登录页面-并检查localStorage。"><a href="#操作-完成后看看是否可以跳转到登录页面-并检查localStorage。" class="headerlink" title="操作, 完成后看看是否可以跳转到登录页面 , 并检查localStorage。"></a>操作, 完成后看看是否可以跳转到登录页面 , 并检查localStorage。</h5><h6 id="x2F-1"><a href="#x2F-1" class="headerlink" title="/**"></a>/**</h6><p><img src="https://s2.loli.net/2022/08/15/nS9RWdL1chFamxC.png" alt="image-20220815182448441"></p>
<h6 id="员工退出"><a href="#员工退出" class="headerlink" title="* 员工退出"></a>* 员工退出</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* @param request</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@PostMapping("/logout")</span><br><span class="line">public R&lt;String&gt; logout(HttpServletRequest request){</span><br><span class="line">//清理Session中保存的当前登录员工的id</span><br><span class="line">request.getSession().removeAttribute("employee");</span><br><span class="line">return R.success("退出成功");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/08/15/yqSvXYUHNwEn827.png" alt="image-20220815182505884"></p>
</body></html>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>瑞吉外卖_day02</title>
    <url>/2022/08/15/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96_day02/</url>
    <content><![CDATA[<html><head></head><body><hr>
<h1 id="瑞吉外卖-Day02"><a href="#瑞吉外卖-Day02" class="headerlink" title="瑞吉外卖-Day02"></a>瑞吉外卖-Day02</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><h5 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h5><h5 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h5><h5 id="员工信息分页查询"><a href="#员工信息分页查询" class="headerlink" title="员工信息分页查询"></a>员工信息分页查询</h5><h5 id="启用-x2F-禁用员工账号"><a href="#启用-x2F-禁用员工账号" class="headerlink" title="启用/禁用员工账号"></a>启用/禁用员工账号</h5><h5 id="编辑员工信息"><a href="#编辑员工信息" class="headerlink" title="编辑员工信息"></a>编辑员工信息</h5><h2 id="1-完善登录功能"><a href="#1-完善登录功能" class="headerlink" title="1. 完善登录功能"></a>1. 完善登录功能</h2><h2 id="1-1-问题分析"><a href="#1-1-问题分析" class="headerlink" title="1.1 问题分析"></a>1.1 问题分析</h2><h5 id="前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个"><a href="#前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个" class="headerlink" title="前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个"></a>前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个</h5><h5 id="这个问题，-以及如何处理。"><a href="#这个问题，-以及如何处理。" class="headerlink" title="这个问题， 以及如何处理。"></a>这个问题， 以及如何处理。</h5><h5 id="1-目前现状"><a href="#1-目前现状" class="headerlink" title="1). 目前现状"></a>1). 目前现状</h5><h5 id="用户如果不登录，直接访问系统首页面，照样可以正常访问。"><a href="#用户如果不登录，直接访问系统首页面，照样可以正常访问。" class="headerlink" title="用户如果不登录，直接访问系统首页面，照样可以正常访问。"></a>用户如果不登录，直接访问系统首页面，照样可以正常访问。</h5><p><img src="https://s2.loli.net/2022/08/17/qPHLyBl1D5wAYtd.png" alt="image-20220815232544699"></p>
<h5 id="2-理想效果"><a href="#2-理想效果" class="headerlink" title="2). 理想效果"></a>2). 理想效果</h5><h5 id="上述这种设计并不合理，我们希望看到的效果应该-是，只有登录成功后才可以访问系统中的页面，如"><a href="#上述这种设计并不合理，我们希望看到的效果应该-是，只有登录成功后才可以访问系统中的页面，如" class="headerlink" title="上述这种设计并不合理，我们希望看到的效果应该 是，只有登录成功后才可以访问系统中的页面，如"></a>上述这种设计并不合理，我们希望看到的效果应该 是，只有登录成功后才可以访问系统中的页面，如</h5><h5 id="果没有登录-访问系统中的任何界面都直接跳转到登录页面。"><a href="#果没有登录-访问系统中的任何界面都直接跳转到登录页面。" class="headerlink" title="果没有登录, 访问系统中的任何界面都直接跳转到登录页面。"></a>果没有登录, 访问系统中的任何界面都直接跳转到登录页面。</h5><p><img src="https://s2.loli.net/2022/08/17/O9eHgxS6WokyG5z.png" alt="image-20220815232809364"></p>
<h5 id="那么，具体应该怎么实现呢？"><a href="#那么，具体应该怎么实现呢？" class="headerlink" title="那么，具体应该怎么实现呢？"></a>那么，具体应该怎么实现呢？</h5><h5 id="可以使用我们之前讲解过的-过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断"><a href="#可以使用我们之前讲解过的-过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断" class="headerlink" title="可以使用我们之前讲解过的 过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断"></a>可以使用我们之前讲解过的 过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断</h5><h5 id="用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。"><a href="#用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。" class="headerlink" title="用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。"></a>用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。</h5><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><p><img src="https://s2.loli.net/2022/08/17/enC7tQqmYpO1rZM.png" alt="image-20220815232834075"></p>
<h5 id="过滤器具体的处理逻辑如下："><a href="#过滤器具体的处理逻辑如下：" class="headerlink" title="过滤器具体的处理逻辑如下："></a>过滤器具体的处理逻辑如下：</h5><h5 id="A-获取本次请求的URI"><a href="#A-获取本次请求的URI" class="headerlink" title="A. 获取本次请求的URI"></a>A. 获取本次请求的URI</h5><h5 id="B-判断本次请求-是否需要登录-才可以访问"><a href="#B-判断本次请求-是否需要登录-才可以访问" class="headerlink" title="B. 判断本次请求, 是否需要登录, 才可以访问"></a>B. 判断本次请求, 是否需要登录, 才可以访问</h5><h5 id="C-如果不需要，则直接放行"><a href="#C-如果不需要，则直接放行" class="headerlink" title="C. 如果不需要，则直接放行"></a>C. 如果不需要，则直接放行</h5><h5 id="D-判断登录状态，如果已登录，则直接放行"><a href="#D-判断登录状态，如果已登录，则直接放行" class="headerlink" title="D. 判断登录状态，如果已登录，则直接放行"></a>D. 判断登录状态，如果已登录，则直接放行</h5><h5 id="E-如果未登录-则返回未登录结果"><a href="#E-如果未登录-则返回未登录结果" class="headerlink" title="E. 如果未登录, 则返回未登录结果"></a>E. 如果未登录, 则返回未登录结果</h5><h5 id="如果未登录-我们需要给前端返回什么样的结果呢-这个时候-我们可以去看看前端是如何处理的"><a href="#如果未登录-我们需要给前端返回什么样的结果呢-这个时候-我们可以去看看前端是如何处理的" class="headerlink" title="如果未登录,我们需要给前端返回什么样的结果呢? 这个时候, 我们可以去看看前端是如何处理的?"></a>如果未登录,我们需要给前端返回什么样的结果呢? 这个时候, 我们可以去看看前端是如何处理的?</h5><p><img src="https://s2.loli.net/2022/08/17/WtmBjQYwSp8eohu.png" alt="image-20220815232921086"></p>
<h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><h5 id="1-定义登录校验过滤器"><a href="#1-定义登录校验过滤器" class="headerlink" title="1). 定义登录校验过滤器"></a>1). 定义登录校验过滤器</h5><h5 id="自定义一个过滤器-LoginCheckFilter-并实现-Filter-接口-在doFilter方法中完成校验的逻"><a href="#自定义一个过滤器-LoginCheckFilter-并实现-Filter-接口-在doFilter方法中完成校验的逻" class="headerlink" title="自定义一个过滤器 LoginCheckFilter 并实现 Filter 接口, 在doFilter方法中完成校验的逻"></a>自定义一个过滤器 LoginCheckFilter 并实现 Filter 接口, 在doFilter方法中完成校验的逻</h5><h5 id="辑。-那么接下来-我们就根据上述分析的步骤-来完成具体的功能代码实现"><a href="#辑。-那么接下来-我们就根据上述分析的步骤-来完成具体的功能代码实现" class="headerlink" title="辑。 那么接下来, 我们就根据上述分析的步骤, 来完成具体的功能代码实现:"></a>辑。 那么接下来, 我们就根据上述分析的步骤, 来完成具体的功能代码实现:</h5><h5 id="所属包-com-itheima-reggie-filter"><a href="#所属包-com-itheima-reggie-filter" class="headerlink" title="所属包: com.itheima.reggie.filter"></a>所属包: com.itheima.reggie.filter</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.util.AntPathMatcher;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br></pre></td></tr></tbody></table></figure>

<h6 id="x2F"><a href="#x2F" class="headerlink" title="/**"></a>/**</h6><h6 id="检查用户是否已经完成登录"><a href="#检查用户是否已经完成登录" class="headerlink" title="* 检查用户是否已经完成登录"></a>* 检查用户是否已经完成登录</h6><h6 id="x2F-1"><a href="#x2F-1" class="headerlink" title="*/"></a>*/</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")</span><br><span class="line">@Slf4j</span><br><span class="line">public class LoginCheckFilter implements Filter{</span><br><span class="line">//路径匹配器，支持通配符</span><br><span class="line">public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();</span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest servletRequest, ServletResponse</span><br><span class="line">servletResponse, FilterChain filterChain) throws IOException, ServletException {</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line">//1、获取本次请求的URI</span><br><span class="line">String requestURI = request.getRequestURI();// /backend/index.html</span><br><span class="line">log.info("拦截到请求：{}",requestURI);</span><br><span class="line">//定义不需要处理的请求路径</span><br><span class="line">String[] urls = new String[]{</span><br><span class="line">"/employee/login",</span><br><span class="line">"/employee/logout",</span><br><span class="line">"/backend/**",</span><br><span class="line">"/front/**"</span><br><span class="line">};</span><br><span class="line">//2、判断本次请求是否需要处理</span><br><span class="line">boolean check = check(urls, requestURI);</span><br><span class="line">//3、如果不需要处理，则直接放行</span><br><span class="line">if(check){</span><br><span class="line">log.info("本次请求{}不需要处理",requestURI);</span><br><span class="line">filterChain.doFilter(request,response);</span><br><span class="line">return;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="AntPathMatcher-拓展"><a href="#AntPathMatcher-拓展" class="headerlink" title="AntPathMatcher 拓展:"></a>AntPathMatcher 拓展:</h5><h5 id="介绍-Spring中提供的路径匹配器"><a href="#介绍-Spring中提供的路径匹配器" class="headerlink" title="介绍: Spring中提供的路径匹配器 ;"></a>介绍: Spring中提供的路径匹配器 ;</h5><h6 id="x2F-x2F-4、判断登录状态，如果已登录，则直接放行"><a href="#x2F-x2F-4、判断登录状态，如果已登录，则直接放行" class="headerlink" title="//4、判断登录状态，如果已登录，则直接放行"></a>//4、判断登录状态，如果已登录，则直接放行</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(request.getSession().getAttribute(<span class="string">"employee"</span>) != <span class="literal">null</span>){</span><br><span class="line">log.info(<span class="string">"用户已登录，用户id为：</span></span><br><span class="line"><span class="string">{}"</span>,request.getSession().getAttribute(<span class="string">"employee"</span>));</span><br><span class="line">filterChain.doFilter(request,response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">log.info(<span class="string">"用户未登录"</span>);</span><br><span class="line"><span class="comment">//5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据</span></span><br><span class="line">response.getWriter().write(JSON.toJSONString(R.error(<span class="string">"NOTLOGIN"</span>)));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 路径匹配，检查本次请求是否需要放行</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> requestURI</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String[] urls,String requestURI)</span>{</span><br><span class="line"><span class="keyword">for</span> (String url : urls) {</span><br><span class="line"><span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> PATH_MATCHER.match(url, requestURI);</span><br><span class="line"><span class="keyword">if</span>(match){</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-开启组件扫描"><a href="#2-开启组件扫描" class="headerlink" title="2). 开启组件扫描"></a>2). 开启组件扫描</h5><h5 id="需要在引导类上-加上Servlet组件扫描的注解-来扫描过滤器配置的-WebFilter注解，-扫描上"><a href="#需要在引导类上-加上Servlet组件扫描的注解-来扫描过滤器配置的-WebFilter注解，-扫描上" class="headerlink" title="需要在引导类上, 加上Servlet组件扫描的注解, 来扫描过滤器配置的@WebFilter注解， 扫描上"></a>需要在引导类上, 加上Servlet组件扫描的注解, 来扫描过滤器配置的@WebFilter注解， 扫描上</h5><h5 id="之后，-过滤器在运行时就生效了。"><a href="#之后，-过滤器在运行时就生效了。" class="headerlink" title="之后， 过滤器在运行时就生效了。"></a>之后， 过滤器在运行时就生效了。</h5><h5 id="ServletComponentScan-的作用"><a href="#ServletComponentScan-的作用" class="headerlink" title="@ServletComponentScan 的作用:"></a>@ServletComponentScan 的作用:</h5><h5 id="在SpringBoot项目中-在引导类-x2F-配置类上加了该注解后-会自动扫描项目中-当前包及"><a href="#在SpringBoot项目中-在引导类-x2F-配置类上加了该注解后-会自动扫描项目中-当前包及" class="headerlink" title="在SpringBoot项目中, 在引导类/配置类上加了该注解后, 会自动扫描项目中(当前包及"></a>在SpringBoot项目中, 在引导类/配置类上加了该注解后, 会自动扫描项目中(当前包及</h5><h5 id="其子包下-的-WebServlet-WebFilter-WebListener-注解-自动注册Servlet的"><a href="#其子包下-的-WebServlet-WebFilter-WebListener-注解-自动注册Servlet的" class="headerlink" title="其子包下)的@WebServlet , @WebFilter , @WebListener 注解, 自动注册Servlet的"></a>其子包下)的@WebServlet , @WebFilter , @WebListener 注解, 自动注册Servlet的</h5><h5 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件 ;"></a>相关组件 ;</h5><h3 id="1-4-功能测试"><a href="#1-4-功能测试" class="headerlink" title="1.4 功能测试"></a>1.4 功能测试</h3><h5 id="代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后"><a href="#代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后" class="headerlink" title="代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后"></a>代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后</h5><h5 id="看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。"><a href="#看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。" class="headerlink" title="看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。"></a>看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。</h5><p><img src="https://s2.loli.net/2022/08/17/Ggy72Ck3v5uIFxi.png" alt="image-20220815233039881"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@ServletComponentScan</span><br><span class="line">public class ReggieApplication {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">log.info("项目启动成功...");</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="对于前端的代码-也可以进行debug调试。"><a href="#对于前端的代码-也可以进行debug调试。" class="headerlink" title="对于前端的代码, 也可以进行debug调试。"></a>对于前端的代码, 也可以进行debug调试。</h5><h5 id="F12打开浏览器的调试工具-找到我们前面提到的request-js-在request-js的响应拦截器位置打"><a href="#F12打开浏览器的调试工具-找到我们前面提到的request-js-在request-js的响应拦截器位置打" class="headerlink" title="F12打开浏览器的调试工具, 找到我们前面提到的request.js, 在request.js的响应拦截器位置打"></a>F12打开浏览器的调试工具, 找到我们前面提到的request.js, 在request.js的响应拦截器位置打</h5><h5 id="上断点。"><a href="#上断点。" class="headerlink" title="上断点。"></a>上断点。</h5><h2 id="2-新增员工"><a href="#2-新增员工" class="headerlink" title="2. 新增员工"></a>2. 新增员工</h2><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><h5 id="后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击-添加员工-按钮跳转到新增页"><a href="#后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击-添加员工-按钮跳转到新增页" class="headerlink" title="后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击[添加员工]按钮跳转到新增页"></a>后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击[添加员工]按钮跳转到新增页</h5><h5 id="面，如下："><a href="#面，如下：" class="headerlink" title="面，如下："></a>面，如下：</h5><p><img src="https://s2.loli.net/2022/08/17/4qTwDh7dLJRYz8K.png" alt="image-20220815233113163"></p>
<h5 id="当填写完表单信息-点击”保存”按钮后-会提交该表单的数据到服务端-在服务端中需要接受数据"><a href="#当填写完表单信息-点击”保存”按钮后-会提交该表单的数据到服务端-在服务端中需要接受数据" class="headerlink" title="当填写完表单信息, 点击”保存”按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据,"></a>当填写完表单信息, 点击”保存”按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据,</h5><h5 id="然后将数据保存至数据库中。"><a href="#然后将数据保存至数据库中。" class="headerlink" title="然后将数据保存至数据库中。"></a>然后将数据保存至数据库中。</h5><h3 id="2-2-数据模型"><a href="#2-2-数据模型" class="headerlink" title="2.2 数据模型"></a>2.2 数据模型</h3><h5 id="新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。employee表中的status字"><a href="#新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。employee表中的status字" class="headerlink" title="新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。employee表中的status字"></a>新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。employee表中的status字</h5><h5 id="段已经设置了默认值-1-，表示状态正常。"><a href="#段已经设置了默认值-1-，表示状态正常。" class="headerlink" title="段已经设置了默认值 1 ，表示状态正常。"></a>段已经设置了默认值 1 ，表示状态正常。</h5><h5 id="需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必"><a href="#需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必" class="headerlink" title="需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必"></a>需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必</h5><h5 id="须是唯一的。"><a href="#须是唯一的。" class="headerlink" title="须是唯一的。"></a>须是唯一的。</h5><p><img src="https://s2.loli.net/2022/08/17/8J17ijOCNWlGsLm.png" alt="image-20220815233130088"></p>
<p><img src="https://s2.loli.net/2022/08/17/gVrXJCxHmqAwI58.png" alt="image-20220815233200739"></p>
<h3 id="2-3-程序执行流程"><a href="#2-3-程序执行流程" class="headerlink" title="2.3 程序执行流程"></a>2.3 程序执行流程</h3><p><img src="https://s2.loli.net/2022/08/17/1AQzGE2x6Da4UHS.png" alt="image-20220815233226285"></p>
<h5 id="在开发代码之前，我们需要结合着前端页面发起的请求，-梳理一下整个程序的执行过程："><a href="#在开发代码之前，我们需要结合着前端页面发起的请求，-梳理一下整个程序的执行过程：" class="headerlink" title="在开发代码之前，我们需要结合着前端页面发起的请求， 梳理一下整个程序的执行过程："></a>在开发代码之前，我们需要结合着前端页面发起的请求， 梳理一下整个程序的执行过程：</h5><h5 id="A-点击”保存”按钮-页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务"><a href="#A-点击”保存”按钮-页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务" class="headerlink" title="A. 点击”保存”按钮, 页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务"></a>A. 点击”保存”按钮, 页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务</h5><h5 id="端-请求方式POST-请求路径-x2F-employee"><a href="#端-请求方式POST-请求路径-x2F-employee" class="headerlink" title="端, 请求方式POST, 请求路径 /employee"></a>端, 请求方式POST, 请求路径 /employee</h5><h5 id="B-服务端Controller接收页面提交的数据并调用Service将数据进行保存"><a href="#B-服务端Controller接收页面提交的数据并调用Service将数据进行保存" class="headerlink" title="B. 服务端Controller接收页面提交的数据并调用Service将数据进行保存"></a>B. 服务端Controller接收页面提交的数据并调用Service将数据进行保存</h5><h5 id="C-Service调用Mapper操作数据库，保存数据"><a href="#C-Service调用Mapper操作数据库，保存数据" class="headerlink" title="C. Service调用Mapper操作数据库，保存数据"></a>C. Service调用Mapper操作数据库，保存数据</h5><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><h5 id="在EmployeeController中增加save方法-用于保存用户员工信息。"><a href="#在EmployeeController中增加save方法-用于保存用户员工信息。" class="headerlink" title="在EmployeeController中增加save方法, 用于保存用户员工信息。"></a>在EmployeeController中增加save方法, 用于保存用户员工信息。</h5><h5 id="A-在新增员工时，-按钮页面原型中的需求描述，-需要给员工设置初始默认密码-123456-，-并对密"><a href="#A-在新增员工时，-按钮页面原型中的需求描述，-需要给员工设置初始默认密码-123456-，-并对密" class="headerlink" title="A. 在新增员工时， 按钮页面原型中的需求描述， 需要给员工设置初始默认密码 123456 ， 并对密"></a>A. 在新增员工时， 按钮页面原型中的需求描述， 需要给员工设置初始默认密码 123456 ， 并对密</h5><h5 id="码进行MD5加密。"><a href="#码进行MD5加密。" class="headerlink" title="码进行MD5加密。"></a>码进行MD5加密。</h5><h5 id="B-在组装员工信息时-还需要封装创建时间、修改时间，创建人、修改人信息-从session中获取当"><a href="#B-在组装员工信息时-还需要封装创建时间、修改时间，创建人、修改人信息-从session中获取当" class="headerlink" title="B. 在组装员工信息时, 还需要封装创建时间、修改时间，创建人、修改人信息(从session中获取当"></a>B. 在组装员工信息时, 还需要封装创建时间、修改时间，创建人、修改人信息(从session中获取当</h5><h5 id="前登录用户-。"><a href="#前登录用户-。" class="headerlink" title="前登录用户)。"></a>前登录用户)。</h5><h6 id="x2F-2"><a href="#x2F-2" class="headerlink" title="/**"></a>/**</h6><h6 id="新增员工-1"><a href="#新增员工-1" class="headerlink" title="* 新增员工"></a>* 新增员工</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* @param employee</span><br><span class="line">* @return</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-5-功能测试"><a href="#2-5-功能测试" class="headerlink" title="2.5 功能测试"></a>2.5 功能测试</h3><h5 id="代码编写完毕之后，我们需要将工程重启-完毕之后直接访问管理系统首页-点击-“员工管理”-页面"><a href="#代码编写完毕之后，我们需要将工程重启-完毕之后直接访问管理系统首页-点击-“员工管理”-页面" class="headerlink" title="代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 点击 “员工管理” 页面"></a>代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 点击 “员工管理” 页面</h5><h5 id="中的-“添加员工”-按钮-输入员工基本信息-然后点击-“保存”-进行数据保存-保存完毕后-检查"><a href="#中的-“添加员工”-按钮-输入员工基本信息-然后点击-“保存”-进行数据保存-保存完毕后-检查" class="headerlink" title="中的 “添加员工” 按钮, 输入员工基本信息, 然后点击 “保存” 进行数据保存, 保存完毕后, 检查"></a>中的 “添加员工” 按钮, 输入员工基本信息, 然后点击 “保存” 进行数据保存, 保存完毕后, 检查</h5><h5 id="数据库中是否录入员工数据。"><a href="#数据库中是否录入员工数据。" class="headerlink" title="数据库中是否录入员工数据。"></a>数据库中是否录入员工数据。</h5><h5 id="当我们在测试中，添加用户时，-输入了一个已存在的用户名时，前端界面出现错误提示信息："><a href="#当我们在测试中，添加用户时，-输入了一个已存在的用户名时，前端界面出现错误提示信息：" class="headerlink" title="当我们在测试中，添加用户时， 输入了一个已存在的用户名时，前端界面出现错误提示信息："></a>当我们在测试中，添加用户时， 输入了一个已存在的用户名时，前端界面出现错误提示信息：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public R&lt;String&gt; save(HttpServletRequest request,@RequestBody Employee employee){</span><br><span class="line">log.info("新增员工，员工信息：{}",employee.toString());</span><br><span class="line">//设置初始密码 123456 ，需要进行md5加密处理</span><br><span class="line">employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));</span><br><span class="line">employee.setCreateTime(LocalDateTime.now());</span><br><span class="line">employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">//获得当前登录用户的id</span><br><span class="line">Long empId = (Long) request.getSession().getAttribute("employee");</span><br><span class="line">employee.setCreateUser(empId);</span><br><span class="line">employee.setUpdateUser(empId);</span><br><span class="line">employeeService.save(employee);</span><br><span class="line">return R.success("新增员工成功");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/08/17/XCsBb2DSkz8A5WP.png" alt="image-20220815233252657"></p>
<h5 id="而此时，服务端已经报错了，-报错信息如下："><a href="#而此时，服务端已经报错了，-报错信息如下：" class="headerlink" title="而此时，服务端已经报错了， 报错信息如下："></a>而此时，服务端已经报错了， 报错信息如下：</h5><p><img src="https://s2.loli.net/2022/08/17/ADIBryYkwEGFqht.png" alt="image-20220815233320769"></p>
<h5 id="出现上述的错误，-主要就是因为在-employee-表结构中，我们针对于username字段，建立了唯一"><a href="#出现上述的错误，-主要就是因为在-employee-表结构中，我们针对于username字段，建立了唯一" class="headerlink" title="出现上述的错误， 主要就是因为在 employee 表结构中，我们针对于username字段，建立了唯一"></a>出现上述的错误， 主要就是因为在 employee 表结构中，我们针对于username字段，建立了唯一</h5><h5 id="索引，添加重复的username数据时，违背该约束，就会报错。但是此时前端提示的信息并不具体，用"><a href="#索引，添加重复的username数据时，违背该约束，就会报错。但是此时前端提示的信息并不具体，用" class="headerlink" title="索引，添加重复的username数据时，违背该约束，就会报错。但是此时前端提示的信息并不具体，用"></a>索引，添加重复的username数据时，违背该约束，就会报错。但是此时前端提示的信息并不具体，用</h5><h5 id="户并不知道是因为什么原因造成的该异常，我们需要给用户提示详细的错误信息-。"><a href="#户并不知道是因为什么原因造成的该异常，我们需要给用户提示详细的错误信息-。" class="headerlink" title="户并不知道是因为什么原因造成的该异常，我们需要给用户提示详细的错误信息 。"></a>户并不知道是因为什么原因造成的该异常，我们需要给用户提示详细的错误信息 。</h5><h3 id="2-6-全局异常处理"><a href="#2-6-全局异常处理" class="headerlink" title="2.6 全局异常处理"></a>2.6 全局异常处理</h3><h4 id="2-6-1-思路分析"><a href="#2-6-1-思路分析" class="headerlink" title="2.6.1 思路分析"></a>2.6.1 思路分析</h4><h5 id="要想解决上述测试中存在的问题，我们需要对程序中可能出现的异常进行捕获，通常有两种处理方式："><a href="#要想解决上述测试中存在的问题，我们需要对程序中可能出现的异常进行捕获，通常有两种处理方式：" class="headerlink" title="要想解决上述测试中存在的问题，我们需要对程序中可能出现的异常进行捕获，通常有两种处理方式："></a>要想解决上述测试中存在的问题，我们需要对程序中可能出现的异常进行捕获，通常有两种处理方式：</h5><h5 id="A-在Controller方法中加入-try…catch-进行异常捕获"><a href="#A-在Controller方法中加入-try…catch-进行异常捕获" class="headerlink" title="A. 在Controller方法中加入 try…catch 进行异常捕获"></a>A. 在Controller方法中加入 try…catch 进行异常捕获</h5><h5 id="形式如下："><a href="#形式如下：" class="headerlink" title="形式如下："></a>形式如下：</h5><p><img src="https://s2.loli.net/2022/08/17/tx26gePac4BDlYC.png" alt="image-20220815233345903"></p>
<h5 id="如果采用这种方式，虽然可以解决，但是存在弊端，需要我们在保存其他业务数据时，也需要在"><a href="#如果采用这种方式，虽然可以解决，但是存在弊端，需要我们在保存其他业务数据时，也需要在" class="headerlink" title="如果采用这种方式，虽然可以解决，但是存在弊端，需要我们在保存其他业务数据时，也需要在"></a>如果采用这种方式，虽然可以解决，但是存在弊端，需要我们在保存其他业务数据时，也需要在</h5><h5 id="Controller方法中加上try…catch进行处理，代码冗余，不通用。"><a href="#Controller方法中加上try…catch进行处理，代码冗余，不通用。" class="headerlink" title="Controller方法中加上try…catch进行处理，代码冗余，不通用。"></a>Controller方法中加上try…catch进行处理，代码冗余，不通用。</h5><h5 id="B-使用异常处理器进行全局异常捕获"><a href="#B-使用异常处理器进行全局异常捕获" class="headerlink" title="B. 使用异常处理器进行全局异常捕获"></a>B. 使用异常处理器进行全局异常捕获</h5><h5 id="采用这种方式来实现，我们只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有"><a href="#采用这种方式来实现，我们只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有" class="headerlink" title="采用这种方式来实现，我们只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有"></a>采用这种方式来实现，我们只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有</h5><h5 id="异常。"><a href="#异常。" class="headerlink" title="异常。"></a>异常。</h5><h4 id="2-6-2-全局异常处理器"><a href="#2-6-2-全局异常处理器" class="headerlink" title="2.6.2 全局异常处理器"></a>2.6.2 全局异常处理器</h4><h5 id="在项目中自定义一个全局异常处理器，在异常处理器上加上注解-ControllerAdvice-可以通过属"><a href="#在项目中自定义一个全局异常处理器，在异常处理器上加上注解-ControllerAdvice-可以通过属" class="headerlink" title="在项目中自定义一个全局异常处理器，在异常处理器上加上注解 @ControllerAdvice,可以通过属"></a>在项目中自定义一个全局异常处理器，在异常处理器上加上注解 @ControllerAdvice,可以通过属</h5><h5 id="性annotations指定拦截哪一类的Controller方法。-并在异常处理器的方法上加上注解"><a href="#性annotations指定拦截哪一类的Controller方法。-并在异常处理器的方法上加上注解" class="headerlink" title="性annotations指定拦截哪一类的Controller方法。 并在异常处理器的方法上加上注解"></a>性annotations指定拦截哪一类的Controller方法。 并在异常处理器的方法上加上注解</h5><h5 id="ExceptionHandler-来指定拦截的是那一类型的异常。"><a href="#ExceptionHandler-来指定拦截的是那一类型的异常。" class="headerlink" title="@ExceptionHandler 来指定拦截的是那一类型的异常。"></a>@ExceptionHandler 来指定拦截的是那一类型的异常。</h5><h5 id="异常处理方法逻辑"><a href="#异常处理方法逻辑" class="headerlink" title="异常处理方法逻辑:"></a>异常处理方法逻辑:</h5><h5 id="指定捕获的异常类型为-SQLIntegrityConstraintViolationException"><a href="#指定捕获的异常类型为-SQLIntegrityConstraintViolationException" class="headerlink" title="指定捕获的异常类型为 SQLIntegrityConstraintViolationException"></a>指定捕获的异常类型为 SQLIntegrityConstraintViolationException</h5><h5 id="解析异常的提示信息-获取出是那个值违背了唯一约束"><a href="#解析异常的提示信息-获取出是那个值违背了唯一约束" class="headerlink" title="解析异常的提示信息, 获取出是那个值违背了唯一约束"></a>解析异常的提示信息, 获取出是那个值违背了唯一约束</h5><h5 id="组装错误信息并返回"><a href="#组装错误信息并返回" class="headerlink" title="组装错误信息并返回"></a>组装错误信息并返回</h5><p><img src="https://s2.loli.net/2022/08/17/J2GFQsqjkgEVUxW.png" alt="image-20220815233415145"></p>
<h5 id="所属包-com-itheima-reggie-common"><a href="#所属包-com-itheima-reggie-common" class="headerlink" title="所属包: com.itheima.reggie.common"></a>所属包: com.itheima.reggie.common</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import java.sql.SQLIntegrityConstraintViolationException;</span><br><span class="line">/**</span><br><span class="line">* 全局异常处理</span><br><span class="line">*/</span><br><span class="line">@ControllerAdvice(annotations = {RestController.class, Controller.class})</span><br><span class="line">@ResponseBody</span><br><span class="line">@Slf4j</span><br><span class="line">public class GlobalExceptionHandler {</span><br><span class="line">/**</span><br><span class="line">* 异常处理方法</span><br><span class="line">* @return</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>

<h5 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明:"></a>注解说明:</h5><h5 id="上述的全局异常处理器上使用了的两个注解-ControllerAdvice-ResponseBody"><a href="#上述的全局异常处理器上使用了的两个注解-ControllerAdvice-ResponseBody" class="headerlink" title="上述的全局异常处理器上使用了的两个注解 @ControllerAdvice , @ResponseBody"></a>上述的全局异常处理器上使用了的两个注解 @ControllerAdvice , @ResponseBody</h5><h5 id="他们的作用分别为"><a href="#他们的作用分别为" class="headerlink" title=", 他们的作用分别为:"></a>, 他们的作用分别为:</h5><h5 id="ControllerAdvice-指定拦截那些类型的控制器"><a href="#ControllerAdvice-指定拦截那些类型的控制器" class="headerlink" title="@ControllerAdvice : 指定拦截那些类型的控制器;"></a>@ControllerAdvice : 指定拦截那些类型的控制器;</h5><h5 id="ResponseBody-将方法的返回值-R-对象转换为json格式的数据-响应给页面"><a href="#ResponseBody-将方法的返回值-R-对象转换为json格式的数据-响应给页面" class="headerlink" title="@ResponseBody: 将方法的返回值 R 对象转换为json格式的数据, 响应给页面;"></a>@ResponseBody: 将方法的返回值 R 对象转换为json格式的数据, 响应给页面;</h5><h5 id="上述使用的两个注解-也可以合并成为一个注解-RestControllerAdvice"><a href="#上述使用的两个注解-也可以合并成为一个注解-RestControllerAdvice" class="headerlink" title="上述使用的两个注解, 也可以合并成为一个注解 @RestControllerAdvice"></a>上述使用的两个注解, 也可以合并成为一个注解 @RestControllerAdvice</h5><h4 id="2-6-3-测试"><a href="#2-6-3-测试" class="headerlink" title="2.6.3 测试"></a>2.6.3 测试</h4><h5 id="全局异常处理器编写完毕之后，我们需要将项目重启-完毕之后直接访问管理系统首页-点击-“员工"><a href="#全局异常处理器编写完毕之后，我们需要将项目重启-完毕之后直接访问管理系统首页-点击-“员工" class="headerlink" title="全局异常处理器编写完毕之后，我们需要将项目重启, 完毕之后直接访问管理系统首页, 点击 “员工"></a>全局异常处理器编写完毕之后，我们需要将项目重启, 完毕之后直接访问管理系统首页, 点击 “员工</h5><h5 id="管理”-页面中的-“添加员工”-按钮。当我们在测试中，添加用户时，-输入了一个已存在的用户名"><a href="#管理”-页面中的-“添加员工”-按钮。当我们在测试中，添加用户时，-输入了一个已存在的用户名" class="headerlink" title="管理” 页面中的 “添加员工” 按钮。当我们在测试中，添加用户时， 输入了一个已存在的用户名"></a>管理” 页面中的 “添加员工” 按钮。当我们在测试中，添加用户时， 输入了一个已存在的用户名</h5><h5 id="时，前端界面出现如下错误提示信息："><a href="#时，前端界面出现如下错误提示信息：" class="headerlink" title="时，前端界面出现如下错误提示信息："></a>时，前端界面出现如下错误提示信息：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span><br><span class="line">public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException</span><br><span class="line">ex){</span><br><span class="line">log.error(ex.getMessage());</span><br><span class="line">if(ex.getMessage().contains("Duplicate entry")){</span><br><span class="line">String[] split = ex.getMessage().split(" ");</span><br><span class="line">String msg = split[ 2 ] + "已存在";</span><br><span class="line">return R.error(msg);</span><br><span class="line">}</span><br><span class="line">return R.error("未知错误");</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/08/17/fNUnzoHYVE1GOpk.png" alt="image-20220815233447982"></p>
<h2 id="3-员工分页查询"><a href="#3-员工分页查询" class="headerlink" title="3. 员工分页查询"></a>3. 员工分页查询</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p><img src="https://s2.loli.net/2022/08/17/EFCwLpqD4XoW8MK.png" alt="image-20220815233518184"></p>
<h5 id="系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系"><a href="#系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系" class="headerlink" title="系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系"></a>系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系</h5><h5 id="统中都会以分页的方式来展示列表数据。而在我们的分页查询页面中-除了分页条件以外，还有一个查"><a href="#统中都会以分页的方式来展示列表数据。而在我们的分页查询页面中-除了分页条件以外，还有一个查" class="headerlink" title="统中都会以分页的方式来展示列表数据。而在我们的分页查询页面中, 除了分页条件以外，还有一个查"></a>统中都会以分页的方式来展示列表数据。而在我们的分页查询页面中, 除了分页条件以外，还有一个查</h5><h5 id="询条件-“员工姓名”。"><a href="#询条件-“员工姓名”。" class="headerlink" title="询条件 “员工姓名”。"></a>询条件 “员工姓名”。</h5><h5 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h5><h5 id="搜索条件：-员工姓名-模糊查询"><a href="#搜索条件：-员工姓名-模糊查询" class="headerlink" title="搜索条件： 员工姓名(模糊查询)"></a>搜索条件： 员工姓名(模糊查询)</h5><h5 id="分页条件：-每页展示条数-，-页码"><a href="#分页条件：-每页展示条数-，-页码" class="headerlink" title="分页条件： 每页展示条数 ， 页码"></a>分页条件： 每页展示条数 ， 页码</h5><h5 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h5><h5 id="总记录数"><a href="#总记录数" class="headerlink" title="总记录数"></a>总记录数</h5><h5 id="结果列表"><a href="#结果列表" class="headerlink" title="结果列表"></a>结果列表</h5><h3 id="3-2-程序执行流程"><a href="#3-2-程序执行流程" class="headerlink" title="3.2 程序执行流程"></a>3.2 程序执行流程</h3><h4 id="3-2-1-页面流程分析"><a href="#3-2-1-页面流程分析" class="headerlink" title="3.2.1 页面流程分析"></a>3.2.1 页面流程分析</h4><p><img src="https://s2.loli.net/2022/08/17/dLHC9wNcv3UDln8.png" alt="image-20220815233535234"></p>
<h5 id="在开发代码之前，需要梳理一下整个程序的执行过程。"><a href="#在开发代码之前，需要梳理一下整个程序的执行过程。" class="headerlink" title="在开发代码之前，需要梳理一下整个程序的执行过程。"></a>在开发代码之前，需要梳理一下整个程序的执行过程。</h5><h5 id="A-点击菜单，打开员工管理页面时，执行查询："><a href="#A-点击菜单，打开员工管理页面时，执行查询：" class="headerlink" title="A. 点击菜单，打开员工管理页面时，执行查询："></a>A. 点击菜单，打开员工管理页面时，执行查询：</h5><h5 id="B-搜索栏输入员工姓名-回车-执行查询"><a href="#B-搜索栏输入员工姓名-回车-执行查询" class="headerlink" title="B. 搜索栏输入员工姓名,回车,执行查询:"></a>B. 搜索栏输入员工姓名,回车,执行查询:</h5><p><img src="https://s2.loli.net/2022/08/17/eUm4lQFaWyI1T2K.png" alt="image-20220815233551935"></p>
<h5 id="1-页面发送ajax请求，将分页查询参数-page、pageSize、name-提交到服务端"><a href="#1-页面发送ajax请求，将分页查询参数-page、pageSize、name-提交到服务端" class="headerlink" title="1). 页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端"></a>1). 页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端</h5><h5 id="2-服务端Controller接收页面提交的数据-并组装条件调用Service查询数据"><a href="#2-服务端Controller接收页面提交的数据-并组装条件调用Service查询数据" class="headerlink" title="2). 服务端Controller接收页面提交的数据, 并组装条件调用Service查询数据"></a>2). 服务端Controller接收页面提交的数据, 并组装条件调用Service查询数据</h5><h5 id="3-Service调用Mapper操作数据库，查询分页数据"><a href="#3-Service调用Mapper操作数据库，查询分页数据" class="headerlink" title="3). Service调用Mapper操作数据库，查询分页数据"></a>3). Service调用Mapper操作数据库，查询分页数据</h5><h5 id="4-Controller将查询到的分页数据-响应给前端页面"><a href="#4-Controller将查询到的分页数据-响应给前端页面" class="headerlink" title="4). Controller将查询到的分页数据, 响应给前端页面"></a>4). Controller将查询到的分页数据, 响应给前端页面</h5><h5 id="5-页面接收到分页数据-并通过ElementUI的Table组件展示到页面上"><a href="#5-页面接收到分页数据-并通过ElementUI的Table组件展示到页面上" class="headerlink" title="5). 页面接收到分页数据, 并通过ElementUI的Table组件展示到页面上"></a>5). 页面接收到分页数据, 并通过ElementUI的Table组件展示到页面上</h5><h4 id="3-2-2-前端代码介绍"><a href="#3-2-2-前端代码介绍" class="headerlink" title="3.2.2 前端代码介绍"></a>3.2.2 前端代码介绍</h4><h5 id="1-访问员工列表页面-x2F-member-x2F-list-html时-会触发Vuejs中的钩子方法-在页面初始化时调用"><a href="#1-访问员工列表页面-x2F-member-x2F-list-html时-会触发Vuejs中的钩子方法-在页面初始化时调用" class="headerlink" title="1). 访问员工列表页面/member/list.html时, 会触发Vuejs中的钩子方法, 在页面初始化时调用"></a>1). 访问员工列表页面/member/list.html时, 会触发Vuejs中的钩子方法, 在页面初始化时调用</h5><h5 id="created方法"><a href="#created方法" class="headerlink" title="created方法"></a>created方法</h5><p><img src="https://s2.loli.net/2022/08/17/iGaqsPKuDpwvBLe.png" alt="image-20220815233615094"></p>
<h5 id="从上述的前端代码中我们可以看到-执行完分页查询-我们需要给前端返回的信息中需要包含两项"><a href="#从上述的前端代码中我们可以看到-执行完分页查询-我们需要给前端返回的信息中需要包含两项" class="headerlink" title="从上述的前端代码中我们可以看到, 执行完分页查询, 我们需要给前端返回的信息中需要包含两项 :"></a>从上述的前端代码中我们可以看到, 执行完分页查询, 我们需要给前端返回的信息中需要包含两项 :</h5><h5 id="records-中封装结果列表-total中封装总记录数-。"><a href="#records-中封装结果列表-total中封装总记录数-。" class="headerlink" title="records 中封装结果列表, total中封装总记录数 。"></a>records 中封装结果列表, total中封装总记录数 。</h5><h5 id="而在组装请求参数时-page、pageSize-都是前端分页插件渲染时的参数；"><a href="#而在组装请求参数时-page、pageSize-都是前端分页插件渲染时的参数；" class="headerlink" title="而在组装请求参数时 , page、pageSize 都是前端分页插件渲染时的参数；"></a>而在组装请求参数时 , page、pageSize 都是前端分页插件渲染时的参数；</h5><p><img src="https://s2.loli.net/2022/08/17/AoMKQIE5jNdwZr8.png" alt="image-20220815233808670"></p>
<h5 id="2-在getMemberList方法中-通过axios发起异步请求"><a href="#2-在getMemberList方法中-通过axios发起异步请求" class="headerlink" title="2). 在getMemberList方法中, 通过axios发起异步请求"></a>2). 在getMemberList方法中, 通过axios发起异步请求</h5><p><img src="https://s2.loli.net/2022/08/17/lc2MXQDJ5C948IS.png" alt="image-20220815233825803"></p>
<h5 id="axios发起的异步请求会被声明在-request-js-中的request拦截器拦截-在其中对get请求进行"><a href="#axios发起的异步请求会被声明在-request-js-中的request拦截器拦截-在其中对get请求进行" class="headerlink" title="axios发起的异步请求会被声明在 request.js 中的request拦截器拦截, 在其中对get请求进行"></a>axios发起的异步请求会被声明在 request.js 中的request拦截器拦截, 在其中对get请求进行</h5><h5 id="进一步的封装处理"><a href="#进一步的封装处理" class="headerlink" title="进一步的封装处理"></a>进一步的封装处理</h5><p><img src="https://s2.loli.net/2022/08/17/7eRLSJZWBFVGYt9.png" alt="image-20220815233844295"></p>
<h5 id="最终发送给服务端的请求为-GET请求-请求链接-x2F-employee-x2F-page"><a href="#最终发送给服务端的请求为-GET请求-请求链接-x2F-employee-x2F-page" class="headerlink" title="最终发送给服务端的请求为 : GET请求 , 请求链接 /employee/page?"></a>最终发送给服务端的请求为 : GET请求 , 请求链接 /employee/page?</h5><h5 id="page-x3D-1-amp-pageSize-x3D-10-amp-name-x3D-xxx"><a href="#page-x3D-1-amp-pageSize-x3D-10-amp-name-x3D-xxx" class="headerlink" title="page=1&amp;pageSize=10&amp;name=xxx"></a>page=1&amp;pageSize=10&amp;name=xxx</h5><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><h4 id="3-3-1-分页插件配置"><a href="#3-3-1-分页插件配置" class="headerlink" title="3.3.1 分页插件配置"></a>3.3.1 分页插件配置</h4><h5 id="当前我们要实现的分页查询功能，而在MybatisPlus要实现分页功能，就需要用到MybatisPlus中提"><a href="#当前我们要实现的分页查询功能，而在MybatisPlus要实现分页功能，就需要用到MybatisPlus中提" class="headerlink" title="当前我们要实现的分页查询功能，而在MybatisPlus要实现分页功能，就需要用到MybatisPlus中提"></a>当前我们要实现的分页查询功能，而在MybatisPlus要实现分页功能，就需要用到MybatisPlus中提</h5><h5 id="供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象。"><a href="#供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象。" class="headerlink" title="供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象。"></a>供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象。</h5><h5 id="所属包-com-itheima-reggie-config"><a href="#所属包-com-itheima-reggie-config" class="headerlink" title="所属包: com.itheima.reggie.config"></a>所属包: com.itheima.reggie.config</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line">import</span><br><span class="line">com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/**</span><br><span class="line">* 配置MP的分页插件</span><br><span class="line">*/</span><br><span class="line">@Configuration</span><br><span class="line">public class MybatisPlusConfig {</span><br><span class="line">@Bean</span><br></pre></td></tr></tbody></table></figure>

<h5 id="请求-说明"><a href="#请求-说明" class="headerlink" title="请求 说明"></a>请求 说明</h5><h5 id="请求方式-GET"><a href="#请求方式-GET" class="headerlink" title="请求方式 GET"></a>请求方式 GET</h5><h5 id="请求路径-x2F-employee-x2F-page"><a href="#请求路径-x2F-employee-x2F-page" class="headerlink" title="请求路径 /employee/page"></a>请求路径 /employee/page</h5><h5 id="请求参数-page-pageSize-name"><a href="#请求参数-page-pageSize-name" class="headerlink" title="请求参数 page , pageSize , name"></a>请求参数 page , pageSize , name</h5><h4 id="3-3-2-分页查询实现"><a href="#3-3-2-分页查询实现" class="headerlink" title="3.3.2 分页查询实现"></a>3.3.2 分页查询实现</h4><h5 id="在上面我们已经分析了，页面在进行分页查询时，-具体的请求信息如下"><a href="#在上面我们已经分析了，页面在进行分页查询时，-具体的请求信息如下" class="headerlink" title="在上面我们已经分析了，页面在进行分页查询时， 具体的请求信息如下:"></a>在上面我们已经分析了，页面在进行分页查询时， 具体的请求信息如下:</h5><p><img src="https://s2.loli.net/2022/08/17/CiYJg9nBPF5A8Qf.png" alt="image-20220815233948995"></p>
<h5 id="那么查询完毕后我们需要给前端返回什么样的结果呢"><a href="#那么查询完毕后我们需要给前端返回什么样的结果呢" class="headerlink" title="那么查询完毕后我们需要给前端返回什么样的结果呢?"></a>那么查询完毕后我们需要给前端返回什么样的结果呢?</h5><h5 id="在上述我们也分析了-查询返回的结果数据data中应该封装两项信息-分别为-records-封装分页"><a href="#在上述我们也分析了-查询返回的结果数据data中应该封装两项信息-分别为-records-封装分页" class="headerlink" title="在上述我们也分析了, 查询返回的结果数据data中应该封装两项信息, 分别为: records 封装分页"></a>在上述我们也分析了, 查询返回的结果数据data中应该封装两项信息, 分别为: records 封装分页</h5><h5 id="列表数据-total-中封装符合条件的总记录数。-那么这个时候-在定义controller方法的返回值"><a href="#列表数据-total-中封装符合条件的总记录数。-那么这个时候-在定义controller方法的返回值" class="headerlink" title="列表数据, total 中封装符合条件的总记录数。 那么这个时候, 在定义controller方法的返回值"></a>列表数据, total 中封装符合条件的总记录数。 那么这个时候, 在定义controller方法的返回值</h5><h5 id="类型R时-我们可以直接将-MybatisPlus-分页查询的结果-Page-直接封装返回-因为Page中的属"><a href="#类型R时-我们可以直接将-MybatisPlus-分页查询的结果-Page-直接封装返回-因为Page中的属" class="headerlink" title="类型R时, 我们可以直接将 MybatisPlus 分页查询的结果 Page 直接封装返回, 因为Page中的属"></a>类型R时, 我们可以直接将 MybatisPlus 分页查询的结果 Page 直接封装返回, 因为Page中的属</h5><h5 id="性如下"><a href="#性如下" class="headerlink" title="性如下:"></a>性如下:</h5><p><img src="https://s2.loli.net/2022/08/17/rVh7n3QlO9uNRD4.png" alt="image-20220815234002918"></p>
<h5 id="那么接下来就依据于这些已知的需求和条件完成分页查询的代码实现。-具体的逻辑如下"><a href="#那么接下来就依据于这些已知的需求和条件完成分页查询的代码实现。-具体的逻辑如下" class="headerlink" title="那么接下来就依据于这些已知的需求和条件完成分页查询的代码实现。 具体的逻辑如下:"></a>那么接下来就依据于这些已知的需求和条件完成分页查询的代码实现。 具体的逻辑如下:</h5><h5 id="A-构造分页条件"><a href="#A-构造分页条件" class="headerlink" title="A. 构造分页条件"></a>A. 构造分页条件</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public MybatisPlusInterceptor mybatisPlusInterceptor(){</span><br><span class="line">MybatisPlusInterceptor mybatisPlusInterceptor = new</span><br><span class="line">MybatisPlusInterceptor();</span><br><span class="line">mybatisPlusInterceptor.addInnerInterceptor(new</span><br><span class="line">PaginationInnerInterceptor());</span><br><span class="line">return mybatisPlusInterceptor;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="B-构建搜索条件-name进行模糊匹配"><a href="#B-构建搜索条件-name进行模糊匹配" class="headerlink" title="B. 构建搜索条件 - name进行模糊匹配"></a>B. 构建搜索条件 - name进行模糊匹配</h5><h5 id="C-构建排序条件-更新时间倒序排序"><a href="#C-构建排序条件-更新时间倒序排序" class="headerlink" title="C. 构建排序条件 - 更新时间倒序排序"></a>C. 构建排序条件 - 更新时间倒序排序</h5><h5 id="D-执行查询"><a href="#D-执行查询" class="headerlink" title="D. 执行查询"></a>D. 执行查询</h5><h5 id="E-组装结果并返回"><a href="#E-组装结果并返回" class="headerlink" title="E. 组装结果并返回"></a>E. 组装结果并返回</h5><h5 id="具体的代码实现如下"><a href="#具体的代码实现如下" class="headerlink" title="具体的代码实现如下:"></a>具体的代码实现如下:</h5><h3 id="3-4-功能测试"><a href="#3-4-功能测试" class="headerlink" title="3.4 功能测试"></a>3.4 功能测试</h3><h6 id="x2F-3"><a href="#x2F-3" class="headerlink" title="/**"></a>/**</h6><h6 id="员工信息分页查询-1"><a href="#员工信息分页查询-1" class="headerlink" title="* 员工信息分页查询"></a>* 员工信息分页查询</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* @param page 当前查询页码</span><br><span class="line">* @param pageSize 每页展示记录数</span><br><span class="line">* @param name 员工姓名 - 可选参数</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@GetMapping("/page")</span><br><span class="line">public R&lt;Page&gt; page(int page,int pageSize,String name){</span><br><span class="line">log.info("page = {},pageSize = {},name = {}" ,page,pageSize,name);</span><br><span class="line">//构造分页构造器</span><br><span class="line">Page pageInfo = new Page(page,pageSize);</span><br><span class="line">//构造条件构造器</span><br><span class="line">LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper();</span><br><span class="line">//添加过滤条件</span><br><span class="line">queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);</span><br><span class="line">//添加排序条件</span><br><span class="line">queryWrapper.orderByDesc(Employee::getUpdateTime);</span><br><span class="line">//执行查询</span><br><span class="line">employeeService.page(pageInfo,queryWrapper);</span><br><span class="line">return R.success(pageInfo);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="代码编写完毕之后，我们需要将工程重启-完毕之后直接访问管理系统首页-默认就会打开员工管理"><a href="#代码编写完毕之后，我们需要将工程重启-完毕之后直接访问管理系统首页-默认就会打开员工管理" class="headerlink" title="代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 默认就会打开员工管理"></a>代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 默认就会打开员工管理</h5><h5 id="的列表页面-我们可以查看列表数据是否可以正常展示-也可以通过分页插件来测试分页功能-及员"><a href="#的列表页面-我们可以查看列表数据是否可以正常展示-也可以通过分页插件来测试分页功能-及员" class="headerlink" title="的列表页面, 我们可以查看列表数据是否可以正常展示, 也可以通过分页插件来测试分页功能, 及员"></a>的列表页面, 我们可以查看列表数据是否可以正常展示, 也可以通过分页插件来测试分页功能, 及员</h5><h5 id="工姓名的模糊查询功能。"><a href="#工姓名的模糊查询功能。" class="headerlink" title="工姓名的模糊查询功能。"></a>工姓名的模糊查询功能。</h5><h5 id="在进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节。-并借助于debug的形"><a href="#在进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节。-并借助于debug的形" class="headerlink" title="在进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节。 并借助于debug的形"></a>在进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节。 并借助于debug的形</h5><h5 id="式，-根据服务端参数接收及逻辑执行情况。"><a href="#式，-根据服务端参数接收及逻辑执行情况。" class="headerlink" title="式， 根据服务端参数接收及逻辑执行情况。"></a>式， 根据服务端参数接收及逻辑执行情况。</h5><p><img src="C:%5CUsers%5C13772%5CDesktop%5Cimg%5Cimage-20220815234032416.png" alt="image-20220815234032416"></p>
<h5 id="测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（-1-或者-0-），但是页面上"><a href="#测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（-1-或者-0-），但是页面上" class="headerlink" title="测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（ 1 或者 0 ），但是页面上"></a>测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（ 1 或者 0 ），但是页面上</h5><h5 id="显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理。"><a href="#显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理。" class="headerlink" title="显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理。"></a>显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理。</h5><p><img src="C:%5CUsers%5C13772%5CDesktop%5Cimg%5Cimage-20220815234056527.png" alt="image-20220815234056527"></p>
<h2 id="4-启用-x2F-禁用员工账号"><a href="#4-启用-x2F-禁用员工账号" class="headerlink" title="4. 启用/禁用员工账号"></a>4. 启用/禁用员工账号</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><h5 id="在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启"><a href="#在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启" class="headerlink" title="在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启"></a>在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启</h5><h5 id="用后的员工可以正常登录。如果某个员工账号状态为正常，则按钮显示为-“禁用”，如果员工账号状态"><a href="#用后的员工可以正常登录。如果某个员工账号状态为正常，则按钮显示为-“禁用”，如果员工账号状态" class="headerlink" title="用后的员工可以正常登录。如果某个员工账号状态为正常，则按钮显示为 “禁用”，如果员工账号状态"></a>用后的员工可以正常登录。如果某个员工账号状态为正常，则按钮显示为 “禁用”，如果员工账号状态</h5><h5 id="为已禁用，则按钮显示为”启用”。"><a href="#为已禁用，则按钮显示为”启用”。" class="headerlink" title="为已禁用，则按钮显示为”启用”。"></a>为已禁用，则按钮显示为”启用”。</h5><h5 id="需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录"><a href="#需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录" class="headerlink" title="需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录"></a>需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录</h5><h5 id="系统后启用、禁用按钮不显示。"><a href="#系统后启用、禁用按钮不显示。" class="headerlink" title="系统后启用、禁用按钮不显示。"></a>系统后启用、禁用按钮不显示。</h5><h5 id="A-admin-管理员登录"><a href="#A-admin-管理员登录" class="headerlink" title="A. admin 管理员登录"></a>A. admin 管理员登录</h5><p><img src="https://s2.loli.net/2022/08/17/6JZSnT9AHdgsNOy.png" alt="image-20220815234111929"></p>
<h5 id="B-普通用户登录"><a href="#B-普通用户登录" class="headerlink" title="B. 普通用户登录"></a>B. 普通用户登录</h5><p><img src="https://s2.loli.net/2022/08/17/SBKp8aHbWicVLnw.png" alt="image-20220815234128776"></p>
<h3 id="4-2-程序执行流程"><a href="#4-2-程序执行流程" class="headerlink" title="4.2 程序执行流程"></a>4.2 程序执行流程</h3><h4 id="4-2-1-页面按钮动态展示"><a href="#4-2-1-页面按钮动态展示" class="headerlink" title="4.2.1 页面按钮动态展示"></a>4.2.1 页面按钮动态展示</h4><h5 id="在上述的需求中-我们提到需要实现的效果是-只有管理员（admin用户）可以对其他普通用户进行"><a href="#在上述的需求中-我们提到需要实现的效果是-只有管理员（admin用户）可以对其他普通用户进行" class="headerlink" title="在上述的需求中,我们提到需要实现的效果是 : 只有管理员（admin用户）可以对其他普通用户进行"></a>在上述的需求中,我们提到需要实现的效果是 : 只有管理员（admin用户）可以对其他普通用户进行</h5><h5 id="启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示-页面中是怎么做到只有管理员"><a href="#启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示-页面中是怎么做到只有管理员" class="headerlink" title="启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示 , 页面中是怎么做到只有管理员"></a>启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示 , 页面中是怎么做到只有管理员</h5><h5 id="admin能够看到启用、禁用按钮的？"><a href="#admin能够看到启用、禁用按钮的？" class="headerlink" title="admin能够看到启用、禁用按钮的？"></a>admin能够看到启用、禁用按钮的？</h5><h5 id="1-在列表页面-list-html-加载时-触发钩子函数created-在钩子函数中-会从"><a href="#1-在列表页面-list-html-加载时-触发钩子函数created-在钩子函数中-会从" class="headerlink" title="1). 在列表页面(list.html)加载时, 触发钩子函数created, 在钩子函数中, 会从"></a>1). 在列表页面(list.html)加载时, 触发钩子函数created, 在钩子函数中, 会从</h5><h5 id="localStorage中获取到用户登录信息-然后获取到用户名"><a href="#localStorage中获取到用户登录信息-然后获取到用户名" class="headerlink" title="localStorage中获取到用户登录信息, 然后获取到用户名"></a>localStorage中获取到用户登录信息, 然后获取到用户名</h5><p><img src="https://s2.loli.net/2022/08/17/uElWDtqYfvXVOm3.png" alt="image-20220815234226735"></p>
<h5 id="2-在页面中-通过Vue指令v-if进行判断-如果登录用户为admin将展示-启用-x2F-禁用-按钮-否则"><a href="#2-在页面中-通过Vue指令v-if进行判断-如果登录用户为admin将展示-启用-x2F-禁用-按钮-否则" class="headerlink" title="2). 在页面中, 通过Vue指令v-if进行判断,如果登录用户为admin将展示 启用/禁用 按钮, 否则"></a>2). 在页面中, 通过Vue指令v-if进行判断,如果登录用户为admin将展示 启用/禁用 按钮, 否则</h5><h5 id="不展示"><a href="#不展示" class="headerlink" title="不展示"></a>不展示</h5><p><img src="https://s2.loli.net/2022/08/17/EO2J3LThpbkFHnv.png" alt="image-20220815234240648"></p>
<h4 id="4-2-2-执行流程分析"><a href="#4-2-2-执行流程分析" class="headerlink" title="4.2.2 执行流程分析"></a>4.2.2 执行流程分析</h4><h5 id="1-当管理员admin点击-“启用”-或-“禁用”-按钮时-调用方法statusHandle"><a href="#1-当管理员admin点击-“启用”-或-“禁用”-按钮时-调用方法statusHandle" class="headerlink" title="1). 当管理员admin点击 “启用” 或 “禁用” 按钮时, 调用方法statusHandle"></a>1). 当管理员admin点击 “启用” 或 “禁用” 按钮时, 调用方法statusHandle</h5><h5 id="scope-row-获取到的是这一行的数据信息"><a href="#scope-row-获取到的是这一行的数据信息" class="headerlink" title="scope.row : 获取到的是这一行的数据信息 ;"></a>scope.row : 获取到的是这一行的数据信息 ;</h5><p><img src="https://s2.loli.net/2022/08/17/G91eDxmJXVQRKYd.png" alt="image-20220815234305791"></p>
<h5 id="2-statusHandle方法中进行二次确认-然后发起ajax请求-传递id、status参数"><a href="#2-statusHandle方法中进行二次确认-然后发起ajax请求-传递id、status参数" class="headerlink" title="2). statusHandle方法中进行二次确认, 然后发起ajax请求, 传递id、status参数"></a>2). statusHandle方法中进行二次确认, 然后发起ajax请求, 传递id、status参数</h5><p><img src="https://s2.loli.net/2022/08/17/oSs8UhMKyR4zNnm.png" alt="image-20220815234325194"></p>
<h5 id="最终发起异步请求-请求服务端-请求信息如下："><a href="#最终发起异步请求-请求服务端-请求信息如下：" class="headerlink" title="最终发起异步请求, 请求服务端, 请求信息如下："></a>最终发起异步请求, 请求服务端, 请求信息如下：</h5><h5 id="请求-说明-1"><a href="#请求-说明-1" class="headerlink" title="请求 说明"></a>请求 说明</h5><h5 id="请求方式-PUT"><a href="#请求方式-PUT" class="headerlink" title="请求方式 PUT"></a>请求方式 PUT</h5><h5 id="请求路径-x2F-employee"><a href="#请求路径-x2F-employee" class="headerlink" title="请求路径 /employee"></a>请求路径 /employee</h5><h5 id="请求参数-“id”-xxx-”status”-xxx"><a href="#请求参数-“id”-xxx-”status”-xxx" class="headerlink" title="请求参数 {“id”:xxx,”status”:xxx}"></a>请求参数 {“id”:xxx,”status”:xxx}</h5><h5 id="…params-三点是ES6中出现的扩展运算符。作用是遍历当前使用的对象能够访问到的所"><a href="#…params-三点是ES6中出现的扩展运算符。作用是遍历当前使用的对象能够访问到的所" class="headerlink" title="{…params} : 三点是ES6中出现的扩展运算符。作用是遍历当前使用的对象能够访问到的所"></a>{…params} : 三点是ES6中出现的扩展运算符。作用是遍历当前使用的对象能够访问到的所</h5><h5 id="有属性，并将属性放入当前对象中。"><a href="#有属性，并将属性放入当前对象中。" class="headerlink" title="有属性，并将属性放入当前对象中。"></a>有属性，并将属性放入当前对象中。</h5><p><img src="https://s2.loli.net/2022/08/17/OoC9SQ1hXcjKPfY.png" alt="image-20220815234341542"></p>
<h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><h5 id="在开发代码之前，需要梳理一下整个程序的执行过程："><a href="#在开发代码之前，需要梳理一下整个程序的执行过程：" class="headerlink" title="在开发代码之前，需要梳理一下整个程序的执行过程："></a>在开发代码之前，需要梳理一下整个程序的执行过程：</h5><h5 id="1-页面发送ajax请求，将参数-id、status-提交到服务端"><a href="#1-页面发送ajax请求，将参数-id、status-提交到服务端" class="headerlink" title="1). 页面发送ajax请求，将参数(id、status)提交到服务端"></a>1). 页面发送ajax请求，将参数(id、status)提交到服务端</h5><h5 id="2-服务端Controller接收页面提交的数据并调用Service更新数据"><a href="#2-服务端Controller接收页面提交的数据并调用Service更新数据" class="headerlink" title="2). 服务端Controller接收页面提交的数据并调用Service更新数据"></a>2). 服务端Controller接收页面提交的数据并调用Service更新数据</h5><h5 id="3-Service调用Mapper操作数据库"><a href="#3-Service调用Mapper操作数据库" class="headerlink" title="3). Service调用Mapper操作数据库"></a>3). Service调用Mapper操作数据库</h5><h5 id="启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作。在"><a href="#启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作。在" class="headerlink" title="启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作。在"></a>启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作。在</h5><h5 id="Controller中创建update方法，此方法是一个通用的修改员工信息的方法。"><a href="#Controller中创建update方法，此方法是一个通用的修改员工信息的方法。" class="headerlink" title="Controller中创建update方法，此方法是一个通用的修改员工信息的方法。"></a>Controller中创建update方法，此方法是一个通用的修改员工信息的方法。</h5><h6 id="x2F-4"><a href="#x2F-4" class="headerlink" title="/**"></a>/**</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* 根据id修改员工信息</span><br><span class="line">* @param employee</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@PutMapping</span><br><span class="line">public R&lt;String&gt; update(HttpServletRequest request,@RequestBody Employee</span><br><span class="line">employee){</span><br><span class="line">log.info(employee.toString());</span><br><span class="line">Long empId = (Long)request.getSession().getAttribute("employee");</span><br><span class="line">employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">employee.setUpdateUser(empId);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-4-功能测试"><a href="#4-4-功能测试" class="headerlink" title="4.4 功能测试"></a>4.4 功能测试</h3><p><img src="https://s2.loli.net/2022/08/17/lKisW87UQ2b1ctI.png" alt="image-20220815234401305"></p>
<h5 id="代码编写完毕之后，我们需要将工程重启。-然后访问前端页面，-进行-“启用”-或-“禁用”-的测试。"><a href="#代码编写完毕之后，我们需要将工程重启。-然后访问前端页面，-进行-“启用”-或-“禁用”-的测试。" class="headerlink" title="代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 进行 “启用” 或 “禁用” 的测试。"></a>代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 进行 “启用” 或 “禁用” 的测试。</h5><h5 id="测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。但是从控制台输出的日"><a href="#测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。但是从控制台输出的日" class="headerlink" title="测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。但是从控制台输出的日"></a>测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。但是从控制台输出的日</h5><h5 id="志，-可以看出确实没有更新成功。"><a href="#志，-可以看出确实没有更新成功。" class="headerlink" title="志， 可以看出确实没有更新成功。"></a>志， 可以看出确实没有更新成功。</h5><h5 id="而在我们的数据库表结构中，-并不存在该ID，-数据库中-风清扬-对应的ID为"><a href="#而在我们的数据库表结构中，-并不存在该ID，-数据库中-风清扬-对应的ID为" class="headerlink" title="而在我们的数据库表结构中， 并不存在该ID， 数据库中 风清扬 对应的ID为"></a>而在我们的数据库表结构中， 并不存在该ID， 数据库中 风清扬 对应的ID为</h5><h5 id="1420038345634918401"><a href="#1420038345634918401" class="headerlink" title="1420038345634918401"></a>1420038345634918401</h5><p><img src="https://s2.loli.net/2022/08/17/jDQIOu5BqVbhgRz.png" alt="image-20220815234414142"></p>
<h3 id="4-5-代码修复"><a href="#4-5-代码修复" class="headerlink" title="4.5 代码修复"></a>4.5 代码修复</h3><h4 id="4-5-1-原因分析"><a href="#4-5-1-原因分析" class="headerlink" title="4.5.1 原因分析"></a>4.5.1 原因分析</h4><p><img src="https://s2.loli.net/2022/08/17/yhDfg9TXEYl7HZb.png" alt="image-20220815234436477">通过观察控制台输出的SQL发现页面传递过来的员工id的值和数据库中的id值不一致，这是怎么回事</p>
<h5 id="呢？"><a href="#呢？" class="headerlink" title="呢？"></a>呢？</h5><h5 id="在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一"><a href="#在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一" class="headerlink" title="在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一"></a>在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一</h5><h5 id="个Long类型的数据，而且是一个长度为-19-位的长整型数据，-该数据返回给前端是没有问题的。"><a href="#个Long类型的数据，而且是一个长度为-19-位的长整型数据，-该数据返回给前端是没有问题的。" class="headerlink" title="个Long类型的数据，而且是一个长度为 19 位的长整型数据， 该数据返回给前端是没有问题的。"></a>个Long类型的数据，而且是一个长度为 19 位的长整型数据， 该数据返回给前端是没有问题的。</h5><p><img src="https://s2.loli.net/2022/08/17/Gf8JBT2g4jzO6NR.png" alt="image-20220815234532569"></p>
<h5 id="那么具体的问题出现在哪儿呢？"><a href="#那么具体的问题出现在哪儿呢？" class="headerlink" title="那么具体的问题出现在哪儿呢？"></a>那么具体的问题出现在哪儿呢？</h5><h5 id="问题实际上，-就出现在前端JS中，-js在对长度较长的长整型数据进行处理时，-会损失精度，-从而"><a href="#问题实际上，-就出现在前端JS中，-js在对长度较长的长整型数据进行处理时，-会损失精度，-从而" class="headerlink" title="问题实际上， 就出现在前端JS中， js在对长度较长的长整型数据进行处理时， 会损失精度， 从而"></a>问题实际上， 就出现在前端JS中， js在对长度较长的长整型数据进行处理时， 会损失精度， 从而</h5><h5 id="导致提交的id和数据库中的id不一致。-这里，我们也可以做一个简单的测试，代码如下："><a href="#导致提交的id和数据库中的id不一致。-这里，我们也可以做一个简单的测试，代码如下：" class="headerlink" title="导致提交的id和数据库中的id不一致。 这里，我们也可以做一个简单的测试，代码如下："></a>导致提交的id和数据库中的id不一致。 这里，我们也可以做一个简单的测试，代码如下：</h5><h4 id="4-5-2-解决方案"><a href="#4-5-2-解决方案" class="headerlink" title="4.5.2 解决方案"></a>4.5.2 解决方案</h4><h5 id="要想解决这个问题，也很简单，我们只需要让js处理的ID数据类型为字符串类型即可-这样就不会损"><a href="#要想解决这个问题，也很简单，我们只需要让js处理的ID数据类型为字符串类型即可-这样就不会损" class="headerlink" title="要想解决这个问题，也很简单，我们只需要让js处理的ID数据类型为字符串类型即可, 这样就不会损"></a>要想解决这个问题，也很简单，我们只需要让js处理的ID数据类型为字符串类型即可, 这样就不会损</h5><h5 id="失精度了。同样，-大家也可以做一个测试："><a href="#失精度了。同样，-大家也可以做一个测试：" class="headerlink" title="失精度了。同样， 大家也可以做一个测试："></a>失精度了。同样， 大家也可以做一个测试：</h5><h5 id="那么在我们的业务中-我们只需要让分页查询返回的json格式数据库中-long类型的属性-不直接"><a href="#那么在我们的业务中-我们只需要让分页查询返回的json格式数据库中-long类型的属性-不直接" class="headerlink" title="那么在我们的业务中, 我们只需要让分页查询返回的json格式数据库中, long类型的属性, 不直接"></a>那么在我们的业务中, 我们只需要让分页查询返回的json格式数据库中, long类型的属性, 不直接</h5><h5 id="转换为数字类型-转换为字符串类型就可以解决这个问题了-最终返回的结果为"><a href="#转换为数字类型-转换为字符串类型就可以解决这个问题了-最终返回的结果为" class="headerlink" title="转换为数字类型, 转换为字符串类型就可以解决这个问题了 , 最终返回的结果为 :"></a>转换为数字类型, 转换为字符串类型就可以解决这个问题了 , 最终返回的结果为 :</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset="UTF-8"&gt;</span><br><span class="line">&lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert( 1420038345634918401 );</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset="UTF-8"&gt;</span><br><span class="line">&lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert("1420038345634918401");</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2022/08/17/F17KStGp6Wavrnw.png" alt="image-20220815234552741"></p>
<h4 id="4-5-3-代码修复"><a href="#4-5-3-代码修复" class="headerlink" title="4.5.3 代码修复"></a>4.5.3 代码修复</h4><h5 id="由于在SpringMVC中-将Controller方法返回值转换为json对象-是通过jackson来实现的-涉"><a href="#由于在SpringMVC中-将Controller方法返回值转换为json对象-是通过jackson来实现的-涉" class="headerlink" title="由于在SpringMVC中, 将Controller方法返回值转换为json对象, 是通过jackson来实现的, 涉"></a>由于在SpringMVC中, 将Controller方法返回值转换为json对象, 是通过jackson来实现的, 涉</h5><h5 id="及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter-所以我们要解"><a href="#及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter-所以我们要解" class="headerlink" title="及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter, 所以我们要解"></a>及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter, 所以我们要解</h5><h5 id="决这个问题-就需要对该消息转换器的功能进行拓展。"><a href="#决这个问题-就需要对该消息转换器的功能进行拓展。" class="headerlink" title="决这个问题, 就需要对该消息转换器的功能进行拓展。"></a>决这个问题, 就需要对该消息转换器的功能进行拓展。</h5><h5 id="具体实现步骤："><a href="#具体实现步骤：" class="headerlink" title="具体实现步骤："></a>具体实现步骤：</h5><h5 id="1-提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资"><a href="#1-提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资" class="headerlink" title="1). 提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资"></a>1). 提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资</h5><h5 id="料中已经提供，直接复制到项目中使用）"><a href="#料中已经提供，直接复制到项目中使用）" class="headerlink" title="料中已经提供，直接复制到项目中使用）"></a>料中已经提供，直接复制到项目中使用）</h5><h5 id="2-在WebMvcConfig配置类中扩展Spring-mvc的消息转换器，在此消息转换器中使用提供的对象"><a href="#2-在WebMvcConfig配置类中扩展Spring-mvc的消息转换器，在此消息转换器中使用提供的对象" class="headerlink" title="2). 在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象"></a>2). 在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象</h5><h5 id="转换器进行Java对象到json数据的转换"><a href="#转换器进行Java对象到json数据的转换" class="headerlink" title="转换器进行Java对象到json数据的转换"></a>转换器进行Java对象到json数据的转换</h5><h5 id="1-引入JacksonObjectMapper"><a href="#1-引入JacksonObjectMapper" class="headerlink" title="1). 引入JacksonObjectMapper"></a>1). 引入JacksonObjectMapper</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import com.fasterxml.jackson.databind.DeserializationFeature;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import com.fasterxml.jackson.databind.module.SimpleModule;</span><br><span class="line">import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;</span><br><span class="line">import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.LocalDateTime;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import java.time.LocalTime;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">import static</span><br><span class="line">com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;</span><br><span class="line">/**</span><br><span class="line">* 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span><br><span class="line">* 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span><br><span class="line">* 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span><br><span class="line">*/</span><br><span class="line">public class JacksonObjectMapper extends ObjectMapper {</span><br><span class="line">public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";</span><br><span class="line">public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";</span><br><span class="line">public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";</span><br><span class="line">public JacksonObjectMapper() {</span><br><span class="line">super();</span><br><span class="line">//收到未知属性时不报异常</span><br><span class="line">this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);</span><br><span class="line">//反序列化时，属性不存在的兼容处理</span><br><span class="line">this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_U</span><br><span class="line">NKNOWN_PROPERTIES);</span><br><span class="line">SimpleModule simpleModule = new SimpleModule()</span><br><span class="line">.addDeserializer(LocalDateTime.class, new</span><br><span class="line">LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">.addDeserializer(LocalDate.class, new</span><br><span class="line">LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">.addDeserializer(LocalTime.class, new</span><br><span class="line">LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))</span><br><span class="line">.addSerializer(BigInteger.class, ToStringSerializer.instance)</span><br><span class="line">.addSerializer(Long.class, ToStringSerializer.instance)</span><br><span class="line">.addSerializer(LocalDateTime.class, new</span><br><span class="line">LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br></pre></td></tr></tbody></table></figure>

<h5 id="该自定义的对象转换器-主要指定了-在进行json数据序列化及反序列化时-LocalDateTime、"><a href="#该自定义的对象转换器-主要指定了-在进行json数据序列化及反序列化时-LocalDateTime、" class="headerlink" title="该自定义的对象转换器, 主要指定了, 在进行json数据序列化及反序列化时, LocalDateTime、"></a>该自定义的对象转换器, 主要指定了, 在进行json数据序列化及反序列化时, LocalDateTime、</h5><h5 id="LocalDate、LocalTime的处理方式-以及BigInteger及Long类型数据，直接转换为字符串。"><a href="#LocalDate、LocalTime的处理方式-以及BigInteger及Long类型数据，直接转换为字符串。" class="headerlink" title="LocalDate、LocalTime的处理方式, 以及BigInteger及Long类型数据，直接转换为字符串。"></a>LocalDate、LocalTime的处理方式, 以及BigInteger及Long类型数据，直接转换为字符串。</h5><h5 id="2-在WebMvcConfig中重写方法extendMessageConverters"><a href="#2-在WebMvcConfig中重写方法extendMessageConverters" class="headerlink" title="2). 在WebMvcConfig中重写方法extendMessageConverters"></a>2). 在WebMvcConfig中重写方法extendMessageConverters</h5><h2 id="编-信息"><a href="#编-信息" class="headerlink" title="编 信息"></a>编 信息</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">.addSerializer(LocalDate.class, new</span><br><span class="line">LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">.addSerializer(LocalTime.class, new</span><br><span class="line">LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));</span><br><span class="line">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span><br><span class="line">this.registerModule(simpleModule);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="x2F-5"><a href="#x2F-5" class="headerlink" title="/**"></a>/**</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* 扩展mvc框架的消息转换器</span><br><span class="line">* @param converters</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span><br><span class="line">{</span><br><span class="line">log.info("扩展消息转换器...");</span><br><span class="line">//创建消息转换器对象</span><br><span class="line">MappingJackson2HttpMessageConverter messageConverter = new</span><br><span class="line">MappingJackson2HttpMessageConverter();</span><br><span class="line">//设置对象转换器，底层使用Jackson将Java对象转为json</span><br><span class="line">messageConverter.setObjectMapper(new JacksonObjectMapper());</span><br><span class="line">//将上面的消息转换器对象追加到mvc框架的转换器集合中</span><br><span class="line">converters.add( 0 ,messageConverter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-编辑员工信息"><a href="#5-编辑员工信息" class="headerlink" title="5. 编辑员工信息"></a>5. 编辑员工信息</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><h5 id="在员工管理列表页面点击-“编辑”-按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最"><a href="#在员工管理列表页面点击-“编辑”-按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最" class="headerlink" title="在员工管理列表页面点击 “编辑” 按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最"></a>在员工管理列表页面点击 “编辑” 按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最</h5><h5 id="后点击-“保存”-按钮完成编辑操作。"><a href="#后点击-“保存”-按钮完成编辑操作。" class="headerlink" title="后点击 “保存” 按钮完成编辑操作。"></a>后点击 “保存” 按钮完成编辑操作。</h5><p><img src="https://s2.loli.net/2022/08/17/wrhgbj1B7l2Cqfo.png" alt="image-20220815234614613"></p>
<h5 id="那么从上述的分析中，我们可以看出当前实现的编辑功能-我们需要实现两个方法"><a href="#那么从上述的分析中，我们可以看出当前实现的编辑功能-我们需要实现两个方法" class="headerlink" title="那么从上述的分析中，我们可以看出当前实现的编辑功能,我们需要实现两个方法:"></a>那么从上述的分析中，我们可以看出当前实现的编辑功能,我们需要实现两个方法:</h5><h5 id="A-根据ID查询-用于页面数据回显"><a href="#A-根据ID查询-用于页面数据回显" class="headerlink" title="A. 根据ID查询, 用于页面数据回显"></a>A. 根据ID查询, 用于页面数据回显</h5><h5 id="B-保存修改"><a href="#B-保存修改" class="headerlink" title="B. 保存修改"></a>B. 保存修改</h5><h3 id="5-2-程序执行流程"><a href="#5-2-程序执行流程" class="headerlink" title="5.2 程序执行流程"></a>5.2 程序执行流程</h3><p><img src="https://s2.loli.net/2022/08/17/B1seUWwA8LiMuDK.png" alt="image-20220815234626520"></p>
<h5 id="在开发代码之前需要梳理一下操作过程和对应的程序的执行流程："><a href="#在开发代码之前需要梳理一下操作过程和对应的程序的执行流程：" class="headerlink" title="在开发代码之前需要梳理一下操作过程和对应的程序的执行流程："></a>在开发代码之前需要梳理一下操作过程和对应的程序的执行流程：</h5><h5 id="1-点击编辑按钮时，页面跳转到add-html，并在url中携带参数-员工id"><a href="#1-点击编辑按钮时，页面跳转到add-html，并在url中携带参数-员工id" class="headerlink" title="1). 点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]"></a>1). 点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]</h5><h5 id="2-在add-html页面获取url中的参数-员工id"><a href="#2-在add-html页面获取url中的参数-员工id" class="headerlink" title="2). 在add.html页面获取url中的参数[员工id]"></a>2). 在add.html页面获取url中的参数[员工id]</h5><h5 id="3-发送ajax请求，请求服务端，同时提交员工id参数"><a href="#3-发送ajax请求，请求服务端，同时提交员工id参数" class="headerlink" title="3). 发送ajax请求，请求服务端，同时提交员工id参数"></a>3). 发送ajax请求，请求服务端，同时提交员工id参数</h5><h5 id="4-服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面"><a href="#4-服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面" class="headerlink" title="4). 服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面"></a>4). 服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面</h5><p><img src="https://s2.loli.net/2022/08/17/4BEsH5GPozImJFi.png" alt="image-20220815234644822"></p>
<h5 id="5-页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显"><a href="#5-页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显" class="headerlink" title="5). 页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显"></a>5). 页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显</h5><h5 id="6-点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端"><a href="#6-点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端" class="headerlink" title="6). 点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端"></a>6). 点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端</h5><h5 id="7-服务端接收员工信息，并进行处理，完成后给页面响应"><a href="#7-服务端接收员工信息，并进行处理，完成后给页面响应" class="headerlink" title="7). 服务端接收员工信息，并进行处理，完成后给页面响应"></a>7). 服务端接收员工信息，并进行处理，完成后给页面响应</h5><h5 id="8-页面接收到服务端响应信息后进行相应处理"><a href="#8-页面接收到服务端响应信息后进行相应处理" class="headerlink" title="8). 页面接收到服务端响应信息后进行相应处理"></a>8). 页面接收到服务端响应信息后进行相应处理</h5><p><img src="C:%5CUsers%5C13772%5CDesktop%5Cimg%5Cimage-20220815234708686.png" alt="image-20220815234708686"></p>
<h5 id="注意：add-html页面为公共页面，新增员工和编辑员工都是在此页面操作"><a href="#注意：add-html页面为公共页面，新增员工和编辑员工都是在此页面操作" class="headerlink" title="注意：add.html页面为公共页面，新增员工和编辑员工都是在此页面操作"></a>注意：add.html页面为公共页面，新增员工和编辑员工都是在此页面操作</h5><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><h4 id="5-3-1-根据ID查询"><a href="#5-3-1-根据ID查询" class="headerlink" title="5.3.1 根据ID查询"></a>5.3.1 根据ID查询</h4><h5 id="经过上述的分析-我们看到-在根据ID查询员工信息时-请求信息如下"><a href="#经过上述的分析-我们看到-在根据ID查询员工信息时-请求信息如下" class="headerlink" title="经过上述的分析,我们看到,在根据ID查询员工信息时,请求信息如下:"></a>经过上述的分析,我们看到,在根据ID查询员工信息时,请求信息如下:</h5><h5 id="请求-说明-2"><a href="#请求-说明-2" class="headerlink" title="请求 说明"></a>请求 说明</h5><h5 id="请求方式-GET-1"><a href="#请求方式-GET-1" class="headerlink" title="请求方式 GET"></a>请求方式 GET</h5><h5 id="请求路径-x2F-employee-x2F-id"><a href="#请求路径-x2F-employee-x2F-id" class="headerlink" title="请求路径 /employee/{id}"></a>请求路径 /employee/{id}</h5><h5 id="请求-说明-3"><a href="#请求-说明-3" class="headerlink" title="请求 说明"></a>请求 说明</h5><h5 id="请求方式-PUT-1"><a href="#请求方式-PUT-1" class="headerlink" title="请求方式 PUT"></a>请求方式 PUT</h5><h5 id="请求路径-x2F-employee-1"><a href="#请求路径-x2F-employee-1" class="headerlink" title="请求路径 /employee"></a>请求路径 /employee</h5><h5 id="请求参数-……-json格式数据"><a href="#请求参数-……-json格式数据" class="headerlink" title="请求参数 {…….} json格式数据"></a>请求参数 {…….} json格式数据</h5><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h5><h5 id="在EmployeeController中增加方法-根据ID查询员工信息。"><a href="#在EmployeeController中增加方法-根据ID查询员工信息。" class="headerlink" title="在EmployeeController中增加方法, 根据ID查询员工信息。"></a>在EmployeeController中增加方法, 根据ID查询员工信息。</h5><h4 id="5-3-2-修改员工"><a href="#5-3-2-修改员工" class="headerlink" title="5.3.2 修改员工"></a>5.3.2 修改员工</h4><h5 id="经过上述的分析-我们看到-在修改员工信息时-请求信息如下"><a href="#经过上述的分析-我们看到-在修改员工信息时-请求信息如下" class="headerlink" title="经过上述的分析,我们看到,在修改员工信息时,请求信息如下:"></a>经过上述的分析,我们看到,在修改员工信息时,请求信息如下:</h5><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现:"></a>代码实现:</h5><h6 id="x2F-6"><a href="#x2F-6" class="headerlink" title="/**"></a>/**</h6><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* 根据id查询员工信息</span><br><span class="line">* @param id</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@GetMapping("/{id}")</span><br><span class="line">public R&lt;Employee&gt; getById(@PathVariable Long id){</span><br><span class="line">log.info("根据id查询员工信息...");</span><br><span class="line">Employee employee = employeeService.getById(id);</span><br><span class="line">if(employee != null){</span><br><span class="line">return R.success(employee);</span><br><span class="line">}</span><br><span class="line">return R.error("没有查询到对应员工信息");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="在EmployeeController中增加方法-根据ID更新员工信息。"><a href="#在EmployeeController中增加方法-根据ID更新员工信息。" class="headerlink" title="在EmployeeController中增加方法, 根据ID更新员工信息。"></a>在EmployeeController中增加方法, 根据ID更新员工信息。</h5><h3 id="5-4-功能测试"><a href="#5-4-功能测试" class="headerlink" title="5.4 功能测试"></a>5.4 功能测试</h3><h5 id="代码编写完毕之后，我们需要将工程重启。-然后访问前端页面，-按照前面分析的操作流程进行测试，"><a href="#代码编写完毕之后，我们需要将工程重启。-然后访问前端页面，-按照前面分析的操作流程进行测试，" class="headerlink" title="代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 按照前面分析的操作流程进行测试，"></a>代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 按照前面分析的操作流程进行测试，</h5><h5 id="查看数据是否正常修改即可。"><a href="#查看数据是否正常修改即可。" class="headerlink" title="查看数据是否正常修改即可。"></a>查看数据是否正常修改即可。</h5><h6 id="x2F-7"><a href="#x2F-7" class="headerlink" title="/**"></a>/**</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">* 根据id修改员工信息</span><br><span class="line">* <span class="meta">@param</span> employee</span><br><span class="line">* <span class="meta">@return</span></span><br><span class="line">*/</span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(HttpServletRequest request,<span class="meta">@RequestBody</span> Employee</span></span><br><span class="line"><span class="params">employee)</span>{</span><br><span class="line">log.info(employee.toString());</span><br><span class="line"><span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long)request.getSession().getAttribute(<span class="string">"employee"</span>);</span><br><span class="line">employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">employee.setUpdateUser(empId);</span><br><span class="line">employeeService.updateById(employee);</span><br><span class="line"><span class="keyword">return</span> R.success(<span class="string">"员工信息修改成功"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之Map遍历</title>
    <url>/2022/08/16/Java%E5%9F%BA%E7%A1%80_Map%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<html><head></head><body><h1 id="Java之Map遍历"><a href="#Java之Map遍历" class="headerlink" title="Java之Map遍历"></a>Java之Map遍历</h1><h2 id="Map集合遍历方式一：键找值"><a href="#Map集合遍历方式一：键找值" class="headerlink" title="Map集合遍历方式一：键找值"></a>Map<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&amp;spm=1001.2101.3001.7020">集合</a>遍历方式一：键找值</h2><ul>
<li>先获取Map集合的全部键的Set集合 //Set key=map.keySet();</li>
<li>遍历键的Set集合，然后通过键提取对应值map.getValue()</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">        Set&lt;String&gt; keys=maps.keySet();</span><br><span class="line">        <span class="keyword">for</span>(String key1:keys){</span><br><span class="line">            <span class="type">int</span> valu1e=maps.get(key1);</span><br><span class="line">            System.out.println(key1+<span class="string">"====&gt;"</span>+valu1e);</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//        鸿星尔克====&gt;2</span></span><br><span class="line"><span class="comment">//        数据结构====&gt;2</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Map集合遍历方式二：键值对流程"><a href="#Map集合遍历方式二：键值对流程" class="headerlink" title="Map集合遍历方式二：键值对流程"></a>Map集合<a href="https://so.csdn.net/so/search?q=%E9%81%8D%E5%8E%86&amp;spm=1001.2101.3001.7020">遍历</a>方式二：键值对流程</h2><ul>
<li>先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了</li>
<li>遍历Set集合，然后提取键以及提取值<br><img src="https://s2.loli.net/2022/08/16/1berpfKN3Ek5d8o.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用foreach遍历map集合，发现Map集合的键值对元素直接是没有类型的，所以不可以直接foreach遍历集合</span></span><br><span class="line"><span class="comment">         * 可以通过条用Map的方法entrySet把Map集合S转换成Set集合形式</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.把Map集合转换成Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries=maps.entrySet();</span><br><span class="line">        <span class="comment">//2.for开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:entries){</span><br><span class="line">            String key=entry.getKey();</span><br><span class="line">            <span class="type">int</span> value=entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">"=====&gt;"</span>+value);</span><br><span class="line">        }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Map集合的遍历方式三：Lambda"><a href="#Map集合的遍历方式三：Lambda" class="headerlink" title="Map集合的遍历方式三：Lambda"></a>Map集合的遍历方式三：Lambda</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">//Map集合的遍历方式：Lambda</span></span><br><span class="line"><span class="comment">//        maps.forEach(new BiConsumer&lt;String, Integer&gt;() {</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String key, Integer value) {</span></span><br><span class="line"><span class="comment">//                System.out.println(key+"---&gt;"+value);</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//        });</span></span><br><span class="line">        maps.forEach((k,v)-&gt;{</span><br><span class="line">            System.out.println(k+<span class="string">"---&gt;"</span>+v);</span><br><span class="line">        });</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>重新安排行程_回溯11</title>
    <url>/2022/08/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF10/</url>
    <content><![CDATA[<html><head></head><body><h1 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h1><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/">力扣题目链接(opens new window)</a></p>
<p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p>
<p>提示：</p>
<ul>
<li>如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前</li>
<li>所有的机场都用三个大写字母表示（机场代码）。</li>
<li>假定所有机票至少存在一种合理的行程。</li>
<li>所有的机票必须都用一次 且 只能用一次。</li>
</ul>
<p>示例 1：</p>
<ul>
<li>输入：[[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]</li>
<li>输出：[“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：[[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]</li>
<li>输出：[“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]</li>
<li>解释：另一种有效的行程是 [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]。但是它自然排序更大更靠后。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目还是很难的，之前我们用回溯法解决了如下问题：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">组合问题 (opens new window)</a>，<a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html">分割问题 (opens new window)</a>，<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">子集问题 (opens new window)</a>，<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">排列问题 (opens new window)</a>。</p>
<p>直觉上来看 这道题和回溯法没有什么关系，更像是图论中的深度优先搜索。</p>
<p>实际上确实是深搜，但这是深搜中使用了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。</p>
<p>所以我倾向于说本题应该使用回溯法，那么我也用回溯法的思路来讲解本题，其实深搜一般都使用了回溯法的思路，在图论系列中我会再详细讲解深搜。</p>
<p><strong>这里就是先给大家拓展一下，原来回溯法还可以这么玩！</strong></p>
<p><strong>这道题目有几个难点：</strong></p>
<ol>
<li>一个行程中，如果航班处理不好容易变成一个圈，成为死循环</li>
<li>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</li>
<li>使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？</li>
<li>搜索的过程中，如何遍历一个机场所对应的所有机场。</li>
</ol>
<p>针对以上问题我来逐一解答！</p>
<h2 id="如何理解死循环"><a href="#如何理解死循环" class="headerlink" title="#如何理解死循环"></a><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%AD%BB%E5%BE%AA%E7%8E%AF">#</a>如何理解死循环</h2><p>对于死循环，我来举一个有重复机场的例子：</p>
<p><img src="https://img-blog.csdnimg.cn/20201115180537865.png" alt="332.重新安排行程"></p>
<p>为什么要举这个例子呢，就是告诉大家，出发机场和到达机场也会重复的，<strong>如果在解题的过程中没有对集合元素处理好，就会死循环。</strong></p>
<h2 id="该记录映射关系"><a href="#该记录映射关系" class="headerlink" title="#该记录映射关系"></a><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E8%AF%A5%E8%AE%B0%E5%BD%95%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB">#</a>该记录映射关系</h2><p>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</p>
<p>一个机场映射多个机场，机场之间要靠字母序排列，一个机场映射多个机场，可以使用std::unordered_map，如果让多个机场之间再有顺序的话，就是用std::map 或者std::multimap 或者 std::multiset。</p>
<p>如果对map 和 set 的实现机制不太了解，也不清楚为什么 map、multimap就是有序的同学，可以看这篇文章<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！ (opens new window)</a>。</p>
<p>这样存放映射关系可以定义为 <code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code> 或者 <code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>。</p>
<p>含义如下：</p>
<p>unordered_map&lt;string, multiset&gt; targets：unordered_map&lt;出发机场, 到达机场的集合&gt; targets</p>
<p>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets：unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</p>
<p>这两个结构，我选择了后者，因为如果使用<code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code> 遍历multiset的时候，不能删除元素，一旦删除元素，迭代器就失效了。</p>
<p><strong>再说一下为什么一定要增删元素呢，正如开篇我给出的图中所示，出发机场和到达机场是会重复的，搜索的过程没及时删除目的机场就会死循环。</strong></p>
<p>所以搜索的过程中就是要不断的删multiset里的元素，那么推荐使用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>。</p>
<p>在遍历 <code>unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</code>的过程中，<strong>可以使用”航班次数”这个字段的数字做相应的增减，来标记到达机场是否使用过了。</strong></p>
<p>如果“航班次数”大于零，说明目的地还可以飞，如果如果“航班次数”等于零说明目的地不能飞了，而不用对集合做删除元素或者增加元素的操作。</p>
<p><strong>相当于说我不删，我就做一个标记！</strong></p>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="#回溯法"></a><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%9B%9E%E6%BA%AF%E6%B3%95">#</a>回溯法</h2><p>这道题目我使用回溯法，那么下面按照我总结的回溯模板来：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">void backtracking(参数) {</span><br><span class="line">    if (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>本题以输入：[[“JFK”, “KUL”], [“JFK”, “NRT”], [“NRT”, “JFK”]为例，抽象为树形结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2020111518065555.png" alt="332.重新安排行程1"></p>
<p>开始回溯三部曲讲解：</p>
<ul>
<li>递归函数参数</li>
</ul>
<p>在讲解映射关系的时候，已经讲过了，使用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;</code> 来记录航班的映射关系，我定义为全局变量。</p>
<p>当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度。</p>
<p>参数里还需要ticketNum，表示有多少个航班（终止条件会用上）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span></span><br><span class="line">unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>{</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意函数返回值我用的是bool！</strong></p>
<p>我们之前讲解回溯算法的时候，一般函数返回值都是void，这次为什么是bool呢？</p>
<p>因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2020111518065555.png" alt="332.重新安排行程1"></p>
<p>所以找到了这个叶子节点了直接返回，这个递归函数的返回值问题我们在讲解二叉树的系列的时候，在这篇<a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>详细介绍过。</p>
<p>当然本题的targets和result都需要初始化，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> vector&lt;string&gt;&amp; vec : tickets) {</span><br><span class="line">    targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]]++; <span class="comment">// 记录映射关系</span></span><br><span class="line">}</span><br><span class="line">result.<span class="built_in">push_back</span>(<span class="string">"JFK"</span>); <span class="comment">// 起始机场</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p>拿题目中的示例为例，输入: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]] ，这是有4个航班，那么只要找出一种行程，行程里的机场个数是5就可以了。</p>
<p>所以终止条件是：我们回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>已经看习惯回溯法代码的同学，到叶子节点了习惯性的想要收集结果，但发现并不需要，本题的result相当于 <a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">回溯算法：求组合总和！ (opens new window)</a>中的path，也就是本题的result就是记录路径的（就一条），在如下单层搜索的逻辑中result就添加元素了。</p>
<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>回溯的过程中，如何遍历一个机场所对应的所有机场呢？</p>
<p><strong>可以说本题既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效</strong>。</p>
<p>所以我选择了<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code> 来做机场之间的映射。</p>
<p>遍历过程如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) {</span><br><span class="line">    <span class="keyword">if</span> (target.second &gt; <span class="number">0</span> ) { <span class="comment">// 记录到达机场是否飞过了</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">        target.second--;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        result.<span class="built_in">pop_back</span>();</span><br><span class="line">        target.second++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题其实可以算是一道hard的题目了，关于本题的难点我在文中已经列出了。</p>
<p><strong>如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上</strong>。</p>
<p>本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，<strong>算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归</strong>。</p>
<p>如果最终代码，发现照着回溯法模板画的话好像也能画出来，但难就难如何知道可以使用回溯，以及如果套进去，所以我再写了这么长的一篇来详细讲解。</p>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;String,Map&lt;String,Integer&gt;&gt; map;</span><br><span class="line">    Deque&lt;String&gt; res;</span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> {</span><br><span class="line">		map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Map&lt;String,Integer&gt;&gt;();</span><br><span class="line">        res = LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; t:tickets) {</span><br><span class="line">            Map&lt;String,Integer&gt; tmp;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(t.get(<span class="number">0</span>))) {</span><br><span class="line">                tmp = map.get(t.get(<span class="number">0</span>));</span><br><span class="line">                tmp.put(t.get(<span class="number">1</span>), tmp.getOrDefault(t.get(<span class="number">1</span>),<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                tmp = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">                tmp.put(t.get(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            map.put(t.get(<span class="number">0</span>),tmp);</span><br><span class="line">        }</span><br><span class="line">        res.push(<span class="string">"JFK"</span>);</span><br><span class="line">        backtracking(tickets.size());</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> ticketsNum)</span> {</span><br><span class="line">        <span class="keyword">if</span>(res.size() == ticketsNum + <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> res.getLast();</span><br><span class="line">       	<span class="keyword">if</span>(map.containsKey(last)) {</span><br><span class="line">            <span class="keyword">for</span>(Map,Entry&lt;String,Integer&gt; target:map.get(last).entrySet()) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> target.getValue();</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>) {</span><br><span class="line">                    res.add(target.getKey());</span><br><span class="line">                    target.setValue(count -<span class="number">1</span>); <span class="comment">// 处处都有回溯</span></span><br><span class="line">                    <span class="keyword">if</span>(backtracking(ticketsNum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    res.removeLast();</span><br><span class="line">                    target.setValue(count);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>N皇后_回溯12</title>
    <url>/2022/08/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E5%9B%9E%E6%BA%AF11/</url>
    <content><![CDATA[<html><head></head><body><h1 id="第51题-N皇后"><a href="#第51题-N皇后" class="headerlink" title="第51题. N皇后"></a>第51题. N皇后</h1><p><a href="https://leetcode.cn/problems/n-queens/">力扣题目链接(opens new window)</a></p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例 1：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211020232201.png" alt="img"></p>
<ul>
<li>输入：n = 4</li>
<li>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</li>
<li>解释：如上图所示，4 皇后问题存在两个不同的解法。</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：n = 1</li>
<li>输出：[[“Q”]]</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>**如果对回溯算法基础还不了解的话，我还特意录制了一期视频：<a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇） (opens new window)</a>**可以结合题解和视频一起看，希望对大家理解回溯算法有所帮助。</p>
<p>都知道n皇后问题是回溯算法解决的经典问题，但是用回溯解决多了组合、切割、子集、排列问题之后，遇到这种二维矩阵还会有点不知所措。</p>
<p>首先来看一下皇后们的约束条件：</p>
<ol>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线</li>
</ol>
<p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p>
<p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后"></p>
<p>从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p>
<p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p>
<h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="#回溯三部曲"></a><a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2">#</a>回溯三部曲</h3><p>按照我总结的如下回溯模板，我们来依次分析：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">void backtracking(参数) {</span><br><span class="line">    if (终止条件) {</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归函数参数</li>
</ul>
<p>我依然是定义全局变量二维数组result来记录最终结果。</p>
<p>参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span> </span>{</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p>在如下树形结构中： <img src="https://img-blog.csdnimg.cn/20210130182532303.jpg" alt="51.N皇后"></p>
<p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (row == n) {</span><br><span class="line">    result.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>单层搜索的逻辑</li>
</ul>
<p>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</p>
<p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col, chessboard, n)) { <span class="comment">// 验证合法就可以放</span></span><br><span class="line">        chessboard[row][col] = <span class="string">'Q'</span>; <span class="comment">// 放置皇后</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, row + <span class="number">1</span>, chessboard);</span><br><span class="line">        chessboard[row][col] = <span class="string">'.'</span>; <span class="comment">// 回溯，撤销皇后</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>验证棋盘是否合法</li>
</ul>
<p>按照如下标准去重：</p>
<ol>
<li>不能同行</li>
<li>不能同列</li>
<li>不能同斜线 （45度和135度角）</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) { <span class="comment">// 这是一个剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][col] == <span class="string">'Q'</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查 45度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) {</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 检查 135度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) {</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p>
<p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : chessboard) {</span><br><span class="line">            Arrays.fill(c, <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line">        backtracking(n,<span class="number">0</span>,chessborad); <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">Array2List</span><span class="params">(<span class="type">char</span>[][] chessboard)</span> {</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : chessboard) {</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> row,<span class="type">char</span>[][] chessboard)</span> {</span><br><span class="line">        <span class="comment">// 终止条件为 row = n的时候 因为n-1的位置还是需要放’Q‘皇后</span></span><br><span class="line">        <span class="keyword">if</span>(n == row) {</span><br><span class="line">            res.add(Array2List(chessborad));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从列开始 for循环 每次都从0开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col&lt;n;col++) {</span><br><span class="line">            <span class="comment">// 检验合格性 1.不能有重复行列 2.不能在同一条斜线上面(45度,以及135度)</span></span><br><span class="line">            <span class="keyword">if</span>(isValid(row,col,chessboard)) {</span><br><span class="line">                <span class="comment">// 合格的话此位置就加入'Q'皇后 </span></span><br><span class="line">                chessboard[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                backtracking(n,row + <span class="number">1</span>,chessboard);</span><br><span class="line">                <span class="comment">// 调回'.'</span></span><br><span class="line">                chessboard[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span>[][] chessboard)</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++) {</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col,<span class="type">int</span> j=row;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;j--,i--) {</span><br><span class="line">            <span class="keyword">if</span>(chessboard[j][i] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col,<span class="type">int</span> j=row;i&lt;n&amp;&amp;j&gt;=<span class="number">0</span>;i++,j--) {</span><br><span class="line">            <span class="keyword">if</span>(chessboard[j][i] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据可视化大屏</title>
    <url>/2022/08/16/python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F_%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<html><head></head><body><h1 id="数据大屏可视化"><a href="#数据大屏可视化" class="headerlink" title="数据大屏可视化"></a>数据大屏可视化</h1><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>便利性工具, 结构简单, 直接传数据就可以实现数据大屏</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple flask</span><br></pre></td></tr></tbody></table></figure>

<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cd big_screen;</span><br><span class="line">python app.py;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>大数据可视化展板通用模板 <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a></li>
<li>4600 万企业数据大屏可视化 <a href="http://127.0.0.1:5000/corp">http://127.0.0.1:5000/corp</a></li>
<li>(2020-09) 厦门 10 万招聘数据大屏可视化 <a href="http://127.0.0.1:5000/job">http://127.0.0.1:5000/job</a></li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="https://s2.loli.net/2022/08/17/dxZPswcq9oRnUSH.png" alt="image-20220816234523123.png"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li>1、编辑 data.py 中的 SourceData 类（或者新增类，新增的话需要编辑 app.py 增加路由，请参考 CorpData/JobData）</li>
<li>2、从任何地方读取你的数据，按照 SourceDataDemo 的数据格式，填充到 SourceData 类</li>
<li>3、运行 python app.py 查看数据变更后的效果</li>
</ul>
<h1 id="源码链接地址"><a href="#源码链接地址" class="headerlink" title="源码链接地址"></a>源码链接地址</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/1qiqiqi/dataVisual</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>理论基础_贪心01</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8301/</url>
    <content><![CDATA[<html><head></head><body><h1 id="关于贪心算法，你该了解这些！"><a href="#关于贪心算法，你该了解这些！" class="headerlink" title="关于贪心算法，你该了解这些！"></a>关于贪心算法，你该了解这些！</h1><p>题目分类大纲如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png" alt="贪心算法大纲"></p>
<h2 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="#什么是贪心"></a><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%AA%E5%BF%83">#</a>什么是贪心</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p>
<p>这么说有点抽象，来举一个例子：</p>
<p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p>
<p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p>
<p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p>
<p>再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。</p>
<h2 id="贪心的套路（什么时候用贪心）"><a href="#贪心的套路（什么时候用贪心）" class="headerlink" title="#贪心的套路（什么时候用贪心）"></a><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E8%B4%AA%E5%BF%83%E7%9A%84%E5%A5%97%E8%B7%AF-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E8%B4%AA%E5%BF%83">#</a>贪心的套路（什么时候用贪心）</h2><p>很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。</p>
<p><strong>说实话贪心算法并没有固定的套路</strong>。</p>
<p>所以唯一的难点就是如何通过局部最优，推出整体最优。</p>
<p>那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？</p>
<p><strong>不好意思，也没有！</strong> 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p>
<p>有同学问了如何验证可不可以用贪心算法呢？</p>
<p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p>
<p>可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。</p>
<p>一般数学证明有如下两种方法：</p>
<ul>
<li>数学归纳法</li>
<li>反证法</li>
</ul>
<p>看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。</p>
<p><strong>面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了</strong>。</p>
<p>举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。</p>
<p>虽然这个例子很极端，但可以表达这么个意思：<strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p>
<p><strong>例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！</strong></p>
<p>所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，<strong>因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！</strong></p>
<p><strong>那么刷题的时候什么时候真的需要数学推导呢？</strong></p>
<p>例如这道题目：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">链表：环找到了，那入口呢？ (opens new window)</a>，这道题不用数学推导一下，就找不出环的起始位置，想试一下就不知道怎么试，这种题目确实需要数学简单推导一下。</p>
<h2 id="贪心一般解题步骤"><a href="#贪心一般解题步骤" class="headerlink" title="#贪心一般解题步骤"></a><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E8%B4%AA%E5%BF%83%E4%B8%80%E8%88%AC%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4">#</a>贪心一般解题步骤</h2><p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<p>其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>本篇给出了什么是贪心以及大家关心的贪心算法固定套路。</p>
<p><strong>不好意思了，贪心没有套路，说白了就是常识性推导加上举反例</strong>。</p>
<p>最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。</p>
<p>本篇没有配图，其实可以找一些动漫周边或者搞笑的图配一配（符合大多数公众号文章的作风），但这不是我的风格，所以本篇文字描述足以！</p>
<h1 id="重点"><a href="#重点" class="headerlink" title="重点:"></a>重点:</h1><p>常识性推导加上举反例.</p>
</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>分发饼干_贪心02</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8302/</url>
    <content><![CDATA[<html><head></head><body><h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h1><p><a href="https://leetcode.cn/problems/assign-cookies/">力扣题目链接(opens new window)</a></p>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>示例 1:</p>
<ul>
<li>输入: g = [1,2,3], s = [1,1]</li>
<li>输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: g = [1,2], s = [1,2,3]</li>
<li>输出: 2</li>
<li>解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= g.length &lt;= 3 * 10^4</li>
<li>0 &lt;= s.length &lt;= 3 * 10^4</li>
<li>1 &lt;= g[i], s[j] &lt;= 2^31 - 1</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p>
<p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p>
<p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p>
<p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123161809624.png" alt="455.分发饼干"></p>
<p>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g,<span class="type">int</span>[] s)</span> {</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=g.length - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i++) {</span><br><span class="line">        <span class="keyword">if</span>(s[index] &gt;= g[i]) index--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s.length - <span class="number">1</span> - index;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>摆动序列_贪心03</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8303/</url>
    <content><![CDATA[<html><head></head><body><h1 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h1><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">力扣题目链接(opens new window)</a></p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>示例 1:</p>
<ul>
<li>输入: [1,7,4,9,2,5]</li>
<li>输出: 6</li>
<li>解释: 整个序列均为摆动序列。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: [1,17,5,10,13,15,10,5,16,8]</li>
<li>输出: 7</li>
<li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: [1,2,3,4,5,6,7,8,9]</li>
<li>输出: 2</li>
</ul>
<h2 id="思路1（贪心解法）"><a href="#思路1（贪心解法）" class="headerlink" title="思路1（贪心解法）"></a>思路1（贪心解法）</h2><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>相信这么一说吓退不少同学，这要求最大摆动序列又可以修改数组，这得如何修改呢？</p>
<p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p>
<p>用示例二来举例，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124174327597.png" alt="376.摆动序列"></p>
<p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p>
<p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p>
<p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p>
<p>（为方便表述，以下说的峰值都是指局部峰值）</p>
<p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p>
<p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong>。</p>
<p>本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。</p>
<p>例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</p>
<p>所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124174357612.png" alt="376.摆动序列1"></p>
<p>针对以上情形，result初始为1（默认最右面有一个峰值），此时curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">	<span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">return</span> nums.length;</span><br><span class="line">	}</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">prediff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">curdiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length - <span class="number">1</span>;i++) {</span><br><span class="line">		curdiff = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">		<span class="keyword">if</span>(curdiff &gt; <span class="number">0</span> &amp;&amp; prediff &lt;=<span class="number">0</span> || curdiff &lt; <span class="number">0</span> &amp;&amp; prediff &gt;= <span class="number">0</span>) {</span><br><span class="line">			count++;</span><br><span class="line">           prediff = curdiff;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏_贪心04</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8304/</url>
    <content><![CDATA[<html><head></head><body><h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h1><p><a href="https://leetcode.cn/problems/jump-game/">力扣题目链接(opens new window)</a></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p>示例 1:</p>
<ul>
<li>输入: [2,3,1,1,4]</li>
<li>输出: true</li>
<li>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: [3,2,1,0,4]</li>
<li>输出: false</li>
<li>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？</p>
<p>其实跳几步无所谓，关键在于可跳的覆盖范围！</p>
<p>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p>
<p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p>
<p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p>
<p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p>
<p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p>
<p>局部最优推出全局最优，找不出反例，试试贪心！</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p>
<p>i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。</p>
<p>而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。</p>
<p>如果cover大于等于了终点下标，直接return true就可以了。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">	<span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;nums.length;i++) {</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + i &gt; cover) cover = nums[i] + i;</span><br><span class="line">        <span class="keyword">if</span>(cover &gt;= nums.length -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏||_贪心05</title>
    <url>/2022/08/18/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8305/</url>
    <content><![CDATA[<html><head></head><body><h1 id="45-跳跃游戏II"><a href="#45-跳跃游戏II" class="headerlink" title="45.跳跃游戏II"></a>45.跳跃游戏II</h1><p><a href="https://leetcode.cn/problems/jump-game-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例:</p>
<ul>
<li>输入: [2,3,1,1,4]</li>
<li>输出: 2</li>
<li>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</li>
</ul>
<p>说明: 假设你总是可以到达数组的最后一个位置。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>本题相对于<a href="https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html">55.跳跃游戏 (opens new window)</a>还是难了不少。</p>
<p>但思路是相似的，还是要看最大覆盖范围。</p>
<p>本题要计算最小步数，那么就要想清楚什么时候步数才一定要加一呢？</p>
<p>贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。</p>
<p>思路虽然是这样，但在写代码的时候还不能真的就能跳多远跳远，那样就不知道下一步最远能跳到哪里了。</p>
<p><strong>所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！</strong></p>
<p><strong>这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖</strong>。</p>
<p>如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201201232309103.png" alt="45.跳跃游戏II"></p>
<p><strong>图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）</strong></p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="#方法一"></a><a href="https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html#%E6%96%B9%E6%B3%95%E4%B8%80">#</a>方法一</h2><p>从图中可以看出来，就是移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。</p>
<p>这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p>
<ul>
<li>如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。</li>
<li>如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。</li>
</ul>
<h1 id="Java01代码如下："><a href="#Java01代码如下：" class="headerlink" title="Java01代码如下："></a>Java01代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">curCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">NextCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++) {</span><br><span class="line">        NextCover = Math.max(nums[i]+i,NextCover);</span><br><span class="line">        <span class="keyword">if</span>(NextCover &gt;= nums.length - <span class="number">1</span>) {</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(curCover == i) {</span><br><span class="line">            <span class="keyword">if</span>(curCover != nums.length -<span class="number">1</span>) {</span><br><span class="line">                count++;</span><br><span class="line">                curCover = NextCover;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>依然是贪心，思路和方法一差不多，代码可以简洁一些。</p>
<p><strong>针对于方法一的特殊情况，可以统一处理</strong>，即：移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。</p>
<p>想要达到这样的效果，只要让移动下标，最大只能移动到nums.size - 2的地方就可以了。</p>
<p>因为当移动下标指向nums.size - 2时：</p>
<ul>
<li>如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图： <img src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2"></li>
<li>如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。如图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201201232338693.png" alt="45.跳跃游戏II1"></p>
<h1 id="Java02代码如下："><a href="#Java02代码如下：" class="headerlink" title="Java02代码如下："></a>Java02代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">curCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">NextCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++) {</span><br><span class="line">        NextCover = Math.max(NextCover,nums[i] + i);</span><br><span class="line">        <span class="keyword">if</span>(curCover == i) {</span><br><span class="line">            count++;</span><br><span class="line">            curCover = NextCover;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>加油站_贪心06</title>
    <url>/2022/08/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8306/</url>
    <content><![CDATA[<html><head></head><body><h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h1><p><a href="https://leetcode.cn/problems/gas-station/">力扣题目链接(opens new window)</a></p>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明:</p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p>示例 1: 输入:</p>
<ul>
<li>gas = [1,2,3,4,5]</li>
<li>cost = [3,4,5,1,2]</li>
</ul>
<p>输出: 3 解释:</p>
<ul>
<li>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</li>
<li>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</li>
<li>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</li>
<li>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</li>
<li>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</li>
<li>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</li>
<li>因此，3 可为起始索引。</li>
</ul>
<p>示例 2: 输入:</p>
<ul>
<li>gas = [2,3,4]</li>
<li>cost = [3,4,3]</li>
<li>输出: -1</li>
<li>解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油。开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油。开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油。你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。</li>
</ul>
<h2 id="暴力方法"><a href="#暴力方法" class="headerlink" title="#暴力方法"></a><a href="https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html#%E6%9A%B4%E5%8A%9B%E6%96%B9%E6%B3%95">#</a>暴力方法</h2><p>暴力的方法很明显就是$O(n^2)$的，遍历每一个加油站为起点的情况，模拟一圈。</p>
<p>如果跑了一圈，中途没有断油，而且最后油量大于等于0，说明这个起点是ok的。</p>
<p>暴力的方法思路比较简单，但代码写起来也不是很容易，关键是要模拟跑一圈的过程。</p>
<p><strong>for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！</strong></p>
<p>C++代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cost.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> rest = gas[i] - cost[i]; <span class="comment">// 记录剩余油量</span></span><br><span class="line">            <span class="type">int</span> index = (i + <span class="number">1</span>) % cost.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (rest &gt; <span class="number">0</span> &amp;&amp; index != i) { <span class="comment">// 模拟以i为起点行驶一圈</span></span><br><span class="line">                rest += gas[index] - cost[index];</span><br><span class="line">                index = (index + <span class="number">1</span>) % cost.<span class="built_in">size</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果以i为起点跑一圈，剩余油量&gt;=0，返回该起始位置</span></span><br><span class="line">            <span class="keyword">if</span> (rest &gt;= <span class="number">0</span> &amp;&amp; index == i) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1</li>
</ul>
<h2 id="贪心算法（方法二）"><a href="#贪心算法（方法二）" class="headerlink" title="贪心算法（方法二）"></a>贪心算法（方法二）</h2><p>可以换一个思路，首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p>
<p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p>
<p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p>
<p>如图： <img src="https://img-blog.csdnimg.cn/20201213162821958.png" alt="134.加油站"></p>
<p>那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现更大的负数？</p>
<p>如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。</p>
<p>而且j之前出现了多少负数，j后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）。</p>
<p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p>
<p>局部最优可以推出全局最优，找不出反例，试试贪心！</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> {</span><br><span class="line">	<span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">TotalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;gas.length;i++) {</span><br><span class="line">		curSum += gas[i] - cost[i];</span><br><span class="line">		TotalSum += gas[i] - cost[i];</span><br><span class="line">		<span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) {</span><br><span class="line">			curSum = <span class="number">0</span>;</span><br><span class="line">			start = (i + <span class="number">1</span>)%gas.length;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(TotalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> start;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>分发糖果_贪心07</title>
    <url>/2022/08/19/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8307/</url>
    <content><![CDATA[<html><head></head><body><h1 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h1><p><a href="https://leetcode.cn/problems/candy/">力扣题目链接(opens new window)</a></p>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li>
</ul>
<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p>示例 1:</p>
<ul>
<li>输入: [1,0,2]</li>
<li>输出: 5</li>
<li>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: [1,2,2]</li>
<li>输出: 4</li>
<li>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p>
<p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p>
<p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p>
<p>局部最优可以推出全局最优。</p>
<p>如果ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个，所以贪心：candyVec[i] = candyVec[i - 1] + 1</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从前向后</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201117114916878.png" alt="135.分发糖果"></p>
<p>再确定左孩子大于右孩子的情况（从后向前遍历）</p>
<p>遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？</p>
<p>因为如果从前向后遍历，根据 ratings[i + 1] 来确定 ratings[i] 对应的糖果，那么每次都不能利用上前一次的比较结果了。</p>
<p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p>
<p>如果 ratings[i] &gt; ratings[i + 1]，此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。</p>
<p>那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<p>局部最优可以推出全局最优。</p>
<p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201117115658791.png" alt="135.分发糖果1"></p>
<p>所以该过程代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从后向前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) {</span><br><span class="line">        candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p>
<p>那么本题我采用了两次贪心的策略：</p>
<ul>
<li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li>
<li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li>
</ul>
<p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<h2 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> {</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">    Arrays.fill(res,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先从左往右边遍历 右边比左边大 就有改动</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;ratings.length;i++) {</span><br><span class="line">        <span class="keyword">if</span>(ratings[i] &gt; ratings[i-<span class="number">1</span>]) {</span><br><span class="line">            res[i] = res[i] + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从右向左遍历 如果左边大于右边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ratings.length - <span class="number">1</span>;j&gt;<span class="number">0</span>;j--) {</span><br><span class="line">        <span class="keyword">if</span>(ratings[j-<span class="number">1</span>] &gt; ratings[j]) {</span><br><span class="line">            <span class="keyword">if</span>(res[j-<span class="number">1</span>] &gt; res[j] + <span class="number">1</span>) {</span><br><span class="line">                </span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                res[j-<span class="number">1</span>] = res[j] + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(res).sum();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>用最少数量的箭引爆气球_贪心08</title>
    <url>/2022/08/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8308/</url>
    <content><![CDATA[<html><head></head><body><h1 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h1><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接(opens new window)</a></p>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>示例 1：</p>
<ul>
<li>输入：points = [[10,16],[2,8],[1,6],[7,12]]</li>
<li>输出：2</li>
<li>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：points = [[1,2],[3,4],[5,6],[7,8]]</li>
<li>输出：4</li>
</ul>
<p>示例 3：</p>
<ul>
<li>输入：points = [[1,2],[2,3],[3,4],[4,5]]</li>
<li>输出：2</li>
</ul>
<p>示例 4：</p>
<ul>
<li>输入：points = [[1,2]]</li>
<li>输出：1</li>
</ul>
<p>示例 5：</p>
<ul>
<li>输入：points = [[2,3],[2,3]]</li>
<li>输出：1</li>
</ul>
<p>提示：</p>
<ul>
<li>0 &lt;= points.length &lt;= 10^4</li>
<li>points[i].length == 2</li>
<li>-2^31 &lt;= xstart &lt; xend &lt;= 2^31 - 1</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>如何使用最少的弓箭呢？</p>
<p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p>
<p>尝试一下举反例，发现没有这种情况。</p>
<p>那么就试一试贪心吧！局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。</p>
<p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p>
<p>如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。</p>
<p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remote气球，只要记录一下箭的数量就可以了。</p>
<p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p>
<p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p>
<p>那么按照气球起始位置排序，还是按照气球终止位置排序呢？</p>
<p>其实都可以！只不过对应的遍历顺序不同，我就按照气球的起始位置排序了。</p>
<p>既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p>
<p>从前向后遍历遇到重叠的气球了怎么办？</p>
<p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p>
<p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）</p>
<p><img src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="452.用最少数量的箭引爆气球"></p>
<p>可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> {</span><br><span class="line">	Arrays.sort(points,(a,b) -&gt; {</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">    });</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMin</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;points.length;i++) {</span><br><span class="line">        <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; rightMin) {</span><br><span class="line">           	count++;</span><br><span class="line">            rightMin = points[i][<span class="number">1</span>];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            rightMin = Math.min(rightMin,points[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>合并区间_贪心10</title>
    <url>/2022/08/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8310/</url>
    <content><![CDATA[<html><head></head><body><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h1><p><a href="https://leetcode.cn/problems/merge-intervals/">力扣题目链接(opens new window)</a></p>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<ul>
<li>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</li>
<li>输出: [[1,6],[8,10],[15,18]]</li>
<li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: intervals = [[1,4],[4,5]]</li>
<li>输出: [[1,5]]</li>
<li>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</li>
<li>注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>大家应该都感觉到了，此题一定要排序，那么按照左边界排序，还是右边界排序呢？</p>
<p>都可以！</p>
<p>那么我按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。</p>
<p>局部最优可以推出全局最优，找不出反例，试试贪心。</p>
<p>那有同学问了，本来不就应该合并最大右边界么，这和贪心有啥关系？</p>
<p>有时候贪心就是常识！哈哈</p>
<p>按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt; intervals[i - 1][1]</code> 即intervals[i]左边界 &lt; intervals[i - 1]右边界，则一定有重复，因为intervals[i]的左边界一定是大于等于intervals[i - 1]的左边界。</p>
<p>即：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，那么一定有重复！</p>
<p>这么说有点抽象，看图：（<strong>注意图中区间都是按照左边界排序之后了</strong>）</p>
<p><img src="https://img-blog.csdnimg.cn/20201223200632791.png" alt="56.合并区间"></p>
<p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p>
<p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。</p>
<h1 id="Java代码如下："><a href="#Java代码如下：" class="headerlink" title="Java代码如下："></a>Java代码如下：</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    Arrays.sort(intervals,(a,b) -&gt; {</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">    })</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++) {</span><br><span class="line">        <span class="comment">// 不能合并时</span></span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; right) {</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {left,right});</span><br><span class="line">            left = intervals[i][<span class="number">0</span>];</span><br><span class="line">            right = intervals[i][<span class="number">1</span>];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            right = Math.max(right,intervals[i][<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="title class_">int</span>[] {left,right});</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>无重叠区间_贪心09</title>
    <url>/2022/08/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8309/</url>
    <content><![CDATA[<html><head></head><body><h1 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h1><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">力扣题目链接(opens new window)</a></p>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
<p>示例 1:</p>
<ul>
<li>输入: [ [1,2], [2,3], [3,4], [1,3] ]</li>
<li>输出: 1</li>
<li>解释: 移除 [1,3] 后，剩下的区间没有重叠。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: [ [1,2], [1,2], [1,2] ]</li>
<li>输出: 2</li>
<li>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: [ [1,2], [2,3] ]</li>
<li>输出: 0</li>
<li>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p><strong>相信很多同学看到这道题目都冥冥之中感觉要排序，但是究竟是按照右边界排序，还是按照左边界排序呢？</strong></p>
<p>这其实是一个难点！</p>
<p>按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的。</p>
<p>按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。</p>
<p>如果按照左边界排序，还从左向右遍历的话，其实也可以，逻辑会有所不同。</p>
<p>一些同学做这道题目可能真的去模拟去重复区间的行为，这是比较麻烦的，还要去删除区间。</p>
<p>题目只是要求移除区间的个数，没有必要去真实的模拟删除区间！</p>
<p><strong>我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p>
<p>此时问题就是要求非交叉区间的最大个数。</p>
<p>右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。</p>
<p>局部最优推出全局最优，试试贪心！</p>
<p>这里记录非交叉区间的个数还是有技巧的，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201221201553618.png" alt="435.无重叠区间"></p>
<p>区间，1，2，3，4，5，6都按照右边界排好序。</p>
<p>每次取非交叉区间的时候，都是可右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间1结束的位置。</p>
<p>接下来就是找大于区间1结束位置的区间，是从区间4开始。<strong>那有同学问了为什么不从区间5开始？别忘已经是按照右边界排序的了</strong>。</p>
<p>区间4结束之后，在找到区间6，所以一共记录非交叉区间的个数是三个。</p>
<p>总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题我认为难度级别可以算是hard级别的！</p>
<p>总结如下难点：</p>
<ul>
<li>难点一：一看题就有感觉需要排序，但究竟怎么排序，按左边界排还是右边界排。</li>
<li>难点二：排完序之后如何遍历，如果没有分析好遍历顺序，那么排序就没有意义了。</li>
<li>难点三：直接求重复的区间是复杂的，转而求最大非重复区间个数。</li>
<li>难点四：求最大非重复区间个数时，需要一个分割点来做标记。</li>
</ul>
<p><strong>这四个难点都不好想，但任何一个没想到位，这道题就解不了</strong>。</p>
<p>一些录友可能看网上的题解代码很简单，照葫芦画瓢稀里糊涂的就过了，但是其题解可能并没有把问题难点讲清楚，然后自己再没有钻研的话，那么一道贪心经典区间问题就这么浪费掉了。</p>
<p>贪心就是这样，代码有时候很简单（不是指代码短，而是逻辑简单），但想法是真的难！</p>
<p>这和动态规划还不一样，动规的代码有个递推公式，可能就看不懂了，而贪心往往是直白的代码，但想法读不懂，哈哈。</p>
<p><strong>所以我把本题的难点也一一列出，帮大家不仅代码看的懂，想法也理解的透彻！</strong></p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">    Arrays.sort(intervals,(a,b) -&gt; {</span><br><span class="line">       <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]; </span><br><span class="line">    });</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;i &lt; intervals.length; i++) {</span><br><span class="line">        <span class="comment">// 没有重叠</span></span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= rightMax) {</span><br><span class="line">            count++;</span><br><span class="line">            rightMax = intervals[i][<span class="number">1</span>];</span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机含手续费_贪心12</title>
    <url>/2022/08/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8312/</url>
    <content><![CDATA[<html><head></head><body><h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8</p>
<p>解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p>
<p>注意:</p>
<ul>
<li>0 &lt; prices.length &lt;= 50000.</li>
<li>0 &lt; prices[i] &lt; 50000.</li>
<li>0 &lt;= fee &lt; 50000.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="#思路"></a><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html#%E6%80%9D%E8%B7%AF">#</a>思路</h2><p>本题相对于<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html">贪心算法：122.买卖股票的最佳时机II (opens new window)</a>，多添加了一个条件就是手续费。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="#贪心算法"></a><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">#</a>贪心算法</h2><p>在<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html">贪心算法：122.买卖股票的最佳时机II (opens new window)</a>中使用贪心策略不用关心具体什么时候买卖，只要收集每天的正利润，最后稳稳的就是最大利润了。</p>
<p>而本题有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。</p>
<p>如果使用贪心策略，就是最低值买，最高值（如果算上手续费还盈利）就卖。</p>
<p>此时无非就是要找到两个点，买入日期，和卖出日期。</p>
<ul>
<li>买入日期：其实很好想，遇到更低点就记录一下。</li>
<li>卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。</li>
</ul>
<p>所以我们在做收获利润操作的时候其实有三种情况：</p>
<ul>
<li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。</li>
<li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li>
<li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li>
</ul>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices,<span class="type">int</span> fee)</span> {</span><br><span class="line">	<span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> prices[<span class="number">0</span>] + fee;</span><br><span class="line">	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> p : prices) {</span><br><span class="line">		<span class="keyword">if</span>(p + fee &lt; buy) {</span><br><span class="line">			buy = p + fee;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(p &gt; buy) {</span><br><span class="line">			sum += p - buy;</span><br><span class="line">			buy = p;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>单调递增的数字_贪心11</title>
    <url>/2022/08/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_%E8%B4%AA%E5%BF%8311/</url>
    <content><![CDATA[<html><head></head><body><h1 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h1><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接(opens new window)</a></p>
<p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p>
<p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）</p>
<p>示例 1:</p>
<ul>
<li>输入: N = 10</li>
<li>输出: 9</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: N = 1234</li>
<li>输出: 1234</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: N = 332</li>
<li>输出: 299</li>
</ul>
<p>说明: N 是在 [0, 10^9] 范围内的一个整数。</p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="#暴力解法"></a><a href="https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">#</a>暴力解法</h2><p>题意很简单，那么首先想的就是暴力解法了，来我替大家暴力一波，结果自然是超时！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkNum</span><span class="params">(<span class="type">int</span> num)</span> </span>{</span><br><span class="line">        <span class="type">int</span> max = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (num) {</span><br><span class="line">            <span class="type">int</span> t = num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (max &gt;= t) max = t;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> N)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkNum</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>时间复杂度：$O(n × m)$ m为n的数字长度</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="#贪心算法"></a><a href="https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">#</a>贪心算法</h2><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。</p>
<p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p>
<p>这一点如果想清楚了，这道题就好办了。</p>
<p><strong>局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。</p>
<p><strong>全局最优：得到小于等于N的最大单调递增的整数</strong>。</p>
<p><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。</p>
<p>此时是从前向后遍历还是从后向前遍历呢？</p>
<p>从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p>
<p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p>
<p><strong>所以从前后向遍历会改变已经遍历过的结果！</strong></p>
<p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p>
<p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p>
<h1 id="Java代码如下"><a href="#Java代码如下" class="headerlink" title="Java代码如下:"></a>Java代码如下:</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> N)</span> {</span><br><span class="line">	String[] strings = (N + <span class="string">""</span>).split(<span class="string">""</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> strings.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strings.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--) {</span><br><span class="line">		<span class="keyword">if</span>(Integer.valueOf(strings[i-<span class="number">1</span>]) &gt; Integer.valueOf(strings[i])) {</span><br><span class="line">            strings[i-<span class="number">1</span>] = String.valueOf(Integer.valueOf(strings[i-<span class="number">1</span>]) - <span class="number">1</span>);</span><br><span class="line">            start = i;</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;strings.length;i++) {</span><br><span class="line">       	strings[i] = <span class="string">"9"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(String.join(<span class="string">""</span>,strings));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法简史</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_大众闲谈</title>
    <url>/2022/08/22/python-%20%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84/</url>
    <content><![CDATA[<html><head></head><body><h1 id="大众闲谈"><a href="#大众闲谈" class="headerlink" title="大众闲谈"></a>大众闲谈</h1><p>先知：评论的数据目前没有采集，要采集也能实现。</p>
<h2 id="打开开发者工具找到加密字体"><a href="#打开开发者工具找到加密字体" class="headerlink" title="打开开发者工具找到加密字体"></a>打开开发者工具找到加密字体</h2><p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220822232904562.png" alt="image-20220822232904562"></p>
<p>再去找到这个字体的font-family</p>
<p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220822233048352.png" alt="image-20220822233048352"></p>
<p>把鼠标放到css结尾的链接上面，你可以看到，这个链接</p>
<p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220822233311427.png" alt="image-20220822233311427"></p>
<p>通过这个链接下载这个woff字体文件并且保存到同层文件夹</p>
<h2 id="分析Html文件"><a href="#分析Html文件" class="headerlink" title="分析Html文件"></a>分析Html文件</h2><p>Html文件head标签里面会有链接，通过正则表达式提取出来，前面加上http通过request模块把它下载到本地</p>
<p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220822235316175.png" alt="image-20220822235316175"></p>
<h2 id="name-amp-amp-id-amp-amp-class"><a href="#name-amp-amp-id-amp-amp-class" class="headerlink" title="name&amp;&amp;id&amp;&amp;class"></a>name&amp;&amp;id&amp;&amp;class</h2><p>通过字典的关系实现相互映射(font.xml文件)，最后通过正则表达式替换源码中的加密字体</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 替换列表页面的字体反爬内容</span></span><br><span class="line">sub_old = <span class="string">'&lt;d class="num"&gt;&amp;#{};&lt;'</span>.<span class="built_in">format</span>(info)</span><br><span class="line">sub_new = <span class="string">'&lt;d class="num"&gt;{}&lt;'</span>.<span class="built_in">format</span>(v)</span><br><span class="line">self.list_html = re.sub(sub_old, sub_new, self.list_html)</span><br></pre></td></tr></tbody></table></figure>

<p>最后就是常规的提取了，就这么简单，需要源码私信我</p>
<h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img src="C:%5CUsers%5C13772%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220823000440773.png" alt="image-20220823000440773"></p>
</body></html>]]></content>
      <categories>
        <category>数据采集</category>
      </categories>
      <tags>
        <tag>数据采集</tag>
      </tags>
  </entry>
</search>
